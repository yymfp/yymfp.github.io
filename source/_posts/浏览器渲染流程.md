---
title: 浏览器渲染流程
date: 2018-10-11 12:12:15
tags: 浏览器
categories: 前端
---

### 浏览器渲染流程

##### 浏览器内核：

主要分成两部分：渲染引擎和JS引擎。

渲染引擎：负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入css等），以及计算机网页的显示方式，然后输出至显示器或打印机。浏览器的内核的不同对网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。

JS引擎：解析和执行javascript来实现网页的动态效果。

> 在最开始的时候渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于指渲染引擎。

##### 常见的浏览器内核：

Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]

Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等

Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]

Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]

##### 渲染前：

1. 浏览器通过dns查找到域名映射的ip地址，成功后取得连接。
2. 浏览器通过HTTP协议向web服务器发起请求，服务器等待处理，并响应。
3. 浏览器接收到服务器返回的html页面代码，并获取服务器端静态资源相关文件如：图片等。
4. 最终渲染显示页面。

##### 浏览器加载html页面内容的顺序：

![](http://bmob-cdn-8350.b0.upaiyun.com/2018/10/11/5aa1c0da40be870480eef4f2f8b77931.png)

**js的加载：**

js不能并行下载和解析（阻塞下载）。

当引用js的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而js中很可能出现直接改变DOM树结构的代码，比如添加一个节点等，所以会出现加载js文件时，阻塞其他的下载和呈现。

##### 浏览器渲染页面流程：

1. 解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）

2. 解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式

3. 将CSS与DOM合并，构建渲染树（Render Tree）

4. 布局和绘制，重绘（repaint）和重排（reflow）

##### 浏览器的重绘和重排：

一个页面由两部分组成：

DOM：描述该页面的结构

render：描述 DOM 节点 (nodes) 在页面上如何呈现

当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint（重绘）。

如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow（重排）。

这两个过程是很耗费浏览器性能的, 从 IE 系列和 Chrome 渲染页面速度上的差距即可看出渲染引擎计算对应值和呈现并不一定高效, 而每次对元素的操作都会发生 repaint 或 reflow, 因此编写 DOM 交互时如果不注意就会导致页面性能低下。

页面的渲染过程如下：

![](http://bmob-cdn-8350.b0.upaiyun.com/2018/10/11/f339212b403299f1802345e04edc3c3e.png)

**不管页面发生了重绘还是重排，它们都会影响性能（最可怕的是重排 ，应尽量避免）**

下列情况会发生重排

- 页面初始渲染
- 添加/删除可见DOM元素
- 改变元素位置
- 改变元素尺寸（宽、高、内外边距、边框等）
- 改变元素内容（文本或图片等）
- 改变窗口尺寸

##### 如何减少重排

1. 分离读写操作

   ```javascript
   let mdiv=document.getElementById(mydiv);
   let dLeft=mdiv.offsetLeft;
   mdiv.style.left=dLeft+1+'px';
   ```


2. 样式集中改变

   ```css
   .div1{
       width:200px;
       height:200px;
   }
   .div2{
       width:200px;
       height:200px;
   }
   .div3{
       width:200px;
       height:200px;
   }
   /*集中改变样式*/
   .div1 .div2 .div3{
       width:200px;
       height:200px;
   }
   ```

   3. 可以使用absolute脱离文档流
   4. 使用`display:none`，不使用visibility，也不要改变它的z-index
   5. 动画尽量使用css3实现

**重排重绘这些步骤都是在cpu中发生的。**

在compostite Layers阶段，cpu 把生成的 BitMap（位图）传输到GPU，渲染到屏幕。 css3就是在GPU发生的：transform  opacity。

在 GPU发生的属性比较高效。所以css3性能比较高。

小结：

渲染的三个阶段 Layout ,Paint,Composite Layers。

修改不同的css属性会触发不同阶段。

触发的阶段越前，渲染的代价越高。

##### 从url输入网址到浏览器页面加载成功所经历的完整过程

1. DNS解析：将域名地址解析为ip地址
   - 浏览器DNS缓存
   - 系统DNS缓存
   - 路由器DNS缓存
   - 网络运营商DNS缓存
   - 递归搜索：www.baidu.com
     1. .com域名下查找DNS解析
     2. .baidu域名下查找DNS解析
     3. www域名下查找DNS解析
     4. 如果都没有解析出来，则报错
2. TCP连接：TCP三次握手
   - 第一次握手：由浏览器发起请求到服务器，告诉服务器我将要发送请求了
   - 第二次握手：由服务器发起，告诉浏览器我准备好了，你开始发送吧
   - 第三次我握手普：由浏览器发起，告诉服务器，我准备好发送了，你准备接收吧
3. 发送请求
   - 请求报文：HTTP协议的通信内容
4. 接收响应
   - 响应报文
5. 渲染页面
   - 遇见HTML标签，浏览器调用HTML解析器解析成Token并构建DOM树
   - 遇见Style/link标记：浏览器调用css解析器，处理css标记并构建cssom树
   - 遇到script标记：调用javaScript解析器，处理script代码（绑定事件，修改dom树/cssom树）
   - 将dom树和cssom树合并成一个渲染树
   - 根据渲染树计算布局，计算每个节点的几何信息（布局）
   - 将各个节点颜色绘制到屏幕上（渲染）
6. 断开连接：TCP四次挥手
   - 第一次挥手：由浏览器发起，告诉服务器我发送结束了（请求报文），你准备关闭吧
   - 第二次挥手：由服务器发起，告诉浏览器我接收完了（请求报文），我准备关闭
   - 第三次挥手：由服务器发起，告诉浏览器我发送完了（响应报文），你准备关闭吧
   - 第四次挥手：由浏览器发起，告诉服务器我接收完了（响应报文），我准备关闭，你也关闭吧