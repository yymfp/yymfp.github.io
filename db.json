{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/hexo-theme-next-master/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/md5.min.js","path":"js/src/md5.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"2a441d77519f98c59c1a61e8752b036e7d9f152f","modified":1708328571564},{"_id":"themes/hexo-theme-next-master/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1708328571692},{"_id":"themes/hexo-theme-next-master/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1708328571692},{"_id":"themes/hexo-theme-next-master/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/README.md","hash":"140f4ece6670327a7d33b293947d958de80b44da","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/_config.yml","hash":"4bc1884f5f04e1d35eab788ff621adca77d3a261","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/bower.json","hash":"23379fec9b4f70bc2611433ac3770445a8ca18d9","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1708328571697},{"_id":"themes/hexo-theme-next-master/package.json","hash":"42186cf60771f5547b3a68cf3865f102011930d0","modified":1708328571711},{"_id":"source/about/index.md","hash":"4ec59a28f5aaf98db34691e13f9456a89d0b7d6c","modified":1708328571638},{"_id":"source/categories/index.md","hash":"24947ff43873a6fe18f9030939946546508b68e5","modified":1708328571638},{"_id":"source/_posts/CommonJS、AMD、CMD.md","hash":"476c0c8baee0c1f8e8919d41a5f940e6e75d9de7","modified":1708328571566},{"_id":"source/_posts/BFC.md","hash":"851c11636f9749ffdb37771073986be5058c1f05","modified":1708328571564},{"_id":"source/_posts/CommonJS规范.md","hash":"16f88fab423bb68d33227355dd7cef27fdf14572","modified":1708328571566},{"_id":"source/_posts/.DS_Store","hash":"4787afbd8985d9cd72889253e31ae395a71d01cc","modified":1708674606735},{"_id":"source/_posts/ES5.md","hash":"0fbb86c30350879ca9e286b7478db30ec6fef402","modified":1708328571566},{"_id":"source/_posts/ES6.md","hash":"ca456a0262f2013d50c7abfc911b0dbaeff7cc8b","modified":1708328571566},{"_id":"source/_posts/ES7.md","hash":"a91327a917b0580413bbf569f226c440f2d54c49","modified":1708328571566},{"_id":"source/_posts/HTML5.md","hash":"69135b59c86b8490a0e4349a8d54b2cfa8f41998","modified":1708328571566},{"_id":"source/_posts/HTTP-Live-Streaming-HLS.md","hash":"f3e21ef3c20d797bb4e189de20094bee5e1ab938","modified":1708339654626},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系.md","hash":"a27f14eb515ebcc3ad1a9920bb3a82e7343a91d6","modified":1708339314142},{"_id":"source/_posts/JavaScript语言精粹笔记.md","hash":"3544736663af9a12e6027cc350cb77283c7dda87","modified":1708328571566},{"_id":"source/_posts/JavaScript高级程序设计笔记.md","hash":"28f6f454ae5dccb4b5b06a0728a087c624efa41d","modified":1708328571566},{"_id":"source/_posts/LeetCode相关题目.md","hash":"ec34ddd38fb8893a29d19a5b512644527ae1061f","modified":1708328571566},{"_id":"source/_posts/MVVM.md","hash":"e75df783966fadf26b936ca8d40fd0d1782a52c0","modified":1708328571566},{"_id":"source/_posts/NodeJs事件轮询机制.md","hash":"db0ee2434d1e9d2d4ae4cfd322d7147bdebd8e7c","modified":1708328571568},{"_id":"source/_posts/Node.md","hash":"0644624e8d8fe188614423828e8f7e59a856f62c","modified":1708328571567},{"_id":"source/_posts/Vuex.md","hash":"b49361bfd6c7b8102ff0e5a43006fecb10a6c7f1","modified":1708328571568},{"_id":"source/_posts/Vue与React异同.md","hash":"2ba689799779eaf3666ea04d2d19529961a75e81","modified":1708328571569},{"_id":"source/_posts/Vue数据绑定Dep与Watcher之间的关系.md","hash":"99bdcb2ad0be2306c99a658de331736ab2fb90b1","modified":1708328571569},{"_id":"source/_posts/WebRtc-Internals工具使用.md","hash":"9cd510dde10e0505cf15ebc557db0e846c3ba41d","modified":1708328571569},{"_id":"source/_posts/axios.md","hash":"b084865a84b8c0c0d5c14833228554549376873a","modified":1708328571598},{"_id":"source/_posts/call、apply使用与区别.md","hash":"254e874dc0eabb852a5eddaaa7a68b080e9f17b9","modified":1708328571598},{"_id":"source/_posts/css层叠上下文、层叠等级、层叠顺序以及z-index.md","hash":"da3ccaa51999389cb2f5ab013448541baa0b0cfa","modified":1708328571599},{"_id":"source/_posts/css3新增的常见属性.md","hash":"1ca64311a8e37d765763a7311437c7bbf5918497","modified":1708328571598},{"_id":"source/_posts/css性能调优.md","hash":"ac8f8e606bf3405627006c3f9e446b8f2181412f","modified":1708328571600},{"_id":"source/_posts/css盒模型.md","hash":"918d0e7c277eadaa352d1ba76acb2b8841b338b2","modified":1708328571600},{"_id":"source/_posts/flex布局.md","hash":"b4bdf25bb7610468c0dca2a3bf2f0b8f6f007159","modified":1708328571600},{"_id":"source/_posts/git使用.md","hash":"2409520b426e27c5d17cc5a23af72ff1b32cced9","modified":1708328571600},{"_id":"source/_posts/html块级元素、内联元素.md","hash":"de871867c1567663733377289c907ab96f63ae45","modified":1708328571601},{"_id":"source/_posts/js包装对象.md","hash":"3427b616f858c64e9cbaf01a74e59e5e0a2f9440","modified":1708328571601},{"_id":"source/_posts/js变量提升-预处理&&执行上下文.md","hash":"798230d0af74cd66194be203d3759f9626f99079","modified":1708328571601},{"_id":"source/_posts/js对象.md","hash":"cd797cc4f4714b3370d73570193539627ab6f584","modified":1708328571604},{"_id":"source/_posts/js作用域与作用域链.md","hash":"056a18a7fdec5028cb2cc60ebf05c158f418f588","modified":1708328571601},{"_id":"source/_posts/js宏任务和微任务.md","hash":"11d0a7bb7f88184952c44112abd27a558b9e012e","modified":1708328571604},{"_id":"source/_posts/js的prototype总结.md","hash":"2d2dc22065c99679c94a7d94f52ef9669bdee760","modified":1708328571604},{"_id":"source/_posts/js深拷贝、浅拷贝.md","hash":"622b74ea9b66b3caae542b19b70d471b59e09f4d","modified":1708328571604},{"_id":"source/_posts/js类型检测总结.md","hash":"9be847edeb33591c37346a388de0f994381a2de9","modified":1708328571607},{"_id":"source/_posts/js的this指向问题.md","hash":"0d7cc8ab67511b30eb82115b0f6b04030283fb0c","modified":1708328571607},{"_id":"source/_posts/less.md","hash":"4738fbca1c3faee018c35d8d4a6c38b9ec0ca38c","modified":1708328571614},{"_id":"source/_posts/position属性.md","hash":"dc7c1bc21d1f2801ce2eb33962e64f252b668c47","modified":1708328571615},{"_id":"source/_posts/js继承.md","hash":"68e04abb5339cd8bacedb2710e012f56b3219873","modified":1708328571609},{"_id":"source/_posts/px、em、rem区别.md","hash":"e574cf6f4168f9a9f701c121dc2b55ffd87d5fd3","modified":1708328571615},{"_id":"source/_posts/js闭包.md","hash":"41b5ccccaca75137ff2ff71342a44334d351535f","modified":1708328571609},{"_id":"source/_posts/package中的devdependencies和dependencies.md","hash":"b1bea744ac26e6de4cfa4e85ff917bde64a59a16","modified":1708328571615},{"_id":"source/_posts/vue-router.md","hash":"758c2a64e6c54ae09acc396fe5df587c46152d51","modified":1708328571619},{"_id":"source/_posts/snabbdom源码笔记.md","hash":"312518fffea42576f79aabf7fa191667379ec8c2","modified":1708328571618},{"_id":"source/_posts/redux.md","hash":"8adbba81ae3d1f21897967fb2d5293d878530df2","modified":1708328571616},{"_id":"source/_posts/react.md","hash":"40a6080c7ce4de198a9de61f6c2568190f72ae71","modified":1708328571615},{"_id":"source/_posts/vue深度监听.md","hash":"dba11ce895ef5440426f2e4b8fa815ca70ed9dd9","modified":1708328571620},{"_id":"source/_posts/vue插槽.md","hash":"ae423f04085dfa958b8d8e0f83fc8dea7b2dbc2b","modified":1708328571619},{"_id":"source/_posts/vue组件间通信方式.md","hash":"fe34fa3268406017196d51ae9fa6e85237e0ca68","modified":1708328571623},{"_id":"source/_posts/vue计算属性和侦听器.md","hash":"7c3afcf1afb4024e86350d0b91a463f9954aa7d7","modified":1708328571623},{"_id":"source/_posts/vue组件生命周期.md","hash":"d16eb78dc9ad3cd55ccc07fde7cbe81bd9ccabe2","modified":1708328571623},{"_id":"source/_posts/vue自定义指令.md","hash":"7cee8cb39c446e78681f74bd4e5489ce0e7c67e3","modified":1708328571623},{"_id":"source/_posts/word-break、overflow-wrap、white-space.md","hash":"4081105edd409979276f6a9232b4317ff814f3f3","modified":1708328571624},{"_id":"source/_posts/事件捕获和事件冒泡.md","hash":"dd0ffb66e53b9c04d17903f5b42675e654e2adaf","modified":1708328571624},{"_id":"source/_posts/二叉树.md","hash":"dd36ada0ed5fcd2f051dc25b4cd266633030341d","modified":1708328571625},{"_id":"source/_posts/webpack.md","hash":"6256fa9815f1e1b481bb0d18b3f50a54ea87786c","modified":1708328571624},{"_id":"source/_posts/你好，潘君毅.md","hash":"a5951674f48c10f244850bdfc12449b31a8c1a68","modified":1708328571633},{"_id":"source/_posts/函数柯里化.md","hash":"6bf4b5d65f025f9cb6c136d05b8f6b7d3b75dae4","modified":1708328571633},{"_id":"source/_posts/常见的几种布局.md","hash":"baf28fa3a5bc7d2c242ddfb02ab5f10dbef05b44","modified":1708328571633},{"_id":"source/_posts/前端性能优化.md","hash":"8981007268418a446f884a4fdbc43e9aa67c919e","modified":1708328571633},{"_id":"source/_posts/开发编码规范.md","hash":"5553bc06b3599f3f14a77ce386aa37c1a46d86fa","modified":1708328571634},{"_id":"source/_posts/数据结构.md","hash":"d227ed77b22a135ab0f2950be271fadafef198fb","modified":1708328571634},{"_id":"source/_posts/发布订阅模式.md","hash":"431cf077e06fcaa963282f45af950c6151490651","modified":1708328571633},{"_id":"source/_posts/常见的排序算法.md","hash":"51d09b9cc2b1465c57544462a934deb2c7c3674b","modified":1708328571633},{"_id":"source/_posts/浏览器兼容问题.md","hash":"9a268b43dc397bbdf3aca2a581bd378151e028ff","modified":1708328571634},{"_id":"source/_posts/浏览器存储.md","hash":"5c7aede2b4f57ac4980ee5126c5c1e2cff4ce7d1","modified":1708328571634},{"_id":"source/_posts/浏览器渲染流程.md","hash":"d86a23a27605d76eb89da303e29eca0c5e53f838","modified":1708328571634},{"_id":"source/_posts/编写可维护的JavaScript笔记.md","hash":"7ee8e01165fe70664682da52458954616a3ce006","modified":1708328571635},{"_id":"source/_posts/观察者模式.md","hash":"d3bd25a05fdb752be2b8552060bc7f5c37264734","modified":1708328571636},{"_id":"source/_posts/计算机网络.md","hash":"ecd9a2aa3524bbedd3dbbbd5f55c0d2983e87c1a","modified":1708328571636},{"_id":"source/_posts/组件编写命名规范.md","hash":"e7cf520a3f5d75912e149ee6fd61ce5b48c04034","modified":1708328571635},{"_id":"source/_posts/跨域问题.md","hash":"dc579ce753f20196fe05f03d2ce65562cf1f5808","modified":1708328571638},{"_id":"source/tags/index.md","hash":"50ddebd6866a717f7c50c7699aefa070d6b0635a","modified":1708328571638},{"_id":"themes/hexo-theme-next-master/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1708328571693},{"_id":"themes/hexo-theme-next-master/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1708328571694},{"_id":"themes/hexo-theme-next-master/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1708328571697},{"_id":"themes/hexo-theme-next-master/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1708328571697},{"_id":"themes/hexo-theme-next-master/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1708328571698},{"_id":"themes/hexo-theme-next-master/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1708328571698},{"_id":"themes/hexo-theme-next-master/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1708328571698},{"_id":"themes/hexo-theme-next-master/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1708328571698},{"_id":"themes/hexo-theme-next-master/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1708328571698},{"_id":"themes/hexo-theme-next-master/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1708328571700},{"_id":"themes/hexo-theme-next-master/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1708328571700},{"_id":"themes/hexo-theme-next-master/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1708328571700},{"_id":"themes/hexo-theme-next-master/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1708328571700},{"_id":"themes/hexo-theme-next-master/layout/_layout.swig","hash":"1b59036ccb2ad571503b94587f458fad46775642","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1708328571699},{"_id":"themes/hexo-theme-next-master/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571728},{"_id":"source/_posts/BFC/1362e17d4024bf32807439bb428f8806.png","hash":"38c82971f033e4c2807a419f0afc193f7e9b5fc4","modified":1708328571565},{"_id":"source/_posts/BFC/2e7435f6404a840180b90b5050465d7d.png","hash":"6471ed8822a52435642d089d2d15c714166a4de0","modified":1708328571565},{"_id":"source/_posts/BFC/58fe0bc24074305e80124130cb611524.png","hash":"21fb211880ad1c791aa61748e1f46098e1422951","modified":1708328571565},{"_id":"source/_posts/BFC/61f755c3404c04f880bf3759d96965db.png","hash":"71808d6623a603401a2540c8857ea24f9ebea7e5","modified":1708328571565},{"_id":"source/_posts/BFC/4e7ccdd640f9f1948001b77f22fff5bc.png","hash":"83a6f68c4b070e61d5ebe1da14d513a947b72f2c","modified":1708328571565},{"_id":"source/_posts/BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png","hash":"72e6d7e09e3550a761c79d7a3872f3bf0b9ba743","modified":1708328571565},{"_id":"source/_posts/BFC/9f51d5ac40bdb5fa804d79aed400cab1.png","hash":"661a07f65ba84c188a519392d0ddef905e793eed","modified":1708328571565},{"_id":"source/_posts/BFC/d1d0d0b84057b84c8064633356e7a56a.png","hash":"bab1f59616eb921ac48ef249d12d125a4efbe653","modified":1708328571565},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/504B85A8EA314E70BC3BB9C865A14FB4.png","hash":"312ec9b007eb8aeadfaccdcc1ef732483e0a0829","modified":1708338773071},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/8AC59C17C15A4885A126F0B3B824E20B.png","hash":"a609cac4202d9c46443f430129fc5c906f7577c0","modified":1708338894192},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/B670A19A85B547999C298B6BA314E0F1.png","hash":"5fdee2bbcc35b0367dae49eb7241da0afacb7acd","modified":1708338963539},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/D7B775D11EB743F094F9802ACDF78DBA.png","hash":"f25e4d68f97764905aad80834000f0596f842ce7","modified":1708338933734},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125110844187.png","hash":"e34c83f53e2a7d9b9ca0be9e4eb2e079fed27eee","modified":1708328571574},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125113409121.png","hash":"f30fd18cb82180f7cae6d87e132dbffc4bce369a","modified":1708328571581},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125113538013.png","hash":"1ce25aa586104c250bf048a8ce1570ba46714bde","modified":1708328571582},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125143155721.png","hash":"fde721a3c2ecdfa8d98825b5fd1570cce2ba01c0","modified":1708328571583},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125162500220.png","hash":"0135f808fd9f4c350ccd1f618c5ae2de229df984","modified":1708328571583},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125162859189.png","hash":"e032e202f9097b5318afe61c4788437dbdaf86cf","modified":1708328571583},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125163342091.png","hash":"15e9715e07bac23ceee047ec5c09be76814991ba","modified":1708328571584},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164612639.png","hash":"ce78ba48cb4b1d9aca5b1927985ce53115fca972","modified":1708328571584},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164622944.png","hash":"05fe9c609c4671abddaec2483fc02e9e69db4bba","modified":1708328571584},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164803760.png","hash":"6749297b758900b2ef24970d83820d2cf34fd7ee","modified":1708328571584},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125165043733.png","hash":"d4bcc4aa0396dacd60795e08f0702844e54901bb","modified":1708328571585},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125165024993.png","hash":"37fe8c950b498ed8262a060ce121e5066deaf006","modified":1708328571585},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172315264.png","hash":"85836085dbad03c37a1b630a2ec3b0357db5cc08","modified":1708328571594},{"_id":"source/_posts/WebRtc-Internals工具使用/截屏2022-01-25 上午10.49.46.png","hash":"5cdd5401a8f4f2c352188962c1c9aa6a14c74b69","modified":1708328571598},{"_id":"source/_posts/css盒模型/0754b65440c0fe40808b6481d881c0d2.png","hash":"326ea43b0ca553d960256b7e79edba78dff0460b","modified":1708328571600},{"_id":"source/_posts/css盒模型/7018d20d4024c8748094ee6c656cbc13.png","hash":"eadaef2aa77f3fa09cd97b9753fc1bb617f6707a","modified":1708328571600},{"_id":"source/_posts/js的prototype总结/3ed52e91409ae13e805e9ea9c771c66c.png","hash":"013c4f9426aa4375c457be452ee9c324c1ab6f5d","modified":1708328571605},{"_id":"source/_posts/js的prototype总结/ad023c9f40a1e17f803967a5a402683e.png","hash":"354356662ad312d2df7991c64d79a0f5d1081b64","modified":1708328571606},{"_id":"source/_posts/js的prototype总结/fc61390740d130488051d1089074ba12.png","hash":"3d92ddfc295517d49b2e9797357197b87dd7c5af","modified":1708328571607},{"_id":"source/_posts/react/231d414640b509d980203a5ab45a3c4e.png","hash":"d6cf098302dc32a842d964599ee4cccc9b2b4e6d","modified":1708328571616},{"_id":"source/_posts/react/35cc29484072961d801e4de7f94c3b65.png","hash":"9051fd4ba2fdf9ac199a270ee885df6653b3ce41","modified":1708328571616},{"_id":"source/_posts/react/6873d82c40e03c3080a5f4098f6df602.png","hash":"4918e3b454b762119791eb6f30fa306c9d9f0b26","modified":1708328571616},{"_id":"source/_posts/事件捕获和事件冒泡/b2a98b1d408c0923807704ad7ac95fde.png","hash":"a7b220063c8408a19e6aa2ea1ae33de671a8f370","modified":1708328571624},{"_id":"source/_posts/二叉树/2153c29240544948808c3bd9081b6a74.png","hash":"d5436415fc01d7d218e99bb07c39b1c2b0b654dc","modified":1708328571625},{"_id":"source/_posts/二叉树/31c90baf409ce7088051e95c118005e1.png","hash":"8f0dc4a842917a08c080ebbaa2cf40b2feb208c8","modified":1708328571626},{"_id":"source/_posts/二叉树/f8f24bb14013ad4f806d1ec8bec299bd.jpg","hash":"6b7133ba73e8f59a3714837b48b73a346348093a","modified":1708328571627},{"_id":"source/_posts/你好,潘君毅/0a07ba0c40de774980cb892145452fea.png","hash":"c4208ace27c630052861269ee309a2a0d6b3f393","modified":1708328571628},{"_id":"source/_posts/你好,潘君毅/1.png","hash":"de4fccf249d47f9aff54c78f6f26b9f3bcc2163e","modified":1708328571628},{"_id":"source/_posts/你好,潘君毅/10.png","hash":"5e9c9ce50a242ccbbcff9e10a9b15ce0fe37626b","modified":1708328571628},{"_id":"source/_posts/你好,潘君毅/1c358a084065a55f8028d9539dc1c22d.png","hash":"d0f6b37b6d0548466e236805ed7e3625ca293e75","modified":1708328571629},{"_id":"source/_posts/你好,潘君毅/2.png","hash":"d0f6b37b6d0548466e236805ed7e3625ca293e75","modified":1708328571629},{"_id":"source/_posts/你好,潘君毅/437fc07240469c578002a18d7c179695.png","hash":"7e52c5dbe3fbb82ad1621c8a705ab9be544548dc","modified":1708328571630},{"_id":"source/_posts/你好,潘君毅/4.png","hash":"c4208ace27c630052861269ee309a2a0d6b3f393","modified":1708328571630},{"_id":"source/_posts/你好,潘君毅/3.png","hash":"018ffd5d777eebec77ccab95be9034851a1e8dee","modified":1708328571630},{"_id":"source/_posts/你好,潘君毅/5.png","hash":"cdc284e093ab0d61148cf6dfe801a9d0d9a54a55","modified":1708328571630},{"_id":"source/_posts/你好,潘君毅/5c56223d40e8e14e80409b9863cc9563.png","hash":"056d95eeb39078c59d1d4ec0d19e527f5f3103b1","modified":1708328571630},{"_id":"source/_posts/你好,潘君毅/6.png","hash":"7e52c5dbe3fbb82ad1621c8a705ab9be544548dc","modified":1708328571631},{"_id":"source/_posts/你好,潘君毅/6ba821354070efd88095cc946e5f084f.png","hash":"c9788b611f8417a4ff728b8e702f992b6a3c92a3","modified":1708328571631},{"_id":"source/_posts/你好,潘君毅/7.png","hash":"056d95eeb39078c59d1d4ec0d19e527f5f3103b1","modified":1708328571631},{"_id":"source/_posts/你好,潘君毅/7b48d7ea40865e3d801a612431c2226f.png","hash":"cdc284e093ab0d61148cf6dfe801a9d0d9a54a55","modified":1708328571632},{"_id":"source/_posts/你好,潘君毅/9.png","hash":"c9788b611f8417a4ff728b8e702f992b6a3c92a3","modified":1708328571632},{"_id":"source/_posts/你好,潘君毅/b8d6706040d9ab598087e7c4a291315c.png","hash":"de4fccf249d47f9aff54c78f6f26b9f3bcc2163e","modified":1708328571633},{"_id":"source/_posts/你好,潘君毅/87c8b71a404cbce3800d7150d62e3572.png","hash":"018ffd5d777eebec77ccab95be9034851a1e8dee","modified":1708328571632},{"_id":"source/_posts/你好,潘君毅/d082fa4140ed737780aa3a6599da6a8f.png","hash":"5e9c9ce50a242ccbbcff9e10a9b15ce0fe37626b","modified":1708328571633},{"_id":"source/_posts/浏览器渲染流程/f339212b403299f1802345e04edc3c3e.png","hash":"8e547f2e98a1f0c2938fbf709699995ee7b875ad","modified":1708328571635},{"_id":"source/_posts/常见的排序算法/9a8c68df405b4ae980c7a100d9395d26.png","hash":"c8b16ca318355c72612d2a009021527a35893910","modified":1708328571634},{"_id":"source/_posts/计算机网络/8b9c50964095160480f00995d28b8ac3.png","hash":"540f0df01047507a5e30ea99e3433917c9dc51b2","modified":1708328571636},{"_id":"themes/hexo-theme-next-master/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1708328571695},{"_id":"themes/hexo-theme-next-master/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1708328571697},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1708328571697},{"_id":"themes/hexo-theme-next-master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1708328571696},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_macro/post.swig","hash":"27922af64ecb9db9a28bcf1c98fb68b26bf0b67a","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1708328571700},{"_id":"themes/hexo-theme-next-master/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1708328571702},{"_id":"themes/hexo-theme-next-master/layout/_partials/comments.swig","hash":"6d62ec5d6e643501b85e0d271887c86f028fb64e","modified":1708328571703},{"_id":"themes/hexo-theme-next-master/layout/_partials/footer.swig","hash":"05cdaf9b6cb32afd442b228cd247aaf9468a31ed","modified":1708328571703},{"_id":"themes/hexo-theme-next-master/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1708328571711},{"_id":"themes/hexo-theme-next-master/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1708328571712},{"_id":"themes/hexo-theme-next-master/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1708328571729},{"_id":"themes/hexo-theme-next-master/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1708328571730},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/5DDB5B88A2924C6A840C41533AE0920D.png","hash":"beefb1679dcb9a8069064ec89e594203fd34fec2","modified":1708338860530},{"_id":"source/_posts/HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png","hash":"0813ab06b03afc34ef0fe5030c80ff7a72a26aa6","modified":1708339362653},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/9DED6512254D4CF0A117E6B1AE5EE402.png","hash":"3848b0480a99b04b330a865ea39218a5dd11f6a8","modified":1708338824301},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/CBED4F4AC4EC45B78044E27BA0CB6A8B.png","hash":"6d98eb08b8bf7c8263ea9fade56726c5ca91c289","modified":1708338988458},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125111731747.png","hash":"8e1982067fb0f15e3d3ae54435b3645d9339a97a","modified":1708328571580},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125170242142.png","hash":"d0848f36cee9b07d3efdd572c430af63a0e5f932","modified":1708328571589},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172252449.png","hash":"1eadbb30c485702b8bf913151715e3ed8103cb7b","modified":1708328571593},{"_id":"source/_posts/git使用/d3c801894031d80480e26efe7008a949.png","hash":"1ca4af925a12d584304ce3f42cdc714af1afe8b1","modified":1708328571601},{"_id":"source/_posts/js的prototype总结/672e52454044214b80a9d2f140417535.png","hash":"9640b316aa249cd04aac6f5aa8810173163c93b2","modified":1708328571605},{"_id":"source/_posts/二叉树/f2b1e4ea4075a3078066c8279e3b8028.png","hash":"38a8d95965be727682af7201ced6b5187a097244","modified":1708328571627},{"_id":"source/_posts/你好,潘君毅/1be67f4740ae60fa8083591da8f65bfa.png","hash":"f5272fe46a9505cc65c814c6f3a4f8ce65ddb3c7","modified":1708328571629},{"_id":"source/_posts/你好,潘君毅/1108615-20171021235722365-818312042.png","hash":"f5272fe46a9505cc65c814c6f3a4f8ce65ddb3c7","modified":1708328571629},{"_id":"source/_posts/你好,潘君毅/8.png","hash":"de46050f93537169f1cd6b67b20d42da229ddfb0","modified":1708328571632},{"_id":"source/_posts/你好,潘君毅/76e9c5364021748380332bcda0314c0e.png","hash":"de46050f93537169f1cd6b67b20d42da229ddfb0","modified":1708328571632},{"_id":"source/_posts/计算机网络/a5edd4d540ed8572803058f6a9f0c854.png","hash":"46cea1b2eea57d0dc44148bf797832e3c2e507cb","modified":1708328571637},{"_id":"source/_posts/计算机网络/e0e0be624093114e805cd93918b993b9.png","hash":"c3294325288ab3f26fd3a53e4115f56cfc991e1a","modified":1708328571637},{"_id":"source/_posts/计算机网络/ffd0bea740c395d2807ae91fd1a27a4f.png","hash":"bbb0be44ccd925b76d2fc1f306c4119168aa615c","modified":1708328571637},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571725},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708328571728},{"_id":"source/_posts/MVVM/c045b16c40f808e480f874a801a7680a.png","hash":"78ecf374b6465b8ef6220dd88a5b6ee35141ab3b","modified":1708328571567},{"_id":"source/_posts/Vuex/ef5b88bd404de9f080415eceb994a780.png","hash":"12f59bbf4f32c3aa819771852d236e6e21864f83","modified":1708328571568},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125170026281.png","hash":"36a565d53cb744e382979f7f941b34758f07e850","modified":1708328571587},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125171344267.png","hash":"48b5585a1dc073b5fd725c8fe288fb82fa9f46de","modified":1708328571590},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125171812419.png","hash":"2bd2aa94669ddea51001f7d7f0adda6e52f35fe7","modified":1708328571592},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172427718.png","hash":"c8c921e137f8f3c819aa270a1cd1b43f0aca76fd","modified":1708328571595},{"_id":"source/_posts/js变量提升-预处理&&执行上下文/image-20200706121750467.png","hash":"e2133c8b267f246edc257e28f9879209bc6149ba","modified":1708328571604},{"_id":"source/_posts/js的prototype总结/fb2ec26540658c9480e22f7217f7ff29.png","hash":"66218307e4ff8721552a9b31b1466bf8fb34884e","modified":1708328571606},{"_id":"source/_posts/redux/417252aa40fd5841805aee7017fc73cd.png","hash":"951317be521b6f25aac756daca760f2c52be9db1","modified":1708328571618},{"_id":"themes/hexo-theme-next-master/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1708328571701},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1708328571703},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1708328571703},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1708328571703},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1708328571705},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1708328571705},{"_id":"themes/hexo-theme-next-master/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1708328571704},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1708328571705},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1708328571705},{"_id":"themes/hexo-theme-next-master/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1708328571705},{"_id":"themes/hexo-theme-next-master/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1708328571706},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1708328571707},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/gitalk.swig","hash":"45d6b4e234495041f71c1a080389105c43e9b4c9","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/gitment.swig","hash":"4a1ed35b7996a2167a6d5a698636f525909bbfbb","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/index.swig","hash":"99858ecfe529a81705a3ce196b31764502ab4f4a","modified":1708328571708},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1708328571709},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1708328571725},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1708328571734},{"_id":"themes/hexo-theme-next-master/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1708328571731},{"_id":"themes/hexo-theme-next-master/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1708328571730},{"_id":"themes/hexo-theme-next-master/source/js/src/md5.min.js","hash":"9bdad105c03b3aa2815f556690de52084023a84c","modified":1708328571731},{"_id":"themes/hexo-theme-next-master/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1708328571731},{"_id":"themes/hexo-theme-next-master/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1708328571732},{"_id":"themes/hexo-theme-next-master/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1708328571731},{"_id":"themes/hexo-theme-next-master/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1708328571732},{"_id":"themes/hexo-theme-next-master/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1708328571731},{"_id":"themes/hexo-theme-next-master/source/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1708328571732},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172507453.png","hash":"9b2256832cce05a02f7eb89bae3806db82c67ea1","modified":1708328571598},{"_id":"source/_posts/css层叠上下文、层叠等级、层叠顺序以及z-index/image-20200805170444733.png","hash":"fa5543a562ee21b9ef6d204f7e02eee1c886024a","modified":1708328571599},{"_id":"source/_posts/js类型检测总结/5e35a8e04062aeeb805a82c051a9560d.png","hash":"b5e2ecb2e7ae3d43cd2230c06c2a2561d1f1661f","modified":1708328571609},{"_id":"source/_posts/js闭包/a33c05334094f1ce80d00166ab7ed5aa.png","hash":"408189910deeffc27dbf292dcf2996cccda0b15a","modified":1708328571611},{"_id":"source/_posts/浏览器渲染流程/5aa1c0da40be870480eef4f2f8b77931.png","hash":"b7a45381077fed3b7f7480e068dd7197cead6837","modified":1708328571635},{"_id":"themes/hexo-theme-next-master/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1708328571733},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/2428C12B709F42D38859BA4234F61E5D.png","hash":"6de70b07bad5a33bc8c1d53922f59297443829ac","modified":1708338693019},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125103700660.png","hash":"8c367a435da532200116658701b4e4d0a031e3ad","modified":1708328571574},{"_id":"source/_posts/vue组件声明周期/da4542b8404aacff8083b804fa48db76.png","hash":"6f83029cfd7edabe52300edf6f48b846ffdd08a5","modified":1708328571623},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1708328571710},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1708328571724},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1708328571713},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1708328571713},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1708328571713},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Gemini/index.styl","hash":"fca5320e2644edcd663888863899d1b80352439b","modified":1708328571725},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1708328571726},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1708328571728},{"_id":"themes/hexo-theme-next-master/source/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1708328571732},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125111712303.png","hash":"86f0dac1b7199678e4a5e0f1050d72864ab22ee8","modified":1708328571578},{"_id":"source/_posts/js变量提升-预处理&&执行上下文/image-20200706120514737.png","hash":"70301f6e5b0a10661c3734ab82f99cd858b2a75c","modified":1708328571602},{"_id":"themes/hexo-theme-next-master/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1708328571733},{"_id":"source/_posts/js闭包/d2a9dab04077415480e81d7d8e8fd13e.png","hash":"8d41a99358d96965b74554ae8ffff90db51f449d","modified":1708328571613},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1708328571714},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1708328571715},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1708328571716},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1708328571717},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1708328571718},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1708328571718},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1708328571718},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1708328571718},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1708328571718},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1708328571719},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1708328571720},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1708328571721},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1708328571721},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1708328571721},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1708328571721},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1708328571721},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/third-party.styl","hash":"fd8fb7ee000fb92876ce101ce887ca5632ce0333","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1708328571723},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1708328571727},{"_id":"themes/hexo-theme-next-master/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1708328571722},{"_id":"themes/hexo-theme-next-master/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1708328571727},{"_id":"source/_posts/HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png","hash":"5d81d026f4a044101ebb0c107895366c44d8bda5","modified":1708339411222},{"_id":"public/searchVersion.txt","hash":"35b620570e5543e7e0810df52a8cb82a5338f53f","modified":1708681029939},{"_id":"public/about/index.html","hash":"68849c659c42c3da247f24d4b2e3839567d8bdb5","modified":1708681029939},{"_id":"public/categories/index.html","hash":"b3cbf2e65ba645cc2765cba2319e248ba7294f66","modified":1708681029939},{"_id":"public/archives/page/8/index.html","hash":"c4c06893ab1affecd791a090aa299a939454b1ce","modified":1708681029939},{"_id":"public/archives/2018/09/index.html","hash":"ca19d9a41e8115ed3f69b4b85ae62a91430be565","modified":1708681029939},{"_id":"public/archives/2018/11/index.html","hash":"0d69023b2028e4d1eb266ecd7aba096beabac5bc","modified":1708681029939},{"_id":"public/archives/2018/12/index.html","hash":"aa7f4e80ae38ffbfb1b4a814b06166c75aecf501","modified":1708681029939},{"_id":"public/archives/2019/page/3/index.html","hash":"84a137af5905d9f7b8dcbd2fa0a313709fdd9105","modified":1708681029939},{"_id":"public/archives/2019/03/index.html","hash":"66742415af8d0285821d9a380178e69c06a8a738","modified":1708681029939},{"_id":"public/archives/2019/04/index.html","hash":"40ed9b7c80293b4d94fac68eaaa3d061a3193138","modified":1708681029939},{"_id":"public/archives/2019/05/index.html","hash":"2060bfe0760cfc96e6c90287a924297df4f0b4da","modified":1708681029939},{"_id":"public/archives/2019/11/index.html","hash":"611f8675ae2f89318466c61cbb993a3b1ca2a08c","modified":1708681029939},{"_id":"public/archives/2020/07/index.html","hash":"499d2b90269ef853b75190d382ec0d5465ef5e1e","modified":1708681029939},{"_id":"public/archives/2020/08/index.html","hash":"c0434bc4c9e5e82cf7724f4f757c5f6d57a5d09f","modified":1708681029939},{"_id":"public/archives/2024/index.html","hash":"2a28690be38329405debe8872a1f9d5ffd27ff74","modified":1708681029939},{"_id":"public/archives/2024/02/index.html","hash":"f820d7a356329b368432827d90f5d73b9c84a3d7","modified":1708681029939},{"_id":"public/categories/前端/page/7/index.html","hash":"9e1963f311b4436a75522362f9433a101e14fb61","modified":1708681029939},{"_id":"public/categories/读书笔记/index.html","hash":"c8ec6a9b758ed2c041c905962f4000ad96acf8bc","modified":1708681029939},{"_id":"public/categories/git/index.html","hash":"9b2326e84ed21dec7985bfd9cc5cb03bc7d4dfdb","modified":1708681029939},{"_id":"public/categories/数据结构/index.html","hash":"71fcd09b324e1c0ee789903ab37ba45664a20f42","modified":1708681029939},{"_id":"public/categories/算法/index.html","hash":"38c29eaa2ee011e0430f452ff811552aca63c62d","modified":1708681029939},{"_id":"public/categories/计算机网络/index.html","hash":"24c6e8fd8cdfc9d1b66eaed7a597bcf5f5dac6be","modified":1708681029939},{"_id":"public/tags/模块开发规范/index.html","hash":"7f1579ef8fbfbb2f81567fb9f9010f5ea98819cd","modified":1708681029939},{"_id":"public/tags/CSS布局和BFC/index.html","hash":"2372124b8d50b7eb32c76c32333cc0b95fb45591","modified":1708681029939},{"_id":"public/tags/HTML/index.html","hash":"9cc8379bad8dc1107ef52f5f6ca64d6984133633","modified":1708681029939},{"_id":"public/tags/音视频/index.html","hash":"5540e4587bb336eea8696d7da7457cfb37a1d4c0","modified":1708681029939},{"_id":"public/tags/算法/index.html","hash":"6b0254c4c990536a33f84c3fe2cef32d71a2958d","modified":1708681029939},{"_id":"public/tags/MVVM相关/index.html","hash":"16beb0f27c667c7256764a51c707885cfe0ce680","modified":1708681029939},{"_id":"public/tags/NodeJS/index.html","hash":"6bb6c2bb06c3c32cb78d7639ddc34de248872877","modified":1708681029939},{"_id":"public/tags/Vue/page/2/index.html","hash":"3684b26309271ea562715e801352491da097eb91","modified":1708681029939},{"_id":"public/tags/axios/index.html","hash":"abcadee23a38eaa638776b88ec53dd2b90b38849","modified":1708681029939},{"_id":"public/tags/前端性能相关/index.html","hash":"a1c17b057c830dc1f48f848beaace9fc84ad13e9","modified":1708681029939},{"_id":"public/tags/git/index.html","hash":"6d2021aefcad3b54ff58b3e39e76db838c809d84","modified":1708681029939},{"_id":"public/tags/react/index.html","hash":"203b2b2efc7e0323ff29e2ad5a24f6e09ff1bf90","modified":1708681029939},{"_id":"public/tags/vue/index.html","hash":"2e2557c4d9dfe3747a21017c7035ee5e162df2b0","modified":1708681029939},{"_id":"public/tags/webpack使用/index.html","hash":"2bbe9c72163f21e27b4a7c5d36ca2d038609492a","modified":1708681029939},{"_id":"public/tags/树/index.html","hash":"02a3d0bc80d23a25634fe2dfcb10e56f316bde53","modified":1708681029939},{"_id":"public/tags/hexo/index.html","hash":"22cb65e69cf9ba3a9d723eceec43d06c08fd6816","modified":1708681029939},{"_id":"public/tags/规范/index.html","hash":"61a61b3315bae69dd475b4117afdb4f0f7a06baa","modified":1708681029939},{"_id":"public/tags/常见布局/index.html","hash":"ca8c82cdf297a5dcbbb167ccbbe3971f36b0887b","modified":1708681029939},{"_id":"public/tags/数据结构/index.html","hash":"86c5502ad3c7d08f5b98f923b4a05b2c14e6cf29","modified":1708681029939},{"_id":"public/tags/设计模式/index.html","hash":"a647b4336b45e891d373af73d3a841b21917c456","modified":1708681029939},{"_id":"public/tags/浏览器/index.html","hash":"e97308f4372cd78548fe577acb997742520b2131","modified":1708681029939},{"_id":"public/tags/计算机网络/index.html","hash":"d6527f8410721a1ba61c8aee769cc082d20911fe","modified":1708681029939},{"_id":"public/tags/跨域/index.html","hash":"8c5fdec16e59cab1dea3c383ce1378692a0318e2","modified":1708681029939},{"_id":"public/tags/index.html","hash":"25033d434d902479fc4e473cfa98d9f2d1fa4421","modified":1708681029939},{"_id":"public/2024/02/19/HTTP-Live-Streaming-HLS/index.html","hash":"8d850b21e486e2abc2b0e05f41c3df90ebc0e350","modified":1708681029939},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/index.html","hash":"fa2640c6cd14f18324840b264d1286116042a7ee","modified":1708681029939},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/index.html","hash":"1be7b2204994ecb44cfe6c3ec421277b58662950","modified":1708681029939},{"_id":"public/2020/08/11/观察者模式/index.html","hash":"d5a113bf257fda901ba189699f560e5990f94036","modified":1708681029939},{"_id":"public/2020/08/11/发布订阅模式/index.html","hash":"8b99fc29eb2640f56e84a40bae76d143d00d027b","modified":1708681029939},{"_id":"public/2020/08/09/函数柯里化/index.html","hash":"f05c9d88f0a972b4af716d2753bc9585916f9ec4","modified":1708681029939},{"_id":"public/2020/08/07/vue插槽/index.html","hash":"b6fcbf68762d9da3b37c7c39b912d4cbc584e313","modified":1708681029939},{"_id":"public/2020/08/05/css层叠上下文、层叠等级、层叠顺序以及z-index/index.html","hash":"c1d1aea21aadc4739a5186cab80da06906954d95","modified":1708681029939},{"_id":"public/2020/08/05/word-break、overflow-wrap、white-space/index.html","hash":"05cbee8a955856c80c71640a07e76d6dcfe2f58e","modified":1708681029939},{"_id":"public/2020/07/30/js作用域与作用域链/index.html","hash":"73ea651dad10af88b161db25c4deec574bfae6b6","modified":1708681029939},{"_id":"public/2020/07/30/snabbdom源码笔记/index.html","hash":"7bd789a25c24e76b83d6de0ac608e38cf92cfbc4","modified":1708681029939},{"_id":"public/2019/11/29/Vue数据绑定Dep与Watcher之间的关系/index.html","hash":"3eb1e289813a8c97815c911cb14d278db576411b","modified":1708681029939},{"_id":"public/2019/06/29/vue深度监听/index.html","hash":"28c2e2da42b7a9a4f882eafc3cafdbd7f99c0ba3","modified":1708681029939},{"_id":"public/2019/06/08/less/index.html","hash":"6481398e11d74b6791afbb6d5ad702438b6a16e3","modified":1708681029939},{"_id":"public/2019/06/01/编写可维护的JavaScript笔记/index.html","hash":"476820b24ce1378818f43b2c8c8bcfe68524c10a","modified":1708681029939},{"_id":"public/2019/06/01/JavaScript高级程序设计笔记/index.html","hash":"e3737e92cad8342b62cf2aa3ad8aef1d220d2cc8","modified":1708681029939},{"_id":"public/2019/06/01/JavaScript语言精粹笔记/index.html","hash":"99238fe9bfe32038691535561a7acdd887826a83","modified":1708681029939},{"_id":"public/2019/06/01/浏览器存储/index.html","hash":"2706ee8cb31e900a35d7daa7c903d77413adadd5","modified":1708681029939},{"_id":"public/2019/06/01/js深拷贝、浅拷贝/index.html","hash":"13475e177288719d35f1f39b87611f2499028e3d","modified":1708681029939},{"_id":"public/2019/05/03/js变量提升-预处理&&执行上下文/index.html","hash":"0930ce30d3b1dc396dc1e91b84cf45dfd5e2b528","modified":1708681029939},{"_id":"public/2019/05/01/ES7/index.html","hash":"1f803824c3ac5790a8a5bc467dbd738eacdb5608","modified":1708681029939},{"_id":"public/2019/05/01/ES6/index.html","hash":"ec1300de62ec9055878492808015bffc409a99df","modified":1708681029939},{"_id":"public/2019/05/01/ES5/index.html","hash":"d80308836539bedf147615c05d20052d05fb8099","modified":1708681029939},{"_id":"public/2019/04/28/vue组件间通信方式/index.html","hash":"a05ff6d8139a594397acf8c3fbf6e4e241f1ac27","modified":1708681029939},{"_id":"public/2019/04/28/Vue与React异同/index.html","hash":"7e686a6054ed9299a2740ed8483fec56219e90a5","modified":1708681029939},{"_id":"public/2019/04/28/js宏任务和微任务/index.html","hash":"5b263cd2fa807eb3e892315eb35e768f550ea300","modified":1708681029939},{"_id":"public/2019/04/26/NodeJs事件轮询机制/index.html","hash":"afde53cfa564ed5485c1a23f3d455f1724255e36","modified":1708681029939},{"_id":"public/2019/04/24/package中的devdependencies和dependencies/index.html","hash":"9a29d6306762f06d6abb3f2889988e772c9cd43d","modified":1708681029939},{"_id":"public/2019/04/24/vue自定义指令/index.html","hash":"93b89653ad234343fca7ad74cac8b5ab0b6f0677","modified":1708681029939},{"_id":"public/2019/03/10/数据结构/index.html","hash":"185fbb03d37ec7cc93c4d2cc45a9e49661698149","modified":1708681029939},{"_id":"public/2019/03/10/LeetCode相关题目/index.html","hash":"116955d95812bc95feddbc6ebe685ffa7288bd7e","modified":1708681029939},{"_id":"public/2019/03/10/浏览器兼容问题/index.html","hash":"66170e0d2c0a74158da0686b2e94091e213de922","modified":1708681029939},{"_id":"public/2019/03/10/前端性能优化/index.html","hash":"ace6ed9169ffc8d5209b13af81fd91072ef03aea","modified":1708681029939},{"_id":"public/2018/12/09/axios/index.html","hash":"7fe7a28b0c7ed4a821321d288b9f28fb2d8fc84c","modified":1708681029939},{"_id":"public/2018/12/09/vue计算属性和侦听器/index.html","hash":"c9c1057fa6b65236390ea0caaa2aa1d336f95c4d","modified":1708681029939},{"_id":"public/2018/12/09/开发编码规范/index.html","hash":"68179e33bd6d93807098a6367ed26b6ef37d02c1","modified":1708681029939},{"_id":"public/2018/12/09/Node/index.html","hash":"00260db7a41cbec38dc0107d25ee55d938b5bf2f","modified":1708681029939},{"_id":"public/2018/12/09/Vuex/index.html","hash":"0d57d460cec49336597b1959bda8741c7c0bd993","modified":1708681029939},{"_id":"public/2018/12/09/MVVM/index.html","hash":"e0d037875738e54447b45d022b43b17e274eedf8","modified":1708681029939},{"_id":"public/2018/12/09/CommonJS规范/index.html","hash":"7b2c88b5eb2099d0ae0e088a6a653c2b6ccf7261","modified":1708681029939},{"_id":"public/2018/11/25/组件编写命名规范/index.html","hash":"36bb42c8370bada7da607590c4d7eecc0b7d0324","modified":1708681029939},{"_id":"public/2018/11/22/redux/index.html","hash":"36b522bd4d0f8eca1edc4a1e143d79682ca18616","modified":1708681029939},{"_id":"public/2018/10/25/webpack/index.html","hash":"2075abc5d649c221a1d15e59ca7374bd22e37867","modified":1708681029939},{"_id":"public/2018/10/24/react/index.html","hash":"ce6eeddc4dd0685e516a0dc6780090612ddf8bea","modified":1708681029939},{"_id":"public/2018/10/23/js对象/index.html","hash":"24387de43b3a9f2c1369d17877c176d3e0d0d67d","modified":1708681029939},{"_id":"public/2018/10/22/js的this指向问题/index.html","hash":"6e10e36d43a6bd65c81a2144e2d67b7d6b1b517a","modified":1708681029939},{"_id":"public/2018/10/21/vue组件生命周期/index.html","hash":"05d853989ad5ff3512ef26638683b741b760e2f9","modified":1708681029939},{"_id":"public/2018/10/21/BFC/index.html","hash":"63f2b635ce7778e4d50938d25e3705ac7af38ca5","modified":1708681029939},{"_id":"public/2018/10/20/vue-router/index.html","hash":"090a3076535c63ca88f06df244d64ff9d67b9b8d","modified":1708681029939},{"_id":"public/2018/10/20/CommonJS、AMD、CMD/index.html","hash":"156a420544fc5fb4bc82fa503bc99df8ea853942","modified":1708681029939},{"_id":"public/2018/10/19/git使用/index.html","hash":"41577da3b451c71cb92485532071877e7b02c7cb","modified":1708681029939},{"_id":"public/2018/10/18/事件捕获和事件冒泡/index.html","hash":"895337699eeb278d1f0b51761826aa05c61b9f2b","modified":1708681029939},{"_id":"public/2018/10/18/position属性/index.html","hash":"07b43b7026f084cbffb5c5fac06d71c2eb9f28c3","modified":1708681029939},{"_id":"public/2018/10/16/二叉树/index.html","hash":"cc91daa2315aa2055295316adc5b019fad0a573b","modified":1708681029939},{"_id":"public/2018/10/16/跨域问题/index.html","hash":"8cd1170f6866d3c37bd20a7eae5002428d0ce0ad","modified":1708681029939},{"_id":"public/2018/10/16/计算机网络/index.html","hash":"159648c9809770a42c854afb6b3cde650abac96f","modified":1708681029939},{"_id":"public/2018/10/12/flex布局/index.html","hash":"973a67cf5b6feb4bd7a7607a64df4e3632c70115","modified":1708681029939},{"_id":"public/2018/10/11/css3新增的常见属性/index.html","hash":"0ea01d31c0d2472fcd25b8c6523d25ec4b41415c","modified":1708681029939},{"_id":"public/2018/10/11/css盒模型/index.html","hash":"f9768ce61cee94a4978ecb8e2ab38030533a4208","modified":1708681029939},{"_id":"public/2018/10/11/HTML5/index.html","hash":"e0aa27bbf3e9c630f368bd7792d3caf9c084ba72","modified":1708681029939},{"_id":"public/2018/10/11/浏览器渲染流程/index.html","hash":"9fb0cf66f620e9b8ba1cc354037f8acdfc2136a1","modified":1708681029939},{"_id":"public/2018/10/11/css性能调优/index.html","hash":"bf88ab9e7869cf835bfdc0a2050f525399b50c95","modified":1708681029939},{"_id":"public/2018/10/11/html块级元素、内联元素/index.html","hash":"3d3e788834e2d82b5aee1af294ac78b8506d17fc","modified":1708681029939},{"_id":"public/2018/10/10/常见的几种布局/index.html","hash":"5e4b3da9cce4c4776965cbdc365154c48eef5e2c","modified":1708681029939},{"_id":"public/2018/10/08/js闭包/index.html","hash":"3b604dfbef2aafbf91334ff29e7b93ad1c3f0379","modified":1708681029939},{"_id":"public/2018/10/08/js包装对象/index.html","hash":"125da15026b0a031b82135621a742e92778b4758","modified":1708681029939},{"_id":"public/2018/10/06/js类型检测总结/index.html","hash":"d6ae63d5ab46de20abedc2e02796cabed2797f58","modified":1708681029939},{"_id":"public/2018/10/06/js的prototype总结/index.html","hash":"6d41c3de4ea1baf0f50b2d808b9769e76e675f88","modified":1708681029939},{"_id":"public/2018/10/05/call、apply使用与区别/index.html","hash":"9faca67161c2f505514d42762903ee8762bed037","modified":1708681029939},{"_id":"public/2018/10/05/js继承/index.html","hash":"0b34237dbb61bbba4aadc927dc2b7848c97fc64e","modified":1708681029939},{"_id":"public/2018/10/01/常见的排序算法/index.html","hash":"f227b7e8bf838a15abfd6009f8a7be7b7d731182","modified":1708681029939},{"_id":"public/2018/09/27/px、em、rem区别/index.html","hash":"a51c5f3b7828c6843afab1cd0b2ecd0ffb20b4a9","modified":1708681029939},{"_id":"public/2018/09/25/你好，潘君毅/index.html","hash":"d657da47385766335e7541d74b6616b9412baec8","modified":1708681029939},{"_id":"public/archives/index.html","hash":"df3174695272c0024bec423e9180f3ab1c84adb0","modified":1708681029939},{"_id":"public/archives/page/2/index.html","hash":"66cbd0f0b4f309317d844f1b2ad326c746cddb99","modified":1708681029939},{"_id":"public/archives/page/3/index.html","hash":"e5df80ec6978885a367e723f629136cefe15ce5c","modified":1708681029939},{"_id":"public/archives/page/4/index.html","hash":"33ec51b88d9cb374b6f89fc1cfb0f9f8c6942c75","modified":1708681029939},{"_id":"public/archives/page/5/index.html","hash":"7d8dece5e268975a256abebf48c50a8b6bfbc7d7","modified":1708681029939},{"_id":"public/archives/page/6/index.html","hash":"bdbd9600524e79914c69e2cb75532f790cc1c786","modified":1708681029939},{"_id":"public/archives/page/7/index.html","hash":"f748f1a99d7262419343bfe5ef788754592a5e4d","modified":1708681029939},{"_id":"public/archives/2018/index.html","hash":"e0eaf3340868d14b4b0808646b99988bf54312d7","modified":1708681029939},{"_id":"public/archives/2018/page/2/index.html","hash":"0e997255c47e4ba4364a38904629534d79c9ac94","modified":1708681029939},{"_id":"public/archives/2018/page/3/index.html","hash":"0342486650a6560abc417805f0f8553157095dbe","modified":1708681029939},{"_id":"public/archives/2018/page/4/index.html","hash":"037b679c8bf4fc18e9dcc52467675a5464f531e7","modified":1708681029939},{"_id":"public/archives/2018/10/index.html","hash":"55f382481b8eb138373cb1488a264a857065b293","modified":1708681029939},{"_id":"public/archives/2018/10/page/2/index.html","hash":"6d8e204a751657070039605c16c99cd6cbb1ec24","modified":1708681029939},{"_id":"public/archives/2018/10/page/3/index.html","hash":"9f2259272f83d0752d8d775846b5ed637cda7e01","modified":1708681029939},{"_id":"public/archives/2019/index.html","hash":"869f4beb77c98eb67e2833c3b78b5745dea52ac1","modified":1708681029939},{"_id":"public/archives/2019/page/2/index.html","hash":"a2b0015511ae19abaea52820b53cd2d12e355d22","modified":1708681029939},{"_id":"public/archives/2019/06/index.html","hash":"28a792e05f8b8179606d00d8f0e22d1adf0bb655","modified":1708681029939},{"_id":"public/archives/2020/index.html","hash":"ebcb7ecd74d0ddb8cf1e9ca7c46ae9b6b5deeb7e","modified":1708681029939},{"_id":"public/categories/前端/index.html","hash":"00431c658ffac239c777a92a4fe430effd47b1f0","modified":1708681029939},{"_id":"public/categories/前端/page/2/index.html","hash":"43f6cd6e7ff06708fe84699ca226d8bb42ef25b9","modified":1708681029939},{"_id":"public/categories/前端/page/3/index.html","hash":"309f9644aa7a0f8fc463700df49dd9561121f61b","modified":1708681029939},{"_id":"public/categories/前端/page/4/index.html","hash":"ab816ad0084e97c54d5e4698bafd5a6d2962e05f","modified":1708681029939},{"_id":"public/categories/前端/page/5/index.html","hash":"7b84bb7b36bdc6b303bd26751036d5f3be1924d2","modified":1708681029939},{"_id":"public/categories/前端/page/6/index.html","hash":"a74f7faca2c07063a34ac435a3d1b5aed72e5ee5","modified":1708681029939},{"_id":"public/index.html","hash":"003831a34ce866a40412f954863ea9a385f3b159","modified":1708681029939},{"_id":"public/page/2/index.html","hash":"0ae4860a2cac7b9094c3707cbdc2940a5aee1a76","modified":1708681029939},{"_id":"public/page/3/index.html","hash":"e2f45127271f27fc8b17eb6567102d2ac392b90b","modified":1708681029939},{"_id":"public/page/4/index.html","hash":"dfa4e1c016647963ff481441a269dcfd2bbf0976","modified":1708681029939},{"_id":"public/page/5/index.html","hash":"c2871ac5eb8cada7d174fd7637a49f8b91be0972","modified":1708681029939},{"_id":"public/page/6/index.html","hash":"c01e5307c5ce272bbfd612aa8556453b569b8beb","modified":1708681029939},{"_id":"public/page/7/index.html","hash":"729cd026b5855b59da42de9517ea100968917fca","modified":1708681029939},{"_id":"public/page/8/index.html","hash":"11e54b7077110e12e30b9851bcc0c48b76ded378","modified":1708681029939},{"_id":"public/tags/js/index.html","hash":"9163b37882621a400b4965a653c1ef729787773d","modified":1708681029939},{"_id":"public/tags/js/page/2/index.html","hash":"b2729fcf7a16595b57b135827de2ca7ac0107e38","modified":1708681029939},{"_id":"public/tags/Vue/index.html","hash":"5d23ffe15b3b0bc0e4898d8a5634b15f0954800a","modified":1708681029939},{"_id":"public/tags/css/index.html","hash":"70dd29b9f489056118fbd44993c52b612940a2d9","modified":1708681029939},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1708339753983},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1708339753983},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1708339753983},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1708339753983},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1708339753983},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1708339753983},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1708339753983},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1708339753983},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1708339753983},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1708339753983},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1708339753983},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1708339753983},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1708339753983},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1708339753983},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1708339753983},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1708339753983},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1708339753983},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1708339753983},{"_id":"public/2018/10/11/css盒模型/0754b65440c0fe40808b6481d881c0d2.png","hash":"326ea43b0ca553d960256b7e79edba78dff0460b","modified":1708339753983},{"_id":"public/2018/10/11/css盒模型/7018d20d4024c8748094ee6c656cbc13.png","hash":"eadaef2aa77f3fa09cd97b9753fc1bb617f6707a","modified":1708339753983},{"_id":"public/2018/10/24/react/231d414640b509d980203a5ab45a3c4e.png","hash":"d6cf098302dc32a842d964599ee4cccc9b2b4e6d","modified":1708339753983},{"_id":"public/2018/10/24/react/35cc29484072961d801e4de7f94c3b65.png","hash":"9051fd4ba2fdf9ac199a270ee885df6653b3ce41","modified":1708339753983},{"_id":"public/2018/10/24/react/6873d82c40e03c3080a5f4098f6df602.png","hash":"4918e3b454b762119791eb6f30fa306c9d9f0b26","modified":1708339753983},{"_id":"public/2018/10/06/js的prototype总结/3ed52e91409ae13e805e9ea9c771c66c.png","hash":"013c4f9426aa4375c457be452ee9c324c1ab6f5d","modified":1708339753983},{"_id":"public/2018/10/06/js的prototype总结/ad023c9f40a1e17f803967a5a402683e.png","hash":"354356662ad312d2df7991c64d79a0f5d1081b64","modified":1708339753983},{"_id":"public/2018/10/06/js的prototype总结/fc61390740d130488051d1089074ba12.png","hash":"3d92ddfc295517d49b2e9797357197b87dd7c5af","modified":1708339753983},{"_id":"public/2018/10/21/BFC/1362e17d4024bf32807439bb428f8806.png","hash":"38c82971f033e4c2807a419f0afc193f7e9b5fc4","modified":1708339753983},{"_id":"public/2018/10/21/BFC/2e7435f6404a840180b90b5050465d7d.png","hash":"6471ed8822a52435642d089d2d15c714166a4de0","modified":1708339753983},{"_id":"public/2018/10/21/BFC/4e7ccdd640f9f1948001b77f22fff5bc.png","hash":"83a6f68c4b070e61d5ebe1da14d513a947b72f2c","modified":1708339753983},{"_id":"public/2018/10/21/BFC/58fe0bc24074305e80124130cb611524.png","hash":"21fb211880ad1c791aa61748e1f46098e1422951","modified":1708339753983},{"_id":"public/2018/10/21/BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png","hash":"72e6d7e09e3550a761c79d7a3872f3bf0b9ba743","modified":1708339753983},{"_id":"public/2018/10/21/BFC/61f755c3404c04f880bf3759d96965db.png","hash":"71808d6623a603401a2540c8857ea24f9ebea7e5","modified":1708339753983},{"_id":"public/2018/10/21/BFC/9f51d5ac40bdb5fa804d79aed400cab1.png","hash":"661a07f65ba84c188a519392d0ddef905e793eed","modified":1708339753983},{"_id":"public/2018/10/21/BFC/d1d0d0b84057b84c8064633356e7a56a.png","hash":"bab1f59616eb921ac48ef249d12d125a4efbe653","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/8AC59C17C15A4885A126F0B3B824E20B.png","hash":"a609cac4202d9c46443f430129fc5c906f7577c0","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/504B85A8EA314E70BC3BB9C865A14FB4.png","hash":"312ec9b007eb8aeadfaccdcc1ef732483e0a0829","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/D7B775D11EB743F094F9802ACDF78DBA.png","hash":"f25e4d68f97764905aad80834000f0596f842ce7","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/B670A19A85B547999C298B6BA314E0F1.png","hash":"5fdee2bbcc35b0367dae49eb7241da0afacb7acd","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125110844187.png","hash":"e34c83f53e2a7d9b9ca0be9e4eb2e079fed27eee","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125113409121.png","hash":"f30fd18cb82180f7cae6d87e132dbffc4bce369a","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125143155721.png","hash":"fde721a3c2ecdfa8d98825b5fd1570cce2ba01c0","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125162500220.png","hash":"0135f808fd9f4c350ccd1f618c5ae2de229df984","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125113538013.png","hash":"1ce25aa586104c250bf048a8ce1570ba46714bde","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125163342091.png","hash":"15e9715e07bac23ceee047ec5c09be76814991ba","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125164612639.png","hash":"ce78ba48cb4b1d9aca5b1927985ce53115fca972","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125164622944.png","hash":"05fe9c609c4671abddaec2483fc02e9e69db4bba","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125165024993.png","hash":"37fe8c950b498ed8262a060ce121e5066deaf006","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125162859189.png","hash":"e032e202f9097b5318afe61c4788437dbdaf86cf","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125164803760.png","hash":"6749297b758900b2ef24970d83820d2cf34fd7ee","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125165043733.png","hash":"d4bcc4aa0396dacd60795e08f0702844e54901bb","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/截屏2022-01-25 上午10.49.46.png","hash":"5cdd5401a8f4f2c352188962c1c9aa6a14c74b69","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125172315264.png","hash":"85836085dbad03c37a1b630a2ec3b0357db5cc08","modified":1708339753983},{"_id":"public/2018/10/18/事件捕获和事件冒泡/b2a98b1d408c0923807704ad7ac95fde.png","hash":"a7b220063c8408a19e6aa2ea1ae33de671a8f370","modified":1708339753983},{"_id":"public/2018/10/01/常见的排序算法/9a8c68df405b4ae980c7a100d9395d26.png","hash":"c8b16ca318355c72612d2a009021527a35893910","modified":1708339753983},{"_id":"public/2018/10/16/二叉树/2153c29240544948808c3bd9081b6a74.png","hash":"d5436415fc01d7d218e99bb07c39b1c2b0b654dc","modified":1708339753983},{"_id":"public/2018/10/16/二叉树/31c90baf409ce7088051e95c118005e1.png","hash":"8f0dc4a842917a08c080ebbaa2cf40b2feb208c8","modified":1708339753983},{"_id":"public/2018/10/11/浏览器渲染流程/f339212b403299f1802345e04edc3c3e.png","hash":"8e547f2e98a1f0c2938fbf709699995ee7b875ad","modified":1708339753983},{"_id":"public/2018/10/16/二叉树/f8f24bb14013ad4f806d1ec8bec299bd.jpg","hash":"6b7133ba73e8f59a3714837b48b73a346348093a","modified":1708339753983},{"_id":"public/2018/10/16/计算机网络/8b9c50964095160480f00995d28b8ac3.png","hash":"540f0df01047507a5e30ea99e3433917c9dc51b2","modified":1708339753983},{"_id":"public/2018/10/19/git使用/d3c801894031d80480e26efe7008a949.png","hash":"1ca4af925a12d584304ce3f42cdc714af1afe8b1","modified":1708339753983},{"_id":"public/2024/02/19/HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png","hash":"0813ab06b03afc34ef0fe5030c80ff7a72a26aa6","modified":1708339753983},{"_id":"public/2018/10/06/js的prototype总结/672e52454044214b80a9d2f140417535.png","hash":"9640b316aa249cd04aac6f5aa8810173163c93b2","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/5DDB5B88A2924C6A840C41533AE0920D.png","hash":"beefb1679dcb9a8069064ec89e594203fd34fec2","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/9DED6512254D4CF0A117E6B1AE5EE402.png","hash":"3848b0480a99b04b330a865ea39218a5dd11f6a8","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/CBED4F4AC4EC45B78044E27BA0CB6A8B.png","hash":"6d98eb08b8bf7c8263ea9fade56726c5ca91c289","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125111731747.png","hash":"8e1982067fb0f15e3d3ae54435b3645d9339a97a","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125170242142.png","hash":"d0848f36cee9b07d3efdd572c430af63a0e5f932","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125172252449.png","hash":"1eadbb30c485702b8bf913151715e3ed8103cb7b","modified":1708339753983},{"_id":"public/2018/10/16/二叉树/f2b1e4ea4075a3078066c8279e3b8028.png","hash":"38a8d95965be727682af7201ced6b5187a097244","modified":1708339753983},{"_id":"public/2018/10/16/计算机网络/e0e0be624093114e805cd93918b993b9.png","hash":"c3294325288ab3f26fd3a53e4115f56cfc991e1a","modified":1708339753983},{"_id":"public/2018/10/16/计算机网络/ffd0bea740c395d2807ae91fd1a27a4f.png","hash":"bbb0be44ccd925b76d2fc1f306c4119168aa615c","modified":1708339753983},{"_id":"public/2018/10/16/计算机网络/a5edd4d540ed8572803058f6a9f0c854.png","hash":"46cea1b2eea57d0dc44148bf797832e3c2e507cb","modified":1708339753983},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1708339753983},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1708339753983},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1708339753983},{"_id":"public/js/src/md5.min.js","hash":"5cd5c4695627f4a02874915eddee964e5c847e6f","modified":1708339753983},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1708339753983},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1708339753983},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1708339753983},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1708339753983},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1708339753983},{"_id":"public/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1708339753983},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1708339753983},{"_id":"public/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1708339753983},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1708339753983},{"_id":"public/css/main.css","hash":"13511552747248d93f8c8066849f93cbc755535d","modified":1708339753983},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1708339753983},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1708339753983},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1708339753983},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1708339753983},{"_id":"public/2018/12/09/Vuex/ef5b88bd404de9f080415eceb994a780.png","hash":"12f59bbf4f32c3aa819771852d236e6e21864f83","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125170026281.png","hash":"36a565d53cb744e382979f7f941b34758f07e850","modified":1708339753983},{"_id":"public/2018/12/09/MVVM/c045b16c40f808e480f874a801a7680a.png","hash":"78ecf374b6465b8ef6220dd88a5b6ee35141ab3b","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125171344267.png","hash":"48b5585a1dc073b5fd725c8fe288fb82fa9f46de","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125171812419.png","hash":"2bd2aa94669ddea51001f7d7f0adda6e52f35fe7","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125172427718.png","hash":"c8c921e137f8f3c819aa270a1cd1b43f0aca76fd","modified":1708339753983},{"_id":"public/2018/11/22/redux/417252aa40fd5841805aee7017fc73cd.png","hash":"951317be521b6f25aac756daca760f2c52be9db1","modified":1708339753983},{"_id":"public/2019/05/03/js变量提升-预处理&&执行上下文/image-20200706121750467.png","hash":"e2133c8b267f246edc257e28f9879209bc6149ba","modified":1708339753983},{"_id":"public/2018/10/06/js的prototype总结/fb2ec26540658c9480e22f7217f7ff29.png","hash":"66218307e4ff8721552a9b31b1466bf8fb34884e","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125172507453.png","hash":"9b2256832cce05a02f7eb89bae3806db82c67ea1","modified":1708339753983},{"_id":"public/2020/08/05/css层叠上下文、层叠等级、层叠顺序以及z-index/image-20200805170444733.png","hash":"fa5543a562ee21b9ef6d204f7e02eee1c886024a","modified":1708339753983},{"_id":"public/2018/10/06/js类型检测总结/5e35a8e04062aeeb805a82c051a9560d.png","hash":"b5e2ecb2e7ae3d43cd2230c06c2a2561d1f1661f","modified":1708339753983},{"_id":"public/2018/10/08/js闭包/a33c05334094f1ce80d00166ab7ed5aa.png","hash":"408189910deeffc27dbf292dcf2996cccda0b15a","modified":1708339753983},{"_id":"public/2018/10/11/浏览器渲染流程/5aa1c0da40be870480eef4f2f8b77931.png","hash":"b7a45381077fed3b7f7480e068dd7197cead6837","modified":1708339753983},{"_id":"public/2024/02/19/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/2428C12B709F42D38859BA4234F61E5D.png","hash":"6de70b07bad5a33bc8c1d53922f59297443829ac","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125103700660.png","hash":"8c367a435da532200116658701b4e4d0a031e3ad","modified":1708339753983},{"_id":"public/2019/05/03/js变量提升-预处理&&执行上下文/image-20200706120514737.png","hash":"70301f6e5b0a10661c3734ab82f99cd858b2a75c","modified":1708339753983},{"_id":"public/2024/02/19/WebRtc-Internals工具使用/image-20220125111712303.png","hash":"86f0dac1b7199678e4a5e0f1050d72864ab22ee8","modified":1708339753983},{"_id":"public/2018/10/08/js闭包/d2a9dab04077415480e81d7d8e8fd13e.png","hash":"8d41a99358d96965b74554ae8ffff90db51f449d","modified":1708339753983},{"_id":"public/2024/02/19/HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png","hash":"5d81d026f4a044101ebb0c107895366c44d8bda5","modified":1708339753983},{"_id":"source/_posts/WebRtc.md","hash":"a65397b65e8f8114ec1b18f6383cddb32ee47976","modified":1708681001882},{"_id":"source/_posts/WebRtc/webrtcJiagou.png","hash":"da1ebeb8c98d2d59994d09c510768a0e5e72066a","modified":1708511468989},{"_id":"source/_posts/WebRtc/NAT.png","hash":"04ef98a85d037b0c8f52ab410466bc07c4b61215","modified":1708653285254},{"_id":"source/_posts/WebRtc/RTCDataChannel.png","hash":"6594a819d42df2ed272ce135e31b48f658053d54","modified":1708598839736},{"_id":"source/_posts/WebRtc/mediaStream.png","hash":"60ff540dfa10b071e7994c677c222693e6915b2b","modified":1708598143932},{"_id":"source/_posts/WebRtc/portNat.png","hash":"b665e18f487a444fece3463c10b80754f03a474f","modified":1708676641881},{"_id":"source/_posts/WebRtc/Full\u001dConeNAT.png","hash":"cefaa4ae2802ef5bb6a37f7587ec55c9a3d22f18","modified":1708675975093},{"_id":"source/_posts/WebRtc/RTCPeerConnection.png","hash":"8e10439dbadff3cd5bb0bf703054b157dc16ac72","modified":1708598571901},{"_id":"source/_posts/WebRtc/NAT穿透流程举例.png","hash":"a3b466b09c24d5e9bc5c120515374c382baaa5e5","modified":1708674337487},{"_id":"source/_posts/WebRtc/ICE.png","hash":"73e92383881fb8d0e11e85cf7731528216d51626","modified":1708675755317},{"_id":"source/_posts/WebRtc/network.png","hash":"26c97b77e81d7188cd228a02e318405a80acc6c7","modified":1708599392276},{"_id":"source/_posts/WebRtc/stun.png","hash":"0acedf13cf6d013c580793aed88928eadef1dae0","modified":1708674895278},{"_id":"source/_posts/WebRtc/IPNat.png","hash":"9274061349aabffdeb909d205216b6df2b6ea945","modified":1708676214693},{"_id":"source/_posts/WebRtc/NATOpen.png","hash":"aab576ab057502a97ad641414817fe6afc314fe6","modified":1708677737101},{"_id":"source/_posts/WebRtc/SymmetricNat.png","hash":"55bc587f192e96fd92f22f4403efb7b52d483dc1","modified":1708676761005},{"_id":"source/_posts/WebRtc/turn.png","hash":"af18c197d761a4d7e55fa03520fdfde14f2a7307","modified":1708675101093},{"_id":"source/_posts/WebRtc/ICESend.png","hash":"31c823e63ed133232ac2956aa2a91b85f78c1129","modified":1708678685143},{"_id":"source/_posts/WebRtc/AS&BPNat.png","hash":"09054188effc16dc70bcc6f93b7e67c2db69f8bb","modified":1708677392050},{"_id":"source/_posts/WebRtc/sdp.png","hash":"f59cdad74be01ed48f173e0c9125bdfd422fe559","modified":1708678593950},{"_id":"source/_posts/WebRtc/A&BFullNat.png","hash":"4960cd9a24b42a0cd9f8e83827c595ac8b0a2547","modified":1708676914312},{"_id":"public/2024/02/21/WebRtc/index.html","hash":"911e5deb15fe9d09463dff2e140276f7a0f2971a","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/RTCDataChannel.png","hash":"6594a819d42df2ed272ce135e31b48f658053d54","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/NAT.png","hash":"04ef98a85d037b0c8f52ab410466bc07c4b61215","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/portNat.png","hash":"b665e18f487a444fece3463c10b80754f03a474f","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/mediaStream.png","hash":"60ff540dfa10b071e7994c677c222693e6915b2b","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/RTCPeerConnection.png","hash":"8e10439dbadff3cd5bb0bf703054b157dc16ac72","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/Full\u001dConeNAT.png","hash":"cefaa4ae2802ef5bb6a37f7587ec55c9a3d22f18","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/NAT穿透流程举例.png","hash":"a3b466b09c24d5e9bc5c120515374c382baaa5e5","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/network.png","hash":"26c97b77e81d7188cd228a02e318405a80acc6c7","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/ICE.png","hash":"73e92383881fb8d0e11e85cf7731528216d51626","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/stun.png","hash":"0acedf13cf6d013c580793aed88928eadef1dae0","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/SymmetricNat.png","hash":"55bc587f192e96fd92f22f4403efb7b52d483dc1","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/IPNat.png","hash":"9274061349aabffdeb909d205216b6df2b6ea945","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/NATOpen.png","hash":"aab576ab057502a97ad641414817fe6afc314fe6","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/turn.png","hash":"af18c197d761a4d7e55fa03520fdfde14f2a7307","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/ICESend.png","hash":"31c823e63ed133232ac2956aa2a91b85f78c1129","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/sdp.png","hash":"f59cdad74be01ed48f173e0c9125bdfd422fe559","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/AS&BPNat.png","hash":"09054188effc16dc70bcc6f93b7e67c2db69f8bb","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/A&BFullNat.png","hash":"4960cd9a24b42a0cd9f8e83827c595ac8b0a2547","modified":1708681029939},{"_id":"public/2024/02/21/WebRtc/webrtcJiagou.png","hash":"da1ebeb8c98d2d59994d09c510768a0e5e72066a","modified":1708681029939}],"Category":[{"name":"前端","_id":"clsstdr8q00041xop5xyn9fmk"},{"name":"读书笔记","_id":"clsstdr9b000q1xop6bh7buvq"},{"name":"git","_id":"clsstdraf002c1xope5hf0m61"},{"name":"数据结构","_id":"clsstdri6005p1xope5edeaqm"},{"name":"算法","_id":"clsstdrie006u1xopb8vv96ca"},{"name":"计算机网络","_id":"clsstdrig00731xop22eg6ze7"}],"Data":[],"Page":[{"title":"about","date":"2018-09-25T10:02:29.000Z","layout":"about","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-25 18:02:29\nlayout: about\ntype: about\n---\n","updated":"2024-02-19T07:42:51.638Z","path":"about/index.html","comments":1,"_id":"clsstdr8a00001xopazyp7khz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2018-09-25T10:00:08.000Z","layout":"categories","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-25 18:00:08\nlayout: categories\ntype: categories\n---\n","updated":"2024-02-19T07:42:51.638Z","path":"categories/index.html","comments":1,"_id":"clsstdr8k00021xop2b8hbray","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-09-25T10:01:34.000Z","layout":"tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-25 18:01:34\nlayout: tags\ntype: tags\n---\n","updated":"2024-02-19T07:42:51.638Z","path":"tags/index.html","comments":1,"_id":"clsstdrhf005c1xop5erbh6r0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CommonJS、AMD、CMD","date":"2018-10-20T03:16:56.000Z","_content":"\n### CommonJS、AMD、CMD\n\n#### 在介绍这些之前，首先介绍下前端模块化的演变过程\n\n### 前端模块化\n\n1. 什么是模块化\n\n   - 将一个复杂的程序按照一定的规则封装成几个块，并进行组合。\n   - 块的内部数据与实现是私有的，外界没有操作改变的权限，只是暴露一些接口与外部其他模块通信。\n\n2. 模块化的进化过程\n\n   - 全局Function模式：将不同的功能封装成不同的全局函数\n\n     > 问题：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。\n\n   - namespace模式：简单对象封装\n\n     > 优点：减少全局变量的污染，解决命名冲突\n     >\n     > 问题：数据不是私有的（内部定义的数据可以被修改），不够安全。\n\n   - IIFE模式：匿名函数自调用(闭包)\n\n     > 作用：数据是私有的，外部只能通过暴露出去的方法进行操作\n     >\n     > 编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口\n     >\n     > 问题：如果当前模块依赖另一个模块时怎么办\n\n     ```js\n     (function(window){\n       // 相关处理\n       let name = 'bar',\n           age = 20;\n       // 私有方法\n       function getName() {\n         console.log(name);\n       }\n       function getAge() {\n         console.log(age);\n       }\n       // 对外提供的入口方法\n       function say() {\n         getName();\n         getAge();\n       }\n       // 对外暴露\n       window.MyPeople = {say}\n     })(window)\n     ```\n\n     \n\n   - IIFE模式增强：引入依赖\n\n     > 做法：将所依赖的库当做参数传入，这样就解决了依赖扩展问题。\n\n3. 模块化的好处\n\n   - 避免命名冲突，减少全局变量污染\n   - 相关功能分离，降低了耦合性，可以做到按需加载\n   - 更高的复用性\n   - 更好维护\n\n4. 引入多个`<script>`后出现的后果\n\n   - 发起的请求过多\n   - 多个外部js文件相互依赖关系不确定\n   - 维护起来困难呢\n\n5. 模块化规范\n\n   > 模块化带来的好处是非常明显的，但是会存在第四点所说的那些问题，为了解决此类问题，所以就有了模块化编写规范的诞生。\n   >\n   > **在服务器端，模块的加载是运行时同步加载的（服务器端，文件的加载都是存储在服务器本地，读取本地文件是非常快的，所以采用同步加载的方式，对性能方面影响不大）；在浏览器端，模块需要提前编译打包处理，属于异步加载模式，这时候采用同步模式加载就不太合适了。（由于浏览器属于异步加载模式，如果采用同步模式的话，会造成阻塞。）**\n\n   - CommonJS\n\n     - 所有代码运行在模块作用域，不会污染全局作用域\n     - 属于同步加载\n     - 模块可以多次加载，但是只会在第一次加载时运行一次，加载结果会被缓存，后续再去加载的话，直接读取的是缓存，如果想要去重新加载，必须清除缓存。\n     - 模块加载的顺序是自上而下按照代码出现的顺序。\n     - CommonJS模块的加载机制是，输入的是被输出的值得拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。(这与ES6模块化有所差异)\n\n   - AMD\n\n     - 非同步加载，允许指定回调函数。\n     - 所有代码运行在模块作用域，不会污染全局作用域\n\n   - CMD\n\n     - 模块加载是异步的，模块使用时才会加载执行。\n\n   - ES6\n\n     ES6与CommonJS模块差异：\n\n     - CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值得引用。\n     - CommonJS模块是运行时加载，ES6模块是编译时输出接口。\n\n##### CommonJS\n\n浏览器不兼容CommonJS的根本原因，在于其缺少四个Node.js环境的变量\n\n- module\n\n- exports\n\n- require\n\n- global\n\n  **如果提供以上四个变量，浏览器就可以加载CommonJS模块**\n\n  Browserify是CommonJS格式转换的工具，语法：\n\n  > ```javascript\n  > // foo.js\n  > module.exports = function(x) {\n  >   console.log(x);\n  > };\n  > \n  > // main.js\n  > var foo = require(\"./foo\");\n  > foo(\"Hi\");\n  > ```\n\n  使用下面的命令，就能将main.js转为浏览器可用的格式。\n\n   \n\n  > ```bash\n  > $ browserify main.js > compiled.js\n  > ```\n\n   \n\n  Browserify到底做了什么？安装一下[browser-unpack](https://www.npmjs.com/package/browser-unpack)，就能看清楚了。\n\n   \n\n  > ```bash\n  > $ npm install browser-unpack -g\n  > ```\n\n   \n\n  然后，将前面生成的compile.js解包。\n\n   \n\n  > ```bash\n  > $ browser-unpack < compiled.js\n  > \n  > [\n  >   {\n  >     \"id\":1,\n  >     \"source\":\"module.exports = function(x) {\\n  console.log(x);\\n};\",\n  >     \"deps\":{}\n  >   },\n  >   {\n  >     \"id\":2,\n  >     \"source\":\"var foo = require(\\\"./foo\\\");\\nfoo(\\\"Hi\\\");\",\n  >     \"deps\":{\"./foo\":1},\n  >     \"entry\":true\n  >   }\n  > ]\n  > ```\n\n   \n\n  可以看到，browerify 将所有模块放入一个数组，`id` 属性是模块的编号，`source` 属性是模块的源码，`deps` 属性是模块的依赖。\n\n   \n\n  因为 `main.js` 里面加载了 `foo.js`，所以` deps` 属性就指定 `./foo` 对应1号模块。执行的时候，浏览器遇到 `require('./foo') `语句，就自动执行1号模块的 `source` 属性，并将执行后的` module.exports` 属性值输出。\n\n   使用CommonJS的不足之处在于同步加载。\n\n  ```js\n  var math=require('math');\n  math.add(2,3);\n  ```\n\n  第二行的`math.add`依赖于`math`文件，需要等到`require('math')`执行之后，才能继续执行。也就是说，如果加载的文件过大的话，就会出现页面停在那里。\n\n  这在服务器端不会存在问题，因为所有的模块都是存在本地的，读取可以同步加载完成，等待时间就是读取本地文件的时间，而在浏览器端就不同了，由于模块都是存放在服务器端的，如果网速过慢，或者文件过大，都会导致加载文件时浏览器产生\"假死\"状态。\n\n  *CommonJS主要是为了JS在后端开发定制的，并不适用于前端，AMD（异步模块定义）主要为前端JS的表现定制的一套规范。*\n\n##### AMD\n\n特点：它采用异步加载方式加载模块，模块的加载不会影响到它后边的语句的执行，所有依赖当前模块的语句，都定义在一个回掉函数中，等加载完成后，才会执行回掉函数的内容。\n\nrequire语法：\n\n```js\nrequire([module],callback); //接受两个参数\n```\n\n*参数`[module]`：是一个数组作为第一个参数，里边的成员就是要加载的模块；参数`callback`：加载成功后的回掉函数。*\n\n目前主要有两个javascript库实现AMD规范：`require.js`和`curl.js`。\n\n##### define函数：\n\n> 语法：\n>\n> ```js\n> define(id?,dependencies,factory);\n> ```\n>\n> **id:**第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名**必须**是“顶级”的和绝对的（不允许相对名字）。\n>\n> **依赖：**第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。\n>\n> **工厂方法：**第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。\n>\n> - 模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串\n>\n> - 单词须为驼峰形式，或者\".\"，\"..\"\n>\n> - 模块名不允许文件扩展名的形式，如\".js\"\n>\n> - 模块名可以为 \"相对的\" 或 \"顶级的\"。如果首字符为\".\"或\"..\"则为\"相对的\"模块名\n>\n> - 顶级的模块名从根命名空间的概念模块解析\n>\n> - 相对的模块名从 \"require\" 书写和调用的模块解析\n>\n>   相对模块名解析示例：\n>\n>   - 如果模块 `\"a/b/c\"` 请求 `\"../d\"`, 则解析为`\"a/d\"`\n>\n>   - 如果模块 `\"a/b/c\"` 请求 `\"./e\"`, 则解析为`\"a/b/e\"`\n>\n\n##### CMD\n\n> 参考：\n>\n> [seajs]: https://github.com/seajs/seajs/issues/242\n\n在CMD规范中，一个模块就是一个文件。\n\n```js\ndefine(factory);\n```\n\n`define`接受`factory`参数，`factory`可以是一个函数，也可以是一个对象或字符串。\n\n`factory`为对象、字符串时，表示模块的接口就是该对象、字符串，比如为一个json数据模块：\n\n```js\ndefine({\"foo\":\"bar\"});\n```\n\n也可以通过字符串定义模板模块：\n\n```js\ndefine('I am a template. My name is {{name}}.');\n```\n\n`factory` 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。`factory` 方法在执行时，默认会传入三个参数：`require`、`exports` 和 `module`：\n\n```js\ndefine(function(require, exports, module) {\n\n  // 模块代码\n\n});\n```\n\n### define `define(id?, deps?, factory)`\n\n`define` 也可以接受两个以上参数。字符串 `id` 表示模块标识，数组 `deps` 是模块依赖。比如：\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n  // 模块代码\n\n});\n```\n\n`id` 和 `deps` 参数可以省略。省略时，可以通过构建工具自动生成。\n\n**注意**：带 `id` 和 `deps` 参数的 `define` 用法不属于 CMD 规范，而属于 [Modules/Transport](https://github.com/cmdjs/specification/blob/master/draft/transport.md) 规范。\n\n##### AMD和CMD异同\n\n1. 相同之处：都是倡导模块化开发理念，核心价值是让JavaScript的模块化开发变得简单自然。\n2. 不同之处：\n   - **定位有差异**。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。\n   - **遵循的规范不同**。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。\n   - **推广理念有差异**。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。\n   - **对开发调试的支持有差异**。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。\n   - **插件机制不同**。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。\n\n**最后：SeaJS对模块的态度是懒执行（用到时再请求）, 而RequireJS对模块的态度是预执行（使用前请求模块）**\n\n\n\n##### **es6 中的export export default 和node 中的module.exports exports区别**\n\n1. export default导出的成员，可以使用任意的变量来接收\n\n   ```js\n   // a.js\n   let obj = {name: '张三'};\n   export default obj;\n   \n   // b.js\n   import objName from './a.js';\n   \n   console.log(objName.name); // 张三\n   ```\n\n2. export 导出的成员，名字必须严格一致，需要改变名字时，使用**as**来起别名，使用{}形式接受，属于按需导出，可以暴露出多个成员\n\n   ```js\n   // a.js\n   export function getName() {};\n   \n   // b.js\n   import {getName} from './a.js';\n   ```\n\n3. node中exports 相当于是module.exports向外暴露的一个别名\n\n   ```js\n   var exports = module.exports;\n   ```\n\n   module变量是一个对象，代表当前模块(node中一个文件就是一个模块)，而exports是module的一个属性，加载某个模块其实是加载的当前模块的module.exports属性。\n\n   ","source":"_posts/CommonJS、AMD、CMD.md","raw":"---\ntitle: CommonJS、AMD、CMD\ndate: 2018-10-20 11:16:56\ntags: 模块开发规范\ncategories: 前端\n---\n\n### CommonJS、AMD、CMD\n\n#### 在介绍这些之前，首先介绍下前端模块化的演变过程\n\n### 前端模块化\n\n1. 什么是模块化\n\n   - 将一个复杂的程序按照一定的规则封装成几个块，并进行组合。\n   - 块的内部数据与实现是私有的，外界没有操作改变的权限，只是暴露一些接口与外部其他模块通信。\n\n2. 模块化的进化过程\n\n   - 全局Function模式：将不同的功能封装成不同的全局函数\n\n     > 问题：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。\n\n   - namespace模式：简单对象封装\n\n     > 优点：减少全局变量的污染，解决命名冲突\n     >\n     > 问题：数据不是私有的（内部定义的数据可以被修改），不够安全。\n\n   - IIFE模式：匿名函数自调用(闭包)\n\n     > 作用：数据是私有的，外部只能通过暴露出去的方法进行操作\n     >\n     > 编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口\n     >\n     > 问题：如果当前模块依赖另一个模块时怎么办\n\n     ```js\n     (function(window){\n       // 相关处理\n       let name = 'bar',\n           age = 20;\n       // 私有方法\n       function getName() {\n         console.log(name);\n       }\n       function getAge() {\n         console.log(age);\n       }\n       // 对外提供的入口方法\n       function say() {\n         getName();\n         getAge();\n       }\n       // 对外暴露\n       window.MyPeople = {say}\n     })(window)\n     ```\n\n     \n\n   - IIFE模式增强：引入依赖\n\n     > 做法：将所依赖的库当做参数传入，这样就解决了依赖扩展问题。\n\n3. 模块化的好处\n\n   - 避免命名冲突，减少全局变量污染\n   - 相关功能分离，降低了耦合性，可以做到按需加载\n   - 更高的复用性\n   - 更好维护\n\n4. 引入多个`<script>`后出现的后果\n\n   - 发起的请求过多\n   - 多个外部js文件相互依赖关系不确定\n   - 维护起来困难呢\n\n5. 模块化规范\n\n   > 模块化带来的好处是非常明显的，但是会存在第四点所说的那些问题，为了解决此类问题，所以就有了模块化编写规范的诞生。\n   >\n   > **在服务器端，模块的加载是运行时同步加载的（服务器端，文件的加载都是存储在服务器本地，读取本地文件是非常快的，所以采用同步加载的方式，对性能方面影响不大）；在浏览器端，模块需要提前编译打包处理，属于异步加载模式，这时候采用同步模式加载就不太合适了。（由于浏览器属于异步加载模式，如果采用同步模式的话，会造成阻塞。）**\n\n   - CommonJS\n\n     - 所有代码运行在模块作用域，不会污染全局作用域\n     - 属于同步加载\n     - 模块可以多次加载，但是只会在第一次加载时运行一次，加载结果会被缓存，后续再去加载的话，直接读取的是缓存，如果想要去重新加载，必须清除缓存。\n     - 模块加载的顺序是自上而下按照代码出现的顺序。\n     - CommonJS模块的加载机制是，输入的是被输出的值得拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。(这与ES6模块化有所差异)\n\n   - AMD\n\n     - 非同步加载，允许指定回调函数。\n     - 所有代码运行在模块作用域，不会污染全局作用域\n\n   - CMD\n\n     - 模块加载是异步的，模块使用时才会加载执行。\n\n   - ES6\n\n     ES6与CommonJS模块差异：\n\n     - CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值得引用。\n     - CommonJS模块是运行时加载，ES6模块是编译时输出接口。\n\n##### CommonJS\n\n浏览器不兼容CommonJS的根本原因，在于其缺少四个Node.js环境的变量\n\n- module\n\n- exports\n\n- require\n\n- global\n\n  **如果提供以上四个变量，浏览器就可以加载CommonJS模块**\n\n  Browserify是CommonJS格式转换的工具，语法：\n\n  > ```javascript\n  > // foo.js\n  > module.exports = function(x) {\n  >   console.log(x);\n  > };\n  > \n  > // main.js\n  > var foo = require(\"./foo\");\n  > foo(\"Hi\");\n  > ```\n\n  使用下面的命令，就能将main.js转为浏览器可用的格式。\n\n   \n\n  > ```bash\n  > $ browserify main.js > compiled.js\n  > ```\n\n   \n\n  Browserify到底做了什么？安装一下[browser-unpack](https://www.npmjs.com/package/browser-unpack)，就能看清楚了。\n\n   \n\n  > ```bash\n  > $ npm install browser-unpack -g\n  > ```\n\n   \n\n  然后，将前面生成的compile.js解包。\n\n   \n\n  > ```bash\n  > $ browser-unpack < compiled.js\n  > \n  > [\n  >   {\n  >     \"id\":1,\n  >     \"source\":\"module.exports = function(x) {\\n  console.log(x);\\n};\",\n  >     \"deps\":{}\n  >   },\n  >   {\n  >     \"id\":2,\n  >     \"source\":\"var foo = require(\\\"./foo\\\");\\nfoo(\\\"Hi\\\");\",\n  >     \"deps\":{\"./foo\":1},\n  >     \"entry\":true\n  >   }\n  > ]\n  > ```\n\n   \n\n  可以看到，browerify 将所有模块放入一个数组，`id` 属性是模块的编号，`source` 属性是模块的源码，`deps` 属性是模块的依赖。\n\n   \n\n  因为 `main.js` 里面加载了 `foo.js`，所以` deps` 属性就指定 `./foo` 对应1号模块。执行的时候，浏览器遇到 `require('./foo') `语句，就自动执行1号模块的 `source` 属性，并将执行后的` module.exports` 属性值输出。\n\n   使用CommonJS的不足之处在于同步加载。\n\n  ```js\n  var math=require('math');\n  math.add(2,3);\n  ```\n\n  第二行的`math.add`依赖于`math`文件，需要等到`require('math')`执行之后，才能继续执行。也就是说，如果加载的文件过大的话，就会出现页面停在那里。\n\n  这在服务器端不会存在问题，因为所有的模块都是存在本地的，读取可以同步加载完成，等待时间就是读取本地文件的时间，而在浏览器端就不同了，由于模块都是存放在服务器端的，如果网速过慢，或者文件过大，都会导致加载文件时浏览器产生\"假死\"状态。\n\n  *CommonJS主要是为了JS在后端开发定制的，并不适用于前端，AMD（异步模块定义）主要为前端JS的表现定制的一套规范。*\n\n##### AMD\n\n特点：它采用异步加载方式加载模块，模块的加载不会影响到它后边的语句的执行，所有依赖当前模块的语句，都定义在一个回掉函数中，等加载完成后，才会执行回掉函数的内容。\n\nrequire语法：\n\n```js\nrequire([module],callback); //接受两个参数\n```\n\n*参数`[module]`：是一个数组作为第一个参数，里边的成员就是要加载的模块；参数`callback`：加载成功后的回掉函数。*\n\n目前主要有两个javascript库实现AMD规范：`require.js`和`curl.js`。\n\n##### define函数：\n\n> 语法：\n>\n> ```js\n> define(id?,dependencies,factory);\n> ```\n>\n> **id:**第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名**必须**是“顶级”的和绝对的（不允许相对名字）。\n>\n> **依赖：**第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。\n>\n> **工厂方法：**第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。\n>\n> - 模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串\n>\n> - 单词须为驼峰形式，或者\".\"，\"..\"\n>\n> - 模块名不允许文件扩展名的形式，如\".js\"\n>\n> - 模块名可以为 \"相对的\" 或 \"顶级的\"。如果首字符为\".\"或\"..\"则为\"相对的\"模块名\n>\n> - 顶级的模块名从根命名空间的概念模块解析\n>\n> - 相对的模块名从 \"require\" 书写和调用的模块解析\n>\n>   相对模块名解析示例：\n>\n>   - 如果模块 `\"a/b/c\"` 请求 `\"../d\"`, 则解析为`\"a/d\"`\n>\n>   - 如果模块 `\"a/b/c\"` 请求 `\"./e\"`, 则解析为`\"a/b/e\"`\n>\n\n##### CMD\n\n> 参考：\n>\n> [seajs]: https://github.com/seajs/seajs/issues/242\n\n在CMD规范中，一个模块就是一个文件。\n\n```js\ndefine(factory);\n```\n\n`define`接受`factory`参数，`factory`可以是一个函数，也可以是一个对象或字符串。\n\n`factory`为对象、字符串时，表示模块的接口就是该对象、字符串，比如为一个json数据模块：\n\n```js\ndefine({\"foo\":\"bar\"});\n```\n\n也可以通过字符串定义模板模块：\n\n```js\ndefine('I am a template. My name is {{name}}.');\n```\n\n`factory` 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。`factory` 方法在执行时，默认会传入三个参数：`require`、`exports` 和 `module`：\n\n```js\ndefine(function(require, exports, module) {\n\n  // 模块代码\n\n});\n```\n\n### define `define(id?, deps?, factory)`\n\n`define` 也可以接受两个以上参数。字符串 `id` 表示模块标识，数组 `deps` 是模块依赖。比如：\n\n```js\ndefine('hello', ['jquery'], function(require, exports, module) {\n\n  // 模块代码\n\n});\n```\n\n`id` 和 `deps` 参数可以省略。省略时，可以通过构建工具自动生成。\n\n**注意**：带 `id` 和 `deps` 参数的 `define` 用法不属于 CMD 规范，而属于 [Modules/Transport](https://github.com/cmdjs/specification/blob/master/draft/transport.md) 规范。\n\n##### AMD和CMD异同\n\n1. 相同之处：都是倡导模块化开发理念，核心价值是让JavaScript的模块化开发变得简单自然。\n2. 不同之处：\n   - **定位有差异**。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。\n   - **遵循的规范不同**。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。\n   - **推广理念有差异**。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。\n   - **对开发调试的支持有差异**。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。\n   - **插件机制不同**。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。\n\n**最后：SeaJS对模块的态度是懒执行（用到时再请求）, 而RequireJS对模块的态度是预执行（使用前请求模块）**\n\n\n\n##### **es6 中的export export default 和node 中的module.exports exports区别**\n\n1. export default导出的成员，可以使用任意的变量来接收\n\n   ```js\n   // a.js\n   let obj = {name: '张三'};\n   export default obj;\n   \n   // b.js\n   import objName from './a.js';\n   \n   console.log(objName.name); // 张三\n   ```\n\n2. export 导出的成员，名字必须严格一致，需要改变名字时，使用**as**来起别名，使用{}形式接受，属于按需导出，可以暴露出多个成员\n\n   ```js\n   // a.js\n   export function getName() {};\n   \n   // b.js\n   import {getName} from './a.js';\n   ```\n\n3. node中exports 相当于是module.exports向外暴露的一个别名\n\n   ```js\n   var exports = module.exports;\n   ```\n\n   module变量是一个对象，代表当前模块(node中一个文件就是一个模块)，而exports是module的一个属性，加载某个模块其实是加载的当前模块的module.exports属性。\n\n   ","slug":"CommonJS、AMD、CMD","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr8g00011xop9cdy97hu","content":"<h3 id=\"CommonJS、AMD、CMD\"><a href=\"#CommonJS、AMD、CMD\" class=\"headerlink\" title=\"CommonJS、AMD、CMD\"></a>CommonJS、AMD、CMD</h3><h4 id=\"在介绍这些之前，首先介绍下前端模块化的演变过程\"><a href=\"#在介绍这些之前，首先介绍下前端模块化的演变过程\" class=\"headerlink\" title=\"在介绍这些之前，首先介绍下前端模块化的演变过程\"></a>在介绍这些之前，首先介绍下前端模块化的演变过程</h4><h3 id=\"前端模块化\"><a href=\"#前端模块化\" class=\"headerlink\" title=\"前端模块化\"></a>前端模块化</h3><ol>\n<li><p>什么是模块化</p>\n<ul>\n<li>将一个复杂的程序按照一定的规则封装成几个块，并进行组合。</li>\n<li>块的内部数据与实现是私有的，外界没有操作改变的权限，只是暴露一些接口与外部其他模块通信。</li>\n</ul>\n</li>\n<li><p>模块化的进化过程</p>\n<ul>\n<li><p>全局Function模式：将不同的功能封装成不同的全局函数</p>\n<blockquote>\n<p>问题：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。</p>\n</blockquote>\n</li>\n<li><p>namespace模式：简单对象封装</p>\n<blockquote>\n<p>优点：减少全局变量的污染，解决命名冲突</p>\n<p>问题：数据不是私有的（内部定义的数据可以被修改），不够安全。</p>\n</blockquote>\n</li>\n<li><p>IIFE模式：匿名函数自调用(闭包)</p>\n<blockquote>\n<p>作用：数据是私有的，外部只能通过暴露出去的方法进行操作</p>\n<p>编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口</p>\n<p>问题：如果当前模块依赖另一个模块时怎么办</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 相关处理</span>\n  <span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'bar'</span><span class=\"token punctuation\">,</span>\n      age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 私有方法</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 对外提供的入口方法</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 对外暴露</span>\n  window<span class=\"token punctuation\">.</span>MyPeople <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>say<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>IIFE模式增强：引入依赖</p>\n<blockquote>\n<p>做法：将所依赖的库当做参数传入，这样就解决了依赖扩展问题。</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>模块化的好处</p>\n<ul>\n<li>避免命名冲突，减少全局变量污染</li>\n<li>相关功能分离，降低了耦合性，可以做到按需加载</li>\n<li>更高的复用性</li>\n<li>更好维护</li>\n</ul>\n</li>\n<li><p>引入多个<code>&lt;script&gt;</code>后出现的后果</p>\n<ul>\n<li>发起的请求过多</li>\n<li>多个外部js文件相互依赖关系不确定</li>\n<li>维护起来困难呢</li>\n</ul>\n</li>\n<li><p>模块化规范</p>\n<blockquote>\n<p>模块化带来的好处是非常明显的，但是会存在第四点所说的那些问题，为了解决此类问题，所以就有了模块化编写规范的诞生。</p>\n<p><strong>在服务器端，模块的加载是运行时同步加载的（服务器端，文件的加载都是存储在服务器本地，读取本地文件是非常快的，所以采用同步加载的方式，对性能方面影响不大）；在浏览器端，模块需要提前编译打包处理，属于异步加载模式，这时候采用同步模式加载就不太合适了。（由于浏览器属于异步加载模式，如果采用同步模式的话，会造成阻塞。）</strong></p>\n</blockquote>\n<ul>\n<li><p>CommonJS</p>\n<ul>\n<li>所有代码运行在模块作用域，不会污染全局作用域</li>\n<li>属于同步加载</li>\n<li>模块可以多次加载，但是只会在第一次加载时运行一次，加载结果会被缓存，后续再去加载的话，直接读取的是缓存，如果想要去重新加载，必须清除缓存。</li>\n<li>模块加载的顺序是自上而下按照代码出现的顺序。</li>\n<li>CommonJS模块的加载机制是，输入的是被输出的值得拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。(这与ES6模块化有所差异)</li>\n</ul>\n</li>\n<li><p>AMD</p>\n<ul>\n<li>非同步加载，允许指定回调函数。</li>\n<li>所有代码运行在模块作用域，不会污染全局作用域</li>\n</ul>\n</li>\n<li><p>CMD</p>\n<ul>\n<li>模块加载是异步的，模块使用时才会加载执行。</li>\n</ul>\n</li>\n<li><p>ES6</p>\n<p>ES6与CommonJS模块差异：</p>\n<ul>\n<li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值得引用。</li>\n<li>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h5><p>浏览器不兼容CommonJS的根本原因，在于其缺少四个Node.js环境的变量</p>\n<ul>\n<li><p>module</p>\n</li>\n<li><p>exports</p>\n</li>\n<li><p>require</p>\n</li>\n<li><p>global</p>\n<p><strong>如果提供以上四个变量，浏览器就可以加载CommonJS模块</strong></p>\n<p>Browserify是CommonJS格式转换的工具，语法：</p>\n<blockquote>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">// foo.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// main.js</span>\n<span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./foo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>使用下面的命令，就能将main.js转为浏览器可用的格式。</p>\n</li>\n</ul>\n<blockquote>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">$ browserify main.js <span class=\"token operator\">></span> compiled.js\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<p>  Browserify到底做了什么？安装一下<a href=\"https://www.npmjs.com/package/browser-unpack\" target=\"_blank\" rel=\"noopener\">browser-unpack</a>，就能看清楚了。</p>\n<blockquote>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span> browser-unpack -g\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<p>  然后，将前面生成的compile.js解包。</p>\n<blockquote>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">$ browser-unpack <span class=\"token operator\">&lt;</span> compiled.js\n\n<span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"id\"</span>:1,\n    <span class=\"token string\">\"source\"</span><span class=\"token keyword\">:</span><span class=\"token string\">\"module.exports = function(x) {\\n  console.log(x);\\n};\"</span>,\n    <span class=\"token string\">\"deps\"</span>:<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>,\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"id\"</span>:2,\n    <span class=\"token string\">\"source\"</span><span class=\"token keyword\">:</span><span class=\"token string\">\"var foo = require(\\\"./foo\\\");\\nfoo(\\\"Hi\\\");\"</span>,\n    <span class=\"token string\">\"deps\"</span>:<span class=\"token punctuation\">{</span><span class=\"token string\">\"./foo\"</span>:1<span class=\"token punctuation\">}</span>,\n    <span class=\"token string\">\"entry\"</span>:true\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<p>  可以看到，browerify 将所有模块放入一个数组，<code>id</code> 属性是模块的编号，<code>source</code> 属性是模块的源码，<code>deps</code> 属性是模块的依赖。</p>\n<p>  因为 <code>main.js</code> 里面加载了 <code>foo.js</code>，所以<code>deps</code> 属性就指定 <code>./foo</code> 对应1号模块。执行的时候，浏览器遇到 <code>require(&#39;./foo&#39;)</code>语句，就自动执行1号模块的 <code>source</code> 属性，并将执行后的<code>module.exports</code> 属性值输出。</p>\n<p>   使用CommonJS的不足之处在于同步加载。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">var</span> math<span class=\"token operator\">=</span><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'math'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  math<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>  第二行的<code>math.add</code>依赖于<code>math</code>文件，需要等到<code>require(&#39;math&#39;)</code>执行之后，才能继续执行。也就是说，如果加载的文件过大的话，就会出现页面停在那里。</p>\n<p>  这在服务器端不会存在问题，因为所有的模块都是存在本地的，读取可以同步加载完成，等待时间就是读取本地文件的时间，而在浏览器端就不同了，由于模块都是存放在服务器端的，如果网速过慢，或者文件过大，都会导致加载文件时浏览器产生”假死”状态。</p>\n<p>  <em>CommonJS主要是为了JS在后端开发定制的，并不适用于前端，AMD（异步模块定义）主要为前端JS的表现定制的一套规范。</em></p>\n<h5 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h5><p>特点：它采用异步加载方式加载模块，模块的加载不会影响到它后边的语句的执行，所有依赖当前模块的语句，都定义在一个回掉函数中，等加载完成后，才会执行回掉函数的内容。</p>\n<p>require语法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>module<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//接受两个参数</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em>参数<code>[module]</code>：是一个数组作为第一个参数，里边的成员就是要加载的模块；参数<code>callback</code>：加载成功后的回掉函数。</em></p>\n<p>目前主要有两个javascript库实现AMD规范：<code>require.js</code>和<code>curl.js</code>。</p>\n<h5 id=\"define函数：\"><a href=\"#define函数：\" class=\"headerlink\" title=\"define函数：\"></a>define函数：</h5><blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span>id<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span>dependencies<span class=\"token punctuation\">,</span>factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>id:</strong>第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名<strong>必须</strong>是“顶级”的和绝对的（不允许相对名字）。</p>\n<p><strong>依赖：</strong>第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。</p>\n<p><strong>工厂方法：</strong>第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。</p>\n<ul>\n<li><p>模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串</p>\n</li>\n<li><p>单词须为驼峰形式，或者”.”，”..”</p>\n</li>\n<li><p>模块名不允许文件扩展名的形式，如”.js”</p>\n</li>\n<li><p>模块名可以为 “相对的” 或 “顶级的”。如果首字符为”.”或”..”则为”相对的”模块名</p>\n</li>\n<li><p>顶级的模块名从根命名空间的概念模块解析</p>\n</li>\n<li><p>相对的模块名从 “require” 书写和调用的模块解析</p>\n<p>相对模块名解析示例：</p>\n<ul>\n<li><p>如果模块 <code>&quot;a/b/c&quot;</code> 请求 <code>&quot;../d&quot;</code>, 则解析为<code>&quot;a/d&quot;</code></p>\n</li>\n<li><p>如果模块 <code>&quot;a/b/c&quot;</code> 请求 <code>&quot;./e&quot;</code>, 则解析为<code>&quot;a/b/e&quot;</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h5><blockquote>\n<p>参考：</p>\n</blockquote>\n<p>在CMD规范中，一个模块就是一个文件。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>define</code>接受<code>factory</code>参数，<code>factory</code>可以是一个函数，也可以是一个对象或字符串。</p>\n<p><code>factory</code>为对象、字符串时，表示模块的接口就是该对象、字符串，比如为一个json数据模块：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"foo\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>也可以通过字符串定义模板模块：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I am a template. My name is {{name}}.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>factory</code> 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<code>factory</code> 方法在执行时，默认会传入三个参数：<code>require</code>、<code>exports</code> 和 <code>module</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 模块代码</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"define-define-id-deps-factory\"><a href=\"#define-define-id-deps-factory\" class=\"headerlink\" title=\"define define(id?, deps?, factory)\"></a>define <code>define(id?, deps?, factory)</code></h3><p><code>define</code> 也可以接受两个以上参数。字符串 <code>id</code> 表示模块标识，数组 <code>deps</code> 是模块依赖。比如：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'jquery'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 模块代码</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>id</code> 和 <code>deps</code> 参数可以省略。省略时，可以通过构建工具自动生成。</p>\n<p><strong>注意</strong>：带 <code>id</code> 和 <code>deps</code> 参数的 <code>define</code> 用法不属于 CMD 规范，而属于 <a href=\"https://github.com/cmdjs/specification/blob/master/draft/transport.md\" target=\"_blank\" rel=\"noopener\">Modules/Transport</a> 规范。</p>\n<h5 id=\"AMD和CMD异同\"><a href=\"#AMD和CMD异同\" class=\"headerlink\" title=\"AMD和CMD异同\"></a>AMD和CMD异同</h5><ol>\n<li>相同之处：都是倡导模块化开发理念，核心价值是让JavaScript的模块化开发变得简单自然。</li>\n<li>不同之处：<ul>\n<li><strong>定位有差异</strong>。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。</li>\n<li><strong>遵循的规范不同</strong>。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。</li>\n<li><strong>推广理念有差异</strong>。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</li>\n<li><strong>对开发调试的支持有差异</strong>。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。</li>\n<li><strong>插件机制不同</strong>。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。</li>\n</ul>\n</li>\n</ol>\n<p><strong>最后：SeaJS对模块的态度是懒执行（用到时再请求）, 而RequireJS对模块的态度是预执行（使用前请求模块）</strong></p>\n<h5 id=\"es6-中的export-export-default-和node-中的module-exports-exports区别\"><a href=\"#es6-中的export-export-default-和node-中的module-exports-exports区别\" class=\"headerlink\" title=\"es6 中的export export default 和node 中的module.exports exports区别\"></a><strong>es6 中的export export default 和node 中的module.exports exports区别</strong></h5><ol>\n<li><p>export default导出的成员，可以使用任意的变量来接收</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// a.js</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'张三'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> obj<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// b.js</span>\n<span class=\"token keyword\">import</span> objName <span class=\"token keyword\">from</span> <span class=\"token string\">'./a.js'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>objName<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 张三</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>export 导出的成员，名字必须严格一致，需要改变名字时，使用<strong>as</strong>来起别名，使用{}形式接受，属于按需导出，可以暴露出多个成员</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// a.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// b.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>getName<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./a.js'</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>node中exports 相当于是module.exports向外暴露的一个别名</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> exports <span class=\"token operator\">=</span> module<span class=\"token punctuation\">.</span>exports<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>module变量是一个对象，代表当前模块(node中一个文件就是一个模块)，而exports是module的一个属性，加载某个模块其实是加载的当前模块的module.exports属性。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CommonJS、AMD、CMD\"><a href=\"#CommonJS、AMD、CMD\" class=\"headerlink\" title=\"CommonJS、AMD、CMD\"></a>CommonJS、AMD、CMD</h3><h4 id=\"在介绍这些之前，首先介绍下前端模块化的演变过程\"><a href=\"#在介绍这些之前，首先介绍下前端模块化的演变过程\" class=\"headerlink\" title=\"在介绍这些之前，首先介绍下前端模块化的演变过程\"></a>在介绍这些之前，首先介绍下前端模块化的演变过程</h4><h3 id=\"前端模块化\"><a href=\"#前端模块化\" class=\"headerlink\" title=\"前端模块化\"></a>前端模块化</h3><ol>\n<li><p>什么是模块化</p>\n<ul>\n<li>将一个复杂的程序按照一定的规则封装成几个块，并进行组合。</li>\n<li>块的内部数据与实现是私有的，外界没有操作改变的权限，只是暴露一些接口与外部其他模块通信。</li>\n</ul>\n</li>\n<li><p>模块化的进化过程</p>\n<ul>\n<li><p>全局Function模式：将不同的功能封装成不同的全局函数</p>\n<blockquote>\n<p>问题：污染全局命名空间，容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系。</p>\n</blockquote>\n</li>\n<li><p>namespace模式：简单对象封装</p>\n<blockquote>\n<p>优点：减少全局变量的污染，解决命名冲突</p>\n<p>问题：数据不是私有的（内部定义的数据可以被修改），不够安全。</p>\n</blockquote>\n</li>\n<li><p>IIFE模式：匿名函数自调用(闭包)</p>\n<blockquote>\n<p>作用：数据是私有的，外部只能通过暴露出去的方法进行操作</p>\n<p>编码：将数据和行为封装到一个函数内部，通过给window添加属性来向外暴露接口</p>\n<p>问题：如果当前模块依赖另一个模块时怎么办</p>\n</blockquote>\n<pre><code class=\"js\">(function(window){\n  // 相关处理\n  let name = &#39;bar&#39;,\n      age = 20;\n  // 私有方法\n  function getName() {\n    console.log(name);\n  }\n  function getAge() {\n    console.log(age);\n  }\n  // 对外提供的入口方法\n  function say() {\n    getName();\n    getAge();\n  }\n  // 对外暴露\n  window.MyPeople = {say}\n})(window)\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>IIFE模式增强：引入依赖</p>\n<blockquote>\n<p>做法：将所依赖的库当做参数传入，这样就解决了依赖扩展问题。</p>\n</blockquote>\n</li>\n</ul>\n<ol start=\"3\">\n<li><p>模块化的好处</p>\n<ul>\n<li>避免命名冲突，减少全局变量污染</li>\n<li>相关功能分离，降低了耦合性，可以做到按需加载</li>\n<li>更高的复用性</li>\n<li>更好维护</li>\n</ul>\n</li>\n<li><p>引入多个<code>&lt;script&gt;</code>后出现的后果</p>\n<ul>\n<li>发起的请求过多</li>\n<li>多个外部js文件相互依赖关系不确定</li>\n<li>维护起来困难呢</li>\n</ul>\n</li>\n<li><p>模块化规范</p>\n<blockquote>\n<p>模块化带来的好处是非常明显的，但是会存在第四点所说的那些问题，为了解决此类问题，所以就有了模块化编写规范的诞生。</p>\n<p><strong>在服务器端，模块的加载是运行时同步加载的（服务器端，文件的加载都是存储在服务器本地，读取本地文件是非常快的，所以采用同步加载的方式，对性能方面影响不大）；在浏览器端，模块需要提前编译打包处理，属于异步加载模式，这时候采用同步模式加载就不太合适了。（由于浏览器属于异步加载模式，如果采用同步模式的话，会造成阻塞。）</strong></p>\n</blockquote>\n<ul>\n<li><p>CommonJS</p>\n<ul>\n<li>所有代码运行在模块作用域，不会污染全局作用域</li>\n<li>属于同步加载</li>\n<li>模块可以多次加载，但是只会在第一次加载时运行一次，加载结果会被缓存，后续再去加载的话，直接读取的是缓存，如果想要去重新加载，必须清除缓存。</li>\n<li>模块加载的顺序是自上而下按照代码出现的顺序。</li>\n<li>CommonJS模块的加载机制是，输入的是被输出的值得拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值了。(这与ES6模块化有所差异)</li>\n</ul>\n</li>\n<li><p>AMD</p>\n<ul>\n<li>非同步加载，允许指定回调函数。</li>\n<li>所有代码运行在模块作用域，不会污染全局作用域</li>\n</ul>\n</li>\n<li><p>CMD</p>\n<ul>\n<li>模块加载是异步的，模块使用时才会加载执行。</li>\n</ul>\n</li>\n<li><p>ES6</p>\n<p>ES6与CommonJS模块差异：</p>\n<ul>\n<li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值得引用。</li>\n<li>CommonJS模块是运行时加载，ES6模块是编译时输出接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h5><p>浏览器不兼容CommonJS的根本原因，在于其缺少四个Node.js环境的变量</p>\n<ul>\n<li><p>module</p>\n</li>\n<li><p>exports</p>\n</li>\n<li><p>require</p>\n</li>\n<li><p>global</p>\n<p><strong>如果提供以上四个变量，浏览器就可以加载CommonJS模块</strong></p>\n<p>Browserify是CommonJS格式转换的工具，语法：</p>\n<blockquote>\n<pre><code class=\"javascript\">// foo.js\nmodule.exports = function(x) {\n  console.log(x);\n};\n\n// main.js\nvar foo = require(&quot;./foo&quot;);\nfoo(&quot;Hi&quot;);\n</code></pre>\n</blockquote>\n<p>使用下面的命令，就能将main.js转为浏览器可用的格式。</p>\n</li>\n</ul>\n<blockquote>\n<pre><code class=\"bash\">$ browserify main.js &gt; compiled.js\n</code></pre>\n</blockquote>\n<p>  Browserify到底做了什么？安装一下<a href=\"https://www.npmjs.com/package/browser-unpack\" target=\"_blank\" rel=\"noopener\">browser-unpack</a>，就能看清楚了。</p>\n<blockquote>\n<pre><code class=\"bash\">$ npm install browser-unpack -g\n</code></pre>\n</blockquote>\n<p>  然后，将前面生成的compile.js解包。</p>\n<blockquote>\n<pre><code class=\"bash\">$ browser-unpack &lt; compiled.js\n\n[\n  {\n    &quot;id&quot;:1,\n    &quot;source&quot;:&quot;module.exports = function(x) {\\n  console.log(x);\\n};&quot;,\n    &quot;deps&quot;:{}\n  },\n  {\n    &quot;id&quot;:2,\n    &quot;source&quot;:&quot;var foo = require(\\&quot;./foo\\&quot;);\\nfoo(\\&quot;Hi\\&quot;);&quot;,\n    &quot;deps&quot;:{&quot;./foo&quot;:1},\n    &quot;entry&quot;:true\n  }\n]\n</code></pre>\n</blockquote>\n<p>  可以看到，browerify 将所有模块放入一个数组，<code>id</code> 属性是模块的编号，<code>source</code> 属性是模块的源码，<code>deps</code> 属性是模块的依赖。</p>\n<p>  因为 <code>main.js</code> 里面加载了 <code>foo.js</code>，所以<code>deps</code> 属性就指定 <code>./foo</code> 对应1号模块。执行的时候，浏览器遇到 <code>require(&#39;./foo&#39;)</code>语句，就自动执行1号模块的 <code>source</code> 属性，并将执行后的<code>module.exports</code> 属性值输出。</p>\n<p>   使用CommonJS的不足之处在于同步加载。</p>\n<pre><code class=\"js\">  var math=require(&#39;math&#39;);\n  math.add(2,3);\n</code></pre>\n<p>  第二行的<code>math.add</code>依赖于<code>math</code>文件，需要等到<code>require(&#39;math&#39;)</code>执行之后，才能继续执行。也就是说，如果加载的文件过大的话，就会出现页面停在那里。</p>\n<p>  这在服务器端不会存在问题，因为所有的模块都是存在本地的，读取可以同步加载完成，等待时间就是读取本地文件的时间，而在浏览器端就不同了，由于模块都是存放在服务器端的，如果网速过慢，或者文件过大，都会导致加载文件时浏览器产生”假死”状态。</p>\n<p>  <em>CommonJS主要是为了JS在后端开发定制的，并不适用于前端，AMD（异步模块定义）主要为前端JS的表现定制的一套规范。</em></p>\n<h5 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h5><p>特点：它采用异步加载方式加载模块，模块的加载不会影响到它后边的语句的执行，所有依赖当前模块的语句，都定义在一个回掉函数中，等加载完成后，才会执行回掉函数的内容。</p>\n<p>require语法：</p>\n<pre><code class=\"js\">require([module],callback); //接受两个参数\n</code></pre>\n<p><em>参数<code>[module]</code>：是一个数组作为第一个参数，里边的成员就是要加载的模块；参数<code>callback</code>：加载成功后的回掉函数。</em></p>\n<p>目前主要有两个javascript库实现AMD规范：<code>require.js</code>和<code>curl.js</code>。</p>\n<h5 id=\"define函数：\"><a href=\"#define函数：\" class=\"headerlink\" title=\"define函数：\"></a>define函数：</h5><blockquote>\n<p>语法：</p>\n<pre><code class=\"js\">define(id?,dependencies,factory);\n</code></pre>\n<p><strong>id:</strong>第一个参数，id，是个字符串。它指的是定义中模块的名字，这个参数是可选的。如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名<strong>必须</strong>是“顶级”的和绝对的（不允许相对名字）。</p>\n<p><strong>依赖：</strong>第二个参数，dependencies，是个定义中模块所依赖模块的数组。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。</p>\n<p><strong>工厂方法：</strong>第三个参数，factory，为模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。如果工厂方法返回一个值（对象，函数，或任意强制类型转换为true的值），应该为设置为模块的输出值。</p>\n<ul>\n<li><p>模块名是由一个或多个单词以正斜杠为分隔符拼接成的字符串</p>\n</li>\n<li><p>单词须为驼峰形式，或者”.”，”..”</p>\n</li>\n<li><p>模块名不允许文件扩展名的形式，如”.js”</p>\n</li>\n<li><p>模块名可以为 “相对的” 或 “顶级的”。如果首字符为”.”或”..”则为”相对的”模块名</p>\n</li>\n<li><p>顶级的模块名从根命名空间的概念模块解析</p>\n</li>\n<li><p>相对的模块名从 “require” 书写和调用的模块解析</p>\n<p>相对模块名解析示例：</p>\n<ul>\n<li><p>如果模块 <code>&quot;a/b/c&quot;</code> 请求 <code>&quot;../d&quot;</code>, 则解析为<code>&quot;a/d&quot;</code></p>\n</li>\n<li><p>如果模块 <code>&quot;a/b/c&quot;</code> 请求 <code>&quot;./e&quot;</code>, 则解析为<code>&quot;a/b/e&quot;</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h5><blockquote>\n<p>参考：</p>\n</blockquote>\n<p>在CMD规范中，一个模块就是一个文件。</p>\n<pre><code class=\"js\">define(factory);\n</code></pre>\n<p><code>define</code>接受<code>factory</code>参数，<code>factory</code>可以是一个函数，也可以是一个对象或字符串。</p>\n<p><code>factory</code>为对象、字符串时，表示模块的接口就是该对象、字符串，比如为一个json数据模块：</p>\n<pre><code class=\"js\">define({&quot;foo&quot;:&quot;bar&quot;});\n</code></pre>\n<p>也可以通过字符串定义模板模块：</p>\n<pre><code class=\"js\">define(&#39;I am a template. My name is {{name}}.&#39;);\n</code></pre>\n<p><code>factory</code> 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<code>factory</code> 方法在执行时，默认会传入三个参数：<code>require</code>、<code>exports</code> 和 <code>module</code>：</p>\n<pre><code class=\"js\">define(function(require, exports, module) {\n\n  // 模块代码\n\n});\n</code></pre>\n<h3 id=\"define-define-id-deps-factory\"><a href=\"#define-define-id-deps-factory\" class=\"headerlink\" title=\"define define(id?, deps?, factory)\"></a>define <code>define(id?, deps?, factory)</code></h3><p><code>define</code> 也可以接受两个以上参数。字符串 <code>id</code> 表示模块标识，数组 <code>deps</code> 是模块依赖。比如：</p>\n<pre><code class=\"js\">define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) {\n\n  // 模块代码\n\n});\n</code></pre>\n<p><code>id</code> 和 <code>deps</code> 参数可以省略。省略时，可以通过构建工具自动生成。</p>\n<p><strong>注意</strong>：带 <code>id</code> 和 <code>deps</code> 参数的 <code>define</code> 用法不属于 CMD 规范，而属于 <a href=\"https://github.com/cmdjs/specification/blob/master/draft/transport.md\" target=\"_blank\" rel=\"noopener\">Modules/Transport</a> 规范。</p>\n<h5 id=\"AMD和CMD异同\"><a href=\"#AMD和CMD异同\" class=\"headerlink\" title=\"AMD和CMD异同\"></a>AMD和CMD异同</h5><ol>\n<li>相同之处：都是倡导模块化开发理念，核心价值是让JavaScript的模块化开发变得简单自然。</li>\n<li>不同之处：<ul>\n<li><strong>定位有差异</strong>。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。</li>\n<li><strong>遵循的规范不同</strong>。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1 和 Node Modules 规范。</li>\n<li><strong>推广理念有差异</strong>。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</li>\n<li><strong>对开发调试的支持有差异</strong>。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。</li>\n<li><strong>插件机制不同</strong>。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。</li>\n</ul>\n</li>\n</ol>\n<p><strong>最后：SeaJS对模块的态度是懒执行（用到时再请求）, 而RequireJS对模块的态度是预执行（使用前请求模块）</strong></p>\n<h5 id=\"es6-中的export-export-default-和node-中的module-exports-exports区别\"><a href=\"#es6-中的export-export-default-和node-中的module-exports-exports区别\" class=\"headerlink\" title=\"es6 中的export export default 和node 中的module.exports exports区别\"></a><strong>es6 中的export export default 和node 中的module.exports exports区别</strong></h5><ol>\n<li><p>export default导出的成员，可以使用任意的变量来接收</p>\n<pre><code class=\"js\">// a.js\nlet obj = {name: &#39;张三&#39;};\nexport default obj;\n\n// b.js\nimport objName from &#39;./a.js&#39;;\n\nconsole.log(objName.name); // 张三\n</code></pre>\n</li>\n<li><p>export 导出的成员，名字必须严格一致，需要改变名字时，使用<strong>as</strong>来起别名，使用{}形式接受，属于按需导出，可以暴露出多个成员</p>\n<pre><code class=\"js\">// a.js\nexport function getName() {};\n\n// b.js\nimport {getName} from &#39;./a.js&#39;;\n</code></pre>\n</li>\n<li><p>node中exports 相当于是module.exports向外暴露的一个别名</p>\n<pre><code class=\"js\">var exports = module.exports;\n</code></pre>\n<p>module变量是一个对象，代表当前模块(node中一个文件就是一个模块)，而exports是module的一个属性，加载某个模块其实是加载的当前模块的module.exports属性。</p>\n</li>\n</ol>\n"},{"title":"BFC","date":"2018-10-21T04:25:33.000Z","_content":"\n### BFC的理解\n\n##### 什么是BFC（Block formatting contexts）\n\n> w3c规范中BFC定义：\n>\n> 浮动元素和绝对定位元素，非块级盒子的块级容器（例如`inline-blocks`，`table-cells`和`table-captions`），以及`overflow`值不为“`visiable`”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。\n>\n> 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。\n>\n> 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。\n>\n> 原文: \n>\n> https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\n>\n>  © \n>\n> w3cplus.com\n\n##### 如何创建BFC\n\n- 设置`overflow`的值不为`visiable`。\n- 使用float（浮动）来创建一个BFC。\n- 使用`position:absolute`或者`position:fixed`\n- 使用`display:inline-block`、`display:table-cell`或者`display:table-caption`，其中`table-cell`和`table-caption`是表格相关元素对应默认CSS值，所以当你创建表格时，对应的每个单元格都会自动创建BFC。\n- 使用多列布局`column-span:all`也可以创建BFC。\n- 使用`display:flow-root`\n\n##### BFC能做什么\n\n1. 使用BFC来防止外边距折叠。\n\n   ```html\n   <div class=\"box\">\n   \t\t<p>box1标签</p>\n   \t\t<p>box2标签</p>\n   </div>\n   <style>\n   \t.box{\n           background-color: #ccc;\n           margin: 0 0 40px 0;\n   \t}\n       .box p{\n           padding:0;\n           margin:10px 0 10px 0;\n           background:red;\n           color:#fff;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/1362e17d4024bf32807439bb428f8806.png)\n\n   *由于`p`元素的边缘与`.box`元素边缘不存在`padding`和`border`，所以`p`元素与`.box`元素紧密相连，`p`元素设置的`margin`属性与外部的`.box`的`margin`相重叠，`p`元素会与`.box`元素的顶部底部齐平，两个`p`元素中间又根据`margin`叠加计算规则得出10px。*\n\n   ```html\n   <div class=\"box\">\n   \t\t<p>box1标签</p>\n   \t\t<p>box2标签</p>\n   </div>\n   <style>\n   \t.box{\n           background-color: #ccc;\n           margin: 0 0 40px 0;\n           overflow: auto;\n   \t}\n       .box p{\n           padding:0;\n           margin:10px 0 10px 0;\n           background:red;\n           color:#fff;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/4e7ccdd640f9f1948001b77f22fff5bc.png)\n\n   通过`overflow`创建BFC，可以将p元素的`margin`包裹在BFC内部。\n\n2. 使用BFC来包含浮动。\n\n   ```html\n   <div class=\"float\">\n   \t\t<div class=\"floatimg\">this is a float img!</div>\n   \t\t<p>this is a float context.this is a float context.</p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/2e7435f6404a840180b90b5050465d7d.png)\n\n   *父容器的高度取决于文本的高度，它将不会包含已经浮动的子元素。可以通过给容器设置`overflow:hidden`，在容器中创建一个新的BFC。*\n\n   ```html\n   <div class=\"float\">\n   \t\t<div class=\"floatimg\">this is a float img!</div>\n   \t\t<p>this is a float context.this is a float context.</p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n           overflow: auto; /*创建BFC*/\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png)\n\n3. 使用BFC来防止文字环绕。\n\n\n\n   ```html\n   <div class=\"float\">\n   \t<div class=\"floatimg\">this is a float img!</div>\n   \t<p>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a \t\t\tfloat context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       </p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/58fe0bc24074305e80124130cb611524.png)\n\n   *上图可以看出，右侧的文字会环绕着左侧的浮动元素，如果我们不想要环绕的效果呢？*\n\n   ```html\n   <div class=\"float\">\n   \t<div class=\"floatimg\">this is a float img!</div>\n   \t<p>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a \t\t\tfloat context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       </p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n       .float p{\n   \t\toverflow: auto;\n   \t}\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/d1d0d0b84057b84c8064633356e7a56a.png)\n\n   *通过设置`overflow`，为p元素创建单独的BFC。*\n\n4. 在多列布局中使用BFC。\n\n   ```html\n   <div class=\"cln\">\n   \t\t<div class=\"column\">column1</div>\n   \t\t<div class=\"column\">column2</div>\n   \t\t<div class=\"column\">column3</div>\n   </div>\n   <style>\n           .cln{\n               width:600px;\n               margin:20px auto;\n   \t\t}\n   \t\t.column{\n   \t\t\twidth:31.33%;\n   \t\t\ttext-align: center;\n   \t\t\tbackground-color:yellow;\n   \t\t\tfloat: left;\n   \t\t\tmargin:0 1%;\n   \t\t}\n   \t\t.column:last-child{\n   \t\t\tfloat: none;\n   \t\t}\n   </style>\n   ```\n\n   效果：\n\n![](BFC/61f755c3404c04f880bf3759d96965db.png)\n\n*上图中多列元素的最后一个被挤到下一行了，造成这样的原因可能时因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。可以通过创建新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。*\n\n```html\n<div class=\"cln\">\n\t\t<div class=\"column\">column1</div>\n\t\t<div class=\"column\">column2</div>\n\t\t<div class=\"column\">column3</div>\n</div>\n<style>\n        .cln{\n            width:600px;\n            margin:20px auto;\n\t\t}\n\t\t.column{\n\t\t\twidth:31.33%;\n\t\t\ttext-align: center;\n\t\t\tbackground-color:yellow;\n\t\t\tfloat: left;\n\t\t\tmargin:0 1%;\n\t\t}\n\t\t.column:last-child{\n\t\t\tfloat: none;\n         \t overflow: hidden;\n\t\t}\n</style>\n```\n\n效果：\n\n![](BFC/9f51d5ac40bdb5fa804d79aed400cab1.png)\n\n","source":"_posts/BFC.md","raw":"---\ntitle: BFC\ndate: 2018-10-21 12:25:33\ntags: CSS布局和BFC\ncategories: 前端\n---\n\n### BFC的理解\n\n##### 什么是BFC（Block formatting contexts）\n\n> w3c规范中BFC定义：\n>\n> 浮动元素和绝对定位元素，非块级盒子的块级容器（例如`inline-blocks`，`table-cells`和`table-captions`），以及`overflow`值不为“`visiable`”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。\n>\n> 在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。\n>\n> 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。\n>\n> 原文: \n>\n> https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\n>\n>  © \n>\n> w3cplus.com\n\n##### 如何创建BFC\n\n- 设置`overflow`的值不为`visiable`。\n- 使用float（浮动）来创建一个BFC。\n- 使用`position:absolute`或者`position:fixed`\n- 使用`display:inline-block`、`display:table-cell`或者`display:table-caption`，其中`table-cell`和`table-caption`是表格相关元素对应默认CSS值，所以当你创建表格时，对应的每个单元格都会自动创建BFC。\n- 使用多列布局`column-span:all`也可以创建BFC。\n- 使用`display:flow-root`\n\n##### BFC能做什么\n\n1. 使用BFC来防止外边距折叠。\n\n   ```html\n   <div class=\"box\">\n   \t\t<p>box1标签</p>\n   \t\t<p>box2标签</p>\n   </div>\n   <style>\n   \t.box{\n           background-color: #ccc;\n           margin: 0 0 40px 0;\n   \t}\n       .box p{\n           padding:0;\n           margin:10px 0 10px 0;\n           background:red;\n           color:#fff;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/1362e17d4024bf32807439bb428f8806.png)\n\n   *由于`p`元素的边缘与`.box`元素边缘不存在`padding`和`border`，所以`p`元素与`.box`元素紧密相连，`p`元素设置的`margin`属性与外部的`.box`的`margin`相重叠，`p`元素会与`.box`元素的顶部底部齐平，两个`p`元素中间又根据`margin`叠加计算规则得出10px。*\n\n   ```html\n   <div class=\"box\">\n   \t\t<p>box1标签</p>\n   \t\t<p>box2标签</p>\n   </div>\n   <style>\n   \t.box{\n           background-color: #ccc;\n           margin: 0 0 40px 0;\n           overflow: auto;\n   \t}\n       .box p{\n           padding:0;\n           margin:10px 0 10px 0;\n           background:red;\n           color:#fff;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/4e7ccdd640f9f1948001b77f22fff5bc.png)\n\n   通过`overflow`创建BFC，可以将p元素的`margin`包裹在BFC内部。\n\n2. 使用BFC来包含浮动。\n\n   ```html\n   <div class=\"float\">\n   \t\t<div class=\"floatimg\">this is a float img!</div>\n   \t\t<p>this is a float context.this is a float context.</p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/2e7435f6404a840180b90b5050465d7d.png)\n\n   *父容器的高度取决于文本的高度，它将不会包含已经浮动的子元素。可以通过给容器设置`overflow:hidden`，在容器中创建一个新的BFC。*\n\n   ```html\n   <div class=\"float\">\n   \t\t<div class=\"floatimg\">this is a float img!</div>\n   \t\t<p>this is a float context.this is a float context.</p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n           overflow: auto; /*创建BFC*/\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png)\n\n3. 使用BFC来防止文字环绕。\n\n\n\n   ```html\n   <div class=\"float\">\n   \t<div class=\"floatimg\">this is a float img!</div>\n   \t<p>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a \t\t\tfloat context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       </p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/58fe0bc24074305e80124130cb611524.png)\n\n   *上图可以看出，右侧的文字会环绕着左侧的浮动元素，如果我们不想要环绕的效果呢？*\n\n   ```html\n   <div class=\"float\">\n   \t<div class=\"floatimg\">this is a float img!</div>\n   \t<p>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a \t\t\tfloat context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       </p>\n   </div>\n   <style>\n   \t.float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n   \t}\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n       .float p{\n   \t\toverflow: auto;\n   \t}\n   </style>\n   ```\n\n   效果：\n\n   ![](BFC/d1d0d0b84057b84c8064633356e7a56a.png)\n\n   *通过设置`overflow`，为p元素创建单独的BFC。*\n\n4. 在多列布局中使用BFC。\n\n   ```html\n   <div class=\"cln\">\n   \t\t<div class=\"column\">column1</div>\n   \t\t<div class=\"column\">column2</div>\n   \t\t<div class=\"column\">column3</div>\n   </div>\n   <style>\n           .cln{\n               width:600px;\n               margin:20px auto;\n   \t\t}\n   \t\t.column{\n   \t\t\twidth:31.33%;\n   \t\t\ttext-align: center;\n   \t\t\tbackground-color:yellow;\n   \t\t\tfloat: left;\n   \t\t\tmargin:0 1%;\n   \t\t}\n   \t\t.column:last-child{\n   \t\t\tfloat: none;\n   \t\t}\n   </style>\n   ```\n\n   效果：\n\n![](BFC/61f755c3404c04f880bf3759d96965db.png)\n\n*上图中多列元素的最后一个被挤到下一行了，造成这样的原因可能时因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。可以通过创建新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。*\n\n```html\n<div class=\"cln\">\n\t\t<div class=\"column\">column1</div>\n\t\t<div class=\"column\">column2</div>\n\t\t<div class=\"column\">column3</div>\n</div>\n<style>\n        .cln{\n            width:600px;\n            margin:20px auto;\n\t\t}\n\t\t.column{\n\t\t\twidth:31.33%;\n\t\t\ttext-align: center;\n\t\t\tbackground-color:yellow;\n\t\t\tfloat: left;\n\t\t\tmargin:0 1%;\n\t\t}\n\t\t.column:last-child{\n\t\t\tfloat: none;\n         \t overflow: hidden;\n\t\t}\n</style>\n```\n\n效果：\n\n![](BFC/9f51d5ac40bdb5fa804d79aed400cab1.png)\n\n","slug":"BFC","published":1,"updated":"2024-02-19T07:42:51.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr8m00031xopd6zh7qsx","content":"<h3 id=\"BFC的理解\"><a href=\"#BFC的理解\" class=\"headerlink\" title=\"BFC的理解\"></a>BFC的理解</h3><h5 id=\"什么是BFC（Block-formatting-contexts）\"><a href=\"#什么是BFC（Block-formatting-contexts）\" class=\"headerlink\" title=\"什么是BFC（Block formatting contexts）\"></a>什么是BFC（Block formatting contexts）</h5><blockquote>\n<p>w3c规范中BFC定义：</p>\n<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如<code>inline-blocks</code>，<code>table-cells</code>和<code>table-captions</code>），以及<code>overflow</code>值不为“<code>visiable</code>”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>\n<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。</p>\n<p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>\n<p>原文: </p>\n<p><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>\n<p> © </p>\n<p>w3cplus.com</p>\n</blockquote>\n<h5 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h5><ul>\n<li>设置<code>overflow</code>的值不为<code>visiable</code>。</li>\n<li>使用float（浮动）来创建一个BFC。</li>\n<li>使用<code>position:absolute</code>或者<code>position:fixed</code></li>\n<li>使用<code>display:inline-block</code>、<code>display:table-cell</code>或者<code>display:table-caption</code>，其中<code>table-cell</code>和<code>table-caption</code>是表格相关元素对应默认CSS值，所以当你创建表格时，对应的每个单元格都会自动创建BFC。</li>\n<li>使用多列布局<code>column-span:all</code>也可以创建BFC。</li>\n<li>使用<code>display:flow-root</code></li>\n</ul>\n<h5 id=\"BFC能做什么\"><a href=\"#BFC能做什么\" class=\"headerlink\" title=\"BFC能做什么\"></a>BFC能做什么</h5><ol>\n<li><p>使用BFC来防止外边距折叠。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>box<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>box1标签<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>box2标签<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token class\">.box</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">40</span>px <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\"><span class=\"token class\">.box</span> p</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span>px <span class=\"token number\">0</span> <span class=\"token number\">10</span>px <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>red<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/1362e17d4024bf32807439bb428f8806.png\" alt></p>\n<p><em>由于<code>p</code>元素的边缘与<code>.box</code>元素边缘不存在<code>padding</code>和<code>border</code>，所以<code>p</code>元素与<code>.box</code>元素紧密相连，<code>p</code>元素设置的<code>margin</code>属性与外部的<code>.box</code>的<code>margin</code>相重叠，<code>p</code>元素会与<code>.box</code>元素的顶部底部齐平，两个<code>p</code>元素中间又根据<code>margin</code>叠加计算规则得出10px。</em></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>box<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>box1标签<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>box2标签<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token class\">.box</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span> <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token number\">0</span> <span class=\"token number\">40</span>px <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\"><span class=\"token class\">.box</span> p</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span>px <span class=\"token number\">0</span> <span class=\"token number\">10</span>px <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>red<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/4e7ccdd640f9f1948001b77f22fff5bc.png\" alt></p>\n<p>通过<code>overflow</code>创建BFC，可以将p元素的<code>margin</code>包裹在BFC内部。</p>\n</li>\n<li><p>使用BFC来包含浮动。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>float<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>floatimg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>this is a float img!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>this is a float context.this is a float context.<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token class\">.float</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>px solid <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span>auto<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\"><span class=\"token class\">.floatimg</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">float</span><span class=\"token punctuation\">:</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>orange<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/2e7435f6404a840180b90b5050465d7d.png\" alt></p>\n<p><em>父容器的高度取决于文本的高度，它将不会包含已经浮动的子元素。可以通过给容器设置<code>overflow:hidden</code>，在容器中创建一个新的BFC。</em></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>float<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>floatimg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>this is a float img!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>this is a float context.this is a float context.<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token class\">.float</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>px solid <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span>auto<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/*创建BFC*/</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\"><span class=\"token class\">.floatimg</span></span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">float</span><span class=\"token punctuation\">:</span>left<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>orange<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png\" alt></p>\n</li>\n<li><p>使用BFC来防止文字环绕。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\">   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>float<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>floatimg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>this is a float img!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a             float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n       <span class=\"token selector\"><span class=\"token class\">.float</span></span><span class=\"token punctuation\">{</span>\n           <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>px solid <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span>auto<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token selector\"><span class=\"token class\">.floatimg</span></span><span class=\"token punctuation\">{</span>\n           <span class=\"token property\">float</span><span class=\"token punctuation\">:</span>left<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n           <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>orange<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n   </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>   效果：</p>\n<p>   <img src=\"/2018/10/21/BFC/58fe0bc24074305e80124130cb611524.png\" alt></p>\n<p>   <em>上图可以看出，右侧的文字会环绕着左侧的浮动元素，如果我们不想要环绕的效果呢？</em></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\">   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>float<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>floatimg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>this is a float img!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a             float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n       <span class=\"token selector\"><span class=\"token class\">.float</span></span><span class=\"token punctuation\">{</span>\n           <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>px solid <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span>auto<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token selector\"><span class=\"token class\">.floatimg</span></span><span class=\"token punctuation\">{</span>\n           <span class=\"token property\">float</span><span class=\"token punctuation\">:</span>left<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">line-height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">50</span>px<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">color</span><span class=\"token punctuation\">:</span><span class=\"token hexcode\">#fff</span><span class=\"token punctuation\">;</span>\n           <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>orange<span class=\"token punctuation\">;</span>\n           <span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span>px<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token selector\"><span class=\"token class\">.float</span> p</span><span class=\"token punctuation\">{</span>\n           <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n   </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>   效果：</p>\n<p>   <img src=\"/2018/10/21/BFC/d1d0d0b84057b84c8064633356e7a56a.png\" alt></p>\n<p>   <em>通过设置<code>overflow</code>，为p元素创建单独的BFC。</em></p>\n<ol start=\"4\">\n<li><p>在多列布局中使用BFC。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>cln<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n        <span class=\"token selector\"><span class=\"token class\">.cln</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">600</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20</span>px auto<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token selector\"><span class=\"token class\">.column</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">31.33%</span><span class=\"token punctuation\">;</span>\n            <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span>yellow<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">float</span><span class=\"token punctuation\">:</span> left<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span> <span class=\"token number\">1%</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token selector\"><span class=\"token class\">.column</span><span class=\"token pseudo-class\">:last-child</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">float</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/21/BFC/61f755c3404c04f880bf3759d96965db.png\" alt></p>\n<p><em>上图中多列元素的最后一个被挤到下一行了，造成这样的原因可能时因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。可以通过创建新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。</em></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>cln<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>column<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>column3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n        <span class=\"token selector\"><span class=\"token class\">.cln</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">600</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20</span>px auto<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token selector\"><span class=\"token class\">.column</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">31.33%</span><span class=\"token punctuation\">;</span>\n            <span class=\"token property\">text-align</span><span class=\"token punctuation\">:</span> center<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">background-color</span><span class=\"token punctuation\">:</span>yellow<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">float</span><span class=\"token punctuation\">:</span> left<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">0</span> <span class=\"token number\">1%</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token selector\"><span class=\"token class\">.column</span><span class=\"token pseudo-class\">:last-child</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">float</span><span class=\"token punctuation\">:</span> none<span class=\"token punctuation\">;</span>\n              <span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span> hidden<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/9f51d5ac40bdb5fa804d79aed400cab1.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"BFC的理解\"><a href=\"#BFC的理解\" class=\"headerlink\" title=\"BFC的理解\"></a>BFC的理解</h3><h5 id=\"什么是BFC（Block-formatting-contexts）\"><a href=\"#什么是BFC（Block-formatting-contexts）\" class=\"headerlink\" title=\"什么是BFC（Block formatting contexts）\"></a>什么是BFC（Block formatting contexts）</h5><blockquote>\n<p>w3c规范中BFC定义：</p>\n<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如<code>inline-blocks</code>，<code>table-cells</code>和<code>table-captions</code>），以及<code>overflow</code>值不为“<code>visiable</code>”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>\n<p>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。</p>\n<p>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>\n<p>原文: </p>\n<p><a href=\"https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>\n<p> © </p>\n<p>w3cplus.com</p>\n</blockquote>\n<h5 id=\"如何创建BFC\"><a href=\"#如何创建BFC\" class=\"headerlink\" title=\"如何创建BFC\"></a>如何创建BFC</h5><ul>\n<li>设置<code>overflow</code>的值不为<code>visiable</code>。</li>\n<li>使用float（浮动）来创建一个BFC。</li>\n<li>使用<code>position:absolute</code>或者<code>position:fixed</code></li>\n<li>使用<code>display:inline-block</code>、<code>display:table-cell</code>或者<code>display:table-caption</code>，其中<code>table-cell</code>和<code>table-caption</code>是表格相关元素对应默认CSS值，所以当你创建表格时，对应的每个单元格都会自动创建BFC。</li>\n<li>使用多列布局<code>column-span:all</code>也可以创建BFC。</li>\n<li>使用<code>display:flow-root</code></li>\n</ul>\n<h5 id=\"BFC能做什么\"><a href=\"#BFC能做什么\" class=\"headerlink\" title=\"BFC能做什么\"></a>BFC能做什么</h5><ol>\n<li><p>使用BFC来防止外边距折叠。</p>\n<pre><code class=\"html\">&lt;div class=&quot;box&quot;&gt;\n        &lt;p&gt;box1标签&lt;/p&gt;\n        &lt;p&gt;box2标签&lt;/p&gt;\n&lt;/div&gt;\n&lt;style&gt;\n    .box{\n        background-color: #ccc;\n        margin: 0 0 40px 0;\n    }\n    .box p{\n        padding:0;\n        margin:10px 0 10px 0;\n        background:red;\n        color:#fff;\n    }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/1362e17d4024bf32807439bb428f8806.png\" alt></p>\n<p><em>由于<code>p</code>元素的边缘与<code>.box</code>元素边缘不存在<code>padding</code>和<code>border</code>，所以<code>p</code>元素与<code>.box</code>元素紧密相连，<code>p</code>元素设置的<code>margin</code>属性与外部的<code>.box</code>的<code>margin</code>相重叠，<code>p</code>元素会与<code>.box</code>元素的顶部底部齐平，两个<code>p</code>元素中间又根据<code>margin</code>叠加计算规则得出10px。</em></p>\n<pre><code class=\"html\">&lt;div class=&quot;box&quot;&gt;\n        &lt;p&gt;box1标签&lt;/p&gt;\n        &lt;p&gt;box2标签&lt;/p&gt;\n&lt;/div&gt;\n&lt;style&gt;\n    .box{\n        background-color: #ccc;\n        margin: 0 0 40px 0;\n        overflow: auto;\n    }\n    .box p{\n        padding:0;\n        margin:10px 0 10px 0;\n        background:red;\n        color:#fff;\n    }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/4e7ccdd640f9f1948001b77f22fff5bc.png\" alt></p>\n<p>通过<code>overflow</code>创建BFC，可以将p元素的<code>margin</code>包裹在BFC内部。</p>\n</li>\n<li><p>使用BFC来包含浮动。</p>\n<pre><code class=\"html\">&lt;div class=&quot;float&quot;&gt;\n        &lt;div class=&quot;floatimg&quot;&gt;this is a float img!&lt;/div&gt;\n        &lt;p&gt;this is a float context.this is a float context.&lt;/p&gt;\n&lt;/div&gt;\n&lt;style&gt;\n    .float{\n        width:300px;\n        padding:5px;\n        border:1px solid #ccc;\n        border-radius: 5px;\n        margin:auto;\n    }\n    .floatimg{\n        float:left;\n        width:100px;\n        height:50px;\n        margin:5px;\n        line-height: 50px;\n        color:#fff;\n        text-align: center;\n        background:orange;\n        border-radius: 5px;\n    }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/2e7435f6404a840180b90b5050465d7d.png\" alt></p>\n<p><em>父容器的高度取决于文本的高度，它将不会包含已经浮动的子元素。可以通过给容器设置<code>overflow:hidden</code>，在容器中创建一个新的BFC。</em></p>\n<pre><code class=\"html\">&lt;div class=&quot;float&quot;&gt;\n        &lt;div class=&quot;floatimg&quot;&gt;this is a float img!&lt;/div&gt;\n        &lt;p&gt;this is a float context.this is a float context.&lt;/p&gt;\n&lt;/div&gt;\n&lt;style&gt;\n    .float{\n        width:300px;\n        padding:5px;\n        border:1px solid #ccc;\n        border-radius: 5px;\n        margin:auto;\n        overflow: auto; /*创建BFC*/\n    }\n    .floatimg{\n        float:left;\n        width:100px;\n        height:50px;\n        margin:5px;\n        line-height: 50px;\n        color:#fff;\n        text-align: center;\n        background:orange;\n        border-radius: 5px;\n    }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png\" alt></p>\n</li>\n<li><p>使用BFC来防止文字环绕。</p>\n</li>\n</ol>\n<pre><code class=\"html\">   &lt;div class=&quot;float&quot;&gt;\n       &lt;div class=&quot;floatimg&quot;&gt;this is a float img!&lt;/div&gt;\n       &lt;p&gt;\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a             float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       &lt;/p&gt;\n   &lt;/div&gt;\n   &lt;style&gt;\n       .float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n       }\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n   &lt;/style&gt;\n</code></pre>\n<p>   效果：</p>\n<p>   <img src=\"/2018/10/21/BFC/58fe0bc24074305e80124130cb611524.png\" alt></p>\n<p>   <em>上图可以看出，右侧的文字会环绕着左侧的浮动元素，如果我们不想要环绕的效果呢？</em></p>\n<pre><code class=\"html\">   &lt;div class=&quot;float&quot;&gt;\n       &lt;div class=&quot;floatimg&quot;&gt;this is a float img!&lt;/div&gt;\n       &lt;p&gt;\n       this is a float context.this is a float context.this is a float context.this is a float        context.this is a float context.this is a float context.this is a float context.this is a             float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.this is a float context.\n       &lt;/p&gt;\n   &lt;/div&gt;\n   &lt;style&gt;\n       .float{\n           width:300px;\n           padding:5px;\n           border:1px solid #ccc;\n           border-radius: 5px;\n           margin:auto;\n       }\n       .floatimg{\n           float:left;\n           width:100px;\n           height:50px;\n           margin:5px;\n           line-height: 50px;\n           color:#fff;\n           text-align: center;\n           background:orange;\n           border-radius: 5px;\n       }\n       .float p{\n           overflow: auto;\n       }\n   &lt;/style&gt;\n</code></pre>\n<p>   效果：</p>\n<p>   <img src=\"/2018/10/21/BFC/d1d0d0b84057b84c8064633356e7a56a.png\" alt></p>\n<p>   <em>通过设置<code>overflow</code>，为p元素创建单独的BFC。</em></p>\n<ol start=\"4\">\n<li><p>在多列布局中使用BFC。</p>\n<pre><code class=\"html\">&lt;div class=&quot;cln&quot;&gt;\n        &lt;div class=&quot;column&quot;&gt;column1&lt;/div&gt;\n        &lt;div class=&quot;column&quot;&gt;column2&lt;/div&gt;\n        &lt;div class=&quot;column&quot;&gt;column3&lt;/div&gt;\n&lt;/div&gt;\n&lt;style&gt;\n        .cln{\n            width:600px;\n            margin:20px auto;\n        }\n        .column{\n            width:31.33%;\n            text-align: center;\n            background-color:yellow;\n            float: left;\n            margin:0 1%;\n        }\n        .column:last-child{\n            float: none;\n        }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/21/BFC/61f755c3404c04f880bf3759d96965db.png\" alt></p>\n<p><em>上图中多列元素的最后一个被挤到下一行了，造成这样的原因可能时因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。可以通过创建新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。</em></p>\n<pre><code class=\"html\">&lt;div class=&quot;cln&quot;&gt;\n        &lt;div class=&quot;column&quot;&gt;column1&lt;/div&gt;\n        &lt;div class=&quot;column&quot;&gt;column2&lt;/div&gt;\n        &lt;div class=&quot;column&quot;&gt;column3&lt;/div&gt;\n&lt;/div&gt;\n&lt;style&gt;\n        .cln{\n            width:600px;\n            margin:20px auto;\n        }\n        .column{\n            width:31.33%;\n            text-align: center;\n            background-color:yellow;\n            float: left;\n            margin:0 1%;\n        }\n        .column:last-child{\n            float: none;\n              overflow: hidden;\n        }\n&lt;/style&gt;\n</code></pre>\n<p>效果：</p>\n<p><img src=\"/2018/10/21/BFC/9f51d5ac40bdb5fa804d79aed400cab1.png\" alt></p>\n"},{"title":"CommonJS规范","date":"2018-12-09T04:12:08.000Z","_content":"\n### **CommonJS规范**\n\n**CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3部分。**\n\n1. 模块引用\n\n   ```js\n   var math = require('math');\n   ```\n\n   在CommonJS规范中，存在`require()`方法，这个方法接受模块标识，以此引入一个模块得API到当前上下文中。\n\n2. 模块定义\n\n   上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中还存在一个`module`对象，它代表模块自身，而`exports`是`module`的属性。在Node中，一个文件就是一个模块，将方法挂载在`exports`对象上作为属性即可定义导出的方式。\n\n   ```js\n   //math.js\n   exports.add=function(){\n       var sum=0,\n           i=0,\n           args=arguments,\n           l=args.length;\n       while(i<l){\n           sum+=args[i++];\n       }\n       return sum;\n   }\n   ```\n\n   在另一个文件中，我们可以通过`require()`方法引入模块后，就能调用定义的属性或方法。\n\n   ```js\n   //program.js\n   var math=require('math');\n   exports.increment=function(val){\n       return math.add(val,1);\n   }\n   ```\n\n3. 模块标识\n\n   模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者是.、..开头的相对路径，或者绝对路径。可以没有文件的后缀名.js。\n\n   模块的定义十分简单，接口十分简洁。它的意义在于将方法和变量等限定在私有的作用域中，同时支持引入和导出功能，每个模块具有独立的空间，它们互不干扰。\n\n##### 包规范\n\n1. 包结构\n\n   主要用于组织包中的各种文件。\n\n2. 包描述文件与NPM\n\n   用于描述包的相关信息，以供外部读取分析。\n\n如果要输出一个键值对象`{}`，可以利用`exports`这个已存在的空对象`{}`，并继续在上面添加新的键值；\n\n如果要输出一个函数或数组，必须直接对`module.exports`对象赋值。\n\n所以我们可以得出结论：直接对`module.exports`赋值，可以应对任何情况：\n\n```js\nmodule.exports = {\n    foo: function () { return 'foo'; }\n};\n```\n\n或者：\n\n```js\nmodule.exports = function () { return 'foo'; };\n```\n\n最终，我们*强烈建议*使用`module.exports = xxx`的方式来输出模块变量，这样，你只需要记忆一种方法。","source":"_posts/CommonJS规范.md","raw":"---\ntitle: CommonJS规范\ndate: 2018-12-09 12:12:08\ntags: 模块开发规范\ncategories: 前端\n---\n\n### **CommonJS规范**\n\n**CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3部分。**\n\n1. 模块引用\n\n   ```js\n   var math = require('math');\n   ```\n\n   在CommonJS规范中，存在`require()`方法，这个方法接受模块标识，以此引入一个模块得API到当前上下文中。\n\n2. 模块定义\n\n   上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中还存在一个`module`对象，它代表模块自身，而`exports`是`module`的属性。在Node中，一个文件就是一个模块，将方法挂载在`exports`对象上作为属性即可定义导出的方式。\n\n   ```js\n   //math.js\n   exports.add=function(){\n       var sum=0,\n           i=0,\n           args=arguments,\n           l=args.length;\n       while(i<l){\n           sum+=args[i++];\n       }\n       return sum;\n   }\n   ```\n\n   在另一个文件中，我们可以通过`require()`方法引入模块后，就能调用定义的属性或方法。\n\n   ```js\n   //program.js\n   var math=require('math');\n   exports.increment=function(val){\n       return math.add(val,1);\n   }\n   ```\n\n3. 模块标识\n\n   模块标识其实就是传递给`require()`方法的参数，它必须是符合小驼峰命名的字符串，或者是.、..开头的相对路径，或者绝对路径。可以没有文件的后缀名.js。\n\n   模块的定义十分简单，接口十分简洁。它的意义在于将方法和变量等限定在私有的作用域中，同时支持引入和导出功能，每个模块具有独立的空间，它们互不干扰。\n\n##### 包规范\n\n1. 包结构\n\n   主要用于组织包中的各种文件。\n\n2. 包描述文件与NPM\n\n   用于描述包的相关信息，以供外部读取分析。\n\n如果要输出一个键值对象`{}`，可以利用`exports`这个已存在的空对象`{}`，并继续在上面添加新的键值；\n\n如果要输出一个函数或数组，必须直接对`module.exports`对象赋值。\n\n所以我们可以得出结论：直接对`module.exports`赋值，可以应对任何情况：\n\n```js\nmodule.exports = {\n    foo: function () { return 'foo'; }\n};\n```\n\n或者：\n\n```js\nmodule.exports = function () { return 'foo'; };\n```\n\n最终，我们*强烈建议*使用`module.exports = xxx`的方式来输出模块变量，这样，你只需要记忆一种方法。","slug":"CommonJS规范","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr8s00061xop9dgke1qb","content":"<h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a><strong>CommonJS规范</strong></h3><p><strong>CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3部分。</strong></p>\n<ol>\n<li><p>模块引用</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> math <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'math'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在CommonJS规范中，存在<code>require()</code>方法，这个方法接受模块标识，以此引入一个模块得API到当前上下文中。</p>\n</li>\n<li><p>模块定义</p>\n<p>上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中还存在一个<code>module</code>对象，它代表模块自身，而<code>exports</code>是<code>module</code>的属性。在Node中，一个文件就是一个模块，将方法挂载在<code>exports</code>对象上作为属性即可定义导出的方式。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//math.js</span>\nexports<span class=\"token punctuation\">.</span>add<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> sum<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n        args<span class=\"token operator\">=</span>arguments<span class=\"token punctuation\">,</span>\n        l<span class=\"token operator\">=</span>args<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;</span>l<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        sum<span class=\"token operator\">+</span><span class=\"token operator\">=</span>args<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在另一个文件中，我们可以通过<code>require()</code>方法引入模块后，就能调用定义的属性或方法。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//program.js</span>\n<span class=\"token keyword\">var</span> math<span class=\"token operator\">=</span><span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'math'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nexports<span class=\"token punctuation\">.</span>increment<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> math<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>模块标识</p>\n<p>模块标识其实就是传递给<code>require()</code>方法的参数，它必须是符合小驼峰命名的字符串，或者是.、..开头的相对路径，或者绝对路径。可以没有文件的后缀名.js。</p>\n<p>模块的定义十分简单，接口十分简洁。它的意义在于将方法和变量等限定在私有的作用域中，同时支持引入和导出功能，每个模块具有独立的空间，它们互不干扰。</p>\n</li>\n</ol>\n<h5 id=\"包规范\"><a href=\"#包规范\" class=\"headerlink\" title=\"包规范\"></a>包规范</h5><ol>\n<li><p>包结构</p>\n<p>主要用于组织包中的各种文件。</p>\n</li>\n<li><p>包描述文件与NPM</p>\n<p>用于描述包的相关信息，以供外部读取分析。</p>\n</li>\n</ol>\n<p>如果要输出一个键值对象<code>{}</code>，可以利用<code>exports</code>这个已存在的空对象<code>{}</code>，并继续在上面添加新的键值；</p>\n<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>\n<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>或者：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token string\">'foo'</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a><strong>CommonJS规范</strong></h3><p><strong>CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3部分。</strong></p>\n<ol>\n<li><p>模块引用</p>\n<pre><code class=\"js\">var math = require(&#39;math&#39;);\n</code></pre>\n<p>在CommonJS规范中，存在<code>require()</code>方法，这个方法接受模块标识，以此引入一个模块得API到当前上下文中。</p>\n</li>\n<li><p>模块定义</p>\n<p>上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中还存在一个<code>module</code>对象，它代表模块自身，而<code>exports</code>是<code>module</code>的属性。在Node中，一个文件就是一个模块，将方法挂载在<code>exports</code>对象上作为属性即可定义导出的方式。</p>\n<pre><code class=\"js\">//math.js\nexports.add=function(){\n    var sum=0,\n        i=0,\n        args=arguments,\n        l=args.length;\n    while(i&lt;l){\n        sum+=args[i++];\n    }\n    return sum;\n}\n</code></pre>\n<p>在另一个文件中，我们可以通过<code>require()</code>方法引入模块后，就能调用定义的属性或方法。</p>\n<pre><code class=\"js\">//program.js\nvar math=require(&#39;math&#39;);\nexports.increment=function(val){\n    return math.add(val,1);\n}\n</code></pre>\n</li>\n<li><p>模块标识</p>\n<p>模块标识其实就是传递给<code>require()</code>方法的参数，它必须是符合小驼峰命名的字符串，或者是.、..开头的相对路径，或者绝对路径。可以没有文件的后缀名.js。</p>\n<p>模块的定义十分简单，接口十分简洁。它的意义在于将方法和变量等限定在私有的作用域中，同时支持引入和导出功能，每个模块具有独立的空间，它们互不干扰。</p>\n</li>\n</ol>\n<h5 id=\"包规范\"><a href=\"#包规范\" class=\"headerlink\" title=\"包规范\"></a>包规范</h5><ol>\n<li><p>包结构</p>\n<p>主要用于组织包中的各种文件。</p>\n</li>\n<li><p>包描述文件与NPM</p>\n<p>用于描述包的相关信息，以供外部读取分析。</p>\n</li>\n</ol>\n<p>如果要输出一个键值对象<code>{}</code>，可以利用<code>exports</code>这个已存在的空对象<code>{}</code>，并继续在上面添加新的键值；</p>\n<p>如果要输出一个函数或数组，必须直接对<code>module.exports</code>对象赋值。</p>\n<p>所以我们可以得出结论：直接对<code>module.exports</code>赋值，可以应对任何情况：</p>\n<pre><code class=\"js\">module.exports = {\n    foo: function () { return &#39;foo&#39;; }\n};\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"js\">module.exports = function () { return &#39;foo&#39;; };\n</code></pre>\n<p>最终，我们<em>强烈建议</em>使用<code>module.exports = xxx</code>的方式来输出模块变量，这样，你只需要记忆一种方法。</p>\n"},{"title":"ES5","date":"2019-05-01T04:56:46.000Z","_content":"\n### ES5新增语法\n\n##### 严格模式\n\n1. 理解\n\n   ES5新增了第二种运行模式：严格模式。在这种模式下，使得JavaScript在更加严格的语法条件下运行\n\n2. 目的/作用\n\n   消除js语法的一些不合理、不严谨之处，减少一些怪异行为。\n\n   消除代码的一些不安全之处。\n\n3. 使用\n\n   在全局或函数的第一条语句定义：`'use strict'`。\n\n   如果浏览器不支持，则会被解析为一条简单的语句，不会产生副作用。\n\n4. 语法和行为\n\n   变量在使用前，必须先声明。\n\n   禁止自定义函数中的this指向window\n\n   创建eval作用域\n\n   对象不能有重名属性\n\n##### JSON对象\n\n1. 新增JSON.stringify(obj/arr)\n\n   js对象（数组）转换为json对象（数组）\n\n   ```js\n   //将js对象转换为JSON对象输出\n   var obj = {username: 'zhangsan'};\n   console.log(JSON.stringify(obj)); // '{\"username\":\"zhangsan\"}'\n   \n   //将js数组转换为JSON数组输出\n   var array = [1,2,3];\n   console.log(JSON.stringify(array)); //'[1,2,3]'\n   ```\n\n2. 新增JSON.parse(json)\n\n   json对象（数组）转换为js对象（数组）\n\n   ```js\n   //将JSON对象转换为js对象\n   var jsonObj = '{\"username\":\"zhangsan\"}';\n   console.log(JSON.parse(jsonObj)); //{username: 'zhangsan'}\n   \n   //将JSON数组转换为js数组\n   var jsonArray = '[1,2,3]';\n   console.log(JSON.parse(jsonArray)); //[1,]\n   ```\n\n##### object的扩展\n\n1. Object.create(prototype,[descriptors])\n\n   - 作用：以指定对象为原型创建新的对象\n   - 为新的对象指定新的属性，并对属性进行描述\n     - value：指定值\n     - writable：标识当前新增的属性值是否是可修改的，默认为false\n     - configurable：标识当前新增的属性是否可以被删除，默认为false\n     - enumerable：标识当前新增的属性是否能够用for in枚举，默认为false\n\n   ```js\n   var obj1 = {username: 'zhangsan'};\n   var obj2 = Object.create(obj1);\n   console.log(obj2); // 输出为{},obj1对象被指定为obj2.__proto__属性中\n   console.log(obj2.__proto__); //{username:'zhangsan'}\n   var obj3 = Object.create(obj1,{\n       sex: {\n           value: '男',\n           writable: true //表示当前属性值可以被修改\n       },\n       age: {\n           value: 20,\n           enumerable: true //表示当前属性可被for in枚举\n       }\n   })\n   ```\n\n2. Object.defineProperties(object,descriptors)\n\n   - 作用：为指定对象定义扩展多个属性\n   - get：用来获取当前属性值的回调函数\n   - set：修改当前属性值的触发的回调函数，并且实参即为修改后的值\n   - 存储器属性：setter，getter一个用来存值，一个用来取值\n\n   ```js\n   var obj2 = {firstName: 'kobe', lastName: 'brant'};\n   Object.defineProperties(obj2,{\n       fullName: {\n           get: function (){ //获取对象扩展属性的值，获取扩展属性时get方法自动调用\n           \treturn this.firstName + \" \" + this.lastName;\n       \t},\n           set: function (data){ //监听扩展属性的值，当扩展属性值发生变化时，自动调用当前函数\n               //data值为当前属性被更新后最新的值\n               var names = data.split(' ');\n               this.firstName = names[0];\n               this.lastName = names[1];\n           }\n       }\n   })\n   console.log(obj2.fullName); //'kobe brant' 调用fullName的get方法\n   obj2.fullName = 'tim duck'; //此时将会触发调用fullName属性中的set方法\n   console.log(obj2.fullName); //'tim duck' 调用fullName的get方法\n   ```\n\n   > 对象本身的两个方法\n   >\n   > - get propertyName(){}用来得到当前属性值的回掉函数\n   >\n   > - set propertyName(){}用来监视当前属性值变化的回掉函数\n   >\n   >   ```js\n   >   var obj = {\n   >       firstName: 'curry',\n   >       lastName: 'step',\n   >       get fullName() { //固定写法，需要省略function,get类似function作用\n   >           return this.firstName + ' ' + this.lastName;\n   >       },\n   >       set fullName(data) {\n   >           var names = data.split(' ');\n   >           this.firstName = names[0];\n   >           this.lastName = names[1];\n   >       }\n   >   }\n   >   ```\n   >\n\n##### Array扩展\n\n1. Array.prototype.indexOf(value)：得到值在数组中的第一个下标\n\n   ```js\n   var arr = [1,2,3,4,5,2];\n   console.log(arr.indexOf(2)); //1\n   ```\n\n2. Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标\n\n   ```js\n   var arr = [1,2,3,4,5,3];\n   console.log(arr.lastIndexOf(3)); //5\n   ```\n\n3. Array.prototype.forEach(function(item,index){})：遍历数组\n\n   ```js\n   var arr = [1,2,3,4,5];\n   arr.forEach(function(item,index) {\n       console.log(item,index);\n   })\n   ```\n\n4. Array.prototype.map(function(item,index){})：遍历数组返回一个新的数组，返回加工之后的值\n\n   ```js\n   var arr = [1,2,3,4,5];\n   var arr2 = arr.map(function(item,index){\n       return item + 1;\n   })\n   console.log(arr2); //[2,3,4,5,6]\n   ```\n\n5. Array.prototype.filter(function(item,index){})：遍历过滤出一个新的子数组，返回条件为true的值\n\n   ```js\n   var arr = [1,2,3,4,5];\n   var arr2 = arr.filter(function(item,index){\n       return item > 3\n   })\n   console.log(arr2); //[4,5]\n   ```\n\n##### Function扩展\n\n1. Function.prototype.bind(obj)：\n   - 作用：将函数内的this绑定obj，并将函数返回\n2. 区别bind()与call()和apply()？\n   - 都能指定函数中改的this\n   - call()/apply()是立即调用函数\n   - bind()是将函数返回\n   - 传入参数形式：\n     - foo.call(obj,33)  //直接传入第二个参数\n     - foo.apply(obj,[33]) //第二个参数必须是数组，传入放在数组里\n     - bind特点：绑定完this不会立即调用当前的函数，而是将函数返回\n\n","source":"_posts/ES5.md","raw":"---\ntitle: ES5\ndate: 2019-05-01 12:56:46\ntags: js\ncategories: 前端\n---\n\n### ES5新增语法\n\n##### 严格模式\n\n1. 理解\n\n   ES5新增了第二种运行模式：严格模式。在这种模式下，使得JavaScript在更加严格的语法条件下运行\n\n2. 目的/作用\n\n   消除js语法的一些不合理、不严谨之处，减少一些怪异行为。\n\n   消除代码的一些不安全之处。\n\n3. 使用\n\n   在全局或函数的第一条语句定义：`'use strict'`。\n\n   如果浏览器不支持，则会被解析为一条简单的语句，不会产生副作用。\n\n4. 语法和行为\n\n   变量在使用前，必须先声明。\n\n   禁止自定义函数中的this指向window\n\n   创建eval作用域\n\n   对象不能有重名属性\n\n##### JSON对象\n\n1. 新增JSON.stringify(obj/arr)\n\n   js对象（数组）转换为json对象（数组）\n\n   ```js\n   //将js对象转换为JSON对象输出\n   var obj = {username: 'zhangsan'};\n   console.log(JSON.stringify(obj)); // '{\"username\":\"zhangsan\"}'\n   \n   //将js数组转换为JSON数组输出\n   var array = [1,2,3];\n   console.log(JSON.stringify(array)); //'[1,2,3]'\n   ```\n\n2. 新增JSON.parse(json)\n\n   json对象（数组）转换为js对象（数组）\n\n   ```js\n   //将JSON对象转换为js对象\n   var jsonObj = '{\"username\":\"zhangsan\"}';\n   console.log(JSON.parse(jsonObj)); //{username: 'zhangsan'}\n   \n   //将JSON数组转换为js数组\n   var jsonArray = '[1,2,3]';\n   console.log(JSON.parse(jsonArray)); //[1,]\n   ```\n\n##### object的扩展\n\n1. Object.create(prototype,[descriptors])\n\n   - 作用：以指定对象为原型创建新的对象\n   - 为新的对象指定新的属性，并对属性进行描述\n     - value：指定值\n     - writable：标识当前新增的属性值是否是可修改的，默认为false\n     - configurable：标识当前新增的属性是否可以被删除，默认为false\n     - enumerable：标识当前新增的属性是否能够用for in枚举，默认为false\n\n   ```js\n   var obj1 = {username: 'zhangsan'};\n   var obj2 = Object.create(obj1);\n   console.log(obj2); // 输出为{},obj1对象被指定为obj2.__proto__属性中\n   console.log(obj2.__proto__); //{username:'zhangsan'}\n   var obj3 = Object.create(obj1,{\n       sex: {\n           value: '男',\n           writable: true //表示当前属性值可以被修改\n       },\n       age: {\n           value: 20,\n           enumerable: true //表示当前属性可被for in枚举\n       }\n   })\n   ```\n\n2. Object.defineProperties(object,descriptors)\n\n   - 作用：为指定对象定义扩展多个属性\n   - get：用来获取当前属性值的回调函数\n   - set：修改当前属性值的触发的回调函数，并且实参即为修改后的值\n   - 存储器属性：setter，getter一个用来存值，一个用来取值\n\n   ```js\n   var obj2 = {firstName: 'kobe', lastName: 'brant'};\n   Object.defineProperties(obj2,{\n       fullName: {\n           get: function (){ //获取对象扩展属性的值，获取扩展属性时get方法自动调用\n           \treturn this.firstName + \" \" + this.lastName;\n       \t},\n           set: function (data){ //监听扩展属性的值，当扩展属性值发生变化时，自动调用当前函数\n               //data值为当前属性被更新后最新的值\n               var names = data.split(' ');\n               this.firstName = names[0];\n               this.lastName = names[1];\n           }\n       }\n   })\n   console.log(obj2.fullName); //'kobe brant' 调用fullName的get方法\n   obj2.fullName = 'tim duck'; //此时将会触发调用fullName属性中的set方法\n   console.log(obj2.fullName); //'tim duck' 调用fullName的get方法\n   ```\n\n   > 对象本身的两个方法\n   >\n   > - get propertyName(){}用来得到当前属性值的回掉函数\n   >\n   > - set propertyName(){}用来监视当前属性值变化的回掉函数\n   >\n   >   ```js\n   >   var obj = {\n   >       firstName: 'curry',\n   >       lastName: 'step',\n   >       get fullName() { //固定写法，需要省略function,get类似function作用\n   >           return this.firstName + ' ' + this.lastName;\n   >       },\n   >       set fullName(data) {\n   >           var names = data.split(' ');\n   >           this.firstName = names[0];\n   >           this.lastName = names[1];\n   >       }\n   >   }\n   >   ```\n   >\n\n##### Array扩展\n\n1. Array.prototype.indexOf(value)：得到值在数组中的第一个下标\n\n   ```js\n   var arr = [1,2,3,4,5,2];\n   console.log(arr.indexOf(2)); //1\n   ```\n\n2. Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标\n\n   ```js\n   var arr = [1,2,3,4,5,3];\n   console.log(arr.lastIndexOf(3)); //5\n   ```\n\n3. Array.prototype.forEach(function(item,index){})：遍历数组\n\n   ```js\n   var arr = [1,2,3,4,5];\n   arr.forEach(function(item,index) {\n       console.log(item,index);\n   })\n   ```\n\n4. Array.prototype.map(function(item,index){})：遍历数组返回一个新的数组，返回加工之后的值\n\n   ```js\n   var arr = [1,2,3,4,5];\n   var arr2 = arr.map(function(item,index){\n       return item + 1;\n   })\n   console.log(arr2); //[2,3,4,5,6]\n   ```\n\n5. Array.prototype.filter(function(item,index){})：遍历过滤出一个新的子数组，返回条件为true的值\n\n   ```js\n   var arr = [1,2,3,4,5];\n   var arr2 = arr.filter(function(item,index){\n       return item > 3\n   })\n   console.log(arr2); //[4,5]\n   ```\n\n##### Function扩展\n\n1. Function.prototype.bind(obj)：\n   - 作用：将函数内的this绑定obj，并将函数返回\n2. 区别bind()与call()和apply()？\n   - 都能指定函数中改的this\n   - call()/apply()是立即调用函数\n   - bind()是将函数返回\n   - 传入参数形式：\n     - foo.call(obj,33)  //直接传入第二个参数\n     - foo.apply(obj,[33]) //第二个参数必须是数组，传入放在数组里\n     - bind特点：绑定完this不会立即调用当前的函数，而是将函数返回\n\n","slug":"ES5","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr8t00071xop9ou15p8y","content":"<h3 id=\"ES5新增语法\"><a href=\"#ES5新增语法\" class=\"headerlink\" title=\"ES5新增语法\"></a>ES5新增语法</h3><h5 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h5><ol>\n<li><p>理解</p>\n<p>ES5新增了第二种运行模式：严格模式。在这种模式下，使得JavaScript在更加严格的语法条件下运行</p>\n</li>\n<li><p>目的/作用</p>\n<p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为。</p>\n<p>消除代码的一些不安全之处。</p>\n</li>\n<li><p>使用</p>\n<p>在全局或函数的第一条语句定义：<code>&#39;use strict&#39;</code>。</p>\n<p>如果浏览器不支持，则会被解析为一条简单的语句，不会产生副作用。</p>\n</li>\n<li><p>语法和行为</p>\n<p>变量在使用前，必须先声明。</p>\n<p>禁止自定义函数中的this指向window</p>\n<p>创建eval作用域</p>\n<p>对象不能有重名属性</p>\n</li>\n</ol>\n<h5 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h5><ol>\n<li><p>新增JSON.stringify(obj/arr)</p>\n<p>js对象（数组）转换为json对象（数组）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//将js对象转换为JSON对象输出</span>\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>username<span class=\"token punctuation\">:</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// '{\"username\":\"zhangsan\"}'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//将js数组转换为JSON数组输出</span>\n<span class=\"token keyword\">var</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'[1,2,3]'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>新增JSON.parse(json)</p>\n<p>json对象（数组）转换为js对象（数组）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//将JSON对象转换为js对象</span>\n<span class=\"token keyword\">var</span> jsonObj <span class=\"token operator\">=</span> <span class=\"token string\">'{\"username\":\"zhangsan\"}'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>jsonObj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//{username: 'zhangsan'}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//将JSON数组转换为js数组</span>\n<span class=\"token keyword\">var</span> jsonArray <span class=\"token operator\">=</span> <span class=\"token string\">'[1,2,3]'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>jsonArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h5 id=\"object的扩展\"><a href=\"#object的扩展\" class=\"headerlink\" title=\"object的扩展\"></a>object的扩展</h5><ol>\n<li><p>Object.create(prototype,[descriptors])</p>\n<ul>\n<li>作用：以指定对象为原型创建新的对象</li>\n<li>为新的对象指定新的属性，并对属性进行描述<ul>\n<li>value：指定值</li>\n<li>writable：标识当前新增的属性值是否是可修改的，默认为false</li>\n<li>configurable：标识当前新增的属性是否可以被删除，默认为false</li>\n<li>enumerable：标识当前新增的属性是否能够用for in枚举，默认为false</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>username<span class=\"token punctuation\">:</span> <span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 输出为{},obj1对象被指定为obj2.__proto__属性中</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//{username:'zhangsan'}</span>\n<span class=\"token keyword\">var</span> obj3 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>\n    sex<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token string\">'男'</span><span class=\"token punctuation\">,</span>\n        writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">//表示当前属性值可以被修改</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n        enumerable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token comment\" spellcheck=\"true\">//表示当前属性可被for in枚举</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Object.defineProperties(object,descriptors)</p>\n<ul>\n<li>作用：为指定对象定义扩展多个属性</li>\n<li>get：用来获取当前属性值的回调函数</li>\n<li>set：修改当前属性值的触发的回调函数，并且实参即为修改后的值</li>\n<li>存储器属性：setter，getter一个用来存值，一个用来取值</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'kobe'</span><span class=\"token punctuation\">,</span> lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">'brant'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperties</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>\n    fullName<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//获取对象扩展属性的值，获取扩展属性时get方法自动调用</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//监听扩展属性的值，当扩展属性值发生变化时，自动调用当前函数</span>\n            <span class=\"token comment\" spellcheck=\"true\">//data值为当前属性被更新后最新的值</span>\n            <span class=\"token keyword\">var</span> names <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">=</span> names<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName <span class=\"token operator\">=</span> names<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">.</span>fullName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'kobe brant' 调用fullName的get方法</span>\nobj2<span class=\"token punctuation\">.</span>fullName <span class=\"token operator\">=</span> <span class=\"token string\">'tim duck'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//此时将会触发调用fullName属性中的set方法</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj2<span class=\"token punctuation\">.</span>fullName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'tim duck' 调用fullName的get方法</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>对象本身的两个方法</p>\n<ul>\n<li><p>get propertyName(){}用来得到当前属性值的回掉函数</p>\n</li>\n<li><p>set propertyName(){}用来监视当前属性值变化的回掉函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'curry'</span><span class=\"token punctuation\">,</span>\n    lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">'step'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">get</span> <span class=\"token function\">fullName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//固定写法，需要省略function,get类似function作用</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span> <span class=\"token function\">fullName</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> names <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName <span class=\"token operator\">=</span> names<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName <span class=\"token operator\">=</span> names<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"Array扩展\"><a href=\"#Array扩展\" class=\"headerlink\" title=\"Array扩展\"></a>Array扩展</h5><ol>\n<li><p>Array.prototype.indexOf(value)：得到值在数组中的第一个下标</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">lastIndexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//5</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>Array.prototype.forEach(function(item,index){})：遍历数组</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Array.prototype.map(function(item,index){})：遍历数组返回一个新的数组，返回加工之后的值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr2 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> item <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[2,3,4,5,6]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Array.prototype.filter(function(item,index){})：遍历过滤出一个新的子数组，返回条件为true的值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> arr2 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> item <span class=\"token operator\">></span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[4,5]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h5 id=\"Function扩展\"><a href=\"#Function扩展\" class=\"headerlink\" title=\"Function扩展\"></a>Function扩展</h5><ol>\n<li>Function.prototype.bind(obj)：<ul>\n<li>作用：将函数内的this绑定obj，并将函数返回</li>\n</ul>\n</li>\n<li>区别bind()与call()和apply()？<ul>\n<li>都能指定函数中改的this</li>\n<li>call()/apply()是立即调用函数</li>\n<li>bind()是将函数返回</li>\n<li>传入参数形式：<ul>\n<li>foo.call(obj,33)  //直接传入第二个参数</li>\n<li>foo.apply(obj,[33]) //第二个参数必须是数组，传入放在数组里</li>\n<li>bind特点：绑定完this不会立即调用当前的函数，而是将函数返回</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ES5新增语法\"><a href=\"#ES5新增语法\" class=\"headerlink\" title=\"ES5新增语法\"></a>ES5新增语法</h3><h5 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h5><ol>\n<li><p>理解</p>\n<p>ES5新增了第二种运行模式：严格模式。在这种模式下，使得JavaScript在更加严格的语法条件下运行</p>\n</li>\n<li><p>目的/作用</p>\n<p>消除js语法的一些不合理、不严谨之处，减少一些怪异行为。</p>\n<p>消除代码的一些不安全之处。</p>\n</li>\n<li><p>使用</p>\n<p>在全局或函数的第一条语句定义：<code>&#39;use strict&#39;</code>。</p>\n<p>如果浏览器不支持，则会被解析为一条简单的语句，不会产生副作用。</p>\n</li>\n<li><p>语法和行为</p>\n<p>变量在使用前，必须先声明。</p>\n<p>禁止自定义函数中的this指向window</p>\n<p>创建eval作用域</p>\n<p>对象不能有重名属性</p>\n</li>\n</ol>\n<h5 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h5><ol>\n<li><p>新增JSON.stringify(obj/arr)</p>\n<p>js对象（数组）转换为json对象（数组）</p>\n<pre><code class=\"js\">//将js对象转换为JSON对象输出\nvar obj = {username: &#39;zhangsan&#39;};\nconsole.log(JSON.stringify(obj)); // &#39;{&quot;username&quot;:&quot;zhangsan&quot;}&#39;\n\n//将js数组转换为JSON数组输出\nvar array = [1,2,3];\nconsole.log(JSON.stringify(array)); //&#39;[1,2,3]&#39;\n</code></pre>\n</li>\n<li><p>新增JSON.parse(json)</p>\n<p>json对象（数组）转换为js对象（数组）</p>\n<pre><code class=\"js\">//将JSON对象转换为js对象\nvar jsonObj = &#39;{&quot;username&quot;:&quot;zhangsan&quot;}&#39;;\nconsole.log(JSON.parse(jsonObj)); //{username: &#39;zhangsan&#39;}\n\n//将JSON数组转换为js数组\nvar jsonArray = &#39;[1,2,3]&#39;;\nconsole.log(JSON.parse(jsonArray)); //[1,]\n</code></pre>\n</li>\n</ol>\n<h5 id=\"object的扩展\"><a href=\"#object的扩展\" class=\"headerlink\" title=\"object的扩展\"></a>object的扩展</h5><ol>\n<li><p>Object.create(prototype,[descriptors])</p>\n<ul>\n<li>作用：以指定对象为原型创建新的对象</li>\n<li>为新的对象指定新的属性，并对属性进行描述<ul>\n<li>value：指定值</li>\n<li>writable：标识当前新增的属性值是否是可修改的，默认为false</li>\n<li>configurable：标识当前新增的属性是否可以被删除，默认为false</li>\n<li>enumerable：标识当前新增的属性是否能够用for in枚举，默认为false</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">var obj1 = {username: &#39;zhangsan&#39;};\nvar obj2 = Object.create(obj1);\nconsole.log(obj2); // 输出为{},obj1对象被指定为obj2.__proto__属性中\nconsole.log(obj2.__proto__); //{username:&#39;zhangsan&#39;}\nvar obj3 = Object.create(obj1,{\n    sex: {\n        value: &#39;男&#39;,\n        writable: true //表示当前属性值可以被修改\n    },\n    age: {\n        value: 20,\n        enumerable: true //表示当前属性可被for in枚举\n    }\n})\n</code></pre>\n</li>\n<li><p>Object.defineProperties(object,descriptors)</p>\n<ul>\n<li>作用：为指定对象定义扩展多个属性</li>\n<li>get：用来获取当前属性值的回调函数</li>\n<li>set：修改当前属性值的触发的回调函数，并且实参即为修改后的值</li>\n<li>存储器属性：setter，getter一个用来存值，一个用来取值</li>\n</ul>\n<pre><code class=\"js\">var obj2 = {firstName: &#39;kobe&#39;, lastName: &#39;brant&#39;};\nObject.defineProperties(obj2,{\n    fullName: {\n        get: function (){ //获取对象扩展属性的值，获取扩展属性时get方法自动调用\n            return this.firstName + &quot; &quot; + this.lastName;\n        },\n        set: function (data){ //监听扩展属性的值，当扩展属性值发生变化时，自动调用当前函数\n            //data值为当前属性被更新后最新的值\n            var names = data.split(&#39; &#39;);\n            this.firstName = names[0];\n            this.lastName = names[1];\n        }\n    }\n})\nconsole.log(obj2.fullName); //&#39;kobe brant&#39; 调用fullName的get方法\nobj2.fullName = &#39;tim duck&#39;; //此时将会触发调用fullName属性中的set方法\nconsole.log(obj2.fullName); //&#39;tim duck&#39; 调用fullName的get方法\n</code></pre>\n<blockquote>\n<p>对象本身的两个方法</p>\n<ul>\n<li><p>get propertyName(){}用来得到当前属性值的回掉函数</p>\n</li>\n<li><p>set propertyName(){}用来监视当前属性值变化的回掉函数</p>\n<pre><code class=\"js\">var obj = {\n    firstName: &#39;curry&#39;,\n    lastName: &#39;step&#39;,\n    get fullName() { //固定写法，需要省略function,get类似function作用\n        return this.firstName + &#39; &#39; + this.lastName;\n    },\n    set fullName(data) {\n        var names = data.split(&#39; &#39;);\n        this.firstName = names[0];\n        this.lastName = names[1];\n    }\n}\n</code></pre>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"Array扩展\"><a href=\"#Array扩展\" class=\"headerlink\" title=\"Array扩展\"></a>Array扩展</h5><ol>\n<li><p>Array.prototype.indexOf(value)：得到值在数组中的第一个下标</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5,2];\nconsole.log(arr.indexOf(2)); //1\n</code></pre>\n</li>\n<li><p>Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5,3];\nconsole.log(arr.lastIndexOf(3)); //5\n</code></pre>\n</li>\n<li><p>Array.prototype.forEach(function(item,index){})：遍历数组</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5];\narr.forEach(function(item,index) {\n    console.log(item,index);\n})\n</code></pre>\n</li>\n<li><p>Array.prototype.map(function(item,index){})：遍历数组返回一个新的数组，返回加工之后的值</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5];\nvar arr2 = arr.map(function(item,index){\n    return item + 1;\n})\nconsole.log(arr2); //[2,3,4,5,6]\n</code></pre>\n</li>\n<li><p>Array.prototype.filter(function(item,index){})：遍历过滤出一个新的子数组，返回条件为true的值</p>\n<pre><code class=\"js\">var arr = [1,2,3,4,5];\nvar arr2 = arr.filter(function(item,index){\n    return item &gt; 3\n})\nconsole.log(arr2); //[4,5]\n</code></pre>\n</li>\n</ol>\n<h5 id=\"Function扩展\"><a href=\"#Function扩展\" class=\"headerlink\" title=\"Function扩展\"></a>Function扩展</h5><ol>\n<li>Function.prototype.bind(obj)：<ul>\n<li>作用：将函数内的this绑定obj，并将函数返回</li>\n</ul>\n</li>\n<li>区别bind()与call()和apply()？<ul>\n<li>都能指定函数中改的this</li>\n<li>call()/apply()是立即调用函数</li>\n<li>bind()是将函数返回</li>\n<li>传入参数形式：<ul>\n<li>foo.call(obj,33)  //直接传入第二个参数</li>\n<li>foo.apply(obj,[33]) //第二个参数必须是数组，传入放在数组里</li>\n<li>bind特点：绑定完this不会立即调用当前的函数，而是将函数返回</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"ES6","date":"2019-05-01T04:57:05.000Z","_content":"\n### ES6新增语法\n\n1. 新增关键字\n\n   - let：作用与var类似，用于声明变量。\n\n     特点：\n\n     1. 在块级作用域内有效。\n\n     2. 不能重复声明。\n\n     3. 不会预处理，不存在变量提升。\n\n        ```js\n        let btns = document.getElementsByTagName('button');\n        for(var i = 0; i<btns.length; i++) {\n    var btn = btns[i];\n            btn.onclick = function() { //属于回掉函数，在主线程执行结束后，点击触发时，此时i为btns.length-1\n                console.log(i); //所有的打印结果都为btns.length-1\n            }\n        }\n        //可以通过立即执行函数来解决（闭包的原理）\n        let btns = document.getElementsByTagName('button');\n        for(var i = 0; i<btns.length; i++) {\n            var btn = btns[i];\n            (function (i){\n                btn.onclick = function() {\n                    console.log(i); //打印出来为数组的下标对应\n                }\n            })(i)\n        }\n        //let有自己的块级作用域，可以通过let来控制循环\n        let btns = document.getElementsByTagName('button');\n        for(let i = 0; i<btns.length; i++) {\n            var btn = btns[i];\n            btn.onclick = function() {\n                console.log(i);\n            }\n        }\n        ```\n        \n     \n     > let相比于var：\n     >\n     > 1. let声明的变量拥有块级作用域，let声明仍然保留了提升的特性，但不会盲目提升。\n     > 2. let声明的全局变量不是全局对象上的属性。不可以通过**window.变量名**的方式访问。\n     > 3. 形如`for (let x...)`的循环在每次迭代时都为x创建新的绑定。\n     > 4. let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发语法错误。\n     \n   - const：作用是定义一个常量。\n   \n     特点：\n   \n     1. 不能修改\n     2. 其他的特点同let\n   \n     主要应用于保存不变的数据。\n   \n2. 变量的解构赋值\n\n   - 从对象或数组中提取数据，并赋值给变量（多个）。\n\n   - 对象的解构赋值。\n\n     ```js\n     let {n,a} = {n:'123',a:'456'};\n     console.log(n); //'123'\n     console.log(a); //'456'\n     ```\n\n   - 数组的解构赋值。\n\n     ```js\n     let [a,b] = ['aaa','bbb'];\n     console.log(a); //'aaa'\n     console.log(b); //'bbb'\n     ```\n\n   - 用途：给多个形参赋值。\n\n     ```js\n     let obj = {username:'zhangsan',age:20};\n     function foo({username,age}) {\n         console.log(username,age);\n     }\n     foo(obj);\n     ```\n\n3. 模板字符串\n\n   - 简化字符串的拼接\n\n   - 模板字符串必须用``包含\n\n   - 变量的部分使用${xxx}定义\n\n     ```js\n     let name = '张三';\n     let str = `http://www.getUser.com?username=${name}`;\n     ```\n\n4. 简化的对象写法\n\n   - 省略同名的属性值\n\n   - 省略方法的function\n\n     ```js\n     let x = 1;\n     let y = 2;\n     let obj = {\n         x,\n         y,\n         getX () {\n             console.log(this.x)\n         }\n     }\n     ```\n\n5. 箭头函数\n\n   - 作用：定义匿名函数\n\n   - 基本语法：\n\n     ```js\n     //没有参数：\n     () => console.log('xxx')\n     //一个参数：\n     i => i+2\n     //多个参数：\n     (i,j) => i+j\n     //函数体不用大括号：默认返回结果\n     //函数体若有多条语句，需要使用{}包裹起来，若需要返回内容，则需要手动return\n     //箭头函数多用来定义回调函数\n     ```\n\n   - 特点：\n\n     1. 简洁。\n     2. 箭头函数没有自己的this，箭头函数内部使用的this不是调用的时候决定的，而是在定义的时候。\n     3. 如何分辨箭头函数的this：箭头函数的this看外层是否有函数，如果有，外层函数的this就是箭头函数内部的this，如果没有，则this指向window。\n\n   > 箭头函数与传统函数的区别：\n   >\n   > 1. 没有this、super、arguments和new.target绑定，这些值由最近一层非箭头函数决定。\n   > 2. 不能通过new关键字调用，所以不能用作构造函数，否则程序会抛出错误。\n   > 3. 没有原型。由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。\n   > 4. 不可以改变this的绑定，函数内部的this值不可以被改变，在函数的生命周期内始终保持一致。\n   > 5. 不支持arguments对象，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。\n   > 6. 不支持重复的命名参数，无论在严格还是非严格模式下，都不支持，而在传统的函数规定中只有在严格模式下才不能有重复命名参数。\n\n6. 三点运算符\n\n   - 用途：可变参数用来取代arguments，但比arguments灵活，只能时最后部分形参参数。\n\n     ```js\n     function fun(a, ...values) {\n         console.log(arguments);\n         //arguments是伪数组，不具备数组的一般方法，例如forEach方法等。\n         //arguments.forEach(function(item, index) { //报错\n          //   console.log(item,index);\n         //})\n         values.forEach((item, index) => {\n             console.log(item, index);\n         })\n     }\n     fun(2,3,4,5,6,7);\n     ```\n\n   - 扩展运算符\n\n     ```js\n     let arr1 = [1,2,3];\n     let arr2 = [...arr1,4,5,6];\n     console.log(arr2); //[1,2,3,4,5,6]\n     //或者\n     arr2.push(...arr1);\n     ```\n\n7. 形参默认值\n\n   - 当不传入参数时，默认使用形式参数的默认值\n\n     ```js\n     function Point(x = 1, y = 2) {\n         this.x = x;\n         this.y = y;\n     }\n     ```\n\n8. Promise对象\n\n   - 作用：代表了未来某个将要发生的事件（通常是一个异步操作）\n\n   - 有了Promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（俗称'回调地狱'）\n\n   - ES6的Promise是一个构造函数，用来生成promise实例\n\n   - 使用Promise基本步骤：\n\n     1. 创建promise对象\n\n        ```js\n        let promise = new Promise((resolve, reject) => {\n            //初始化promise状态为pending\n            //执行异步操作\n            if(异步操作成功) {\n            \tresolve(value); //修改promise的状态为fullfilled\n            }else {\n            \treject(errMsg); //修改promise的状态为rejected\n            }\n        })\n        ```\n\n     2. 调用promise的then()\n\n        ```js\n        promise.then((resolve) => {\n          //成功时处理  \n        },(reject) => {\n            //失败时处理\n        })\n        ```\n\n     3. promise对象的三个状态\n\n        - pending：初始化状态\n        - fullfilled：成功状态\n        - rejected：失败状态\n\n     4. 应用：\n\n        - 使用promise实现超时处理\n        - 使用promise封装处理ajax请求\n     \n   - promise实现原理\n\n     \n   \n     ```js\n     // 初始化状态值\n     const PENDING = 'pending';\n     const FULFILLED = 'fulfilled';\n     const REJECTED = 'rejected';\n     \n     // Promise\n     function _Promise(handle) {\n     \t\n     \tlet self = this;\n     \tself.status = PENDING;\n     \tself.onFulfilled = []; // 执行成功时的回调\n     \tself.onRejected = [];  // 执行失败时的回调\n     \n     \t// 定义resolve方法\n     \tfunction resolve(value) {\n     \t\tif(self.status === PENDING) {\n     \t\t\tself.status = FULFILLED;\n     \t\t\tself.value = value;\n     \t\t\tself.onFulfilled.forEach(fn => fn());\n     \t\t}\n     \t}\n     \n     \t// 定义reject方法\n     \tfunction reject(reason) {\n     \t\tif(self.status === PENDING) {\n     \t\t\tself.status = REJECTED;\n     \t\t\tself.reason = reason;\n     \t\t\tself.onRejected.forEach(fn => fn());\n     \t\t}\n     \t}\n     \n     \ttry {\n     \t\thandle(resolve,reject);\n     \t}catch(err) {\n     \t\treject(err);\n     \t}\n     }\n     \n     // Promise.then\n     _Promise.prototype.then = function(onFulfilled, onRejected) {\n     \n     \t// 判断回调函数类型\n     \tonFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n     \tonRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n     \n     \tlet self = this; // this代表Promise实例本身\n     \n     \t// 定义需要返回出去的Promise\n     \tlet Promise2 = new _Promise((resolve, reject) => {\n     \t\t\n     \t\t// 如果状态为成功\n     \t\tif(self.status === FULFILLED) {\n     \n     \t\t\t// 这里使用setTimeout不是特别清楚，自己认为可能是为了实现同步逻辑\n     \t\t\tsetTimeout(() => {\n     \t\t\t\ttry {\n     \t\t\t\t\tlet x = onFulfilled(self.value);\n     \t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t}catch(err) {\n     \t\t\t\t\treject(err);\n     \t\t\t\t}\n     \t\t\t})\n     \t\t}else if(self.status === REJECTED) { // 如果状态为失败\n     \t\t\tsetTimeout(() => {\n     \t\t\t\ttry {\n     \t\t\t\t\tlet x = onRejected(self.reason);\n     \t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t}catch(err) {\n     \t\t\t\t\treject(err);\n     \t\t\t\t}\n     \t\t\t})\n     \t\t}else if(self.status === PENDING) { // 如果状态为进行中\n     \n     \t\t\t// 成功回调队列添加\n     \t\t\tself.onFulfilled.push(() => {\n     \t\t\t\tsetTimeout(() => {\n     \t\t\t\t\ttry {\n     \t\t\t\t\t\tlet x = onFulfilled(self.value);\n     \t\t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t\t}catch(err) {\n     \t\t\t\t\t\treject(err);\n     \t\t\t\t\t}\n     \t\t\t\t})\n     \t\t\t})\n     \n     \t\t\t// 失败回调队列添加\n     \t\t\tself.onRejected.push(() => {\n     \t\t\t\tsetTimeout(() => {\n     \t\t\t\t\ttry {\n     \t\t\t\t\t\tlet x = onRejected(self.reason);\n     \t\t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t\t}catch(err) {\n     \t\t\t\t\t\treject(err);\n     \t\t\t\t\t}\n     \t\t\t\t})\n     \t\t\t})\n     \t\t}\n     \t});\n     \treturn Promise2;\n     }\n     \n     function resolvePromise(Promise2, x, resolve, reject) {\n     \tlet self = this;\n     \n     \t// 判断Promise2 与 x是否一致\n     \tif(Promise2 === x) {\n     \t\treject(new TypeError(\"Promise2与x一致，拒绝执行promise\"))\n     \t}\n     \n     \tif(x && typeof x === 'object' || typeof x === 'function') { // 判断x是否为对象或者函数\n     \t\tlet used;  // 只允许调用一次\n     \t\ttry {\n     \t\t\tlet then = x.then;  // 获取x的then方法\n     \n     \t\t\t// 判断then是否是函数，如果是则认为x是一个promise对象，如果不是则x为普通对象\n     \t\t\tif(typeof then === 'function') {\n     \t\t\t\tthen.call(x, y => {\n     \t\t\t\t\t// y 代表x的resolve所传入的参数\n     \n     \t\t\t\t\tif(used) {\n     \t\t\t\t\t\treturn;\n     \t\t\t\t\t}\n     \t\t\t\t\tused = true;\n     \t\t\t\t\tresolvePromise(Promise2, y, resolve, reject);  //递归调用\n     \t\t\t\t}, err => {\n     \t\t\t\t\tif(used) {\n     \t\t\t\t\t\treturn;\n     \t\t\t\t\t}\n     \t\t\t\t\tused = true;\n     \t\t\t\t\treject(err);\n     \t\t\t\t})\n     \t\t\t}else { // x为普通对象\n     \t\t\t\tif(used) {\n     \t\t\t\t\treturn;\n     \t\t\t\t}\n     \t\t\t\tused = true;\n     \t\t\t\tresolve(x);\n     \t\t\t}\n     \t\t}catch(err) {\n     \t\t\tif(used) {\n     \t\t\t\treturn;\n     \t\t\t}\n     \t\t\tused = true;\n     \t\t\treject(err);\n     \t\t}\n     \t}else {\n     \t\tresolve(x)\n     \t}\n     \n     }\n     module.exports = _Promise;\n     // 添加测试代码\n     \n     _Promise.defer = _Promise.deferred = function () {\n         let dfd = {};\n         dfd.promise = new _Promise((resolve, reject) => {\n             dfd.resolve = resolve;\n             dfd.reject = reject;\n         });\n         return dfd;\n     }\n     ```\n\n   \n  \n   \n- Promise其他方法\n  \n  - Promise.resolve\n  \n     >  Promise.resolve(value)返回一个以给定值解析后的Promise 对象.\n  \n  1. 如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态\n     2. 如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。\n     3. 其他情况，直接返回以该值为成功状态的promise对象。\n  \n     ```js\n     Promise.resolve = function (param) {\n             if (param instanceof Promise) {\n             return param;\n         }\n         return new Promise((resolve, reject) => {\n             if (param && param.then && typeof param.then === 'function') {\n                 setTimeout(() => {\n                     param.then(resolve, reject);\n                 });\n             } else {\n                 resolve(param);\n             }\n         });\n     }\n  \n     ```\n  - Promise.reject\n  \n     > Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n  \n     ```js\n     Promise.reject = function (reason) {\n         return new Promise((resolve, reject) => {\n             reject(reason);\n         });\n  }\n     ```\n  - Promise.catch\n  \n     > Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续 .then\n  \n     ```js\n     Promise.prototype.catch = function (onRejected) {\n         return this.then(null, onRejected);\n  }\n     ```\n  - Promise.finally\n  \n     > 不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.\n  \n     ```js\n     Promise.prototype.finally = function (callback) {\n         return this.then((value) => {\n             return Promise.resolve(callback()).then(() => {\n                 return value;\n             });\n         }, (err) => {\n             return Promise.resolve(callback()).then(() => {\n                 throw err;\n             });\n         });\n  }\n     ```\n  - Promise.all\n  \n     > Promise.all(promises) 返回一个promise对象\n  \n     1. 如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。\n     2. 如果传入的参数不包含任何promise，则返回一个异步完成.\n     3. promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。\n     4. 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败\n     5. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组\n\n\n```js\n\n Promise.all = function (promises) {\n     return new Promise((resolve, reject) => {\n         let index = 0;\n         let result = [];\n         if (promises.length === 0) {\n             resolve(result);\n         } else {\n             function processValue(i, data) {\n                 result[i] = data;\n                 if (++index === promises.length) {\n                     resolve(result);\n                 }\n             }\n             for (let i = 0; i < promises.length; i++) {\n                   //promises[i] 可能是普通值\n                   Promise.resolve(promises[i]).then((data) => {\n                     processValue(i, data);\n                 }, (err) => {\n                     reject(err);\n                     return;\n                 });\n             }\n         }\n     });\n }\n\n```\n\n- Promise.race\n\n1. Promise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。\n2. 如果传的参数数组是空，则返回的 promise 将永远等待。\n3. 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。\n\n\n\n参考 \n\n https://www.jianshu.com/p/43de678e918a\n\n http://www.ituring.com.cn/article/66566\n\n https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment\n\n9. Symbol\n\n   - 前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境\n\n   - Symbol属于ES6新添加的原始数据类型。已有的原始数据类型（String，Number，bollean,null,undefined,Object）\n\n   - 特点：\n\n     1. Symbol属性对应的值是唯一的，解决命名冲突问题\n     2. Symbol值不能与其他数据进行计算，包括同字符串拼串\n     3. for in，for of遍历时不会遍历symbol属性\n\n   - 使用：\n\n     1. 调用Symbol函数得到Symbol值\n\n        ```js\n        let symbol = Symbol();\n        let obj = {};\n        obj[symbol] = 'hello'\n        ```\n\n     2. 传参标识\n\n        ```js\n        let symbol1 = Symbol('one');\n        let symbol2 = Symbol('two');\n        console.log(symbol1); //Symbol('one')\n        console.log(symbol2); //Symbol('two')\n        ```\n\n     3. 内置Symbol值\n\n        - 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法\n        - Symbol.iterator\n          * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法\n\n10. iterator\n\n    - 概念：iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制\n\n    - 作用：\n\n      1. 为各种数据结构，提供统一的，简便的访问接口\n      2. 使得数据结构的成员能够按某种次序排列\n      3. ES6创造了一种新的遍历方法for  of循环，Iterator接口主要供for of消费\n\n    - 工作原理：\n\n      1. 创建一个指针对象（遍历器对象），指向数据结构的起始位置。\n      2. 第一次调用next方法，指针自动指向数据结构的第一个成员。\n      3. 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员。\n      4. 每次调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值，done：布尔值}\n         - value代表当前成员的值，done对应的布尔值表示当前数据的结构是否遍历结束\n         - 当遍历结束的时候返回的value值是undefined，done的值是false\n\n    - 原生具备Iterator接口的数据（可用for of循环）\n\n      扩展理解：\n\n      1. 当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历\n      2. 当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性\n      3. 具有Iterator接口的原生数据类型：\n         - Array\n         - arguments\n         - set容器\n         - map容器\n         - String\n\n    ```js\n    //模拟指针对象（遍历器对象）\n    function myIterator(arr) {\n        let nextIndex = 0;\n        return {\n            next:function () {\n                return nextIndex < arr.length?{value: arr[nextIndex++], done: false}:{value:undefined,done:true}\n            }\n        }\n    }\n    //三点运算符，解构赋值，默认调用iterator接口\n    ```\n\n11. **Reflect** \n\n    > **Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。\n    >\n    > 与大多数全局对象不同，`Reflect`不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像是Math对象）。\n\n    **reflect存在的意义：**\n\n    1. 将对象(Object)一些内部的方法，放到Reflect对象上。比如：Object.defineProperty。*说明：现阶段这些方法存在以Object和Reflect对象上，未来只存在于Reflect对象上。*\n\n    2. 操作对象时出现报错返回false *说明：比如调用Object.defineProperty(target, name, value)在无法定义属性时，会出现异常，抛出错误，而Reflect.defineProperty(target, name, value)则会返回false。*\n\n       ```js\n       // 通过Object调用\n       try {\n         Object.defineProperty(target, name, attributes)\n       } catch (e) {\n         // 处理异常\n       }\n       \n       // 使用Reflect写法\n       if (Reflect.defineProperty(target, name, attributes)) {\n         // success\n       } else {\n         // failure\n       }\n       ```\n\n    3. 通过调用函数方法，让本来写法变为函数式编程的写法\n\n       ```js\n       // 之前的写法\n       'name' in Object // true\n       \n       // 使用Reflect\n       Reflect.has(Object, 'name') // true\n       ```\n\n    4. 保持和Proxy对象的方法一一对应 *说明：Reflect对象与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。*\n\n       ```js\n       \n       new Proxy(target, {\n         set: function(target, name, value, receiver) {\n           var success = Reflect.set(target, name, value, receiver);\n           if (success) {\n             // \n           }\n           return success;\n         }\n       });\n       ```\n\n       ","source":"_posts/ES6.md","raw":"---\ntitle: ES6\ndate: 2019-05-01 12:57:05\ntags: js\ncategories: 前端\n---\n\n### ES6新增语法\n\n1. 新增关键字\n\n   - let：作用与var类似，用于声明变量。\n\n     特点：\n\n     1. 在块级作用域内有效。\n\n     2. 不能重复声明。\n\n     3. 不会预处理，不存在变量提升。\n\n        ```js\n        let btns = document.getElementsByTagName('button');\n        for(var i = 0; i<btns.length; i++) {\n    var btn = btns[i];\n            btn.onclick = function() { //属于回掉函数，在主线程执行结束后，点击触发时，此时i为btns.length-1\n                console.log(i); //所有的打印结果都为btns.length-1\n            }\n        }\n        //可以通过立即执行函数来解决（闭包的原理）\n        let btns = document.getElementsByTagName('button');\n        for(var i = 0; i<btns.length; i++) {\n            var btn = btns[i];\n            (function (i){\n                btn.onclick = function() {\n                    console.log(i); //打印出来为数组的下标对应\n                }\n            })(i)\n        }\n        //let有自己的块级作用域，可以通过let来控制循环\n        let btns = document.getElementsByTagName('button');\n        for(let i = 0; i<btns.length; i++) {\n            var btn = btns[i];\n            btn.onclick = function() {\n                console.log(i);\n            }\n        }\n        ```\n        \n     \n     > let相比于var：\n     >\n     > 1. let声明的变量拥有块级作用域，let声明仍然保留了提升的特性，但不会盲目提升。\n     > 2. let声明的全局变量不是全局对象上的属性。不可以通过**window.变量名**的方式访问。\n     > 3. 形如`for (let x...)`的循环在每次迭代时都为x创建新的绑定。\n     > 4. let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发语法错误。\n     \n   - const：作用是定义一个常量。\n   \n     特点：\n   \n     1. 不能修改\n     2. 其他的特点同let\n   \n     主要应用于保存不变的数据。\n   \n2. 变量的解构赋值\n\n   - 从对象或数组中提取数据，并赋值给变量（多个）。\n\n   - 对象的解构赋值。\n\n     ```js\n     let {n,a} = {n:'123',a:'456'};\n     console.log(n); //'123'\n     console.log(a); //'456'\n     ```\n\n   - 数组的解构赋值。\n\n     ```js\n     let [a,b] = ['aaa','bbb'];\n     console.log(a); //'aaa'\n     console.log(b); //'bbb'\n     ```\n\n   - 用途：给多个形参赋值。\n\n     ```js\n     let obj = {username:'zhangsan',age:20};\n     function foo({username,age}) {\n         console.log(username,age);\n     }\n     foo(obj);\n     ```\n\n3. 模板字符串\n\n   - 简化字符串的拼接\n\n   - 模板字符串必须用``包含\n\n   - 变量的部分使用${xxx}定义\n\n     ```js\n     let name = '张三';\n     let str = `http://www.getUser.com?username=${name}`;\n     ```\n\n4. 简化的对象写法\n\n   - 省略同名的属性值\n\n   - 省略方法的function\n\n     ```js\n     let x = 1;\n     let y = 2;\n     let obj = {\n         x,\n         y,\n         getX () {\n             console.log(this.x)\n         }\n     }\n     ```\n\n5. 箭头函数\n\n   - 作用：定义匿名函数\n\n   - 基本语法：\n\n     ```js\n     //没有参数：\n     () => console.log('xxx')\n     //一个参数：\n     i => i+2\n     //多个参数：\n     (i,j) => i+j\n     //函数体不用大括号：默认返回结果\n     //函数体若有多条语句，需要使用{}包裹起来，若需要返回内容，则需要手动return\n     //箭头函数多用来定义回调函数\n     ```\n\n   - 特点：\n\n     1. 简洁。\n     2. 箭头函数没有自己的this，箭头函数内部使用的this不是调用的时候决定的，而是在定义的时候。\n     3. 如何分辨箭头函数的this：箭头函数的this看外层是否有函数，如果有，外层函数的this就是箭头函数内部的this，如果没有，则this指向window。\n\n   > 箭头函数与传统函数的区别：\n   >\n   > 1. 没有this、super、arguments和new.target绑定，这些值由最近一层非箭头函数决定。\n   > 2. 不能通过new关键字调用，所以不能用作构造函数，否则程序会抛出错误。\n   > 3. 没有原型。由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。\n   > 4. 不可以改变this的绑定，函数内部的this值不可以被改变，在函数的生命周期内始终保持一致。\n   > 5. 不支持arguments对象，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。\n   > 6. 不支持重复的命名参数，无论在严格还是非严格模式下，都不支持，而在传统的函数规定中只有在严格模式下才不能有重复命名参数。\n\n6. 三点运算符\n\n   - 用途：可变参数用来取代arguments，但比arguments灵活，只能时最后部分形参参数。\n\n     ```js\n     function fun(a, ...values) {\n         console.log(arguments);\n         //arguments是伪数组，不具备数组的一般方法，例如forEach方法等。\n         //arguments.forEach(function(item, index) { //报错\n          //   console.log(item,index);\n         //})\n         values.forEach((item, index) => {\n             console.log(item, index);\n         })\n     }\n     fun(2,3,4,5,6,7);\n     ```\n\n   - 扩展运算符\n\n     ```js\n     let arr1 = [1,2,3];\n     let arr2 = [...arr1,4,5,6];\n     console.log(arr2); //[1,2,3,4,5,6]\n     //或者\n     arr2.push(...arr1);\n     ```\n\n7. 形参默认值\n\n   - 当不传入参数时，默认使用形式参数的默认值\n\n     ```js\n     function Point(x = 1, y = 2) {\n         this.x = x;\n         this.y = y;\n     }\n     ```\n\n8. Promise对象\n\n   - 作用：代表了未来某个将要发生的事件（通常是一个异步操作）\n\n   - 有了Promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（俗称'回调地狱'）\n\n   - ES6的Promise是一个构造函数，用来生成promise实例\n\n   - 使用Promise基本步骤：\n\n     1. 创建promise对象\n\n        ```js\n        let promise = new Promise((resolve, reject) => {\n            //初始化promise状态为pending\n            //执行异步操作\n            if(异步操作成功) {\n            \tresolve(value); //修改promise的状态为fullfilled\n            }else {\n            \treject(errMsg); //修改promise的状态为rejected\n            }\n        })\n        ```\n\n     2. 调用promise的then()\n\n        ```js\n        promise.then((resolve) => {\n          //成功时处理  \n        },(reject) => {\n            //失败时处理\n        })\n        ```\n\n     3. promise对象的三个状态\n\n        - pending：初始化状态\n        - fullfilled：成功状态\n        - rejected：失败状态\n\n     4. 应用：\n\n        - 使用promise实现超时处理\n        - 使用promise封装处理ajax请求\n     \n   - promise实现原理\n\n     \n   \n     ```js\n     // 初始化状态值\n     const PENDING = 'pending';\n     const FULFILLED = 'fulfilled';\n     const REJECTED = 'rejected';\n     \n     // Promise\n     function _Promise(handle) {\n     \t\n     \tlet self = this;\n     \tself.status = PENDING;\n     \tself.onFulfilled = []; // 执行成功时的回调\n     \tself.onRejected = [];  // 执行失败时的回调\n     \n     \t// 定义resolve方法\n     \tfunction resolve(value) {\n     \t\tif(self.status === PENDING) {\n     \t\t\tself.status = FULFILLED;\n     \t\t\tself.value = value;\n     \t\t\tself.onFulfilled.forEach(fn => fn());\n     \t\t}\n     \t}\n     \n     \t// 定义reject方法\n     \tfunction reject(reason) {\n     \t\tif(self.status === PENDING) {\n     \t\t\tself.status = REJECTED;\n     \t\t\tself.reason = reason;\n     \t\t\tself.onRejected.forEach(fn => fn());\n     \t\t}\n     \t}\n     \n     \ttry {\n     \t\thandle(resolve,reject);\n     \t}catch(err) {\n     \t\treject(err);\n     \t}\n     }\n     \n     // Promise.then\n     _Promise.prototype.then = function(onFulfilled, onRejected) {\n     \n     \t// 判断回调函数类型\n     \tonFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n     \tonRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n     \n     \tlet self = this; // this代表Promise实例本身\n     \n     \t// 定义需要返回出去的Promise\n     \tlet Promise2 = new _Promise((resolve, reject) => {\n     \t\t\n     \t\t// 如果状态为成功\n     \t\tif(self.status === FULFILLED) {\n     \n     \t\t\t// 这里使用setTimeout不是特别清楚，自己认为可能是为了实现同步逻辑\n     \t\t\tsetTimeout(() => {\n     \t\t\t\ttry {\n     \t\t\t\t\tlet x = onFulfilled(self.value);\n     \t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t}catch(err) {\n     \t\t\t\t\treject(err);\n     \t\t\t\t}\n     \t\t\t})\n     \t\t}else if(self.status === REJECTED) { // 如果状态为失败\n     \t\t\tsetTimeout(() => {\n     \t\t\t\ttry {\n     \t\t\t\t\tlet x = onRejected(self.reason);\n     \t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t}catch(err) {\n     \t\t\t\t\treject(err);\n     \t\t\t\t}\n     \t\t\t})\n     \t\t}else if(self.status === PENDING) { // 如果状态为进行中\n     \n     \t\t\t// 成功回调队列添加\n     \t\t\tself.onFulfilled.push(() => {\n     \t\t\t\tsetTimeout(() => {\n     \t\t\t\t\ttry {\n     \t\t\t\t\t\tlet x = onFulfilled(self.value);\n     \t\t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t\t}catch(err) {\n     \t\t\t\t\t\treject(err);\n     \t\t\t\t\t}\n     \t\t\t\t})\n     \t\t\t})\n     \n     \t\t\t// 失败回调队列添加\n     \t\t\tself.onRejected.push(() => {\n     \t\t\t\tsetTimeout(() => {\n     \t\t\t\t\ttry {\n     \t\t\t\t\t\tlet x = onRejected(self.reason);\n     \t\t\t\t\t\tresolvePromise(Promise2, x, resolve, reject);\n     \t\t\t\t\t}catch(err) {\n     \t\t\t\t\t\treject(err);\n     \t\t\t\t\t}\n     \t\t\t\t})\n     \t\t\t})\n     \t\t}\n     \t});\n     \treturn Promise2;\n     }\n     \n     function resolvePromise(Promise2, x, resolve, reject) {\n     \tlet self = this;\n     \n     \t// 判断Promise2 与 x是否一致\n     \tif(Promise2 === x) {\n     \t\treject(new TypeError(\"Promise2与x一致，拒绝执行promise\"))\n     \t}\n     \n     \tif(x && typeof x === 'object' || typeof x === 'function') { // 判断x是否为对象或者函数\n     \t\tlet used;  // 只允许调用一次\n     \t\ttry {\n     \t\t\tlet then = x.then;  // 获取x的then方法\n     \n     \t\t\t// 判断then是否是函数，如果是则认为x是一个promise对象，如果不是则x为普通对象\n     \t\t\tif(typeof then === 'function') {\n     \t\t\t\tthen.call(x, y => {\n     \t\t\t\t\t// y 代表x的resolve所传入的参数\n     \n     \t\t\t\t\tif(used) {\n     \t\t\t\t\t\treturn;\n     \t\t\t\t\t}\n     \t\t\t\t\tused = true;\n     \t\t\t\t\tresolvePromise(Promise2, y, resolve, reject);  //递归调用\n     \t\t\t\t}, err => {\n     \t\t\t\t\tif(used) {\n     \t\t\t\t\t\treturn;\n     \t\t\t\t\t}\n     \t\t\t\t\tused = true;\n     \t\t\t\t\treject(err);\n     \t\t\t\t})\n     \t\t\t}else { // x为普通对象\n     \t\t\t\tif(used) {\n     \t\t\t\t\treturn;\n     \t\t\t\t}\n     \t\t\t\tused = true;\n     \t\t\t\tresolve(x);\n     \t\t\t}\n     \t\t}catch(err) {\n     \t\t\tif(used) {\n     \t\t\t\treturn;\n     \t\t\t}\n     \t\t\tused = true;\n     \t\t\treject(err);\n     \t\t}\n     \t}else {\n     \t\tresolve(x)\n     \t}\n     \n     }\n     module.exports = _Promise;\n     // 添加测试代码\n     \n     _Promise.defer = _Promise.deferred = function () {\n         let dfd = {};\n         dfd.promise = new _Promise((resolve, reject) => {\n             dfd.resolve = resolve;\n             dfd.reject = reject;\n         });\n         return dfd;\n     }\n     ```\n\n   \n  \n   \n- Promise其他方法\n  \n  - Promise.resolve\n  \n     >  Promise.resolve(value)返回一个以给定值解析后的Promise 对象.\n  \n  1. 如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态\n     2. 如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。\n     3. 其他情况，直接返回以该值为成功状态的promise对象。\n  \n     ```js\n     Promise.resolve = function (param) {\n             if (param instanceof Promise) {\n             return param;\n         }\n         return new Promise((resolve, reject) => {\n             if (param && param.then && typeof param.then === 'function') {\n                 setTimeout(() => {\n                     param.then(resolve, reject);\n                 });\n             } else {\n                 resolve(param);\n             }\n         });\n     }\n  \n     ```\n  - Promise.reject\n  \n     > Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n  \n     ```js\n     Promise.reject = function (reason) {\n         return new Promise((resolve, reject) => {\n             reject(reason);\n         });\n  }\n     ```\n  - Promise.catch\n  \n     > Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续 .then\n  \n     ```js\n     Promise.prototype.catch = function (onRejected) {\n         return this.then(null, onRejected);\n  }\n     ```\n  - Promise.finally\n  \n     > 不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.\n  \n     ```js\n     Promise.prototype.finally = function (callback) {\n         return this.then((value) => {\n             return Promise.resolve(callback()).then(() => {\n                 return value;\n             });\n         }, (err) => {\n             return Promise.resolve(callback()).then(() => {\n                 throw err;\n             });\n         });\n  }\n     ```\n  - Promise.all\n  \n     > Promise.all(promises) 返回一个promise对象\n  \n     1. 如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。\n     2. 如果传入的参数不包含任何promise，则返回一个异步完成.\n     3. promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。\n     4. 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败\n     5. 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组\n\n\n```js\n\n Promise.all = function (promises) {\n     return new Promise((resolve, reject) => {\n         let index = 0;\n         let result = [];\n         if (promises.length === 0) {\n             resolve(result);\n         } else {\n             function processValue(i, data) {\n                 result[i] = data;\n                 if (++index === promises.length) {\n                     resolve(result);\n                 }\n             }\n             for (let i = 0; i < promises.length; i++) {\n                   //promises[i] 可能是普通值\n                   Promise.resolve(promises[i]).then((data) => {\n                     processValue(i, data);\n                 }, (err) => {\n                     reject(err);\n                     return;\n                 });\n             }\n         }\n     });\n }\n\n```\n\n- Promise.race\n\n1. Promise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。\n2. 如果传的参数数组是空，则返回的 promise 将永远等待。\n3. 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。\n\n\n\n参考 \n\n https://www.jianshu.com/p/43de678e918a\n\n http://www.ituring.com.cn/article/66566\n\n https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment\n\n9. Symbol\n\n   - 前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境\n\n   - Symbol属于ES6新添加的原始数据类型。已有的原始数据类型（String，Number，bollean,null,undefined,Object）\n\n   - 特点：\n\n     1. Symbol属性对应的值是唯一的，解决命名冲突问题\n     2. Symbol值不能与其他数据进行计算，包括同字符串拼串\n     3. for in，for of遍历时不会遍历symbol属性\n\n   - 使用：\n\n     1. 调用Symbol函数得到Symbol值\n\n        ```js\n        let symbol = Symbol();\n        let obj = {};\n        obj[symbol] = 'hello'\n        ```\n\n     2. 传参标识\n\n        ```js\n        let symbol1 = Symbol('one');\n        let symbol2 = Symbol('two');\n        console.log(symbol1); //Symbol('one')\n        console.log(symbol2); //Symbol('two')\n        ```\n\n     3. 内置Symbol值\n\n        - 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法\n        - Symbol.iterator\n          * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法\n\n10. iterator\n\n    - 概念：iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制\n\n    - 作用：\n\n      1. 为各种数据结构，提供统一的，简便的访问接口\n      2. 使得数据结构的成员能够按某种次序排列\n      3. ES6创造了一种新的遍历方法for  of循环，Iterator接口主要供for of消费\n\n    - 工作原理：\n\n      1. 创建一个指针对象（遍历器对象），指向数据结构的起始位置。\n      2. 第一次调用next方法，指针自动指向数据结构的第一个成员。\n      3. 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员。\n      4. 每次调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值，done：布尔值}\n         - value代表当前成员的值，done对应的布尔值表示当前数据的结构是否遍历结束\n         - 当遍历结束的时候返回的value值是undefined，done的值是false\n\n    - 原生具备Iterator接口的数据（可用for of循环）\n\n      扩展理解：\n\n      1. 当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历\n      2. 当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性\n      3. 具有Iterator接口的原生数据类型：\n         - Array\n         - arguments\n         - set容器\n         - map容器\n         - String\n\n    ```js\n    //模拟指针对象（遍历器对象）\n    function myIterator(arr) {\n        let nextIndex = 0;\n        return {\n            next:function () {\n                return nextIndex < arr.length?{value: arr[nextIndex++], done: false}:{value:undefined,done:true}\n            }\n        }\n    }\n    //三点运算符，解构赋值，默认调用iterator接口\n    ```\n\n11. **Reflect** \n\n    > **Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。\n    >\n    > 与大多数全局对象不同，`Reflect`不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像是Math对象）。\n\n    **reflect存在的意义：**\n\n    1. 将对象(Object)一些内部的方法，放到Reflect对象上。比如：Object.defineProperty。*说明：现阶段这些方法存在以Object和Reflect对象上，未来只存在于Reflect对象上。*\n\n    2. 操作对象时出现报错返回false *说明：比如调用Object.defineProperty(target, name, value)在无法定义属性时，会出现异常，抛出错误，而Reflect.defineProperty(target, name, value)则会返回false。*\n\n       ```js\n       // 通过Object调用\n       try {\n         Object.defineProperty(target, name, attributes)\n       } catch (e) {\n         // 处理异常\n       }\n       \n       // 使用Reflect写法\n       if (Reflect.defineProperty(target, name, attributes)) {\n         // success\n       } else {\n         // failure\n       }\n       ```\n\n    3. 通过调用函数方法，让本来写法变为函数式编程的写法\n\n       ```js\n       // 之前的写法\n       'name' in Object // true\n       \n       // 使用Reflect\n       Reflect.has(Object, 'name') // true\n       ```\n\n    4. 保持和Proxy对象的方法一一对应 *说明：Reflect对象与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。*\n\n       ```js\n       \n       new Proxy(target, {\n         set: function(target, name, value, receiver) {\n           var success = Reflect.set(target, name, value, receiver);\n           if (success) {\n             // \n           }\n           return success;\n         }\n       });\n       ```\n\n       ","slug":"ES6","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr8v00081xopf79aa958","content":"<h3 id=\"ES6新增语法\"><a href=\"#ES6新增语法\" class=\"headerlink\" title=\"ES6新增语法\"></a>ES6新增语法</h3><ol>\n<li><p>新增关键字</p>\n<ul>\n<li><p>let：作用与var类似，用于声明变量。</p>\n<p>特点：</p>\n<ol>\n<li><p>在块级作用域内有效。</p>\n</li>\n<li><p>不能重复声明。</p>\n</li>\n<li><p>不会预处理，不存在变量提升。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> btns <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>btns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">var</span> btn <span class=\"token operator\">=</span> btns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    btn<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//属于回掉函数，在主线程执行结束后，点击触发时，此时i为btns.length-1</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//所有的打印结果都为btns.length-1</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//可以通过立即执行函数来解决（闭包的原理）</span>\n<span class=\"token keyword\">let</span> btns <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>btns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> btn <span class=\"token operator\">=</span> btns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        btn<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//打印出来为数组的下标对应</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//let有自己的块级作用域，可以通过let来控制循环</span>\n<span class=\"token keyword\">let</span> btns <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>btns<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> btn <span class=\"token operator\">=</span> btns<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    btn<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code> &gt; let相比于var：\n &gt;\n &gt; 1. let声明的变量拥有块级作用域，let声明仍然保留了提升的特性，但不会盲目提升。\n &gt; 2. let声明的全局变量不是全局对象上的属性。不可以通过**window.变量名**的方式访问。\n &gt; 3. 形如`for (let x...)`的循环在每次迭代时都为x创建新的绑定。\n &gt; 4. let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发语法错误。\n</code></pre><ul>\n<li><p>const：作用是定义一个常量。</p>\n<p>特点：</p>\n<ol>\n<li>不能修改</li>\n<li>其他的特点同let</li>\n</ol>\n<p>主要应用于保存不变的数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>变量的解构赋值</p>\n<ul>\n<li><p>从对象或数组中提取数据，并赋值给变量（多个）。</p>\n</li>\n<li><p>对象的解构赋值。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>n<span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>n<span class=\"token punctuation\">:</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">:</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'123'</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'456'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>数组的解构赋值。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'aaa'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'bbb'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'aaa'</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'bbb'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>用途：给多个形参赋值。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>username<span class=\"token punctuation\">:</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">:</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>username<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>username<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>模板字符串</p>\n<ul>\n<li><p>简化字符串的拼接</p>\n</li>\n<li><p>模板字符串必须用<code></code>包含</p>\n</li>\n<li><p>变量的部分使用${xxx}定义</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'张三'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> str <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token string\">`http://www.getUser.com?username=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>简化的对象写法</p>\n<ul>\n<li><p>省略同名的属性值</p>\n</li>\n<li><p>省略方法的function</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">,</span>\n    getX <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>箭头函数</p>\n<ul>\n<li><p>作用：定义匿名函数</p>\n</li>\n<li><p>基本语法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//没有参数：</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'xxx'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//一个参数：</span>\ni <span class=\"token operator\">=</span><span class=\"token operator\">></span> i<span class=\"token operator\">+</span><span class=\"token number\">2</span>\n<span class=\"token comment\" spellcheck=\"true\">//多个参数：</span>\n<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span>j<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> i<span class=\"token operator\">+</span>j\n<span class=\"token comment\" spellcheck=\"true\">//函数体不用大括号：默认返回结果</span>\n<span class=\"token comment\" spellcheck=\"true\">//函数体若有多条语句，需要使用{}包裹起来，若需要返回内容，则需要手动return</span>\n<span class=\"token comment\" spellcheck=\"true\">//箭头函数多用来定义回调函数</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>特点：</p>\n<ol>\n<li>简洁。</li>\n<li>箭头函数没有自己的this，箭头函数内部使用的this不是调用的时候决定的，而是在定义的时候。</li>\n<li>如何分辨箭头函数的this：箭头函数的this看外层是否有函数，如果有，外层函数的this就是箭头函数内部的this，如果没有，则this指向window。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>箭头函数与传统函数的区别：</p>\n<ol>\n<li>没有this、super、arguments和new.target绑定，这些值由最近一层非箭头函数决定。</li>\n<li>不能通过new关键字调用，所以不能用作构造函数，否则程序会抛出错误。</li>\n<li>没有原型。由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。</li>\n<li>不可以改变this的绑定，函数内部的this值不可以被改变，在函数的生命周期内始终保持一致。</li>\n<li>不支持arguments对象，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。</li>\n<li>不支持重复的命名参数，无论在严格还是非严格模式下，都不支持，而在传统的函数规定中只有在严格模式下才不能有重复命名参数。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>三点运算符</p>\n<ul>\n<li><p>用途：可变参数用来取代arguments，但比arguments灵活，只能时最后部分形参参数。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>values<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//arguments是伪数组，不具备数组的一般方法，例如forEach方法等。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//arguments.forEach(function(item, index) { //报错</span>\n     <span class=\"token comment\" spellcheck=\"true\">//   console.log(item,index);</span>\n    <span class=\"token comment\" spellcheck=\"true\">//})</span>\n    values<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">fun</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>扩展运算符</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> arr1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> arr2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arr1<span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5,6]</span>\n<span class=\"token comment\" spellcheck=\"true\">//或者</span>\narr2<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>arr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>形参默认值</p>\n<ul>\n<li><p>当不传入参数时，默认使用形式参数的默认值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Point</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n<li><p>Promise对象</p>\n<ul>\n<li><p>作用：代表了未来某个将要发生的事件（通常是一个异步操作）</p>\n</li>\n<li><p>有了Promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（俗称’回调地狱’）</p>\n</li>\n<li><p>ES6的Promise是一个构造函数，用来生成promise实例</p>\n</li>\n<li><p>使用Promise基本步骤：</p>\n<ol>\n<li><p>创建promise对象</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化promise状态为pending</span>\n    <span class=\"token comment\" spellcheck=\"true\">//执行异步操作</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>异步操作成功<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//修改promise的状态为fullfilled</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>errMsg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//修改promise的状态为rejected</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>调用promise的then()</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">//成功时处理  </span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//失败时处理</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>promise对象的三个状态</p>\n<ul>\n<li>pending：初始化状态</li>\n<li>fullfilled：成功状态</li>\n<li>rejected：失败状态</li>\n</ul>\n</li>\n<li><p>应用：</p>\n<ul>\n<li>使用promise实现超时处理</li>\n<li>使用promise封装处理ajax请求</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>promise实现原理</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code> ```js\n // 初始化状态值\n const PENDING = &#39;pending&#39;;\n const FULFILLED = &#39;fulfilled&#39;;\n const REJECTED = &#39;rejected&#39;;\n\n // Promise\n function _Promise(handle) {\n\n     let self = this;\n     self.status = PENDING;\n     self.onFulfilled = []; // 执行成功时的回调\n     self.onRejected = [];  // 执行失败时的回调\n\n     // 定义resolve方法\n     function resolve(value) {\n         if(self.status === PENDING) {\n             self.status = FULFILLED;\n             self.value = value;\n             self.onFulfilled.forEach(fn =&gt; fn());\n         }\n     }\n\n     // 定义reject方法\n     function reject(reason) {\n         if(self.status === PENDING) {\n             self.status = REJECTED;\n             self.reason = reason;\n             self.onRejected.forEach(fn =&gt; fn());\n         }\n     }\n\n     try {\n         handle(resolve,reject);\n     }catch(err) {\n         reject(err);\n     }\n }\n\n // Promise.then\n _Promise.prototype.then = function(onFulfilled, onRejected) {\n\n     // 判断回调函数类型\n     onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : value =&gt; value;\n     onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };\n\n     let self = this; // this代表Promise实例本身\n\n     // 定义需要返回出去的Promise\n     let Promise2 = new _Promise((resolve, reject) =&gt; {\n\n         // 如果状态为成功\n         if(self.status === FULFILLED) {\n\n             // 这里使用setTimeout不是特别清楚，自己认为可能是为了实现同步逻辑\n             setTimeout(() =&gt; {\n                 try {\n                     let x = onFulfilled(self.value);\n                     resolvePromise(Promise2, x, resolve, reject);\n                 }catch(err) {\n                     reject(err);\n                 }\n             })\n         }else if(self.status === REJECTED) { // 如果状态为失败\n             setTimeout(() =&gt; {\n                 try {\n                     let x = onRejected(self.reason);\n                     resolvePromise(Promise2, x, resolve, reject);\n                 }catch(err) {\n                     reject(err);\n                 }\n             })\n         }else if(self.status === PENDING) { // 如果状态为进行中\n\n             // 成功回调队列添加\n             self.onFulfilled.push(() =&gt; {\n                 setTimeout(() =&gt; {\n                     try {\n                         let x = onFulfilled(self.value);\n                         resolvePromise(Promise2, x, resolve, reject);\n                     }catch(err) {\n                         reject(err);\n                     }\n                 })\n             })\n\n             // 失败回调队列添加\n             self.onRejected.push(() =&gt; {\n                 setTimeout(() =&gt; {\n                     try {\n                         let x = onRejected(self.reason);\n                         resolvePromise(Promise2, x, resolve, reject);\n                     }catch(err) {\n                         reject(err);\n                     }\n                 })\n             })\n         }\n     });\n     return Promise2;\n }\n\n function resolvePromise(Promise2, x, resolve, reject) {\n     let self = this;\n\n     // 判断Promise2 与 x是否一致\n     if(Promise2 === x) {\n         reject(new TypeError(&quot;Promise2与x一致，拒绝执行promise&quot;))\n     }\n\n     if(x &amp;&amp; typeof x === &#39;object&#39; || typeof x === &#39;function&#39;) { // 判断x是否为对象或者函数\n         let used;  // 只允许调用一次\n         try {\n             let then = x.then;  // 获取x的then方法\n\n             // 判断then是否是函数，如果是则认为x是一个promise对象，如果不是则x为普通对象\n             if(typeof then === &#39;function&#39;) {\n                 then.call(x, y =&gt; {\n                     // y 代表x的resolve所传入的参数\n\n                     if(used) {\n                         return;\n                     }\n                     used = true;\n                     resolvePromise(Promise2, y, resolve, reject);  //递归调用\n                 }, err =&gt; {\n                     if(used) {\n                         return;\n                     }\n                     used = true;\n                     reject(err);\n                 })\n             }else { // x为普通对象\n                 if(used) {\n                     return;\n                 }\n                 used = true;\n                 resolve(x);\n             }\n         }catch(err) {\n             if(used) {\n                 return;\n             }\n             used = true;\n             reject(err);\n         }\n     }else {\n         resolve(x)\n     }\n\n }\n module.exports = _Promise;\n // 添加测试代码\n\n _Promise.defer = _Promise.deferred = function () {\n     let dfd = {};\n     dfd.promise = new _Promise((resolve, reject) =&gt; {\n         dfd.resolve = resolve;\n         dfd.reject = reject;\n     });\n     return dfd;\n }\n ```\n</code></pre><ul>\n<li><p>Promise其他方法</p>\n<ul>\n<li><p>Promise.resolve</p>\n<blockquote>\n<p> Promise.resolve(value)返回一个以给定值解析后的Promise 对象.</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p>如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态</p>\n<ol start=\"2\">\n<li>如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。</li>\n<li>其他情况，直接返回以该值为成功状态的promise对象。</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Promise<span class=\"token punctuation\">.</span>resolve <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>param <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> param<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>param <span class=\"token operator\">&amp;&amp;</span> param<span class=\"token punctuation\">.</span>then <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> param<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                param<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ul>\n<li><p>Promise.reject</p>\n<blockquote>\n<p>Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> Promise<span class=\"token punctuation\">.</span>reject <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n         <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Promise.catch</p>\n<blockquote>\n<p>Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续 .then</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> Promise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>onRejected<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Promise.finally</p>\n<blockquote>\n<p>不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> Promise<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token keyword\">finally</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>Promise.all</p>\n<blockquote>\n<p>Promise.all(promises) 返回一个promise对象</p>\n</blockquote>\n<ol>\n<li>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。</li>\n<li>如果传入的参数不包含任何promise，则返回一个异步完成.</li>\n<li>promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。</li>\n<li>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</li>\n<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n Promise<span class=\"token punctuation\">.</span>all <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">function</span> <span class=\"token function\">processValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 result<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">;</span>\n                 <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>index <span class=\"token operator\">===</span> promises<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                     <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span>\n             <span class=\"token punctuation\">}</span>\n             <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> promises<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                   <span class=\"token comment\" spellcheck=\"true\">//promises[i] 可能是普通值</span>\n                   Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                     <span class=\"token function\">processValue</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                     <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                     <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span>\n         <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>Promise.race</li>\n</ul>\n<ol>\n<li>Promise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</li>\n<li>如果传的参数数组是空，则返回的 promise 将永远等待。</li>\n<li>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</li>\n</ol>\n<p>参考 </p>\n<p> <a href=\"https://www.jianshu.com/p/43de678e918a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/43de678e918a</a></p>\n<p> <a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/article/66566</a></p>\n<p> <a href=\"https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment</a></p>\n<ol start=\"9\">\n<li><p>Symbol</p>\n<ul>\n<li><p>前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境</p>\n</li>\n<li><p>Symbol属于ES6新添加的原始数据类型。已有的原始数据类型（String，Number，bollean,null,undefined,Object）</p>\n</li>\n<li><p>特点：</p>\n<ol>\n<li>Symbol属性对应的值是唯一的，解决命名冲突问题</li>\n<li>Symbol值不能与其他数据进行计算，包括同字符串拼串</li>\n<li>for in，for of遍历时不会遍历symbol属性</li>\n</ol>\n</li>\n<li><p>使用：</p>\n<ol>\n<li><p>调用Symbol函数得到Symbol值</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> symbol <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nobj<span class=\"token punctuation\">[</span>symbol<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'hello'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>传参标识</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> symbol1 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'one'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> symbol2 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'two'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>symbol1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Symbol('one')</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>symbol2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Symbol('two')</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>内置Symbol值</p>\n<ul>\n<li>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法</li>\n<li>Symbol.iterator<ul>\n<li>对象的Symbol.iterator属性，指向该对象的默认遍历器方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>iterator</p>\n<ul>\n<li><p>概念：iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制</p>\n</li>\n<li><p>作用：</p>\n<ol>\n<li>为各种数据结构，提供统一的，简便的访问接口</li>\n<li>使得数据结构的成员能够按某种次序排列</li>\n<li>ES6创造了一种新的遍历方法for  of循环，Iterator接口主要供for of消费</li>\n</ol>\n</li>\n<li><p>工作原理：</p>\n<ol>\n<li>创建一个指针对象（遍历器对象），指向数据结构的起始位置。</li>\n<li>第一次调用next方法，指针自动指向数据结构的第一个成员。</li>\n<li>接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员。</li>\n<li>每次调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值，done：布尔值}<ul>\n<li>value代表当前成员的值，done对应的布尔值表示当前数据的结构是否遍历结束</li>\n<li>当遍历结束的时候返回的value值是undefined，done的值是false</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>原生具备Iterator接口的数据（可用for of循环）</p>\n<p>扩展理解：</p>\n<ol>\n<li>当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历</li>\n<li>当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性</li>\n<li>具有Iterator接口的原生数据类型：<ul>\n<li>Array</li>\n<li>arguments</li>\n<li>set容器</li>\n<li>map容器</li>\n<li>String</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//模拟指针对象（遍历器对象）</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">myIterator</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> nextIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        next<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> nextIndex <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">?</span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">:</span> arr<span class=\"token punctuation\">[</span>nextIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">:</span>undefined<span class=\"token punctuation\">,</span>done<span class=\"token punctuation\">:</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//三点运算符，解构赋值，默认调用iterator接口</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>Reflect</strong> </p>\n<blockquote>\n<p><strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p>\n<p>与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像是Math对象）。</p>\n</blockquote>\n<p><strong>reflect存在的意义：</strong></p>\n<ol>\n<li><p>将对象(Object)一些内部的方法，放到Reflect对象上。比如：Object.defineProperty。<em>说明：现阶段这些方法存在以Object和Reflect对象上，未来只存在于Reflect对象上。</em></p>\n</li>\n<li><p>操作对象时出现报错返回false <em>说明：比如调用Object.defineProperty(target, name, value)在无法定义属性时，会出现异常，抛出错误，而Reflect.defineProperty(target, name, value)则会返回false。</em></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 通过Object调用</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> attributes<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 处理异常</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用Reflect写法</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> attributes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// success</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// failure</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过调用函数方法，让本来写法变为函数式编程的写法</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 之前的写法</span>\n<span class=\"token string\">'name'</span> <span class=\"token keyword\">in</span> Object <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用Reflect</span>\nReflect<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">,</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>保持和Proxy对象的方法一一对应 <em>说明：Reflect对象与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</em></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> success <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// </span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> success<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ES6新增语法\"><a href=\"#ES6新增语法\" class=\"headerlink\" title=\"ES6新增语法\"></a>ES6新增语法</h3><ol>\n<li><p>新增关键字</p>\n<ul>\n<li><p>let：作用与var类似，用于声明变量。</p>\n<p>特点：</p>\n<ol>\n<li><p>在块级作用域内有效。</p>\n</li>\n<li><p>不能重复声明。</p>\n</li>\n<li><p>不会预处理，不存在变量提升。</p>\n<pre><code class=\"js\">let btns = document.getElementsByTagName(&#39;button&#39;);\nfor(var i = 0; i&lt;btns.length; i++) {\nvar btn = btns[i];\n    btn.onclick = function() { //属于回掉函数，在主线程执行结束后，点击触发时，此时i为btns.length-1\n        console.log(i); //所有的打印结果都为btns.length-1\n    }\n}\n//可以通过立即执行函数来解决（闭包的原理）\nlet btns = document.getElementsByTagName(&#39;button&#39;);\nfor(var i = 0; i&lt;btns.length; i++) {\n    var btn = btns[i];\n    (function (i){\n        btn.onclick = function() {\n            console.log(i); //打印出来为数组的下标对应\n        }\n    })(i)\n}\n//let有自己的块级作用域，可以通过let来控制循环\nlet btns = document.getElementsByTagName(&#39;button&#39;);\nfor(let i = 0; i&lt;btns.length; i++) {\n    var btn = btns[i];\n    btn.onclick = function() {\n        console.log(i);\n    }\n}\n</code></pre>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code> &gt; let相比于var：\n &gt;\n &gt; 1. let声明的变量拥有块级作用域，let声明仍然保留了提升的特性，但不会盲目提升。\n &gt; 2. let声明的全局变量不是全局对象上的属性。不可以通过**window.变量名**的方式访问。\n &gt; 3. 形如`for (let x...)`的循环在每次迭代时都为x创建新的绑定。\n &gt; 4. let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发语法错误。\n</code></pre><ul>\n<li><p>const：作用是定义一个常量。</p>\n<p>特点：</p>\n<ol>\n<li>不能修改</li>\n<li>其他的特点同let</li>\n</ol>\n<p>主要应用于保存不变的数据。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>变量的解构赋值</p>\n<ul>\n<li><p>从对象或数组中提取数据，并赋值给变量（多个）。</p>\n</li>\n<li><p>对象的解构赋值。</p>\n<pre><code class=\"js\">let {n,a} = {n:&#39;123&#39;,a:&#39;456&#39;};\nconsole.log(n); //&#39;123&#39;\nconsole.log(a); //&#39;456&#39;\n</code></pre>\n</li>\n<li><p>数组的解构赋值。</p>\n<pre><code class=\"js\">let [a,b] = [&#39;aaa&#39;,&#39;bbb&#39;];\nconsole.log(a); //&#39;aaa&#39;\nconsole.log(b); //&#39;bbb&#39;\n</code></pre>\n</li>\n<li><p>用途：给多个形参赋值。</p>\n<pre><code class=\"js\">let obj = {username:&#39;zhangsan&#39;,age:20};\nfunction foo({username,age}) {\n    console.log(username,age);\n}\nfoo(obj);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>模板字符串</p>\n<ul>\n<li><p>简化字符串的拼接</p>\n</li>\n<li><p>模板字符串必须用<code></code>包含</p>\n</li>\n<li><p>变量的部分使用${xxx}定义</p>\n<pre><code class=\"js\">let name = &#39;张三&#39;;\nlet str = `http://www.getUser.com?username=${name}`;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>简化的对象写法</p>\n<ul>\n<li><p>省略同名的属性值</p>\n</li>\n<li><p>省略方法的function</p>\n<pre><code class=\"js\">let x = 1;\nlet y = 2;\nlet obj = {\n    x,\n    y,\n    getX () {\n        console.log(this.x)\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>箭头函数</p>\n<ul>\n<li><p>作用：定义匿名函数</p>\n</li>\n<li><p>基本语法：</p>\n<pre><code class=\"js\">//没有参数：\n() =&gt; console.log(&#39;xxx&#39;)\n//一个参数：\ni =&gt; i+2\n//多个参数：\n(i,j) =&gt; i+j\n//函数体不用大括号：默认返回结果\n//函数体若有多条语句，需要使用{}包裹起来，若需要返回内容，则需要手动return\n//箭头函数多用来定义回调函数\n</code></pre>\n</li>\n<li><p>特点：</p>\n<ol>\n<li>简洁。</li>\n<li>箭头函数没有自己的this，箭头函数内部使用的this不是调用的时候决定的，而是在定义的时候。</li>\n<li>如何分辨箭头函数的this：箭头函数的this看外层是否有函数，如果有，外层函数的this就是箭头函数内部的this，如果没有，则this指向window。</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>箭头函数与传统函数的区别：</p>\n<ol>\n<li>没有this、super、arguments和new.target绑定，这些值由最近一层非箭头函数决定。</li>\n<li>不能通过new关键字调用，所以不能用作构造函数，否则程序会抛出错误。</li>\n<li>没有原型。由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。</li>\n<li>不可以改变this的绑定，函数内部的this值不可以被改变，在函数的生命周期内始终保持一致。</li>\n<li>不支持arguments对象，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。</li>\n<li>不支持重复的命名参数，无论在严格还是非严格模式下，都不支持，而在传统的函数规定中只有在严格模式下才不能有重复命名参数。</li>\n</ol>\n</blockquote>\n</li>\n<li><p>三点运算符</p>\n<ul>\n<li><p>用途：可变参数用来取代arguments，但比arguments灵活，只能时最后部分形参参数。</p>\n<pre><code class=\"js\">function fun(a, ...values) {\n    console.log(arguments);\n    //arguments是伪数组，不具备数组的一般方法，例如forEach方法等。\n    //arguments.forEach(function(item, index) { //报错\n     //   console.log(item,index);\n    //})\n    values.forEach((item, index) =&gt; {\n        console.log(item, index);\n    })\n}\nfun(2,3,4,5,6,7);\n</code></pre>\n</li>\n<li><p>扩展运算符</p>\n<pre><code class=\"js\">let arr1 = [1,2,3];\nlet arr2 = [...arr1,4,5,6];\nconsole.log(arr2); //[1,2,3,4,5,6]\n//或者\narr2.push(...arr1);\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>形参默认值</p>\n<ul>\n<li><p>当不传入参数时，默认使用形式参数的默认值</p>\n<pre><code class=\"js\">function Point(x = 1, y = 2) {\n    this.x = x;\n    this.y = y;\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Promise对象</p>\n<ul>\n<li><p>作用：代表了未来某个将要发生的事件（通常是一个异步操作）</p>\n</li>\n<li><p>有了Promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（俗称’回调地狱’）</p>\n</li>\n<li><p>ES6的Promise是一个构造函数，用来生成promise实例</p>\n</li>\n<li><p>使用Promise基本步骤：</p>\n<ol>\n<li><p>创建promise对象</p>\n<pre><code class=\"js\">let promise = new Promise((resolve, reject) =&gt; {\n    //初始化promise状态为pending\n    //执行异步操作\n    if(异步操作成功) {\n        resolve(value); //修改promise的状态为fullfilled\n    }else {\n        reject(errMsg); //修改promise的状态为rejected\n    }\n})\n</code></pre>\n</li>\n<li><p>调用promise的then()</p>\n<pre><code class=\"js\">promise.then((resolve) =&gt; {\n  //成功时处理  \n},(reject) =&gt; {\n    //失败时处理\n})\n</code></pre>\n</li>\n<li><p>promise对象的三个状态</p>\n<ul>\n<li>pending：初始化状态</li>\n<li>fullfilled：成功状态</li>\n<li>rejected：失败状态</li>\n</ul>\n</li>\n<li><p>应用：</p>\n<ul>\n<li>使用promise实现超时处理</li>\n<li>使用promise封装处理ajax请求</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>promise实现原理</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code> ```js\n // 初始化状态值\n const PENDING = &#39;pending&#39;;\n const FULFILLED = &#39;fulfilled&#39;;\n const REJECTED = &#39;rejected&#39;;\n\n // Promise\n function _Promise(handle) {\n\n     let self = this;\n     self.status = PENDING;\n     self.onFulfilled = []; // 执行成功时的回调\n     self.onRejected = [];  // 执行失败时的回调\n\n     // 定义resolve方法\n     function resolve(value) {\n         if(self.status === PENDING) {\n             self.status = FULFILLED;\n             self.value = value;\n             self.onFulfilled.forEach(fn =&gt; fn());\n         }\n     }\n\n     // 定义reject方法\n     function reject(reason) {\n         if(self.status === PENDING) {\n             self.status = REJECTED;\n             self.reason = reason;\n             self.onRejected.forEach(fn =&gt; fn());\n         }\n     }\n\n     try {\n         handle(resolve,reject);\n     }catch(err) {\n         reject(err);\n     }\n }\n\n // Promise.then\n _Promise.prototype.then = function(onFulfilled, onRejected) {\n\n     // 判断回调函数类型\n     onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : value =&gt; value;\n     onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };\n\n     let self = this; // this代表Promise实例本身\n\n     // 定义需要返回出去的Promise\n     let Promise2 = new _Promise((resolve, reject) =&gt; {\n\n         // 如果状态为成功\n         if(self.status === FULFILLED) {\n\n             // 这里使用setTimeout不是特别清楚，自己认为可能是为了实现同步逻辑\n             setTimeout(() =&gt; {\n                 try {\n                     let x = onFulfilled(self.value);\n                     resolvePromise(Promise2, x, resolve, reject);\n                 }catch(err) {\n                     reject(err);\n                 }\n             })\n         }else if(self.status === REJECTED) { // 如果状态为失败\n             setTimeout(() =&gt; {\n                 try {\n                     let x = onRejected(self.reason);\n                     resolvePromise(Promise2, x, resolve, reject);\n                 }catch(err) {\n                     reject(err);\n                 }\n             })\n         }else if(self.status === PENDING) { // 如果状态为进行中\n\n             // 成功回调队列添加\n             self.onFulfilled.push(() =&gt; {\n                 setTimeout(() =&gt; {\n                     try {\n                         let x = onFulfilled(self.value);\n                         resolvePromise(Promise2, x, resolve, reject);\n                     }catch(err) {\n                         reject(err);\n                     }\n                 })\n             })\n\n             // 失败回调队列添加\n             self.onRejected.push(() =&gt; {\n                 setTimeout(() =&gt; {\n                     try {\n                         let x = onRejected(self.reason);\n                         resolvePromise(Promise2, x, resolve, reject);\n                     }catch(err) {\n                         reject(err);\n                     }\n                 })\n             })\n         }\n     });\n     return Promise2;\n }\n\n function resolvePromise(Promise2, x, resolve, reject) {\n     let self = this;\n\n     // 判断Promise2 与 x是否一致\n     if(Promise2 === x) {\n         reject(new TypeError(&quot;Promise2与x一致，拒绝执行promise&quot;))\n     }\n\n     if(x &amp;&amp; typeof x === &#39;object&#39; || typeof x === &#39;function&#39;) { // 判断x是否为对象或者函数\n         let used;  // 只允许调用一次\n         try {\n             let then = x.then;  // 获取x的then方法\n\n             // 判断then是否是函数，如果是则认为x是一个promise对象，如果不是则x为普通对象\n             if(typeof then === &#39;function&#39;) {\n                 then.call(x, y =&gt; {\n                     // y 代表x的resolve所传入的参数\n\n                     if(used) {\n                         return;\n                     }\n                     used = true;\n                     resolvePromise(Promise2, y, resolve, reject);  //递归调用\n                 }, err =&gt; {\n                     if(used) {\n                         return;\n                     }\n                     used = true;\n                     reject(err);\n                 })\n             }else { // x为普通对象\n                 if(used) {\n                     return;\n                 }\n                 used = true;\n                 resolve(x);\n             }\n         }catch(err) {\n             if(used) {\n                 return;\n             }\n             used = true;\n             reject(err);\n         }\n     }else {\n         resolve(x)\n     }\n\n }\n module.exports = _Promise;\n // 添加测试代码\n\n _Promise.defer = _Promise.deferred = function () {\n     let dfd = {};\n     dfd.promise = new _Promise((resolve, reject) =&gt; {\n         dfd.resolve = resolve;\n         dfd.reject = reject;\n     });\n     return dfd;\n }\n ```\n</code></pre><ul>\n<li><p>Promise其他方法</p>\n<ul>\n<li><p>Promise.resolve</p>\n<blockquote>\n<p> Promise.resolve(value)返回一个以给定值解析后的Promise 对象.</p>\n</blockquote>\n</li>\n</ul>\n<ol>\n<li><p>如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态</p>\n<ol start=\"2\">\n<li>如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。</li>\n<li>其他情况，直接返回以该值为成功状态的promise对象。</li>\n</ol>\n<pre><code class=\"js\">Promise.resolve = function (param) {\n        if (param instanceof Promise) {\n        return param;\n    }\n    return new Promise((resolve, reject) =&gt; {\n        if (param &amp;&amp; param.then &amp;&amp; typeof param.then === &#39;function&#39;) {\n            setTimeout(() =&gt; {\n                param.then(resolve, reject);\n            });\n        } else {\n            resolve(param);\n        }\n    });\n}\n\n</code></pre>\n</li>\n</ol>\n<ul>\n<li><p>Promise.reject</p>\n<blockquote>\n<p>Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</p>\n</blockquote>\n<pre><code class=\"js\"> Promise.reject = function (reason) {\n     return new Promise((resolve, reject) =&gt; {\n         reject(reason);\n     });\n}\n</code></pre>\n</li>\n<li><p>Promise.catch</p>\n<blockquote>\n<p>Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续 .then</p>\n</blockquote>\n<pre><code class=\"js\"> Promise.prototype.catch = function (onRejected) {\n     return this.then(null, onRejected);\n}\n</code></pre>\n</li>\n<li><p>Promise.finally</p>\n<blockquote>\n<p>不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.</p>\n</blockquote>\n<pre><code class=\"js\"> Promise.prototype.finally = function (callback) {\n     return this.then((value) =&gt; {\n         return Promise.resolve(callback()).then(() =&gt; {\n             return value;\n         });\n     }, (err) =&gt; {\n         return Promise.resolve(callback()).then(() =&gt; {\n             throw err;\n         });\n     });\n}\n</code></pre>\n</li>\n<li><p>Promise.all</p>\n<blockquote>\n<p>Promise.all(promises) 返回一个promise对象</p>\n</blockquote>\n<ol>\n<li>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。</li>\n<li>如果传入的参数不包含任何promise，则返回一个异步完成.</li>\n<li>promises 中所有的promise都promise都“完成”时或参数中不包含 promise 时回调完成。</li>\n<li>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</li>\n<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"js\">\n Promise.all = function (promises) {\n     return new Promise((resolve, reject) =&gt; {\n         let index = 0;\n         let result = [];\n         if (promises.length === 0) {\n             resolve(result);\n         } else {\n             function processValue(i, data) {\n                 result[i] = data;\n                 if (++index === promises.length) {\n                     resolve(result);\n                 }\n             }\n             for (let i = 0; i &lt; promises.length; i++) {\n                   //promises[i] 可能是普通值\n                   Promise.resolve(promises[i]).then((data) =&gt; {\n                     processValue(i, data);\n                 }, (err) =&gt; {\n                     reject(err);\n                     return;\n                 });\n             }\n         }\n     });\n }\n\n</code></pre>\n<ul>\n<li>Promise.race</li>\n</ul>\n<ol>\n<li>Promise.race函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。</li>\n<li>如果传的参数数组是空，则返回的 promise 将永远等待。</li>\n<li>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</li>\n</ol>\n<p>参考 </p>\n<p> <a href=\"https://www.jianshu.com/p/43de678e918a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/43de678e918a</a></p>\n<p> <a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">http://www.ituring.com.cn/article/66566</a></p>\n<p> <a href=\"https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c88e427f265da2d8d6a1c84#comment</a></p>\n<ol start=\"9\">\n<li><p>Symbol</p>\n<ul>\n<li><p>前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境</p>\n</li>\n<li><p>Symbol属于ES6新添加的原始数据类型。已有的原始数据类型（String，Number，bollean,null,undefined,Object）</p>\n</li>\n<li><p>特点：</p>\n<ol>\n<li>Symbol属性对应的值是唯一的，解决命名冲突问题</li>\n<li>Symbol值不能与其他数据进行计算，包括同字符串拼串</li>\n<li>for in，for of遍历时不会遍历symbol属性</li>\n</ol>\n</li>\n<li><p>使用：</p>\n<ol>\n<li><p>调用Symbol函数得到Symbol值</p>\n<pre><code class=\"js\">let symbol = Symbol();\nlet obj = {};\nobj[symbol] = &#39;hello&#39;\n</code></pre>\n</li>\n<li><p>传参标识</p>\n<pre><code class=\"js\">let symbol1 = Symbol(&#39;one&#39;);\nlet symbol2 = Symbol(&#39;two&#39;);\nconsole.log(symbol1); //Symbol(&#39;one&#39;)\nconsole.log(symbol2); //Symbol(&#39;two&#39;)\n</code></pre>\n</li>\n<li><p>内置Symbol值</p>\n<ul>\n<li>除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法</li>\n<li>Symbol.iterator<ul>\n<li>对象的Symbol.iterator属性，指向该对象的默认遍历器方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>iterator</p>\n<ul>\n<li><p>概念：iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制</p>\n</li>\n<li><p>作用：</p>\n<ol>\n<li>为各种数据结构，提供统一的，简便的访问接口</li>\n<li>使得数据结构的成员能够按某种次序排列</li>\n<li>ES6创造了一种新的遍历方法for  of循环，Iterator接口主要供for of消费</li>\n</ol>\n</li>\n<li><p>工作原理：</p>\n<ol>\n<li>创建一个指针对象（遍历器对象），指向数据结构的起始位置。</li>\n<li>第一次调用next方法，指针自动指向数据结构的第一个成员。</li>\n<li>接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员。</li>\n<li>每次调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值，done：布尔值}<ul>\n<li>value代表当前成员的值，done对应的布尔值表示当前数据的结构是否遍历结束</li>\n<li>当遍历结束的时候返回的value值是undefined，done的值是false</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>原生具备Iterator接口的数据（可用for of循环）</p>\n<p>扩展理解：</p>\n<ol>\n<li>当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历</li>\n<li>当使用for of去遍历目标数据的时候，该数据会自动去找Symbol.iterator属性</li>\n<li>具有Iterator接口的原生数据类型：<ul>\n<li>Array</li>\n<li>arguments</li>\n<li>set容器</li>\n<li>map容器</li>\n<li>String</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">//模拟指针对象（遍历器对象）\nfunction myIterator(arr) {\n    let nextIndex = 0;\n    return {\n        next:function () {\n            return nextIndex &lt; arr.length?{value: arr[nextIndex++], done: false}:{value:undefined,done:true}\n        }\n    }\n}\n//三点运算符，解构赋值，默认调用iterator接口\n</code></pre>\n</li>\n<li><p><strong>Reflect</strong> </p>\n<blockquote>\n<p><strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p>\n<p>与大多数全局对象不同，<code>Reflect</code>不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像是Math对象）。</p>\n</blockquote>\n<p><strong>reflect存在的意义：</strong></p>\n<ol>\n<li><p>将对象(Object)一些内部的方法，放到Reflect对象上。比如：Object.defineProperty。<em>说明：现阶段这些方法存在以Object和Reflect对象上，未来只存在于Reflect对象上。</em></p>\n</li>\n<li><p>操作对象时出现报错返回false <em>说明：比如调用Object.defineProperty(target, name, value)在无法定义属性时，会出现异常，抛出错误，而Reflect.defineProperty(target, name, value)则会返回false。</em></p>\n<pre><code class=\"js\">// 通过Object调用\ntry {\n  Object.defineProperty(target, name, attributes)\n} catch (e) {\n  // 处理异常\n}\n\n// 使用Reflect写法\nif (Reflect.defineProperty(target, name, attributes)) {\n  // success\n} else {\n  // failure\n}\n</code></pre>\n</li>\n<li><p>通过调用函数方法，让本来写法变为函数式编程的写法</p>\n<pre><code class=\"js\">// 之前的写法\n&#39;name&#39; in Object // true\n\n// 使用Reflect\nReflect.has(Object, &#39;name&#39;) // true\n</code></pre>\n</li>\n<li><p>保持和Proxy对象的方法一一对应 <em>说明：Reflect对象与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</em></p>\n<pre><code class=\"js\">\nnew Proxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      // \n    }\n    return success;\n  }\n});\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"ES7","date":"2019-05-01T04:57:19.000Z","_content":"\n### ES7新增语法","source":"_posts/ES7.md","raw":"---\ntitle: ES7\ndate: 2019-05-01 12:57:19\ntags: js\ncategories: 前端\n---\n\n### ES7新增语法","slug":"ES7","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr92000c1xop83no97cs","content":"<h3 id=\"ES7新增语法\"><a href=\"#ES7新增语法\" class=\"headerlink\" title=\"ES7新增语法\"></a>ES7新增语法</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"ES7新增语法\"><a href=\"#ES7新增语法\" class=\"headerlink\" title=\"ES7新增语法\"></a>ES7新增语法</h3>"},{"title":"HTML5","date":"2018-10-11T06:01:39.000Z","_content":"\n### HTML5\n\n**使用HTML5新增的标签，可以让HTML代码结构看起来更加清晰明了，维护起来更加方便，阅读性更高。**\n\n##### 标签：\n\n```html\n<header>\n\theader元素表示页面中的一个内容区块或者整个页面的标题\n</header>\n<nav>\n\tnav标签表示页面中导航的部分\n</nav>\n<article>\n\tarticle标签表示页面中的一块与上下文不相关的独立内容，比如一篇文章\n</article>\n<section>\n\tsection标签表示页面中一块内容区域，比如章节的页眉、页脚\n</section>\n<aside>\n\taside标签表示article元素的内容之外的，和内容相关的辅助信息\n</aside>\n<footer>\n\tfooter标签表示页面或者页面中的一块区域的页脚，比如存放文件的创建时间、作者、联系方式等\n</footer>\n```\n\n##### 废除的标签：\n\n1. 能使用css代替的元素：basefont、big、center、font、s、strike、tt、u\n2. 不在使用frame框架\n3. 只有部分浏览器支持的元素：applet、bgsound、blink、marquee\n4. 其他被废除的元素：rb使用ruby代替，acronym使用abbr代替\n\n- DOCTYPE声明     在html5中，刻意不使用版本声明，一份文档将会适用于所有版本的Html(不区分大小写，引号不区分单引号或双引号)\n\n  ```html\n  <DOCTYPE html>\n  ```\n\n- 指定字符编码\n\n  ```html\n  <meta charset=\"UTF-8\">\n  ```\n\n- 可以省略标记的元素\n\n  1. 不允许写结束 标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。\n\n  2. 可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。\n\n  3. 可以省略全部标记的元素有：html、head、body、colgroup、tbody。\n\n     >\"不允许写结束标记的元素\"是指，不允许使用开始标记与结束标记将元素括起来的形式，只允许使用\"<元素/>\"的形式进行书写。例如\"\\<br>…\\<br/>\"的书写方式是错误的，正确的书写方式为\"\\<br/>\"。当然也可以“\\<br>”。\n     >\n     >\"可以省略全部标记的元素\"是指，该元素可以完全被省略。即使标记被省略，该元素还是以隐式的方式存在的。例如将body元素省略，但它在文档结构中依然存在，也可以通过js的dom获取到。\n\n- 具有boolean指的属性\n\n  ```html\n  <!--只写属性不写属性值代表属性为true -->\n  <input type=\"checkbox\" checked>\n  <!--不写属性代表属性为false -->\n  <input type=\"checkbox\">\n  <!--属性值等于属性名时，代表属性为true -->\n  <input type=\"checkbox\" checked=\"checked\">\n  <!--属性值为空字符串时，代表属性为true -->\n  <input type=\"checkbox\" checked=\"\">\n  ```\n\n- 新增的结构元素\n\n  1. section：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。可以结合h1-h6来使用。\n\n  2. article：表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。\n\n  3. aside：表示article元素内容之外的、与article元素的内容相关的辅助信息。\n\n  4. header：表示页面中一个内容区块或整个页面的标题。\n\n  5. hgroup：表示用于对整个页面或页面中一个内容区块的标题进行组合。\n\n  6. footer：表示整个页面或者页面中一个内容区块的脚注。\n\n  7. nav：表示页面中导航链接的部分。\n\n  8. figure：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。\n\n     ```html\n     <figure>\n         <p>\n             The People's Republic of China was born in 1949...\n         </p>\n     </figure>\n     ```\n\n  **article元素与section区别：**\n\n  >article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。section元素强调分段或分块，而article强调独立性。如果一块内容相对来说比较独立、完整的时候，应该使用article元素，但如果想将一块内容分成几段时，应该使用section元素。\n\n- 新增其他元素\n\n  1. video：用于定义视频。\n\n     ```html\n     <video src=\"movie.mp4\" controls>video元素</video>\n     ```\n\n  2. audio：用于定义音频。\n\n     ```html\n     <audio src=\"someaudio.wav\">audio元素</audio>\n     ```\n\n  3. embed：用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。\n\n     ```html\n     <embed src=\"horse.wav\">\n     ```\n\n  4. mark：用来在视觉上向用户呈现那些需要突出显示或高亮显示的文字。\n\n     ```html\n     <mark></mark>\n     ```\n\n  5. progress：表示运行中的进程。\n\n  6. time：表示日期或时间。\n\n  7. canvas：表示图形。这个元素本身没有行为，仅提供一块画布，提供绘图API给客户端JavaScript。\n\n  8. menu：表示菜单列表。\n\n- 新增表单相关属性\n\n  1. 可以对input（type=text）、select、textarea与button元素指定autofocus属性。以指定属性的方式让元素在画面打开时自动获取焦点。\n  2. 可以对Input元素与textarea元素指定placeholder属性，可以用来提示用户输入内容。\n  3. 可以对input元素（type=text）与textarea元素指定required属性。该属性表示在用户提交的时候进行检查，检查该元素内一定要有输入内容。\n  4. 为input元素添加可几个新的属性：autocomplete、min、max、multiple、pattern与step。\n\n- 其他属性\n\n  1. 为ol元素增加属性reversed,它指定列表倒序显示。\n  2. 为menu元素增加两个新属性—— type与label。label属性为菜单定义一个可见的标注，type属性让菜单可以以上下文菜单、工具条与列表菜单的三种形式表现。\n  3. 为style元素增加scoped属性，用来规定样式的作用范围。\n  4. 为script元素增加async属性，定义脚本是否异步执行。\n\n- 全局属性\n\n  1. contentEditable属性：允许用户编辑元素中的内容。该属性是一个布尔值，可以指定true或false。通过inherit(继承)状态，来指定子元素是否允许编辑。\n  2. designMode属性：用来指定整个页面是否可编辑。只能在JavaScript脚本里被编辑修改。on代表可编辑，off不可编辑。\n  3. hidden属性：在html5中，所有元素都允许使用一个hidden属性，通知浏览器不渲染该元素，使该元素处于不可见状态。\n  4. spellcheck：html5针对input元素(type=text)与textarea这两个文本输入元素提供的属性，功能是对用户输入的文本内容进行拼写和语法检查。它在书写时有一个特殊的地方，就是必须明确声明属性值为true或false。","source":"_posts/HTML5.md","raw":"---\ntitle: HTML5\ndate: 2018-10-11 14:01:39\ntags: HTML\ncategories: 前端\n---\n\n### HTML5\n\n**使用HTML5新增的标签，可以让HTML代码结构看起来更加清晰明了，维护起来更加方便，阅读性更高。**\n\n##### 标签：\n\n```html\n<header>\n\theader元素表示页面中的一个内容区块或者整个页面的标题\n</header>\n<nav>\n\tnav标签表示页面中导航的部分\n</nav>\n<article>\n\tarticle标签表示页面中的一块与上下文不相关的独立内容，比如一篇文章\n</article>\n<section>\n\tsection标签表示页面中一块内容区域，比如章节的页眉、页脚\n</section>\n<aside>\n\taside标签表示article元素的内容之外的，和内容相关的辅助信息\n</aside>\n<footer>\n\tfooter标签表示页面或者页面中的一块区域的页脚，比如存放文件的创建时间、作者、联系方式等\n</footer>\n```\n\n##### 废除的标签：\n\n1. 能使用css代替的元素：basefont、big、center、font、s、strike、tt、u\n2. 不在使用frame框架\n3. 只有部分浏览器支持的元素：applet、bgsound、blink、marquee\n4. 其他被废除的元素：rb使用ruby代替，acronym使用abbr代替\n\n- DOCTYPE声明     在html5中，刻意不使用版本声明，一份文档将会适用于所有版本的Html(不区分大小写，引号不区分单引号或双引号)\n\n  ```html\n  <DOCTYPE html>\n  ```\n\n- 指定字符编码\n\n  ```html\n  <meta charset=\"UTF-8\">\n  ```\n\n- 可以省略标记的元素\n\n  1. 不允许写结束 标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。\n\n  2. 可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。\n\n  3. 可以省略全部标记的元素有：html、head、body、colgroup、tbody。\n\n     >\"不允许写结束标记的元素\"是指，不允许使用开始标记与结束标记将元素括起来的形式，只允许使用\"<元素/>\"的形式进行书写。例如\"\\<br>…\\<br/>\"的书写方式是错误的，正确的书写方式为\"\\<br/>\"。当然也可以“\\<br>”。\n     >\n     >\"可以省略全部标记的元素\"是指，该元素可以完全被省略。即使标记被省略，该元素还是以隐式的方式存在的。例如将body元素省略，但它在文档结构中依然存在，也可以通过js的dom获取到。\n\n- 具有boolean指的属性\n\n  ```html\n  <!--只写属性不写属性值代表属性为true -->\n  <input type=\"checkbox\" checked>\n  <!--不写属性代表属性为false -->\n  <input type=\"checkbox\">\n  <!--属性值等于属性名时，代表属性为true -->\n  <input type=\"checkbox\" checked=\"checked\">\n  <!--属性值为空字符串时，代表属性为true -->\n  <input type=\"checkbox\" checked=\"\">\n  ```\n\n- 新增的结构元素\n\n  1. section：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。可以结合h1-h6来使用。\n\n  2. article：表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。\n\n  3. aside：表示article元素内容之外的、与article元素的内容相关的辅助信息。\n\n  4. header：表示页面中一个内容区块或整个页面的标题。\n\n  5. hgroup：表示用于对整个页面或页面中一个内容区块的标题进行组合。\n\n  6. footer：表示整个页面或者页面中一个内容区块的脚注。\n\n  7. nav：表示页面中导航链接的部分。\n\n  8. figure：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。\n\n     ```html\n     <figure>\n         <p>\n             The People's Republic of China was born in 1949...\n         </p>\n     </figure>\n     ```\n\n  **article元素与section区别：**\n\n  >article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。section元素强调分段或分块，而article强调独立性。如果一块内容相对来说比较独立、完整的时候，应该使用article元素，但如果想将一块内容分成几段时，应该使用section元素。\n\n- 新增其他元素\n\n  1. video：用于定义视频。\n\n     ```html\n     <video src=\"movie.mp4\" controls>video元素</video>\n     ```\n\n  2. audio：用于定义音频。\n\n     ```html\n     <audio src=\"someaudio.wav\">audio元素</audio>\n     ```\n\n  3. embed：用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。\n\n     ```html\n     <embed src=\"horse.wav\">\n     ```\n\n  4. mark：用来在视觉上向用户呈现那些需要突出显示或高亮显示的文字。\n\n     ```html\n     <mark></mark>\n     ```\n\n  5. progress：表示运行中的进程。\n\n  6. time：表示日期或时间。\n\n  7. canvas：表示图形。这个元素本身没有行为，仅提供一块画布，提供绘图API给客户端JavaScript。\n\n  8. menu：表示菜单列表。\n\n- 新增表单相关属性\n\n  1. 可以对input（type=text）、select、textarea与button元素指定autofocus属性。以指定属性的方式让元素在画面打开时自动获取焦点。\n  2. 可以对Input元素与textarea元素指定placeholder属性，可以用来提示用户输入内容。\n  3. 可以对input元素（type=text）与textarea元素指定required属性。该属性表示在用户提交的时候进行检查，检查该元素内一定要有输入内容。\n  4. 为input元素添加可几个新的属性：autocomplete、min、max、multiple、pattern与step。\n\n- 其他属性\n\n  1. 为ol元素增加属性reversed,它指定列表倒序显示。\n  2. 为menu元素增加两个新属性—— type与label。label属性为菜单定义一个可见的标注，type属性让菜单可以以上下文菜单、工具条与列表菜单的三种形式表现。\n  3. 为style元素增加scoped属性，用来规定样式的作用范围。\n  4. 为script元素增加async属性，定义脚本是否异步执行。\n\n- 全局属性\n\n  1. contentEditable属性：允许用户编辑元素中的内容。该属性是一个布尔值，可以指定true或false。通过inherit(继承)状态，来指定子元素是否允许编辑。\n  2. designMode属性：用来指定整个页面是否可编辑。只能在JavaScript脚本里被编辑修改。on代表可编辑，off不可编辑。\n  3. hidden属性：在html5中，所有元素都允许使用一个hidden属性，通知浏览器不渲染该元素，使该元素处于不可见状态。\n  4. spellcheck：html5针对input元素(type=text)与textarea这两个文本输入元素提供的属性，功能是对用户输入的文本内容进行拼写和语法检查。它在书写时有一个特殊的地方，就是必须明确声明属性值为true或false。","slug":"HTML5","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr94000d1xop74wsdp2w","content":"<h3 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h3><p><strong>使用HTML5新增的标签，可以让HTML代码结构看起来更加清晰明了，维护起来更加方便，阅读性更高。</strong></p>\n<h5 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h5><pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>header</span><span class=\"token punctuation\">></span></span>\n    header元素表示页面中的一个内容区块或者整个页面的标题\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>header</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>nav</span><span class=\"token punctuation\">></span></span>\n    nav标签表示页面中导航的部分\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>nav</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>article</span><span class=\"token punctuation\">></span></span>\n    article标签表示页面中的一块与上下文不相关的独立内容，比如一篇文章\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>article</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span>\n    section标签表示页面中一块内容区域，比如章节的页眉、页脚\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>aside</span><span class=\"token punctuation\">></span></span>\n    aside标签表示article元素的内容之外的，和内容相关的辅助信息\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>aside</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>footer</span><span class=\"token punctuation\">></span></span>\n    footer标签表示页面或者页面中的一块区域的页脚，比如存放文件的创建时间、作者、联系方式等\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>footer</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"废除的标签：\"><a href=\"#废除的标签：\" class=\"headerlink\" title=\"废除的标签：\"></a>废除的标签：</h5><ol>\n<li>能使用css代替的元素：basefont、big、center、font、s、strike、tt、u</li>\n<li>不在使用frame框架</li>\n<li>只有部分浏览器支持的元素：applet、bgsound、blink、marquee</li>\n<li>其他被废除的元素：rb使用ruby代替，acronym使用abbr代替</li>\n</ol>\n<ul>\n<li><p>DOCTYPE声明     在html5中，刻意不使用版本声明，一份文档将会适用于所有版本的Html(不区分大小写，引号不区分单引号或双引号)</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>DOCTYPE</span> <span class=\"token attr-name\">html</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>指定字符编码</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>UTF-8<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>可以省略标记的元素</p>\n<ol>\n<li><p>不允许写结束 标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。</p>\n</li>\n<li><p>可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。</p>\n</li>\n<li><p>可以省略全部标记的元素有：html、head、body、colgroup、tbody。</p>\n<blockquote>\n<p>“不允许写结束标记的元素”是指，不允许使用开始标记与结束标记将元素括起来的形式，只允许使用”&lt;元素/&gt;”的形式进行书写。例如”\\<br>…\\<br>“的书写方式是错误的，正确的书写方式为”\\<br>“。当然也可以“\\<br>”。</p>\n<p>“可以省略全部标记的元素”是指，该元素可以完全被省略。即使标记被省略，该元素还是以隐式的方式存在的。例如将body元素省略，但它在文档结构中依然存在，也可以通过js的dom获取到。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>具有boolean指的属性</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!--只写属性不写属性值代表属性为true --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>checkbox<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">checked</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!--不写属性代表属性为false --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>checkbox<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!--属性值等于属性名时，代表属性为true --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>checkbox<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">checked</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>checked<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!--属性值为空字符串时，代表属性为true --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>checkbox<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">checked</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span><span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>新增的结构元素</p>\n<ol>\n<li><p>section：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。可以结合h1-h6来使用。</p>\n</li>\n<li><p>article：表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。</p>\n</li>\n<li><p>aside：表示article元素内容之外的、与article元素的内容相关的辅助信息。</p>\n</li>\n<li><p>header：表示页面中一个内容区块或整个页面的标题。</p>\n</li>\n<li><p>hgroup：表示用于对整个页面或页面中一个内容区块的标题进行组合。</p>\n</li>\n<li><p>footer：表示整个页面或者页面中一个内容区块的脚注。</p>\n</li>\n<li><p>nav：表示页面中导航链接的部分。</p>\n</li>\n<li><p>figure：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>figure</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n        The People's Republic of China was born in 1949...\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>figure</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p><strong>article元素与section区别：</strong></p>\n<blockquote>\n<p>article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。section元素强调分段或分块，而article强调独立性。如果一块内容相对来说比较独立、完整的时候，应该使用article元素，但如果想将一块内容分成几段时，应该使用section元素。</p>\n</blockquote>\n</li>\n<li><p>新增其他元素</p>\n<ol>\n<li><p>video：用于定义视频。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>video</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>movie.mp4<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">controls</span><span class=\"token punctuation\">></span></span>video元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>video</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>audio：用于定义音频。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>audio</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>someaudio.wav<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>audio元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>audio</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>embed：用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>embed</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>horse.wav<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>mark：用来在视觉上向用户呈现那些需要突出显示或高亮显示的文字。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>mark</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>mark</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>progress：表示运行中的进程。</p>\n</li>\n<li><p>time：表示日期或时间。</p>\n</li>\n<li><p>canvas：表示图形。这个元素本身没有行为，仅提供一块画布，提供绘图API给客户端JavaScript。</p>\n</li>\n<li><p>menu：表示菜单列表。</p>\n</li>\n</ol>\n</li>\n<li><p>新增表单相关属性</p>\n<ol>\n<li>可以对input（type=text）、select、textarea与button元素指定autofocus属性。以指定属性的方式让元素在画面打开时自动获取焦点。</li>\n<li>可以对Input元素与textarea元素指定placeholder属性，可以用来提示用户输入内容。</li>\n<li>可以对input元素（type=text）与textarea元素指定required属性。该属性表示在用户提交的时候进行检查，检查该元素内一定要有输入内容。</li>\n<li>为input元素添加可几个新的属性：autocomplete、min、max、multiple、pattern与step。</li>\n</ol>\n</li>\n<li><p>其他属性</p>\n<ol>\n<li>为ol元素增加属性reversed,它指定列表倒序显示。</li>\n<li>为menu元素增加两个新属性—— type与label。label属性为菜单定义一个可见的标注，type属性让菜单可以以上下文菜单、工具条与列表菜单的三种形式表现。</li>\n<li>为style元素增加scoped属性，用来规定样式的作用范围。</li>\n<li>为script元素增加async属性，定义脚本是否异步执行。</li>\n</ol>\n</li>\n<li><p>全局属性</p>\n<ol>\n<li>contentEditable属性：允许用户编辑元素中的内容。该属性是一个布尔值，可以指定true或false。通过inherit(继承)状态，来指定子元素是否允许编辑。</li>\n<li>designMode属性：用来指定整个页面是否可编辑。只能在JavaScript脚本里被编辑修改。on代表可编辑，off不可编辑。</li>\n<li>hidden属性：在html5中，所有元素都允许使用一个hidden属性，通知浏览器不渲染该元素，使该元素处于不可见状态。</li>\n<li>spellcheck：html5针对input元素(type=text)与textarea这两个文本输入元素提供的属性，功能是对用户输入的文本内容进行拼写和语法检查。它在书写时有一个特殊的地方，就是必须明确声明属性值为true或false。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a>HTML5</h3><p><strong>使用HTML5新增的标签，可以让HTML代码结构看起来更加清晰明了，维护起来更加方便，阅读性更高。</strong></p>\n<h5 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h5><pre><code class=\"html\">&lt;header&gt;\n    header元素表示页面中的一个内容区块或者整个页面的标题\n&lt;/header&gt;\n&lt;nav&gt;\n    nav标签表示页面中导航的部分\n&lt;/nav&gt;\n&lt;article&gt;\n    article标签表示页面中的一块与上下文不相关的独立内容，比如一篇文章\n&lt;/article&gt;\n&lt;section&gt;\n    section标签表示页面中一块内容区域，比如章节的页眉、页脚\n&lt;/section&gt;\n&lt;aside&gt;\n    aside标签表示article元素的内容之外的，和内容相关的辅助信息\n&lt;/aside&gt;\n&lt;footer&gt;\n    footer标签表示页面或者页面中的一块区域的页脚，比如存放文件的创建时间、作者、联系方式等\n&lt;/footer&gt;\n</code></pre>\n<h5 id=\"废除的标签：\"><a href=\"#废除的标签：\" class=\"headerlink\" title=\"废除的标签：\"></a>废除的标签：</h5><ol>\n<li>能使用css代替的元素：basefont、big、center、font、s、strike、tt、u</li>\n<li>不在使用frame框架</li>\n<li>只有部分浏览器支持的元素：applet、bgsound、blink、marquee</li>\n<li>其他被废除的元素：rb使用ruby代替，acronym使用abbr代替</li>\n</ol>\n<ul>\n<li><p>DOCTYPE声明     在html5中，刻意不使用版本声明，一份文档将会适用于所有版本的Html(不区分大小写，引号不区分单引号或双引号)</p>\n<pre><code class=\"html\">&lt;DOCTYPE html&gt;\n</code></pre>\n</li>\n<li><p>指定字符编码</p>\n<pre><code class=\"html\">&lt;meta charset=&quot;UTF-8&quot;&gt;\n</code></pre>\n</li>\n<li><p>可以省略标记的元素</p>\n<ol>\n<li><p>不允许写结束 标记的元素有：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。</p>\n</li>\n<li><p>可以省略结束标记的元素有：li、dt、dd、p、rt、rp、optgroup、option、colgroup、thead、tbody、tfoot、tr、td、th。</p>\n</li>\n<li><p>可以省略全部标记的元素有：html、head、body、colgroup、tbody。</p>\n<blockquote>\n<p>“不允许写结束标记的元素”是指，不允许使用开始标记与结束标记将元素括起来的形式，只允许使用”&lt;元素/&gt;”的形式进行书写。例如”\\<br>…\\<br>“的书写方式是错误的，正确的书写方式为”\\<br>“。当然也可以“\\<br>”。</p>\n<p>“可以省略全部标记的元素”是指，该元素可以完全被省略。即使标记被省略，该元素还是以隐式的方式存在的。例如将body元素省略，但它在文档结构中依然存在，也可以通过js的dom获取到。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>具有boolean指的属性</p>\n<pre><code class=\"html\">&lt;!--只写属性不写属性值代表属性为true --&gt;\n&lt;input type=&quot;checkbox&quot; checked&gt;\n&lt;!--不写属性代表属性为false --&gt;\n&lt;input type=&quot;checkbox&quot;&gt;\n&lt;!--属性值等于属性名时，代表属性为true --&gt;\n&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;\n&lt;!--属性值为空字符串时，代表属性为true --&gt;\n&lt;input type=&quot;checkbox&quot; checked=&quot;&quot;&gt;\n</code></pre>\n</li>\n<li><p>新增的结构元素</p>\n<ol>\n<li><p>section：表示页面中的一个内容区块，比如章节、页眉、页脚或页面中的其他部分。可以结合h1-h6来使用。</p>\n</li>\n<li><p>article：表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章或报纸中的一篇文章。</p>\n</li>\n<li><p>aside：表示article元素内容之外的、与article元素的内容相关的辅助信息。</p>\n</li>\n<li><p>header：表示页面中一个内容区块或整个页面的标题。</p>\n</li>\n<li><p>hgroup：表示用于对整个页面或页面中一个内容区块的标题进行组合。</p>\n</li>\n<li><p>footer：表示整个页面或者页面中一个内容区块的脚注。</p>\n</li>\n<li><p>nav：表示页面中导航链接的部分。</p>\n</li>\n<li><p>figure：表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。</p>\n<pre><code class=\"html\">&lt;figure&gt;\n    &lt;p&gt;\n        The People&#39;s Republic of China was born in 1949...\n    &lt;/p&gt;\n&lt;/figure&gt;\n</code></pre>\n</li>\n</ol>\n<p><strong>article元素与section区别：</strong></p>\n<blockquote>\n<p>article元素可以看成是一种特殊种类的section元素，它比section元素更强调独立性。section元素强调分段或分块，而article强调独立性。如果一块内容相对来说比较独立、完整的时候，应该使用article元素，但如果想将一块内容分成几段时，应该使用section元素。</p>\n</blockquote>\n</li>\n<li><p>新增其他元素</p>\n<ol>\n<li><p>video：用于定义视频。</p>\n<pre><code class=\"html\">&lt;video src=&quot;movie.mp4&quot; controls&gt;video元素&lt;/video&gt;\n</code></pre>\n</li>\n<li><p>audio：用于定义音频。</p>\n<pre><code class=\"html\">&lt;audio src=&quot;someaudio.wav&quot;&gt;audio元素&lt;/audio&gt;\n</code></pre>\n</li>\n<li><p>embed：用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。</p>\n<pre><code class=\"html\">&lt;embed src=&quot;horse.wav&quot;&gt;\n</code></pre>\n</li>\n<li><p>mark：用来在视觉上向用户呈现那些需要突出显示或高亮显示的文字。</p>\n<pre><code class=\"html\">&lt;mark&gt;&lt;/mark&gt;\n</code></pre>\n</li>\n<li><p>progress：表示运行中的进程。</p>\n</li>\n<li><p>time：表示日期或时间。</p>\n</li>\n<li><p>canvas：表示图形。这个元素本身没有行为，仅提供一块画布，提供绘图API给客户端JavaScript。</p>\n</li>\n<li><p>menu：表示菜单列表。</p>\n</li>\n</ol>\n</li>\n<li><p>新增表单相关属性</p>\n<ol>\n<li>可以对input（type=text）、select、textarea与button元素指定autofocus属性。以指定属性的方式让元素在画面打开时自动获取焦点。</li>\n<li>可以对Input元素与textarea元素指定placeholder属性，可以用来提示用户输入内容。</li>\n<li>可以对input元素（type=text）与textarea元素指定required属性。该属性表示在用户提交的时候进行检查，检查该元素内一定要有输入内容。</li>\n<li>为input元素添加可几个新的属性：autocomplete、min、max、multiple、pattern与step。</li>\n</ol>\n</li>\n<li><p>其他属性</p>\n<ol>\n<li>为ol元素增加属性reversed,它指定列表倒序显示。</li>\n<li>为menu元素增加两个新属性—— type与label。label属性为菜单定义一个可见的标注，type属性让菜单可以以上下文菜单、工具条与列表菜单的三种形式表现。</li>\n<li>为style元素增加scoped属性，用来规定样式的作用范围。</li>\n<li>为script元素增加async属性，定义脚本是否异步执行。</li>\n</ol>\n</li>\n<li><p>全局属性</p>\n<ol>\n<li>contentEditable属性：允许用户编辑元素中的内容。该属性是一个布尔值，可以指定true或false。通过inherit(继承)状态，来指定子元素是否允许编辑。</li>\n<li>designMode属性：用来指定整个页面是否可编辑。只能在JavaScript脚本里被编辑修改。on代表可编辑，off不可编辑。</li>\n<li>hidden属性：在html5中，所有元素都允许使用一个hidden属性，通知浏览器不渲染该元素，使该元素处于不可见状态。</li>\n<li>spellcheck：html5针对input元素(type=text)与textarea这两个文本输入元素提供的属性，功能是对用户输入的文本内容进行拼写和语法检查。它在书写时有一个特殊的地方，就是必须明确声明属性值为true或false。</li>\n</ol>\n</li>\n</ul>\n"},{"title":"I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系","date":"2024-02-19T10:29:15.000Z","_content":"### 1. 视频传输原理\n视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此就有了H.264、H.265、VP8、VP9等视频压缩标准。\n\n\n\n### 2. 视频播放器原理\n视频播放器播放一个互联网上的视频文件，需要经过以及几个步骤：解协议、解封装、解码音视频以及音视频同步。完整过程如下图所示：\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/2428C12B709F42D38859BA4234F61E5D.png)\n\n**解协议**：作用就是将流媒体协议的数据解析为标准的相应的封装格式数据（HTTP/RTMP等）\n\n**解封装**：作用就是将输入的封装格式的数据分离成为视频流压缩编码数据和音频流压缩编码数据。（MP4/TS等）\n\n**解码**：作用就是将音视频压缩编码数据解码成为非压缩的音视频原始数据。\n\n- 音频：MP3/AAC --> PCM \n\n- 视频：H.264/VP8 ---> YUV/RGB\n\n**音视频同步**：根据解封装模块处理过程中获取到的参数信息，同步解码出来的音频和视频数据，并将音视频数据送到显卡和声卡中播放。\n\n\n### 3. 帧内预测和帧间预测\n以下方图片为例。图片显示了两个视频帧（彼此相邻），有一个黑色像素的矩形块在其中移动。在第一帧中，该块位于图像左侧，而第二帧中它移动到了右侧。如何压缩帧2图像数据呢？\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/504B85A8EA314E70BC3BB9C865A14FB4.png)\n大致步骤：\n\n- 将视频分解成为多个像素块（宏块），并逐一压缩。\n\n- 为了压缩每个宏块，首先在当前帧（**帧内预测**）和前后帧（**帧间预测**）中搜索，找到与我们想要压缩的宏块相似的宏块。\n\n- 记录最佳匹配的宏块的位置（位于哪一帧以及在该帧中的位置）。然后，两个宏块之间的差异被压缩，并和位置信息一起被发送给解码器。\n\n\n### 4. I帧\nI帧：即Intra-coded picture（帧内编码图像帧），I帧表示关键帧，可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。也就是说I帧只会进行**帧内预测**，匹配相似的宏块进行压缩。\n\n**I帧的特点**：\n1. 它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输；\n2. 解码时仅用I帧的数据就可重构完整图像； \n3. I帧描述了图像背景和运动主体的详情；\n4. I帧是P帧和B帧的参考帧（其质量直接影响到同组内以后各帧的质量）；\n5. I帧是帧组GOP的基础帧（第一帧），在一组中只有一个I帧；\n6. I帧所占数据的信息量比较大；\n\n### 5. P帧\nP帧：即Predictive-coded Picture（**前向预测编码图像帧**）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/9DED6512254D4CF0A117E6B1AE5EE402.png)\n\n**P帧的预测与重构**：P帧是以前面I/P帧为参考帧，在前面的I/P帧中找出P帧“某点”的预测值和运动矢量，取预测差值和运动矢量一起传送。在接收端根据运动矢量从I/P帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。\n\n\n**P帧特点**：\n1. P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);\n2. 解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;\n3. P帧属于前向预测的帧间预测。它只参考前面最靠近它的I帧或P帧;\n4. P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;\n5. 由于P帧是参考帧,它可能造成解码错误的扩散;\n6. 由于是差值传送,P帧的压缩比较高。\n\n### 6. B帧\nB帧：即Bidirectionally predicted picture（**双向预测编码图像帧**)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗CPU。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/5DDB5B88A2924C6A840C41533AE0920D.png)\n\n**B帧的预测与重构**：B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码。\n\n\n**B帧的特点**：\n1. B帧是由前面的I或P帧和后面的P帧来进行预测的;\n2. B帧传送的是它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量;\n3. B帧是双向预测编码帧;\n4. B帧压缩比最高,因为它只反映参考帧间运动主体的变化情况,预测比较准确;\n5. B帧不是参考帧,不会造成解码错误的扩散\n\n\n### 7. GOP（序列）和IDR\n**序列**：一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。\n\n\n**IDR**：即立即刷新图像，是一个序列的第一个图像，IDR图像都是I帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。\n\n\n**GOP**：即Group of picture（**图像组**），指两个I帧之间的距离，两个I帧之间形成一组图片，就是GOP。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/8AC59C17C15A4885A126F0B3B824E20B.png)\n\n### 为什么需要B帧：\n想要理解B帧的作用，我们需要先理解呈现顺序和编解码顺序的概念。\n以I帧和P帧为例。如果你只使用了这两种类型的帧，那么每一帧要么参考自身（I帧），要么参考前一帧（P帧）。因此，帧可以以相同的顺序进出编码器。这里，呈现顺序（或显示顺序）与编码、解码顺序相同。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/D7B775D11EB743F094F9802ACDF78DBA.png)\n\n网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。\n\n**下图编解码顺序：IPBBPBB...I**\n\n**呈现顺序：IBBPBBP...I**\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/B670A19A85B547999C298B6BA314E0F1.png)\n\n### 8. PTS和DTS\n\n为什么会有PTS和DTS的概念\n\n通过上面的解释可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面的I帧或P帧以及后面的P帧才可以生成一张完整的图片。这样一来就有一个问题：在视频流中，先到来的B帧无法理解解码，需要等待它依赖的后面的P帧先解码完成才行，这样一来播放时间与解码时间就不一致了，所以需要针对这种顺序进行重新排序，这时就引入了另外的两个概念：DTS和PTS。\n\n\n**DTS（Decoding Time Stamp）**：即**解码时间戳**，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\n\n**PTS（Presentation Time Stamp）**：即**显示时间戳**，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/CBED4F4AC4EC45B78044E27BA0CB6A8B.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系.md","raw":"---\ntitle: 'I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系'\ndate: 2024-02-19 18:29:15\ntags: 音视频\ncategories: 前端\n---\n### 1. 视频传输原理\n视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此就有了H.264、H.265、VP8、VP9等视频压缩标准。\n\n\n\n### 2. 视频播放器原理\n视频播放器播放一个互联网上的视频文件，需要经过以及几个步骤：解协议、解封装、解码音视频以及音视频同步。完整过程如下图所示：\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/2428C12B709F42D38859BA4234F61E5D.png)\n\n**解协议**：作用就是将流媒体协议的数据解析为标准的相应的封装格式数据（HTTP/RTMP等）\n\n**解封装**：作用就是将输入的封装格式的数据分离成为视频流压缩编码数据和音频流压缩编码数据。（MP4/TS等）\n\n**解码**：作用就是将音视频压缩编码数据解码成为非压缩的音视频原始数据。\n\n- 音频：MP3/AAC --> PCM \n\n- 视频：H.264/VP8 ---> YUV/RGB\n\n**音视频同步**：根据解封装模块处理过程中获取到的参数信息，同步解码出来的音频和视频数据，并将音视频数据送到显卡和声卡中播放。\n\n\n### 3. 帧内预测和帧间预测\n以下方图片为例。图片显示了两个视频帧（彼此相邻），有一个黑色像素的矩形块在其中移动。在第一帧中，该块位于图像左侧，而第二帧中它移动到了右侧。如何压缩帧2图像数据呢？\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/504B85A8EA314E70BC3BB9C865A14FB4.png)\n大致步骤：\n\n- 将视频分解成为多个像素块（宏块），并逐一压缩。\n\n- 为了压缩每个宏块，首先在当前帧（**帧内预测**）和前后帧（**帧间预测**）中搜索，找到与我们想要压缩的宏块相似的宏块。\n\n- 记录最佳匹配的宏块的位置（位于哪一帧以及在该帧中的位置）。然后，两个宏块之间的差异被压缩，并和位置信息一起被发送给解码器。\n\n\n### 4. I帧\nI帧：即Intra-coded picture（帧内编码图像帧），I帧表示关键帧，可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。也就是说I帧只会进行**帧内预测**，匹配相似的宏块进行压缩。\n\n**I帧的特点**：\n1. 它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输；\n2. 解码时仅用I帧的数据就可重构完整图像； \n3. I帧描述了图像背景和运动主体的详情；\n4. I帧是P帧和B帧的参考帧（其质量直接影响到同组内以后各帧的质量）；\n5. I帧是帧组GOP的基础帧（第一帧），在一组中只有一个I帧；\n6. I帧所占数据的信息量比较大；\n\n### 5. P帧\nP帧：即Predictive-coded Picture（**前向预测编码图像帧**）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/9DED6512254D4CF0A117E6B1AE5EE402.png)\n\n**P帧的预测与重构**：P帧是以前面I/P帧为参考帧，在前面的I/P帧中找出P帧“某点”的预测值和运动矢量，取预测差值和运动矢量一起传送。在接收端根据运动矢量从I/P帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。\n\n\n**P帧特点**：\n1. P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);\n2. 解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;\n3. P帧属于前向预测的帧间预测。它只参考前面最靠近它的I帧或P帧;\n4. P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;\n5. 由于P帧是参考帧,它可能造成解码错误的扩散;\n6. 由于是差值传送,P帧的压缩比较高。\n\n### 6. B帧\nB帧：即Bidirectionally predicted picture（**双向预测编码图像帧**)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗CPU。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/5DDB5B88A2924C6A840C41533AE0920D.png)\n\n**B帧的预测与重构**：B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码。\n\n\n**B帧的特点**：\n1. B帧是由前面的I或P帧和后面的P帧来进行预测的;\n2. B帧传送的是它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量;\n3. B帧是双向预测编码帧;\n4. B帧压缩比最高,因为它只反映参考帧间运动主体的变化情况,预测比较准确;\n5. B帧不是参考帧,不会造成解码错误的扩散\n\n\n### 7. GOP（序列）和IDR\n**序列**：一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。\n\n\n**IDR**：即立即刷新图像，是一个序列的第一个图像，IDR图像都是I帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。\n\n\n**GOP**：即Group of picture（**图像组**），指两个I帧之间的距离，两个I帧之间形成一组图片，就是GOP。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/8AC59C17C15A4885A126F0B3B824E20B.png)\n\n### 为什么需要B帧：\n想要理解B帧的作用，我们需要先理解呈现顺序和编解码顺序的概念。\n以I帧和P帧为例。如果你只使用了这两种类型的帧，那么每一帧要么参考自身（I帧），要么参考前一帧（P帧）。因此，帧可以以相同的顺序进出编码器。这里，呈现顺序（或显示顺序）与编码、解码顺序相同。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/D7B775D11EB743F094F9802ACDF78DBA.png)\n\n网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。\n\n**下图编解码顺序：IPBBPBB...I**\n\n**呈现顺序：IBBPBBP...I**\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/B670A19A85B547999C298B6BA314E0F1.png)\n\n### 8. PTS和DTS\n\n为什么会有PTS和DTS的概念\n\n通过上面的解释可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面的I帧或P帧以及后面的P帧才可以生成一张完整的图片。这样一来就有一个问题：在视频流中，先到来的B帧无法理解解码，需要等待它依赖的后面的P帧先解码完成才行，这样一来播放时间与解码时间就不一致了，所以需要针对这种顺序进行重新排序，这时就引入了另外的两个概念：DTS和PTS。\n\n\n**DTS（Decoding Time Stamp）**：即**解码时间戳**，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。\n\n**PTS（Presentation Time Stamp）**：即**显示时间戳**，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。\n\n![image](I帧、P帧、B帧、GOP、IDR 和PTS, DTS之间的关系/CBED4F4AC4EC45B78044E27BA0CB6A8B.png)\n\n\n\n\n\n\n\n\n\n","slug":"I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系","published":1,"updated":"2024-02-19T10:41:54.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr96000h1xopfgpo11r7","content":"<h3 id=\"1-视频传输原理\"><a href=\"#1-视频传输原理\" class=\"headerlink\" title=\"1. 视频传输原理\"></a>1. 视频传输原理</h3><p>视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此就有了H.264、H.265、VP8、VP9等视频压缩标准。</p>\n<h3 id=\"2-视频播放器原理\"><a href=\"#2-视频播放器原理\" class=\"headerlink\" title=\"2. 视频播放器原理\"></a>2. 视频播放器原理</h3><p>视频播放器播放一个互联网上的视频文件，需要经过以及几个步骤：解协议、解封装、解码音视频以及音视频同步。完整过程如下图所示：<br><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/2428C12B709F42D38859BA4234F61E5D.png\" alt=\"image\"></p>\n<p><strong>解协议</strong>：作用就是将流媒体协议的数据解析为标准的相应的封装格式数据（HTTP/RTMP等）</p>\n<p><strong>解封装</strong>：作用就是将输入的封装格式的数据分离成为视频流压缩编码数据和音频流压缩编码数据。（MP4/TS等）</p>\n<p><strong>解码</strong>：作用就是将音视频压缩编码数据解码成为非压缩的音视频原始数据。</p>\n<ul>\n<li><p>音频：MP3/AAC –&gt; PCM </p>\n</li>\n<li><p>视频：H.264/VP8 —&gt; YUV/RGB</p>\n</li>\n</ul>\n<p><strong>音视频同步</strong>：根据解封装模块处理过程中获取到的参数信息，同步解码出来的音频和视频数据，并将音视频数据送到显卡和声卡中播放。</p>\n<h3 id=\"3-帧内预测和帧间预测\"><a href=\"#3-帧内预测和帧间预测\" class=\"headerlink\" title=\"3. 帧内预测和帧间预测\"></a>3. 帧内预测和帧间预测</h3><p>以下方图片为例。图片显示了两个视频帧（彼此相邻），有一个黑色像素的矩形块在其中移动。在第一帧中，该块位于图像左侧，而第二帧中它移动到了右侧。如何压缩帧2图像数据呢？</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/504B85A8EA314E70BC3BB9C865A14FB4.png\" alt=\"image\"><br>大致步骤：</p>\n<ul>\n<li><p>将视频分解成为多个像素块（宏块），并逐一压缩。</p>\n</li>\n<li><p>为了压缩每个宏块，首先在当前帧（<strong>帧内预测</strong>）和前后帧（<strong>帧间预测</strong>）中搜索，找到与我们想要压缩的宏块相似的宏块。</p>\n</li>\n<li><p>记录最佳匹配的宏块的位置（位于哪一帧以及在该帧中的位置）。然后，两个宏块之间的差异被压缩，并和位置信息一起被发送给解码器。</p>\n</li>\n</ul>\n<h3 id=\"4-I帧\"><a href=\"#4-I帧\" class=\"headerlink\" title=\"4. I帧\"></a>4. I帧</h3><p>I帧：即Intra-coded picture（帧内编码图像帧），I帧表示关键帧，可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。也就是说I帧只会进行<strong>帧内预测</strong>，匹配相似的宏块进行压缩。</p>\n<p><strong>I帧的特点</strong>：</p>\n<ol>\n<li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输；</li>\n<li>解码时仅用I帧的数据就可重构完整图像； </li>\n<li>I帧描述了图像背景和运动主体的详情；</li>\n<li>I帧是P帧和B帧的参考帧（其质量直接影响到同组内以后各帧的质量）；</li>\n<li>I帧是帧组GOP的基础帧（第一帧），在一组中只有一个I帧；</li>\n<li>I帧所占数据的信息量比较大；</li>\n</ol>\n<h3 id=\"5-P帧\"><a href=\"#5-P帧\" class=\"headerlink\" title=\"5. P帧\"></a>5. P帧</h3><p>P帧：即Predictive-coded Picture（<strong>前向预测编码图像帧</strong>）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/9DED6512254D4CF0A117E6B1AE5EE402.png\" alt=\"image\"></p>\n<p><strong>P帧的预测与重构</strong>：P帧是以前面I/P帧为参考帧，在前面的I/P帧中找出P帧“某点”的预测值和运动矢量，取预测差值和运动矢量一起传送。在接收端根据运动矢量从I/P帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p>\n<p><strong>P帧特点</strong>：</p>\n<ol>\n<li>P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li>\n<li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li>\n<li>P帧属于前向预测的帧间预测。它只参考前面最靠近它的I帧或P帧;</li>\n<li>P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li>\n<li>由于P帧是参考帧,它可能造成解码错误的扩散;</li>\n<li>由于是差值传送,P帧的压缩比较高。</li>\n</ol>\n<h3 id=\"6-B帧\"><a href=\"#6-B帧\" class=\"headerlink\" title=\"6. B帧\"></a>6. B帧</h3><p>B帧：即Bidirectionally predicted picture（<strong>双向预测编码图像帧</strong>)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗CPU。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/5DDB5B88A2924C6A840C41533AE0920D.png\" alt=\"image\"></p>\n<p><strong>B帧的预测与重构</strong>：B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码。</p>\n<p><strong>B帧的特点</strong>：</p>\n<ol>\n<li>B帧是由前面的I或P帧和后面的P帧来进行预测的;</li>\n<li>B帧传送的是它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量;</li>\n<li>B帧是双向预测编码帧;</li>\n<li>B帧压缩比最高,因为它只反映参考帧间运动主体的变化情况,预测比较准确;</li>\n<li>B帧不是参考帧,不会造成解码错误的扩散</li>\n</ol>\n<h3 id=\"7-GOP（序列）和IDR\"><a href=\"#7-GOP（序列）和IDR\" class=\"headerlink\" title=\"7. GOP（序列）和IDR\"></a>7. GOP（序列）和IDR</h3><p><strong>序列</strong>：一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</p>\n<p><strong>IDR</strong>：即立即刷新图像，是一个序列的第一个图像，IDR图像都是I帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>\n<p><strong>GOP</strong>：即Group of picture（<strong>图像组</strong>），指两个I帧之间的距离，两个I帧之间形成一组图片，就是GOP。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/8AC59C17C15A4885A126F0B3B824E20B.png\" alt=\"image\"></p>\n<h3 id=\"为什么需要B帧：\"><a href=\"#为什么需要B帧：\" class=\"headerlink\" title=\"为什么需要B帧：\"></a>为什么需要B帧：</h3><p>想要理解B帧的作用，我们需要先理解呈现顺序和编解码顺序的概念。<br>以I帧和P帧为例。如果你只使用了这两种类型的帧，那么每一帧要么参考自身（I帧），要么参考前一帧（P帧）。因此，帧可以以相同的顺序进出编码器。这里，呈现顺序（或显示顺序）与编码、解码顺序相同。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/D7B775D11EB743F094F9802ACDF78DBA.png\" alt=\"image\"></p>\n<p>网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p>\n<p><strong>下图编解码顺序：IPBBPBB…I</strong></p>\n<p><strong>呈现顺序：IBBPBBP…I</strong></p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/B670A19A85B547999C298B6BA314E0F1.png\" alt=\"image\"></p>\n<h3 id=\"8-PTS和DTS\"><a href=\"#8-PTS和DTS\" class=\"headerlink\" title=\"8. PTS和DTS\"></a>8. PTS和DTS</h3><p>为什么会有PTS和DTS的概念</p>\n<p>通过上面的解释可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面的I帧或P帧以及后面的P帧才可以生成一张完整的图片。这样一来就有一个问题：在视频流中，先到来的B帧无法理解解码，需要等待它依赖的后面的P帧先解码完成才行，这样一来播放时间与解码时间就不一致了，所以需要针对这种顺序进行重新排序，这时就引入了另外的两个概念：DTS和PTS。</p>\n<p><strong>DTS（Decoding Time Stamp）</strong>：即<strong>解码时间戳</strong>，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</p>\n<p><strong>PTS（Presentation Time Stamp）</strong>：即<strong>显示时间戳</strong>，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/CBED4F4AC4EC45B78044E27BA0CB6A8B.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-视频传输原理\"><a href=\"#1-视频传输原理\" class=\"headerlink\" title=\"1. 视频传输原理\"></a>1. 视频传输原理</h3><p>视频是利用人眼视觉暂留的原理，通过播放一系列的图片，使人眼产生运动的感觉。单纯传输视频画面，视频量非常大，对现有的网络和存储来说是不可接受的。为了能够使视频便于传输和存储，人们发现视频有大量重复的信息，如果将重复信息在发送端去掉，在接收端恢复出来，这样就大大减少了视频数据的文件，因此就有了H.264、H.265、VP8、VP9等视频压缩标准。</p>\n<h3 id=\"2-视频播放器原理\"><a href=\"#2-视频播放器原理\" class=\"headerlink\" title=\"2. 视频播放器原理\"></a>2. 视频播放器原理</h3><p>视频播放器播放一个互联网上的视频文件，需要经过以及几个步骤：解协议、解封装、解码音视频以及音视频同步。完整过程如下图所示：<br><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/2428C12B709F42D38859BA4234F61E5D.png\" alt=\"image\"></p>\n<p><strong>解协议</strong>：作用就是将流媒体协议的数据解析为标准的相应的封装格式数据（HTTP/RTMP等）</p>\n<p><strong>解封装</strong>：作用就是将输入的封装格式的数据分离成为视频流压缩编码数据和音频流压缩编码数据。（MP4/TS等）</p>\n<p><strong>解码</strong>：作用就是将音视频压缩编码数据解码成为非压缩的音视频原始数据。</p>\n<ul>\n<li><p>音频：MP3/AAC –&gt; PCM </p>\n</li>\n<li><p>视频：H.264/VP8 —&gt; YUV/RGB</p>\n</li>\n</ul>\n<p><strong>音视频同步</strong>：根据解封装模块处理过程中获取到的参数信息，同步解码出来的音频和视频数据，并将音视频数据送到显卡和声卡中播放。</p>\n<h3 id=\"3-帧内预测和帧间预测\"><a href=\"#3-帧内预测和帧间预测\" class=\"headerlink\" title=\"3. 帧内预测和帧间预测\"></a>3. 帧内预测和帧间预测</h3><p>以下方图片为例。图片显示了两个视频帧（彼此相邻），有一个黑色像素的矩形块在其中移动。在第一帧中，该块位于图像左侧，而第二帧中它移动到了右侧。如何压缩帧2图像数据呢？</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/504B85A8EA314E70BC3BB9C865A14FB4.png\" alt=\"image\"><br>大致步骤：</p>\n<ul>\n<li><p>将视频分解成为多个像素块（宏块），并逐一压缩。</p>\n</li>\n<li><p>为了压缩每个宏块，首先在当前帧（<strong>帧内预测</strong>）和前后帧（<strong>帧间预测</strong>）中搜索，找到与我们想要压缩的宏块相似的宏块。</p>\n</li>\n<li><p>记录最佳匹配的宏块的位置（位于哪一帧以及在该帧中的位置）。然后，两个宏块之间的差异被压缩，并和位置信息一起被发送给解码器。</p>\n</li>\n</ul>\n<h3 id=\"4-I帧\"><a href=\"#4-I帧\" class=\"headerlink\" title=\"4. I帧\"></a>4. I帧</h3><p>I帧：即Intra-coded picture（帧内编码图像帧），I帧表示关键帧，可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。也就是说I帧只会进行<strong>帧内预测</strong>，匹配相似的宏块进行压缩。</p>\n<p><strong>I帧的特点</strong>：</p>\n<ol>\n<li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输；</li>\n<li>解码时仅用I帧的数据就可重构完整图像； </li>\n<li>I帧描述了图像背景和运动主体的详情；</li>\n<li>I帧是P帧和B帧的参考帧（其质量直接影响到同组内以后各帧的质量）；</li>\n<li>I帧是帧组GOP的基础帧（第一帧），在一组中只有一个I帧；</li>\n<li>I帧所占数据的信息量比较大；</li>\n</ol>\n<h3 id=\"5-P帧\"><a href=\"#5-P帧\" class=\"headerlink\" title=\"5. P帧\"></a>5. P帧</h3><p>P帧：即Predictive-coded Picture（<strong>前向预测编码图像帧</strong>）。P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/9DED6512254D4CF0A117E6B1AE5EE402.png\" alt=\"image\"></p>\n<p><strong>P帧的预测与重构</strong>：P帧是以前面I/P帧为参考帧，在前面的I/P帧中找出P帧“某点”的预测值和运动矢量，取预测差值和运动矢量一起传送。在接收端根据运动矢量从I/P帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。</p>\n<p><strong>P帧特点</strong>：</p>\n<ol>\n<li>P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li>\n<li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li>\n<li>P帧属于前向预测的帧间预测。它只参考前面最靠近它的I帧或P帧;</li>\n<li>P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li>\n<li>由于P帧是参考帧,它可能造成解码错误的扩散;</li>\n<li>由于是差值传送,P帧的压缩比较高。</li>\n</ol>\n<h3 id=\"6-B帧\"><a href=\"#6-B帧\" class=\"headerlink\" title=\"6. B帧\"></a>6. B帧</h3><p>B帧：即Bidirectionally predicted picture（<strong>双向预测编码图像帧</strong>)。B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时比较耗CPU。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/5DDB5B88A2924C6A840C41533AE0920D.png\" alt=\"image\"></p>\n<p><strong>B帧的预测与重构</strong>：B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。采用运动预测的方式进行帧间双向预测编码。</p>\n<p><strong>B帧的特点</strong>：</p>\n<ol>\n<li>B帧是由前面的I或P帧和后面的P帧来进行预测的;</li>\n<li>B帧传送的是它与前面的I帧或P帧和后面的P帧之间的预测误差及运动矢量;</li>\n<li>B帧是双向预测编码帧;</li>\n<li>B帧压缩比最高,因为它只反映参考帧间运动主体的变化情况,预测比较准确;</li>\n<li>B帧不是参考帧,不会造成解码错误的扩散</li>\n</ol>\n<h3 id=\"7-GOP（序列）和IDR\"><a href=\"#7-GOP（序列）和IDR\" class=\"headerlink\" title=\"7. GOP（序列）和IDR\"></a>7. GOP（序列）和IDR</h3><p><strong>序列</strong>：一个序列就是一段内容差异不太大的图像编码后生成的一串数据流。当运动变化比较少时，一个序列可以很长，因为运动变化少就代表图像画面的内容变动很小，所以就可以编一个I帧，然后一直P帧、B帧了。当运动变化多时，可能一个序列就比较短了，比如就包含一个I帧和3、4个P帧。</p>\n<p><strong>IDR</strong>：即立即刷新图像，是一个序列的第一个图像，IDR图像都是I帧图像。引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>\n<p><strong>GOP</strong>：即Group of picture（<strong>图像组</strong>），指两个I帧之间的距离，两个I帧之间形成一组图片，就是GOP。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/8AC59C17C15A4885A126F0B3B824E20B.png\" alt=\"image\"></p>\n<h3 id=\"为什么需要B帧：\"><a href=\"#为什么需要B帧：\" class=\"headerlink\" title=\"为什么需要B帧：\"></a>为什么需要B帧：</h3><p>想要理解B帧的作用，我们需要先理解呈现顺序和编解码顺序的概念。<br>以I帧和P帧为例。如果你只使用了这两种类型的帧，那么每一帧要么参考自身（I帧），要么参考前一帧（P帧）。因此，帧可以以相同的顺序进出编码器。这里，呈现顺序（或显示顺序）与编码、解码顺序相同。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/D7B775D11EB743F094F9802ACDF78DBA.png\" alt=\"image\"></p>\n<p>网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。</p>\n<p><strong>下图编解码顺序：IPBBPBB…I</strong></p>\n<p><strong>呈现顺序：IBBPBBP…I</strong></p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/B670A19A85B547999C298B6BA314E0F1.png\" alt=\"image\"></p>\n<h3 id=\"8-PTS和DTS\"><a href=\"#8-PTS和DTS\" class=\"headerlink\" title=\"8. PTS和DTS\"></a>8. PTS和DTS</h3><p>为什么会有PTS和DTS的概念</p>\n<p>通过上面的解释可以看出：P帧需要参考前面的I帧或P帧才可以生成一张完整的图片，而B帧则需要参考前面的I帧或P帧以及后面的P帧才可以生成一张完整的图片。这样一来就有一个问题：在视频流中，先到来的B帧无法理解解码，需要等待它依赖的后面的P帧先解码完成才行，这样一来播放时间与解码时间就不一致了，所以需要针对这种顺序进行重新排序，这时就引入了另外的两个概念：DTS和PTS。</p>\n<p><strong>DTS（Decoding Time Stamp）</strong>：即<strong>解码时间戳</strong>，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。</p>\n<p><strong>PTS（Presentation Time Stamp）</strong>：即<strong>显示时间戳</strong>，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。</p>\n<p><img src=\"/2024/02/19/I%E5%B8%A7%E3%80%81P%E5%B8%A7%E3%80%81B%E5%B8%A7%E3%80%81GOP%E3%80%81IDR-%E5%92%8CPTS-DTS%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/CBED4F4AC4EC45B78044E27BA0CB6A8B.png\" alt=\"image\"></p>\n"},{"title":"JavaScript语言精粹笔记","date":"2019-06-01T03:49:07.000Z","_content":"\n### JavaScript语言精粹\n\n- **对象枚举**\n\n  for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性---所以有必要过滤掉那些你不想要的值。通常使用的过滤器是`hasOwnProperty`方法，以及使用`typeof`来排除函数。\n\n  原型链中的任何属性通过typeof判断：\n\n  ```js\n  typeof obj.toString    // 'function'\n  typeof obj.constructor  // 'function'\n  ```\n\n  ```js\n  var name;\n  //通过typeof来排除原型中的属性\n  for(name in obj) {\n      if(typeof obj[name] !== 'function') {\n          //执行其他\n      }\n  }\n  //通过hasOwnProperty来排除原型中的属性\n  for(name in obj) {\n      if(obj.hasOwnProperty(name)) {\n          //执行其他\n      }\n  }\n  ```\n\n  在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。\n\n  ```js\n  var i;\n  var properties = [\n      'first-name',\n      'middle-name',\n      'last-name',\n      'profession'\n  ]\n  for(i = 0; i < properties.length; i += 1) {\n      obj[properties[i]];\n  }\n  ```\n\n- **删除对象中的属性**\n\n  `delete`运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。\n  \n- **减少全局变量污染**\n\n  js可以很随意的定义那些可保存所有应用资源的全局变量。不幸的是，全局变量削弱了程序的灵活性，所以应该避免。\n  \n  最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：\n  \n```js\nvar MYAPP = {};\n```\n  该变量此时变成了你的应用的容器：\n\n```js\nMYAPP.stooge = {\n    \"name\": \"Tom\",\n    \"age\": 20\n};\nMYAPP.flight = {\n    airline: \"Oceanic\",\n    number: 88,\n    departure: {\n        time: \"2019-03-20 12:55\",\n        city: \"Sydney\"\n    }\n}\n```\n只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。程序也会变得更易读。\n\n- **函数对象**\n  \n  在js中函数就是对象。对象是一个“名/值”对的集合，并且拥有一个连到原型对象的隐藏连接。对象字面量产生的对象连接到`Object.prototype`。函数对象连接到`Function.prototype`（该原型对象本身连接到`Object.prototype`）。每个函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。\n  \n  因为函数是对象，所以它们可以像任何其他的值一样被使用。函数可以存放在变量、对象和数组中，函数也可以被当做参数传递给其他函数，函数也可以再返回函数。而且因为函数是对象，所以函数可以拥有方法。\n\n  *函数的与众不同之处在于它们可以被调用。*\n  \n- **函数调用**\n  \n  调用一个函数时，将暂定当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数接收两个附加的参数：this和arguments。\n\n  在js中，一共有四种调用模式（这些模式在如何初始化关键参数this上存在差异）：\n  \n 1.   方法调用模式\n        \n      -- 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。\n\n```js\n// 创建myObject。它有一个value属性和一个increment方法。\n// increment方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1\n\nvar myObject ={\n  value: 0,\n  increment: function (inc) {\n      this.value += typeof inc === 'number' ? inc : 1;\n  }\n}\nmyObject.increment();\nconsole.log(myObject.value);  // 1\n\nmyObject.increment(2);\nconsole.log(muObject.value);  //3\n```\n方法可以使用this去访问对象，所以可以从对象中取值或修改该对象。\n\n 2.   函数调用模式\n  \n      -- 当一个函数并非一个对象的属性时，那么它被当作一个函数来调用：\n\n```js\nvar sum = add(3, 4);  // sum的值是7\n```\n当函数以此模式调用时，this被绑定到全局对象。\n\n 3.   构造器调用模式\n\n      -- 如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将会被绑定到那个新对象上。\n\n```js\n// 创建一个名为Quo的构造器函数。它构造一个代用status属性的对象\n\nvar Quo = function (string) {\n    this.status = string;\n}\n\nQuo.prototype.get_status = function() {\n    return this.status;\n}\n\nvar myQuo = new Quo(\"confused\");\n```\n 4.   apply调用模式\n\n      -- apply方法让我们构建一个参数数组并用其去调用函数。允许我们选择this的值。apply方法接收两个参数，第一个是将被绑定给this的值，第二个就是一个参数数组。\n\n\n```js\nvar statusObject = {\n    status: 'A-OK'\n};\n\n// statusObject并没有继承自Quo.prototype,但我们可以在statusObject上调\n// 用get_status方法，尽管statusObject并没有名为get_status的方法。\n\nvar status = Quo.prototype.get_status.apply(statusObject);  // status 值为 'A-OK'\n```\n- **闭包**\n\n  函数内部返回出去的对象或函数可以访问它被创建时所处的上下文环境。被称为闭包。\n  \n  \n```js\nvar myObject = function () {\n    var value = 0;\n    \n    return {\n        increment: function (inc) {\n            value += typeof inc === 'number' ? inc : 1;\n        },\n        getValue: function () {\n            return value;\n        }\n    }\n}();\n\n// 我们没有把一个函数赋值给myObject，而是将函数的返回结果赋值给了它。注意最后一行（）。\n// 该函数返回一个包含两个方法的对象，并且这些方法继续享有访问value变量的特权。\n\n\n\n// 创建一个名为quo的构造函数\n// 它构造出带有get_status方法和status私有属性的一个对象。\n\nvar quo = function (status) {\n    return {\n        get_status: function () {\n            return status;\n        }\n    }\n}\n\n// 构造一个quo的实例\n\nvar myQuo = quo(\"amazed\");\nconsole.log(myQuo.get_status());\n\n\n// 这个函数被设计称无须在前面加上new来使用，所以名字也没有首字母大写，\n// 调用quo时，返回带有get_status方法的新对象。该对象的一个引用保存在myQuo中\n// 。即使quo已经返回了，但get_status方法仍然享有访问quo对象的status属性的特权。\n// 它访问的就是该参数的本身而不是参数的拷贝。\n\n```\n- 记忆\n  \n  函数可以用对象去记住先前操作的结果，从而能避免无谓的运算。这种优化被称为记忆。\n\n  \n```js\n  // 不适用记忆，采用递归函数计算Fibonacci数列。\n  // 一个Fibonacci数字是之前两个Fibonacci数字之和。\n  // 最初是两个数字是0和1。\n  var fibonacci = function (n) {\n      return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n  };\n  for (var i = 0; i <= 10; i += 1) {\n      console.log('//' + i + ':' + fibonacci(i));\n  }\n  \n  \n  // 0: 0\n  // 1: 1\n  // 2: 1\n  // 3: 2\n  // 4: 3\n  // 5: 5\n  // 6: 8\n  // 7: 13\n  // 8: 21\n  // 9: 34\n  // 10: 55\n```\n  虽然这样是可以工作的，但它做了很多无谓的工作。fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少它的运算量。\n\n\n```js\n  // 使用memo数组保存计算结果,采用闭包的形式\n  \n  var fibonacci = function () {\n      var memo = [0 ,1];\n      var fib = function (n) {\n          var result = memo[n];\n          if (typeof result !== 'number') {\n              result = fib(n - 1) + fib(n - 2);\n              memo[n] = result;\n          }\n          return result\n      }\n      return fib;\n  }();\n```\n\n  这个函数返回同样的结果，但它只被调用了29次。我们调用了11次。它自身调用了18次去取的计算结果。\n\n  我们可以编写一个函数来帮助我们构造带记忆功能的函数。memoizer函数将取的一个初始的memo数组和fundamental函数。\n\n\n```js\n  var memoizer = function (memo, fundamental) {\n      var shell = function (n) {\n          var result = memo[n];\n          if(typeof result !== 'number') {\n              result = fundamental(shell, n);\n              memo[n] = result;\n          }\n          return result;\n      };\n      return shell;\n  }\n  \n  // 使用memoizer来定义fibonacci函数\n  \n  var fibonacci = memoizer([0 ,1], function (shell, n){\n      return shell(n - 1) + shell(n - 2);\n  });\n  \n  //  通过设计能产生出其他函数的函数，可以极大减少我们必须要做的工作。\n  //  产生一个可以记忆的阶乘函数，我们只需提供基本的阶乘公式即可：\n\n  var factorial = memoizer([1, 1], function (shell, n){\n      return n * shell(n - 1);\n  })\n```\n\n- 全局变量\n\n  js所有糟糕的特性之中最为糟糕的就是它对全局变量的依赖性。全局变量就是在所有作用域中都可见的变量。全局变量可以被程序的任何部分在任何时间改变，它们会使得程序的行为被极大地复杂化。在程序中使用全局变量降低了程序的可靠性。\n  \n  全局变量使得在同一个程序中运行独立的子程序变得更难，如果某些全局变量的名称碰巧和子程序中的变量名称相同，那么它们将会相互冲突并可能导致程序无法运行，而且通常难以调试。\n  \n  定义全局变量有三种方式：\n  \n```js\n// 第一种脱离任何函数安排一个var语句：\n    var foo = value;\n    \n// 第二种是直接添加一个属性到全局对象上。\n// 全局对象是所有全局变量的容器。\n// 在Web浏览器里，全局对象名为window\n\n    window.foo = value;\n    \n// 第三种是直接使用未经声明的变量。这被称为隐式的全局变量\n\n    foo = value;\n```\n\n- 自动插入分号\n\n  js有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。\n  \n  如果一个return语句返回一个值，这个值表达式开始部分必须和return在同一行上。\n  \n  \n```js\n    return\n    {\n        status: true\n    }\n    /*\n        上述代码看起来是要返回一个包含status成员元素的对象，不幸的是，自动插入分号让它变成了返回undefined。\n        如果把{放在上一行的尾部而不是下一行的头部就可以避免该问题\n    */\n    \n    return {\n        status: true\n    }\n```\n\n- typeof\n\n  typeof运算符返回一个用于表示其运算数类型的字符串。\n  \n  \n```js\n typeof 98.6  // number\n typeof null // 返回object而不是null\n \n // typeof不能辨别出null与对象，可以像下面这样做\n // 因为null值为假，而所有对象值为真\n \n // my_value === null;\n if(my_value && typeof my_value === 'object') {\n     // my_value是一个对象或数组\n }\n```\n- parseInt\n\n  parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析，所以parseInt(\"16\")与parseInt(\"16 tons\")产生相同的结果。\n  \n  如果该字符串第一个字符是0，那么该字符串将被基于八进制而不是十进制来求值。在八进制中，8和9不是数字，所依parseInt(\"08\")和parseInt(\"09\")产生0作为结果。这个错误导致了程序解析日期和时间时出现问题。幸运的是，parseInt可以接受一个基数作为参数，parseInt(\"08\",10)结果为8。使用parseInt总是提供这个基数参数是有必要的。\n  \n- '+'\n\n  '+'运算符可以用于加法运算或字符串连接。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，它返回两者之和。如果你打算用+去做加法运算，请确保两个运算数都是整数。\n  \n- NaN\n\n  NaN是IEEE754中定义的一个特殊的数量值，它表示不是一个数字。\n  \n  ```js\n  typeof NaN === 'number'  // true\n  \n  // 该值可能会在试图将非数字形式的字符串转换为数字时产生。\n  \n  + '0'  // 0\n  + 'aksk' // NaN\n  \n  // 需要注意的是，如果你有一个公式链产生出NaN的结果，那么至少其中一个输入项是NaN，或者在某个地方产生了NaN。\n  \n  // NaN不等同与它自己\n  \n  NaN === NaN   // false\n  NaN !== NaN   // true\n  \n  // js提供了isNaN函数检测是否是NaN\n  \n  isNaN(NaN);   // true\n  isNaN(0);   // false\n  isNaN('asnsnsn');   // ture\n  isNaN('0');  // false\n  ```\n  \n  判断一个值是否可用做数字的最佳方法是使用isFinite函数，因为它会筛除掉NaN和Infinity。不幸的是，isFinite会试图把它的运算数转换为一个数字，所以，如果值事实上不是一个数字，它就不是一个好的测试。可以自己定义isNumber函数：\n  \n  ```js\n    function isNumber(value) {\n        return typeof value === 'number' && isFinite(value);\n    }\n  ```\n  \n- 伪数组\n\n  js没有真正的数组。\n  \n  typeof运算符不能辨别数组和对象。要判断一个值是否为数组，必须要检查它的constructor属性：\n  \n  \n```js\n    if(my_value && typeof my_value === 'object' && my_value.constructor === Array) {\n        // my_value是一个数组\n    }\n```\n上面的检测对于在不同的帧或窗口创建的数组将会给出false。当数组有可能哎其他的帧中被创建时，下面的检测更为可靠：\n\n\n```js\n    if(my_value && typeof my_value === 'object' && typeof my_value.length === 'number' && !(my_value.propertyIsEnumerable('length'))) {\n        // my_value确实是一个数组\n    }\n```\n\n-  ==\n\n  js有两组相等运算符：=== 和 !==，以及 == 和 !=。 === 和 !==这一组运算符会按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么 === 返回 true，而 !==返回false。而 == 和 !=只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型时，它们试图去强制转换类型。\n  \n  \n```js\n '' == '0'   // false\n 0 == ''     // true\n 0 == '0'    // true\n \n false == 'false'  // false\n false == '0'  // true\n \n false == undefined  // false\n false == null    // false\n null == undefined   // true\n\n```\n== 运算符对传递性的缺乏值得我们警惕。建议永远不要用== 和 !=。始终使用 === 和 !==。\n\n> 传递性是一种编程约定。可以这么去理解：对于任意的引用值x、y和z，如果x == y和y == z为true，那么x == z 为true。而js中的==运算符在某些特例上违背了传递性。\n\n****\n\n**避免使用with语句，with语句严重影响了js处理器的速度，因为它阻止了变量名的词法作用域绑定。**\n\n****\n\n**避免使用eval。使用它会使得性能显著降低，因为它须运行编译器。**\n* Function构造器是eval的另一种形式，所以它同样也应该被避免使用。\n* 浏览器提供的setTimeout和setInterval函数，它们能接受字符串参数或函数参数。当传递的是字符串参数时，setTimeout和setInterval会像eval那样去处理。字符串参数形式也应该被避免使用。\n\n****\n\n**continue语句**\n\ncontinue语句跳到循环的顶部。通过移除continue语句后，性能会得到改善。\n\n****\n\n**switch贯穿**\n\n使用switch语句时，每一个条件都是需要添加break，防止上一个case条件向下贯穿到另一个case条件。\n\n****\n\n**function语句对比函数表达式**\n\njs中既有function语句，同时也有函数表达式。这是令人困惑的，因为它们看起来就是相同的。一个function语句就是其值为一个函数法人var语句的速记形式。\n\n\n```js\n    // 下面语句：\n    function foo () {}\n    \n    //意思相当于：\n    var foo = function foo() {};\n```\n\n第二种形式能明确表示foo是一个包含一个函数值的变量。function语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域的顶层。禁止在if语句中声明function语句。\n\n一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句。解决方法就是把函数表达式括在一个圆括号之中。\n\n\n```js\n    (function () {\n        var hidden_variable;\n        \n        // 这个函数可能对环境有一些影响，但不会引入新的全局变量\n    })\n```\n\n****\n\n**在使用new运算符创建新对象时，千万别忘了new，否则会造成this被绑定到全局对象，而不是新创建的对象。**","source":"_posts/JavaScript语言精粹笔记.md","raw":"---\ntitle: JavaScript语言精粹笔记\ndate: 2019-06-01 11:49:07\ntags: js\ncategories: 读书笔记\n---\n\n### JavaScript语言精粹\n\n- **对象枚举**\n\n  for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性---所以有必要过滤掉那些你不想要的值。通常使用的过滤器是`hasOwnProperty`方法，以及使用`typeof`来排除函数。\n\n  原型链中的任何属性通过typeof判断：\n\n  ```js\n  typeof obj.toString    // 'function'\n  typeof obj.constructor  // 'function'\n  ```\n\n  ```js\n  var name;\n  //通过typeof来排除原型中的属性\n  for(name in obj) {\n      if(typeof obj[name] !== 'function') {\n          //执行其他\n      }\n  }\n  //通过hasOwnProperty来排除原型中的属性\n  for(name in obj) {\n      if(obj.hasOwnProperty(name)) {\n          //执行其他\n      }\n  }\n  ```\n\n  在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。\n\n  ```js\n  var i;\n  var properties = [\n      'first-name',\n      'middle-name',\n      'last-name',\n      'profession'\n  ]\n  for(i = 0; i < properties.length; i += 1) {\n      obj[properties[i]];\n  }\n  ```\n\n- **删除对象中的属性**\n\n  `delete`运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。\n  \n- **减少全局变量污染**\n\n  js可以很随意的定义那些可保存所有应用资源的全局变量。不幸的是，全局变量削弱了程序的灵活性，所以应该避免。\n  \n  最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：\n  \n```js\nvar MYAPP = {};\n```\n  该变量此时变成了你的应用的容器：\n\n```js\nMYAPP.stooge = {\n    \"name\": \"Tom\",\n    \"age\": 20\n};\nMYAPP.flight = {\n    airline: \"Oceanic\",\n    number: 88,\n    departure: {\n        time: \"2019-03-20 12:55\",\n        city: \"Sydney\"\n    }\n}\n```\n只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。程序也会变得更易读。\n\n- **函数对象**\n  \n  在js中函数就是对象。对象是一个“名/值”对的集合，并且拥有一个连到原型对象的隐藏连接。对象字面量产生的对象连接到`Object.prototype`。函数对象连接到`Function.prototype`（该原型对象本身连接到`Object.prototype`）。每个函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。\n  \n  因为函数是对象，所以它们可以像任何其他的值一样被使用。函数可以存放在变量、对象和数组中，函数也可以被当做参数传递给其他函数，函数也可以再返回函数。而且因为函数是对象，所以函数可以拥有方法。\n\n  *函数的与众不同之处在于它们可以被调用。*\n  \n- **函数调用**\n  \n  调用一个函数时，将暂定当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数接收两个附加的参数：this和arguments。\n\n  在js中，一共有四种调用模式（这些模式在如何初始化关键参数this上存在差异）：\n  \n 1.   方法调用模式\n        \n      -- 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。\n\n```js\n// 创建myObject。它有一个value属性和一个increment方法。\n// increment方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1\n\nvar myObject ={\n  value: 0,\n  increment: function (inc) {\n      this.value += typeof inc === 'number' ? inc : 1;\n  }\n}\nmyObject.increment();\nconsole.log(myObject.value);  // 1\n\nmyObject.increment(2);\nconsole.log(muObject.value);  //3\n```\n方法可以使用this去访问对象，所以可以从对象中取值或修改该对象。\n\n 2.   函数调用模式\n  \n      -- 当一个函数并非一个对象的属性时，那么它被当作一个函数来调用：\n\n```js\nvar sum = add(3, 4);  // sum的值是7\n```\n当函数以此模式调用时，this被绑定到全局对象。\n\n 3.   构造器调用模式\n\n      -- 如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将会被绑定到那个新对象上。\n\n```js\n// 创建一个名为Quo的构造器函数。它构造一个代用status属性的对象\n\nvar Quo = function (string) {\n    this.status = string;\n}\n\nQuo.prototype.get_status = function() {\n    return this.status;\n}\n\nvar myQuo = new Quo(\"confused\");\n```\n 4.   apply调用模式\n\n      -- apply方法让我们构建一个参数数组并用其去调用函数。允许我们选择this的值。apply方法接收两个参数，第一个是将被绑定给this的值，第二个就是一个参数数组。\n\n\n```js\nvar statusObject = {\n    status: 'A-OK'\n};\n\n// statusObject并没有继承自Quo.prototype,但我们可以在statusObject上调\n// 用get_status方法，尽管statusObject并没有名为get_status的方法。\n\nvar status = Quo.prototype.get_status.apply(statusObject);  // status 值为 'A-OK'\n```\n- **闭包**\n\n  函数内部返回出去的对象或函数可以访问它被创建时所处的上下文环境。被称为闭包。\n  \n  \n```js\nvar myObject = function () {\n    var value = 0;\n    \n    return {\n        increment: function (inc) {\n            value += typeof inc === 'number' ? inc : 1;\n        },\n        getValue: function () {\n            return value;\n        }\n    }\n}();\n\n// 我们没有把一个函数赋值给myObject，而是将函数的返回结果赋值给了它。注意最后一行（）。\n// 该函数返回一个包含两个方法的对象，并且这些方法继续享有访问value变量的特权。\n\n\n\n// 创建一个名为quo的构造函数\n// 它构造出带有get_status方法和status私有属性的一个对象。\n\nvar quo = function (status) {\n    return {\n        get_status: function () {\n            return status;\n        }\n    }\n}\n\n// 构造一个quo的实例\n\nvar myQuo = quo(\"amazed\");\nconsole.log(myQuo.get_status());\n\n\n// 这个函数被设计称无须在前面加上new来使用，所以名字也没有首字母大写，\n// 调用quo时，返回带有get_status方法的新对象。该对象的一个引用保存在myQuo中\n// 。即使quo已经返回了，但get_status方法仍然享有访问quo对象的status属性的特权。\n// 它访问的就是该参数的本身而不是参数的拷贝。\n\n```\n- 记忆\n  \n  函数可以用对象去记住先前操作的结果，从而能避免无谓的运算。这种优化被称为记忆。\n\n  \n```js\n  // 不适用记忆，采用递归函数计算Fibonacci数列。\n  // 一个Fibonacci数字是之前两个Fibonacci数字之和。\n  // 最初是两个数字是0和1。\n  var fibonacci = function (n) {\n      return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n  };\n  for (var i = 0; i <= 10; i += 1) {\n      console.log('//' + i + ':' + fibonacci(i));\n  }\n  \n  \n  // 0: 0\n  // 1: 1\n  // 2: 1\n  // 3: 2\n  // 4: 3\n  // 5: 5\n  // 6: 8\n  // 7: 13\n  // 8: 21\n  // 9: 34\n  // 10: 55\n```\n  虽然这样是可以工作的，但它做了很多无谓的工作。fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少它的运算量。\n\n\n```js\n  // 使用memo数组保存计算结果,采用闭包的形式\n  \n  var fibonacci = function () {\n      var memo = [0 ,1];\n      var fib = function (n) {\n          var result = memo[n];\n          if (typeof result !== 'number') {\n              result = fib(n - 1) + fib(n - 2);\n              memo[n] = result;\n          }\n          return result\n      }\n      return fib;\n  }();\n```\n\n  这个函数返回同样的结果，但它只被调用了29次。我们调用了11次。它自身调用了18次去取的计算结果。\n\n  我们可以编写一个函数来帮助我们构造带记忆功能的函数。memoizer函数将取的一个初始的memo数组和fundamental函数。\n\n\n```js\n  var memoizer = function (memo, fundamental) {\n      var shell = function (n) {\n          var result = memo[n];\n          if(typeof result !== 'number') {\n              result = fundamental(shell, n);\n              memo[n] = result;\n          }\n          return result;\n      };\n      return shell;\n  }\n  \n  // 使用memoizer来定义fibonacci函数\n  \n  var fibonacci = memoizer([0 ,1], function (shell, n){\n      return shell(n - 1) + shell(n - 2);\n  });\n  \n  //  通过设计能产生出其他函数的函数，可以极大减少我们必须要做的工作。\n  //  产生一个可以记忆的阶乘函数，我们只需提供基本的阶乘公式即可：\n\n  var factorial = memoizer([1, 1], function (shell, n){\n      return n * shell(n - 1);\n  })\n```\n\n- 全局变量\n\n  js所有糟糕的特性之中最为糟糕的就是它对全局变量的依赖性。全局变量就是在所有作用域中都可见的变量。全局变量可以被程序的任何部分在任何时间改变，它们会使得程序的行为被极大地复杂化。在程序中使用全局变量降低了程序的可靠性。\n  \n  全局变量使得在同一个程序中运行独立的子程序变得更难，如果某些全局变量的名称碰巧和子程序中的变量名称相同，那么它们将会相互冲突并可能导致程序无法运行，而且通常难以调试。\n  \n  定义全局变量有三种方式：\n  \n```js\n// 第一种脱离任何函数安排一个var语句：\n    var foo = value;\n    \n// 第二种是直接添加一个属性到全局对象上。\n// 全局对象是所有全局变量的容器。\n// 在Web浏览器里，全局对象名为window\n\n    window.foo = value;\n    \n// 第三种是直接使用未经声明的变量。这被称为隐式的全局变量\n\n    foo = value;\n```\n\n- 自动插入分号\n\n  js有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。\n  \n  如果一个return语句返回一个值，这个值表达式开始部分必须和return在同一行上。\n  \n  \n```js\n    return\n    {\n        status: true\n    }\n    /*\n        上述代码看起来是要返回一个包含status成员元素的对象，不幸的是，自动插入分号让它变成了返回undefined。\n        如果把{放在上一行的尾部而不是下一行的头部就可以避免该问题\n    */\n    \n    return {\n        status: true\n    }\n```\n\n- typeof\n\n  typeof运算符返回一个用于表示其运算数类型的字符串。\n  \n  \n```js\n typeof 98.6  // number\n typeof null // 返回object而不是null\n \n // typeof不能辨别出null与对象，可以像下面这样做\n // 因为null值为假，而所有对象值为真\n \n // my_value === null;\n if(my_value && typeof my_value === 'object') {\n     // my_value是一个对象或数组\n }\n```\n- parseInt\n\n  parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析，所以parseInt(\"16\")与parseInt(\"16 tons\")产生相同的结果。\n  \n  如果该字符串第一个字符是0，那么该字符串将被基于八进制而不是十进制来求值。在八进制中，8和9不是数字，所依parseInt(\"08\")和parseInt(\"09\")产生0作为结果。这个错误导致了程序解析日期和时间时出现问题。幸运的是，parseInt可以接受一个基数作为参数，parseInt(\"08\",10)结果为8。使用parseInt总是提供这个基数参数是有必要的。\n  \n- '+'\n\n  '+'运算符可以用于加法运算或字符串连接。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，它返回两者之和。如果你打算用+去做加法运算，请确保两个运算数都是整数。\n  \n- NaN\n\n  NaN是IEEE754中定义的一个特殊的数量值，它表示不是一个数字。\n  \n  ```js\n  typeof NaN === 'number'  // true\n  \n  // 该值可能会在试图将非数字形式的字符串转换为数字时产生。\n  \n  + '0'  // 0\n  + 'aksk' // NaN\n  \n  // 需要注意的是，如果你有一个公式链产生出NaN的结果，那么至少其中一个输入项是NaN，或者在某个地方产生了NaN。\n  \n  // NaN不等同与它自己\n  \n  NaN === NaN   // false\n  NaN !== NaN   // true\n  \n  // js提供了isNaN函数检测是否是NaN\n  \n  isNaN(NaN);   // true\n  isNaN(0);   // false\n  isNaN('asnsnsn');   // ture\n  isNaN('0');  // false\n  ```\n  \n  判断一个值是否可用做数字的最佳方法是使用isFinite函数，因为它会筛除掉NaN和Infinity。不幸的是，isFinite会试图把它的运算数转换为一个数字，所以，如果值事实上不是一个数字，它就不是一个好的测试。可以自己定义isNumber函数：\n  \n  ```js\n    function isNumber(value) {\n        return typeof value === 'number' && isFinite(value);\n    }\n  ```\n  \n- 伪数组\n\n  js没有真正的数组。\n  \n  typeof运算符不能辨别数组和对象。要判断一个值是否为数组，必须要检查它的constructor属性：\n  \n  \n```js\n    if(my_value && typeof my_value === 'object' && my_value.constructor === Array) {\n        // my_value是一个数组\n    }\n```\n上面的检测对于在不同的帧或窗口创建的数组将会给出false。当数组有可能哎其他的帧中被创建时，下面的检测更为可靠：\n\n\n```js\n    if(my_value && typeof my_value === 'object' && typeof my_value.length === 'number' && !(my_value.propertyIsEnumerable('length'))) {\n        // my_value确实是一个数组\n    }\n```\n\n-  ==\n\n  js有两组相等运算符：=== 和 !==，以及 == 和 !=。 === 和 !==这一组运算符会按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么 === 返回 true，而 !==返回false。而 == 和 !=只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型时，它们试图去强制转换类型。\n  \n  \n```js\n '' == '0'   // false\n 0 == ''     // true\n 0 == '0'    // true\n \n false == 'false'  // false\n false == '0'  // true\n \n false == undefined  // false\n false == null    // false\n null == undefined   // true\n\n```\n== 运算符对传递性的缺乏值得我们警惕。建议永远不要用== 和 !=。始终使用 === 和 !==。\n\n> 传递性是一种编程约定。可以这么去理解：对于任意的引用值x、y和z，如果x == y和y == z为true，那么x == z 为true。而js中的==运算符在某些特例上违背了传递性。\n\n****\n\n**避免使用with语句，with语句严重影响了js处理器的速度，因为它阻止了变量名的词法作用域绑定。**\n\n****\n\n**避免使用eval。使用它会使得性能显著降低，因为它须运行编译器。**\n* Function构造器是eval的另一种形式，所以它同样也应该被避免使用。\n* 浏览器提供的setTimeout和setInterval函数，它们能接受字符串参数或函数参数。当传递的是字符串参数时，setTimeout和setInterval会像eval那样去处理。字符串参数形式也应该被避免使用。\n\n****\n\n**continue语句**\n\ncontinue语句跳到循环的顶部。通过移除continue语句后，性能会得到改善。\n\n****\n\n**switch贯穿**\n\n使用switch语句时，每一个条件都是需要添加break，防止上一个case条件向下贯穿到另一个case条件。\n\n****\n\n**function语句对比函数表达式**\n\njs中既有function语句，同时也有函数表达式。这是令人困惑的，因为它们看起来就是相同的。一个function语句就是其值为一个函数法人var语句的速记形式。\n\n\n```js\n    // 下面语句：\n    function foo () {}\n    \n    //意思相当于：\n    var foo = function foo() {};\n```\n\n第二种形式能明确表示foo是一个包含一个函数值的变量。function语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域的顶层。禁止在if语句中声明function语句。\n\n一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句。解决方法就是把函数表达式括在一个圆括号之中。\n\n\n```js\n    (function () {\n        var hidden_variable;\n        \n        // 这个函数可能对环境有一些影响，但不会引入新的全局变量\n    })\n```\n\n****\n\n**在使用new运算符创建新对象时，千万别忘了new，否则会造成this被绑定到全局对象，而不是新创建的对象。**","slug":"JavaScript语言精粹笔记","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr97000k1xop1xmx4j0u","content":"<h3 id=\"JavaScript语言精粹\"><a href=\"#JavaScript语言精粹\" class=\"headerlink\" title=\"JavaScript语言精粹\"></a>JavaScript语言精粹</h3><ul>\n<li><p><strong>对象枚举</strong></p>\n<p>for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性—所以有必要过滤掉那些你不想要的值。通常使用的过滤器是<code>hasOwnProperty</code>方法，以及使用<code>typeof</code>来排除函数。</p>\n<p>原型链中的任何属性通过typeof判断：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">.</span>toString    <span class=\"token comment\" spellcheck=\"true\">// 'function'</span>\n<span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">.</span>constructor  <span class=\"token comment\" spellcheck=\"true\">// 'function'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//通过typeof来排除原型中的属性</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行其他</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//通过hasOwnProperty来排除原型中的属性</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行其他</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'first-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'middle-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'last-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'profession'</span>\n<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> properties<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    obj<span class=\"token punctuation\">[</span>properties<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>删除对象中的属性</strong></p>\n<p><code>delete</code>运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。</p>\n</li>\n<li><p><strong>减少全局变量污染</strong></p>\n<p>js可以很随意的定义那些可保存所有应用资源的全局变量。不幸的是，全局变量削弱了程序的灵活性，所以应该避免。</p>\n<p>最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> MYAPP <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>  该变量此时变成了你的应用的容器：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">MYAPP<span class=\"token punctuation\">.</span>stooge <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Tom\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"age\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nMYAPP<span class=\"token punctuation\">.</span>flight <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    airline<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Oceanic\"</span><span class=\"token punctuation\">,</span>\n    number<span class=\"token punctuation\">:</span> <span class=\"token number\">88</span><span class=\"token punctuation\">,</span>\n    departure<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        time<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2019-03-20 12:55\"</span><span class=\"token punctuation\">,</span>\n        city<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Sydney\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。程序也会变得更易读。</p>\n<ul>\n<li><p><strong>函数对象</strong></p>\n<p>在js中函数就是对象。对象是一个“名/值”对的集合，并且拥有一个连到原型对象的隐藏连接。对象字面量产生的对象连接到<code>Object.prototype</code>。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。</p>\n<p>因为函数是对象，所以它们可以像任何其他的值一样被使用。函数可以存放在变量、对象和数组中，函数也可以被当做参数传递给其他函数，函数也可以再返回函数。而且因为函数是对象，所以函数可以拥有方法。</p>\n<p><em>函数的与众不同之处在于它们可以被调用。</em></p>\n</li>\n<li><p><strong>函数调用</strong></p>\n<p>调用一个函数时，将暂定当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数接收两个附加的参数：this和arguments。</p>\n<p>在js中，一共有四种调用模式（这些模式在如何初始化关键参数this上存在差异）：</p>\n<ol>\n<li><p>方法调用模式</p>\n<p>– 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。</p>\n</li>\n</ol>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 创建myObject。它有一个value属性和一个increment方法。</span>\n<span class=\"token comment\" spellcheck=\"true\">// increment方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1</span>\n\n<span class=\"token keyword\">var</span> myObject <span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n  increment<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>inc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> inc <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span> <span class=\"token operator\">?</span> inc <span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nmyObject<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myObject<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 1</span>\n\nmyObject<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>muObject<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//3</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>方法可以使用this去访问对象，所以可以从对象中取值或修改该对象。</p>\n<ol start=\"2\">\n<li><p>函数调用模式</p>\n<p>– 当一个函数并非一个对象的属性时，那么它被当作一个函数来调用：</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// sum的值是7</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当函数以此模式调用时，this被绑定到全局对象。</p>\n<ol start=\"3\">\n<li><p>构造器调用模式</p>\n<p>– 如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将会被绑定到那个新对象上。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 创建一个名为Quo的构造器函数。它构造一个代用status属性的对象</span>\n\n<span class=\"token keyword\">var</span> Quo <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> string<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nQuo<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>get_status <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> myQuo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Quo</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"confused\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"4\">\n<li><p>apply调用模式</p>\n<p>– apply方法让我们构建一个参数数组并用其去调用函数。允许我们选择this的值。apply方法接收两个参数，第一个是将被绑定给this的值，第二个就是一个参数数组。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> statusObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    status<span class=\"token punctuation\">:</span> <span class=\"token string\">'A-OK'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// statusObject并没有继承自Quo.prototype,但我们可以在statusObject上调</span>\n<span class=\"token comment\" spellcheck=\"true\">// 用get_status方法，尽管statusObject并没有名为get_status的方法。</span>\n\n<span class=\"token keyword\">var</span> status <span class=\"token operator\">=</span> Quo<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>get_status<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>statusObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// status 值为 'A-OK'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p><strong>闭包</strong></p>\n<p>函数内部返回出去的对象或函数可以访问它被创建时所处的上下文环境。被称为闭包。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myObject <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        increment<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>inc<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            value <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token keyword\">typeof</span> inc <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span> <span class=\"token operator\">?</span> inc <span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        getValue<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 我们没有把一个函数赋值给myObject，而是将函数的返回结果赋值给了它。注意最后一行（）。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 该函数返回一个包含两个方法的对象，并且这些方法继续享有访问value变量的特权。</span>\n\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建一个名为quo的构造函数</span>\n<span class=\"token comment\" spellcheck=\"true\">// 它构造出带有get_status方法和status私有属性的一个对象。</span>\n\n<span class=\"token keyword\">var</span> quo <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        get_status<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> status<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 构造一个quo的实例</span>\n\n<span class=\"token keyword\">var</span> myQuo <span class=\"token operator\">=</span> <span class=\"token function\">quo</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"amazed\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myQuo<span class=\"token punctuation\">.</span><span class=\"token function\">get_status</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">// 这个函数被设计称无须在前面加上new来使用，所以名字也没有首字母大写，</span>\n<span class=\"token comment\" spellcheck=\"true\">// 调用quo时，返回带有get_status方法的新对象。该对象的一个引用保存在myQuo中</span>\n<span class=\"token comment\" spellcheck=\"true\">// 。即使quo已经返回了，但get_status方法仍然享有访问quo对象的status属性的特权。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 它访问的就是该参数的本身而不是参数的拷贝。</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>记忆</p>\n<p>函数可以用对象去记住先前操作的结果，从而能避免无谓的运算。这种优化被称为记忆。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token comment\" spellcheck=\"true\">// 不适用记忆，采用递归函数计算Fibonacci数列。</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 一个Fibonacci数字是之前两个Fibonacci数字之和。</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 最初是两个数字是0和1。</span>\n  <span class=\"token keyword\">var</span> fibonacci <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token operator\">?</span> n <span class=\"token punctuation\">:</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'//'</span> <span class=\"token operator\">+</span> i <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\" spellcheck=\"true\">// 0: 0</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 1: 1</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 2: 1</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 3: 2</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 4: 3</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 5: 5</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 6: 8</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 7: 13</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 8: 21</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 9: 34</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 10: 55</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  虽然这样是可以工作的，但它做了很多无谓的工作。fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少它的运算量。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token comment\" spellcheck=\"true\">// 使用memo数组保存计算结果,采用闭包的形式</span>\n\n  <span class=\"token keyword\">var</span> fibonacci <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> memo <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">var</span> fib <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> result <span class=\"token operator\">!==</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              result <span class=\"token operator\">=</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">return</span> result\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> fib<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>  这个函数返回同样的结果，但它只被调用了29次。我们调用了11次。它自身调用了18次去取的计算结果。</p>\n<p>  我们可以编写一个函数来帮助我们构造带记忆功能的函数。memoizer函数将取的一个初始的memo数组和fundamental函数。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">var</span> memoizer <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>memo<span class=\"token punctuation\">,</span> fundamental<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">var</span> shell <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> result <span class=\"token operator\">!==</span> <span class=\"token string\">'number'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              result <span class=\"token operator\">=</span> <span class=\"token function\">fundamental</span><span class=\"token punctuation\">(</span>shell<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              memo<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> shell<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 使用memoizer来定义fibonacci函数</span>\n\n  <span class=\"token keyword\">var</span> fibonacci <span class=\"token operator\">=</span> <span class=\"token function\">memoizer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>shell<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">shell</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">shell</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//  通过设计能产生出其他函数的函数，可以极大减少我们必须要做的工作。</span>\n  <span class=\"token comment\" spellcheck=\"true\">//  产生一个可以记忆的阶乘函数，我们只需提供基本的阶乘公式即可：</span>\n\n  <span class=\"token keyword\">var</span> factorial <span class=\"token operator\">=</span> <span class=\"token function\">memoizer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>shell<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">shell</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>全局变量</p>\n<p>js所有糟糕的特性之中最为糟糕的就是它对全局变量的依赖性。全局变量就是在所有作用域中都可见的变量。全局变量可以被程序的任何部分在任何时间改变，它们会使得程序的行为被极大地复杂化。在程序中使用全局变量降低了程序的可靠性。</p>\n<p>全局变量使得在同一个程序中运行独立的子程序变得更难，如果某些全局变量的名称碰巧和子程序中的变量名称相同，那么它们将会相互冲突并可能导致程序无法运行，而且通常难以调试。</p>\n<p>定义全局变量有三种方式：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 第一种脱离任何函数安排一个var语句：</span>\n    <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 第二种是直接添加一个属性到全局对象上。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 全局对象是所有全局变量的容器。</span>\n<span class=\"token comment\" spellcheck=\"true\">// 在Web浏览器里，全局对象名为window</span>\n\n    window<span class=\"token punctuation\">.</span>foo <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 第三种是直接使用未经声明的变量。这被称为隐式的全局变量</span>\n\n    foo <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>自动插入分号</p>\n<p>js有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。</p>\n<p>如果一个return语句返回一个值，这个值表达式开始部分必须和return在同一行上。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token keyword\">return</span>\n    <span class=\"token punctuation\">{</span>\n        status<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n        上述代码看起来是要返回一个包含status成员元素的对象，不幸的是，自动插入分号让它变成了返回undefined。\n        如果把{放在上一行的尾部而不是下一行的头部就可以避免该问题\n    */</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        status<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>typeof</p>\n<p>typeof运算符返回一个用于表示其运算数类型的字符串。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token keyword\">typeof</span> <span class=\"token number\">98.6</span>  <span class=\"token comment\" spellcheck=\"true\">// number</span>\n <span class=\"token keyword\">typeof</span> <span class=\"token keyword\">null</span> <span class=\"token comment\" spellcheck=\"true\">// 返回object而不是null</span>\n\n <span class=\"token comment\" spellcheck=\"true\">// typeof不能辨别出null与对象，可以像下面这样做</span>\n <span class=\"token comment\" spellcheck=\"true\">// 因为null值为假，而所有对象值为真</span>\n\n <span class=\"token comment\" spellcheck=\"true\">// my_value === null;</span>\n <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>my_value <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> my_value <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\" spellcheck=\"true\">// my_value是一个对象或数组</span>\n <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>parseInt</p>\n<p>parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析，所以parseInt(“16”)与parseInt(“16 tons”)产生相同的结果。</p>\n<p>如果该字符串第一个字符是0，那么该字符串将被基于八进制而不是十进制来求值。在八进制中，8和9不是数字，所依parseInt(“08”)和parseInt(“09”)产生0作为结果。这个错误导致了程序解析日期和时间时出现问题。幸运的是，parseInt可以接受一个基数作为参数，parseInt(“08”,10)结果为8。使用parseInt总是提供这个基数参数是有必要的。</p>\n</li>\n<li><p>‘+’</p>\n<p>‘+’运算符可以用于加法运算或字符串连接。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，它返回两者之和。如果你打算用+去做加法运算，请确保两个运算数都是整数。</p>\n</li>\n<li><p>NaN</p>\n<p>NaN是IEEE754中定义的一个特殊的数量值，它表示不是一个数字。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">typeof</span> <span class=\"token number\">NaN</span> <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span>  <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 该值可能会在试图将非数字形式的字符串转换为数字时产生。</span>\n\n<span class=\"token operator\">+</span> <span class=\"token string\">'0'</span>  <span class=\"token comment\" spellcheck=\"true\">// 0</span>\n<span class=\"token operator\">+</span> <span class=\"token string\">'aksk'</span> <span class=\"token comment\" spellcheck=\"true\">// NaN</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 需要注意的是，如果你有一个公式链产生出NaN的结果，那么至少其中一个输入项是NaN，或者在某个地方产生了NaN。</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// NaN不等同与它自己</span>\n\n<span class=\"token number\">NaN</span> <span class=\"token operator\">===</span> <span class=\"token number\">NaN</span>   <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token number\">NaN</span> <span class=\"token operator\">!==</span> <span class=\"token number\">NaN</span>   <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// js提供了isNaN函数检测是否是NaN</span>\n\n<span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// true</span>\n<span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span><span class=\"token string\">'asnsnsn'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// ture</span>\n<span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span><span class=\"token string\">'0'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// false</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>判断一个值是否可用做数字的最佳方法是使用isFinite函数，因为它会筛除掉NaN和Infinity。不幸的是，isFinite会试图把它的运算数转换为一个数字，所以，如果值事实上不是一个数字，它就不是一个好的测试。可以自己定义isNumber函数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">  <span class=\"token keyword\">function</span> <span class=\"token function\">isNumber</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> value <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">isFinite</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>伪数组</p>\n<p>js没有真正的数组。</p>\n<p>typeof运算符不能辨别数组和对象。要判断一个值是否为数组，必须要检查它的constructor属性：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>my_value <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> my_value <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> my_value<span class=\"token punctuation\">.</span>constructor <span class=\"token operator\">===</span> Array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// my_value是一个数组</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>上面的检测对于在不同的帧或窗口创建的数组将会给出false。当数组有可能哎其他的帧中被创建时，下面的检测更为可靠：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>my_value <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> my_value <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> my_value<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token string\">'number'</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>my_value<span class=\"token punctuation\">.</span><span class=\"token function\">propertyIsEnumerable</span><span class=\"token punctuation\">(</span><span class=\"token string\">'length'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// my_value确实是一个数组</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>==</p>\n<p>js有两组相等运算符：=== 和 !==，以及 == 和 !=。 === 和 !==这一组运算符会按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么 === 返回 true，而 !==返回false。而 == 和 !=只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型时，它们试图去强制转换类型。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"> <span class=\"token string\">''</span> <span class=\"token operator\">==</span> <span class=\"token string\">'0'</span>   <span class=\"token comment\" spellcheck=\"true\">// false</span>\n <span class=\"token number\">0</span> <span class=\"token operator\">==</span> <span class=\"token string\">''</span>     <span class=\"token comment\" spellcheck=\"true\">// true</span>\n <span class=\"token number\">0</span> <span class=\"token operator\">==</span> <span class=\"token string\">'0'</span>    <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n <span class=\"token boolean\">false</span> <span class=\"token operator\">==</span> <span class=\"token string\">'false'</span>  <span class=\"token comment\" spellcheck=\"true\">// false</span>\n <span class=\"token boolean\">false</span> <span class=\"token operator\">==</span> <span class=\"token string\">'0'</span>  <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n <span class=\"token boolean\">false</span> <span class=\"token operator\">==</span> undefined  <span class=\"token comment\" spellcheck=\"true\">// false</span>\n <span class=\"token boolean\">false</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span>    <span class=\"token comment\" spellcheck=\"true\">// false</span>\n <span class=\"token keyword\">null</span> <span class=\"token operator\">==</span> undefined   <span class=\"token comment\" spellcheck=\"true\">// true</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>== 运算符对传递性的缺乏值得我们警惕。建议永远不要用== 和 !=。始终使用 === 和 !==。</p>\n<blockquote>\n<p>传递性是一种编程约定。可以这么去理解：对于任意的引用值x、y和z，如果x == y和y == z为true，那么x == z 为true。而js中的==运算符在某些特例上违背了传递性。</p>\n</blockquote>\n<hr>\n<p><strong>避免使用with语句，with语句严重影响了js处理器的速度，因为它阻止了变量名的词法作用域绑定。</strong></p>\n<hr>\n<p><strong>避免使用eval。使用它会使得性能显著降低，因为它须运行编译器。</strong></p>\n<ul>\n<li>Function构造器是eval的另一种形式，所以它同样也应该被避免使用。</li>\n<li>浏览器提供的setTimeout和setInterval函数，它们能接受字符串参数或函数参数。当传递的是字符串参数时，setTimeout和setInterval会像eval那样去处理。字符串参数形式也应该被避免使用。</li>\n</ul>\n<hr>\n<p><strong>continue语句</strong></p>\n<p>continue语句跳到循环的顶部。通过移除continue语句后，性能会得到改善。</p>\n<hr>\n<p><strong>switch贯穿</strong></p>\n<p>使用switch语句时，每一个条件都是需要添加break，防止上一个case条件向下贯穿到另一个case条件。</p>\n<hr>\n<p><strong>function语句对比函数表达式</strong></p>\n<p>js中既有function语句，同时也有函数表达式。这是令人困惑的，因为它们看起来就是相同的。一个function语句就是其值为一个函数法人var语句的速记形式。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token comment\" spellcheck=\"true\">// 下面语句：</span>\n    <span class=\"token keyword\">function</span> foo <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//意思相当于：</span>\n    <span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>第二种形式能明确表示foo是一个包含一个函数值的变量。function语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域的顶层。禁止在if语句中声明function语句。</p>\n<p>一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句。解决方法就是把函数表达式括在一个圆括号之中。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> hidden_variable<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 这个函数可能对环境有一些影响，但不会引入新的全局变量</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<p><strong>在使用new运算符创建新对象时，千万别忘了new，否则会造成this被绑定到全局对象，而不是新创建的对象。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JavaScript语言精粹\"><a href=\"#JavaScript语言精粹\" class=\"headerlink\" title=\"JavaScript语言精粹\"></a>JavaScript语言精粹</h3><ul>\n<li><p><strong>对象枚举</strong></p>\n<p>for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性—所以有必要过滤掉那些你不想要的值。通常使用的过滤器是<code>hasOwnProperty</code>方法，以及使用<code>typeof</code>来排除函数。</p>\n<p>原型链中的任何属性通过typeof判断：</p>\n<pre><code class=\"js\">typeof obj.toString    // &#39;function&#39;\ntypeof obj.constructor  // &#39;function&#39;\n</code></pre>\n<pre><code class=\"js\">var name;\n//通过typeof来排除原型中的属性\nfor(name in obj) {\n    if(typeof obj[name] !== &#39;function&#39;) {\n        //执行其他\n    }\n}\n//通过hasOwnProperty来排除原型中的属性\nfor(name in obj) {\n    if(obj.hasOwnProperty(name)) {\n        //执行其他\n    }\n}\n</code></pre>\n<p>在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。</p>\n<pre><code class=\"js\">var i;\nvar properties = [\n    &#39;first-name&#39;,\n    &#39;middle-name&#39;,\n    &#39;last-name&#39;,\n    &#39;profession&#39;\n]\nfor(i = 0; i &lt; properties.length; i += 1) {\n    obj[properties[i]];\n}\n</code></pre>\n</li>\n<li><p><strong>删除对象中的属性</strong></p>\n<p><code>delete</code>运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。</p>\n</li>\n<li><p><strong>减少全局变量污染</strong></p>\n<p>js可以很随意的定义那些可保存所有应用资源的全局变量。不幸的是，全局变量削弱了程序的灵活性，所以应该避免。</p>\n<p>最小化使用全局变量的一个方法是在你的应用中只创建唯一一个全局变量：</p>\n</li>\n</ul>\n<pre><code class=\"js\">var MYAPP = {};\n</code></pre>\n<p>  该变量此时变成了你的应用的容器：</p>\n<pre><code class=\"js\">MYAPP.stooge = {\n    &quot;name&quot;: &quot;Tom&quot;,\n    &quot;age&quot;: 20\n};\nMYAPP.flight = {\n    airline: &quot;Oceanic&quot;,\n    number: 88,\n    departure: {\n        time: &quot;2019-03-20 12:55&quot;,\n        city: &quot;Sydney&quot;\n    }\n}\n</code></pre>\n<p>只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。程序也会变得更易读。</p>\n<ul>\n<li><p><strong>函数对象</strong></p>\n<p>在js中函数就是对象。对象是一个“名/值”对的集合，并且拥有一个连到原型对象的隐藏连接。对象字面量产生的对象连接到<code>Object.prototype</code>。函数对象连接到<code>Function.prototype</code>（该原型对象本身连接到<code>Object.prototype</code>）。每个函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。</p>\n<p>因为函数是对象，所以它们可以像任何其他的值一样被使用。函数可以存放在变量、对象和数组中，函数也可以被当做参数传递给其他函数，函数也可以再返回函数。而且因为函数是对象，所以函数可以拥有方法。</p>\n<p><em>函数的与众不同之处在于它们可以被调用。</em></p>\n</li>\n<li><p><strong>函数调用</strong></p>\n<p>调用一个函数时，将暂定当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数接收两个附加的参数：this和arguments。</p>\n<p>在js中，一共有四种调用模式（这些模式在如何初始化关键参数this上存在差异）：</p>\n<ol>\n<li><p>方法调用模式</p>\n<p>– 当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。</p>\n</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"js\">// 创建myObject。它有一个value属性和一个increment方法。\n// increment方法接受一个可选的参数。如果参数不是数字，那么默认使用数字1\n\nvar myObject ={\n  value: 0,\n  increment: function (inc) {\n      this.value += typeof inc === &#39;number&#39; ? inc : 1;\n  }\n}\nmyObject.increment();\nconsole.log(myObject.value);  // 1\n\nmyObject.increment(2);\nconsole.log(muObject.value);  //3\n</code></pre>\n<p>方法可以使用this去访问对象，所以可以从对象中取值或修改该对象。</p>\n<ol start=\"2\">\n<li><p>函数调用模式</p>\n<p>– 当一个函数并非一个对象的属性时，那么它被当作一个函数来调用：</p>\n</li>\n</ol>\n<pre><code class=\"js\">var sum = add(3, 4);  // sum的值是7\n</code></pre>\n<p>当函数以此模式调用时，this被绑定到全局对象。</p>\n<ol start=\"3\">\n<li><p>构造器调用模式</p>\n<p>– 如果在一个函数前面带上new来调用，那么将创建一个隐藏连接到该函数的prototype成员的新对象，同时this将会被绑定到那个新对象上。</p>\n</li>\n</ol>\n<pre><code class=\"js\">// 创建一个名为Quo的构造器函数。它构造一个代用status属性的对象\n\nvar Quo = function (string) {\n    this.status = string;\n}\n\nQuo.prototype.get_status = function() {\n    return this.status;\n}\n\nvar myQuo = new Quo(&quot;confused&quot;);\n</code></pre>\n<ol start=\"4\">\n<li><p>apply调用模式</p>\n<p>– apply方法让我们构建一个参数数组并用其去调用函数。允许我们选择this的值。apply方法接收两个参数，第一个是将被绑定给this的值，第二个就是一个参数数组。</p>\n</li>\n</ol>\n<pre><code class=\"js\">var statusObject = {\n    status: &#39;A-OK&#39;\n};\n\n// statusObject并没有继承自Quo.prototype,但我们可以在statusObject上调\n// 用get_status方法，尽管statusObject并没有名为get_status的方法。\n\nvar status = Quo.prototype.get_status.apply(statusObject);  // status 值为 &#39;A-OK&#39;\n</code></pre>\n<ul>\n<li><p><strong>闭包</strong></p>\n<p>函数内部返回出去的对象或函数可以访问它被创建时所处的上下文环境。被称为闭包。</p>\n</li>\n</ul>\n<pre><code class=\"js\">var myObject = function () {\n    var value = 0;\n\n    return {\n        increment: function (inc) {\n            value += typeof inc === &#39;number&#39; ? inc : 1;\n        },\n        getValue: function () {\n            return value;\n        }\n    }\n}();\n\n// 我们没有把一个函数赋值给myObject，而是将函数的返回结果赋值给了它。注意最后一行（）。\n// 该函数返回一个包含两个方法的对象，并且这些方法继续享有访问value变量的特权。\n\n\n\n// 创建一个名为quo的构造函数\n// 它构造出带有get_status方法和status私有属性的一个对象。\n\nvar quo = function (status) {\n    return {\n        get_status: function () {\n            return status;\n        }\n    }\n}\n\n// 构造一个quo的实例\n\nvar myQuo = quo(&quot;amazed&quot;);\nconsole.log(myQuo.get_status());\n\n\n// 这个函数被设计称无须在前面加上new来使用，所以名字也没有首字母大写，\n// 调用quo时，返回带有get_status方法的新对象。该对象的一个引用保存在myQuo中\n// 。即使quo已经返回了，但get_status方法仍然享有访问quo对象的status属性的特权。\n// 它访问的就是该参数的本身而不是参数的拷贝。\n\n</code></pre>\n<ul>\n<li><p>记忆</p>\n<p>函数可以用对象去记住先前操作的结果，从而能避免无谓的运算。这种优化被称为记忆。</p>\n</li>\n</ul>\n<pre><code class=\"js\">  // 不适用记忆，采用递归函数计算Fibonacci数列。\n  // 一个Fibonacci数字是之前两个Fibonacci数字之和。\n  // 最初是两个数字是0和1。\n  var fibonacci = function (n) {\n      return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n  };\n  for (var i = 0; i &lt;= 10; i += 1) {\n      console.log(&#39;//&#39; + i + &#39;:&#39; + fibonacci(i));\n  }\n\n\n  // 0: 0\n  // 1: 1\n  // 2: 1\n  // 3: 2\n  // 4: 3\n  // 5: 5\n  // 6: 8\n  // 7: 13\n  // 8: 21\n  // 9: 34\n  // 10: 55\n</code></pre>\n<p>  虽然这样是可以工作的，但它做了很多无谓的工作。fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让该函数具备记忆功能，就可以显著地减少它的运算量。</p>\n<pre><code class=\"js\">  // 使用memo数组保存计算结果,采用闭包的形式\n\n  var fibonacci = function () {\n      var memo = [0 ,1];\n      var fib = function (n) {\n          var result = memo[n];\n          if (typeof result !== &#39;number&#39;) {\n              result = fib(n - 1) + fib(n - 2);\n              memo[n] = result;\n          }\n          return result\n      }\n      return fib;\n  }();\n</code></pre>\n<p>  这个函数返回同样的结果，但它只被调用了29次。我们调用了11次。它自身调用了18次去取的计算结果。</p>\n<p>  我们可以编写一个函数来帮助我们构造带记忆功能的函数。memoizer函数将取的一个初始的memo数组和fundamental函数。</p>\n<pre><code class=\"js\">  var memoizer = function (memo, fundamental) {\n      var shell = function (n) {\n          var result = memo[n];\n          if(typeof result !== &#39;number&#39;) {\n              result = fundamental(shell, n);\n              memo[n] = result;\n          }\n          return result;\n      };\n      return shell;\n  }\n\n  // 使用memoizer来定义fibonacci函数\n\n  var fibonacci = memoizer([0 ,1], function (shell, n){\n      return shell(n - 1) + shell(n - 2);\n  });\n\n  //  通过设计能产生出其他函数的函数，可以极大减少我们必须要做的工作。\n  //  产生一个可以记忆的阶乘函数，我们只需提供基本的阶乘公式即可：\n\n  var factorial = memoizer([1, 1], function (shell, n){\n      return n * shell(n - 1);\n  })\n</code></pre>\n<ul>\n<li><p>全局变量</p>\n<p>js所有糟糕的特性之中最为糟糕的就是它对全局变量的依赖性。全局变量就是在所有作用域中都可见的变量。全局变量可以被程序的任何部分在任何时间改变，它们会使得程序的行为被极大地复杂化。在程序中使用全局变量降低了程序的可靠性。</p>\n<p>全局变量使得在同一个程序中运行独立的子程序变得更难，如果某些全局变量的名称碰巧和子程序中的变量名称相同，那么它们将会相互冲突并可能导致程序无法运行，而且通常难以调试。</p>\n<p>定义全局变量有三种方式：</p>\n</li>\n</ul>\n<pre><code class=\"js\">// 第一种脱离任何函数安排一个var语句：\n    var foo = value;\n\n// 第二种是直接添加一个属性到全局对象上。\n// 全局对象是所有全局变量的容器。\n// 在Web浏览器里，全局对象名为window\n\n    window.foo = value;\n\n// 第三种是直接使用未经声明的变量。这被称为隐式的全局变量\n\n    foo = value;\n</code></pre>\n<ul>\n<li><p>自动插入分号</p>\n<p>js有一个机制，它试图通过自动插入分号来修正有缺损的程序。千万不要依靠它，它可能会掩盖更为严重的错误。</p>\n<p>如果一个return语句返回一个值，这个值表达式开始部分必须和return在同一行上。</p>\n</li>\n</ul>\n<pre><code class=\"js\">    return\n    {\n        status: true\n    }\n    /*\n        上述代码看起来是要返回一个包含status成员元素的对象，不幸的是，自动插入分号让它变成了返回undefined。\n        如果把{放在上一行的尾部而不是下一行的头部就可以避免该问题\n    */\n\n    return {\n        status: true\n    }\n</code></pre>\n<ul>\n<li><p>typeof</p>\n<p>typeof运算符返回一个用于表示其运算数类型的字符串。</p>\n</li>\n</ul>\n<pre><code class=\"js\"> typeof 98.6  // number\n typeof null // 返回object而不是null\n\n // typeof不能辨别出null与对象，可以像下面这样做\n // 因为null值为假，而所有对象值为真\n\n // my_value === null;\n if(my_value &amp;&amp; typeof my_value === &#39;object&#39;) {\n     // my_value是一个对象或数组\n }\n</code></pre>\n<ul>\n<li><p>parseInt</p>\n<p>parseInt是一个将字符串转换为整数的函数。它在遇到非数字时停止解析，所以parseInt(“16”)与parseInt(“16 tons”)产生相同的结果。</p>\n<p>如果该字符串第一个字符是0，那么该字符串将被基于八进制而不是十进制来求值。在八进制中，8和9不是数字，所依parseInt(“08”)和parseInt(“09”)产生0作为结果。这个错误导致了程序解析日期和时间时出现问题。幸运的是，parseInt可以接受一个基数作为参数，parseInt(“08”,10)结果为8。使用parseInt总是提供这个基数参数是有必要的。</p>\n</li>\n<li><p>‘+’</p>\n<p>‘+’运算符可以用于加法运算或字符串连接。如果其中一个运算数是一个空字符串，它会把另一个运算数转换成字符串并返回。如果两个运算数都是数字，它返回两者之和。如果你打算用+去做加法运算，请确保两个运算数都是整数。</p>\n</li>\n<li><p>NaN</p>\n<p>NaN是IEEE754中定义的一个特殊的数量值，它表示不是一个数字。</p>\n<pre><code class=\"js\">typeof NaN === &#39;number&#39;  // true\n\n// 该值可能会在试图将非数字形式的字符串转换为数字时产生。\n\n+ &#39;0&#39;  // 0\n+ &#39;aksk&#39; // NaN\n\n// 需要注意的是，如果你有一个公式链产生出NaN的结果，那么至少其中一个输入项是NaN，或者在某个地方产生了NaN。\n\n// NaN不等同与它自己\n\nNaN === NaN   // false\nNaN !== NaN   // true\n\n// js提供了isNaN函数检测是否是NaN\n\nisNaN(NaN);   // true\nisNaN(0);   // false\nisNaN(&#39;asnsnsn&#39;);   // ture\nisNaN(&#39;0&#39;);  // false\n</code></pre>\n<p>判断一个值是否可用做数字的最佳方法是使用isFinite函数，因为它会筛除掉NaN和Infinity。不幸的是，isFinite会试图把它的运算数转换为一个数字，所以，如果值事实上不是一个数字，它就不是一个好的测试。可以自己定义isNumber函数：</p>\n<pre><code class=\"js\">  function isNumber(value) {\n      return typeof value === &#39;number&#39; &amp;&amp; isFinite(value);\n  }\n</code></pre>\n</li>\n<li><p>伪数组</p>\n<p>js没有真正的数组。</p>\n<p>typeof运算符不能辨别数组和对象。要判断一个值是否为数组，必须要检查它的constructor属性：</p>\n</li>\n</ul>\n<pre><code class=\"js\">    if(my_value &amp;&amp; typeof my_value === &#39;object&#39; &amp;&amp; my_value.constructor === Array) {\n        // my_value是一个数组\n    }\n</code></pre>\n<p>上面的检测对于在不同的帧或窗口创建的数组将会给出false。当数组有可能哎其他的帧中被创建时，下面的检测更为可靠：</p>\n<pre><code class=\"js\">    if(my_value &amp;&amp; typeof my_value === &#39;object&#39; &amp;&amp; typeof my_value.length === &#39;number&#39; &amp;&amp; !(my_value.propertyIsEnumerable(&#39;length&#39;))) {\n        // my_value确实是一个数组\n    }\n</code></pre>\n<ul>\n<li><p>==</p>\n<p>js有两组相等运算符：=== 和 !==，以及 == 和 !=。 === 和 !==这一组运算符会按照你期望的方式工作。如果两个运算数类型一致且拥有相同的值，那么 === 返回 true，而 !==返回false。而 == 和 !=只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型时，它们试图去强制转换类型。</p>\n</li>\n</ul>\n<pre><code class=\"js\"> &#39;&#39; == &#39;0&#39;   // false\n 0 == &#39;&#39;     // true\n 0 == &#39;0&#39;    // true\n\n false == &#39;false&#39;  // false\n false == &#39;0&#39;  // true\n\n false == undefined  // false\n false == null    // false\n null == undefined   // true\n\n</code></pre>\n<p>== 运算符对传递性的缺乏值得我们警惕。建议永远不要用== 和 !=。始终使用 === 和 !==。</p>\n<blockquote>\n<p>传递性是一种编程约定。可以这么去理解：对于任意的引用值x、y和z，如果x == y和y == z为true，那么x == z 为true。而js中的==运算符在某些特例上违背了传递性。</p>\n</blockquote>\n<hr>\n<p><strong>避免使用with语句，with语句严重影响了js处理器的速度，因为它阻止了变量名的词法作用域绑定。</strong></p>\n<hr>\n<p><strong>避免使用eval。使用它会使得性能显著降低，因为它须运行编译器。</strong></p>\n<ul>\n<li>Function构造器是eval的另一种形式，所以它同样也应该被避免使用。</li>\n<li>浏览器提供的setTimeout和setInterval函数，它们能接受字符串参数或函数参数。当传递的是字符串参数时，setTimeout和setInterval会像eval那样去处理。字符串参数形式也应该被避免使用。</li>\n</ul>\n<hr>\n<p><strong>continue语句</strong></p>\n<p>continue语句跳到循环的顶部。通过移除continue语句后，性能会得到改善。</p>\n<hr>\n<p><strong>switch贯穿</strong></p>\n<p>使用switch语句时，每一个条件都是需要添加break，防止上一个case条件向下贯穿到另一个case条件。</p>\n<hr>\n<p><strong>function语句对比函数表达式</strong></p>\n<p>js中既有function语句，同时也有函数表达式。这是令人困惑的，因为它们看起来就是相同的。一个function语句就是其值为一个函数法人var语句的速记形式。</p>\n<pre><code class=\"js\">    // 下面语句：\n    function foo () {}\n\n    //意思相当于：\n    var foo = function foo() {};\n</code></pre>\n<p>第二种形式能明确表示foo是一个包含一个函数值的变量。function语句在解析时会发生被提升的情况，这意味着不管function被放置在哪里，它会被移动到被定义时所在作用域的顶层。禁止在if语句中声明function语句。</p>\n<p>一个语句不能以一个函数表达式开头，因为官方的语法假定以单词function开头的语句是一个function语句。解决方法就是把函数表达式括在一个圆括号之中。</p>\n<pre><code class=\"js\">    (function () {\n        var hidden_variable;\n\n        // 这个函数可能对环境有一些影响，但不会引入新的全局变量\n    })\n</code></pre>\n<hr>\n<p><strong>在使用new运算符创建新对象时，千万别忘了new，否则会造成this被绑定到全局对象，而不是新创建的对象。</strong></p>\n"},{"title":"HTTP Live Streaming (HLS)","date":"2024-02-19T10:41:04.000Z","_content":"## 概述\n> HLS（HTTP Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分。一是M3U8播放列表，二是TS媒体文件（H.265对应的是FMP4格式的文件）。\n\n## 特点\n- 基于HTTP协议进行传输，兼容性好\n- 单个片段包含完整的音视频数据以及字幕信息等，不存在音视频同步问题\n- 自适应流：可根据网络情况和设备性能动态调整视频质量和比特率\n- 支持加解密传输\n- 支持中间插入广告\n- 播放延迟较大\n\n## 适用场景\n- 视频直播：HLS是一种流媒体协议，可以实现实时或准实时的视频播放，因此在各种直播平台（如Twitch，YouTube Live等）中都有应用。\n- 点播服务：除了直播，HLS也可以用于点播服务，用户可以随时选择观看的内容。\n- 在线教育：在线教育平台可以使用HLS提供实时的课程直播，或者录制好的课程视频。\n- 网络电视：一些网络电视服务商也使用HLS技术，提供电视节目的在线播放。\n\n## 核心原理\n通过将整条流切割成一个小的可以通过HTTP下载的媒体文件（TS片段），然后提供一个配套的媒体列表文件（m3u8）提供给客户端，客户端按照列表顺序去拉取这些媒体文件进行播放，视觉上就是在播放一整段流的效果。由于传输层协议用的标准的HTTP协议，HLS可以方便的透过防火墙或者代理服务器以及利用CDN进行分发加速。\n\n![image](HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png)\n\n## M3U8索引文件\n\nM3U8文件实质是一个播放列表，其可能是一个媒体播放列表（Media PlayList），或者是一个主列表（Master Playlist）。\n\n- 媒体播放列表：这种类型的M3U8文件包含了一系列的媒体段（通常是TS或fMP4文件）的URL链接，这些媒体段按照在播放列表中的顺序进行播放。对于点播来说，客户端只需要按照顺序下载片段资源，依次播放即可。而对于直播来说，客户端需要定时重新请求该m3u8文件，拉取最新的片段数据。\n```\n#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3 //  HLS 的协议版本号\n#EXT-X-TARGETDURATION:10 // 该标签指定了媒体文件持续时间的最大值,，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次。\n#EXTINF:10,\nhttp://example.com/1.ts\n#EXTINF:10,\nhttp://example.com/2.ts\n#EXTINF:10,\nhttp://example.com/3.ts\n#EXT-X-ENDLIST\n```\n\n- 主播放列表：这种类型的M3U8文件并不直接包含媒体内容，而是包含了一系列的媒体播放列表的URL链接。每一个媒体播放列表都代表了同一份媒体内容的不同版本，例如不同的分辨率、不同的码率等。客户端可以根据自身的网络状况和设备性能，从主播放列表中选择最合适的媒体播放列表进行播放。\n```\n#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3   //  HLS 的协议版本号\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,RESOLUTION=720x480\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=1280x720\nhttp://example.com/mid.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,RESOLUTION=1920x1080\nhttp://example.com/high.m3u8\n```\n\n## TS文件\n\nTS（Transport Stream）是一种音视频封装格式，全称MPEG2-TS。MPEG-TS主要应用于实时传送的节目，比如实时广播的电视节目。\n\nTS文件（流）可以分为三层：**TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）**。\n\n- ES层就是音视频数据\n- PES层是在音视频数据上加了时间戳等对数据帧的说明信息\n- TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。\n\n\n## 加解密\n\nHLS协议支持对媒体内容进行AES-128或SAMPLE-AES加密，以保护媒体内容的安全。\n1. 加密流程：\n- 服务端首先生成一个随机的AES密钥。\n- 使用这个AES密钥对媒体内容进行AES-128或SAMPLE-AES加密，生成加密后的媒体段。\n- 将AES密钥加密后存储在服务端，同时生成一个可以用于获取AES密钥的URL链接。\n- 在M3U8播放列表中，对于每一个加密的媒体段，都会添加一个EXT-X-KEY标签，该标签包含了获取AES密钥的URL链接和加密方法。\n\n2. 解密流程：\n- 客户端在解析M3U8播放列表时，发现EXT-X-KEY标签，就知道媒体段是加密的。\n- 客户端通过EXT-X-KEY标签中的URL链接向服务端请求AES密钥。\n- 服务端验证客户端的请求后，返回加密的AES密钥。\n- 客户端解密AES密钥，然后使用AES密钥对媒体段进行解密，得到原始的媒体内容。\n \n\n## web端如何使用HLS播放云存储视频\n\n![image](HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png)\n\n\n```typescript\nconst HlsVideo: React.FC<IHlsVideoProps> = ({\n  debug = false,\n  keyPreset = \"\",\n  enableWorker = true,\n  url = \"\",\n  hlsRef,\n  videoRef,\n  videoProps = {},\n}) => {\n  const defaultVideoProps = React.useMemo(\n    () => ({\n      disablePictureInPicture: true,\n      autoPlay: true,\n      controls: false,\n    }),\n    []\n  );\n  const _videoProps = { ...defaultVideoProps, ...videoProps };\n\n  React.useEffect(() => {\n    const hls = new Hls(config(debug, keyPreset, enableWorker) as any);\n    if (hlsRef) {\n      hlsRef.current = hls;\n    }\n    const video = videoRef.current;\n    if (hls && video && url) {\n      hls.loadSource(url); // 加载m3u8\n      hls.attachMedia(video); // 绑定videoElement和hls实例\n      return () => hls.detachMedia();\n    }\n  }, [url]);\n\n  return (\n    <video\n      style={{ height: \"100%\", width: \"100%\" }}\n      ref={videoRef}\n      {..._videoProps}\n    />\n  );\n};\n```\n\n```typescript\n// @ts-nocheck\nimport Hls from \"hls.js\";\n\nconst KEY_URL = \"/api/jarvis/hls/key\"; // 前端网关配置的用于获取密钥的链接（业务鉴权之类的）\nconst ORIGIN_KEY_URL = \"/api/cloud/key\"; // m3u8返回的通用的用于获取密钥的链接\n\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf));\n}\nfunction _base64ToArrayBuffer(base64: string) {\n  // base64 解码\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // 二进制数组\n  return bytes.buffer;\n}\n\nconst configure = (debug: boolean, keyPreset: string, enableWorker: boolean) => ({\n  debug,\n  enableWorker,\n  // defaultAudioCodec: 'mp4a.40.2',\n  // enableWorker: false,\n  // maxAudioFramesDrift: 23,\n  loader: function (config) {\n    const loader = new Hls.DefaultConfig.loader(config);\n\n    Object.defineProperties(this, {\n      stats: {\n        get: () => loader.stats,\n      },\n      context: {\n        get: () => loader.context,\n      },\n    });\n\n    this.abort = () => loader.abort();\n    this.destroy = () => loader.destroy();\n\n    this.load = (context, config, callbacks) => {\n      const { type } = context;\n      const onSuccess = callbacks.onSuccess;\n      callbacks.onSuccess = (response, stats, context1, networkDetails) => {\n        if (type !== \"manifest\" && context1.url.includes(\"key?devId\")) {\n          // 针对密钥进行base64解密处理\n          const key = keyPreset || JSON.parse(ab2str(response.data)).result.key;\n          response.data = _base64ToArrayBuffer(key);\n        }\n        onSuccess(response, stats, context, networkDetails);\n      };\n      loader.load(context, config, callbacks);\n    };\n  },\n  xhrSetup: function (xhr: XMLHttpRequest, url: string) {\n    // 自定义xhr，替换密钥链接\n    const u = url.includes(ORIGIN_KEY_URL)\n      ? KEY_URL + \"?\" + (url as string).split(\"?\")[1]\n      : url;\n    xhr.open(\"GET\", u, true);\n  },\n});\n\nexport default configure;\n```\n\n## HLS直播延迟原因\n1. 存在安全缓冲时长，客户端应该从M3U8文件中倒数第三个分片开始播放\n2. 服务器更新M3U8文件的间隔，理论上服务器需要大于等于一个EXT-X-TARGETDURATION的时长去更新M3u8文件\n3. CDN缓存机制。若当前源站 M3U8 已经更新到了第四个片段，但是CDN边缘节点还缓存着上一个版本的 M3U8文件（只包含3个片段）。此时就需要等文件的TTL过期，边缘节点才会去获取最新版本的 M3U8 文件。而这个缓存TTL也不能取消，如果每个端上的请求到达CDN边缘节点时都去找源站要最新版本，源站就可能会被流量冲垮。\n4. 服务器处理时间：服务器接收到媒体源数据后，进行切片编码之后再进行传输。\n5. 网络延迟：文件从服务器到客户端中间的网络传输延迟。\n\n## 优化延迟方法\n\n1. 减少客户端安全缓冲时长\n2. 减少服务器更新M3U8文件的间隔\n3. 减小分片长度\n","source":"_posts/HTTP-Live-Streaming-HLS.md","raw":"---\ntitle: HTTP Live Streaming (HLS)\ndate: 2024-02-19 18:41:04\ntags: 音视频\ncategories: 前端\n---\n## 概述\n> HLS（HTTP Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分。一是M3U8播放列表，二是TS媒体文件（H.265对应的是FMP4格式的文件）。\n\n## 特点\n- 基于HTTP协议进行传输，兼容性好\n- 单个片段包含完整的音视频数据以及字幕信息等，不存在音视频同步问题\n- 自适应流：可根据网络情况和设备性能动态调整视频质量和比特率\n- 支持加解密传输\n- 支持中间插入广告\n- 播放延迟较大\n\n## 适用场景\n- 视频直播：HLS是一种流媒体协议，可以实现实时或准实时的视频播放，因此在各种直播平台（如Twitch，YouTube Live等）中都有应用。\n- 点播服务：除了直播，HLS也可以用于点播服务，用户可以随时选择观看的内容。\n- 在线教育：在线教育平台可以使用HLS提供实时的课程直播，或者录制好的课程视频。\n- 网络电视：一些网络电视服务商也使用HLS技术，提供电视节目的在线播放。\n\n## 核心原理\n通过将整条流切割成一个小的可以通过HTTP下载的媒体文件（TS片段），然后提供一个配套的媒体列表文件（m3u8）提供给客户端，客户端按照列表顺序去拉取这些媒体文件进行播放，视觉上就是在播放一整段流的效果。由于传输层协议用的标准的HTTP协议，HLS可以方便的透过防火墙或者代理服务器以及利用CDN进行分发加速。\n\n![image](HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png)\n\n## M3U8索引文件\n\nM3U8文件实质是一个播放列表，其可能是一个媒体播放列表（Media PlayList），或者是一个主列表（Master Playlist）。\n\n- 媒体播放列表：这种类型的M3U8文件包含了一系列的媒体段（通常是TS或fMP4文件）的URL链接，这些媒体段按照在播放列表中的顺序进行播放。对于点播来说，客户端只需要按照顺序下载片段资源，依次播放即可。而对于直播来说，客户端需要定时重新请求该m3u8文件，拉取最新的片段数据。\n```\n#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3 //  HLS 的协议版本号\n#EXT-X-TARGETDURATION:10 // 该标签指定了媒体文件持续时间的最大值,，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次。\n#EXTINF:10,\nhttp://example.com/1.ts\n#EXTINF:10,\nhttp://example.com/2.ts\n#EXTINF:10,\nhttp://example.com/3.ts\n#EXT-X-ENDLIST\n```\n\n- 主播放列表：这种类型的M3U8文件并不直接包含媒体内容，而是包含了一系列的媒体播放列表的URL链接。每一个媒体播放列表都代表了同一份媒体内容的不同版本，例如不同的分辨率、不同的码率等。客户端可以根据自身的网络状况和设备性能，从主播放列表中选择最合适的媒体播放列表进行播放。\n```\n#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3   //  HLS 的协议版本号\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,RESOLUTION=720x480\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=1280x720\nhttp://example.com/mid.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,RESOLUTION=1920x1080\nhttp://example.com/high.m3u8\n```\n\n## TS文件\n\nTS（Transport Stream）是一种音视频封装格式，全称MPEG2-TS。MPEG-TS主要应用于实时传送的节目，比如实时广播的电视节目。\n\nTS文件（流）可以分为三层：**TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）**。\n\n- ES层就是音视频数据\n- PES层是在音视频数据上加了时间戳等对数据帧的说明信息\n- TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。\n\n\n## 加解密\n\nHLS协议支持对媒体内容进行AES-128或SAMPLE-AES加密，以保护媒体内容的安全。\n1. 加密流程：\n- 服务端首先生成一个随机的AES密钥。\n- 使用这个AES密钥对媒体内容进行AES-128或SAMPLE-AES加密，生成加密后的媒体段。\n- 将AES密钥加密后存储在服务端，同时生成一个可以用于获取AES密钥的URL链接。\n- 在M3U8播放列表中，对于每一个加密的媒体段，都会添加一个EXT-X-KEY标签，该标签包含了获取AES密钥的URL链接和加密方法。\n\n2. 解密流程：\n- 客户端在解析M3U8播放列表时，发现EXT-X-KEY标签，就知道媒体段是加密的。\n- 客户端通过EXT-X-KEY标签中的URL链接向服务端请求AES密钥。\n- 服务端验证客户端的请求后，返回加密的AES密钥。\n- 客户端解密AES密钥，然后使用AES密钥对媒体段进行解密，得到原始的媒体内容。\n \n\n## web端如何使用HLS播放云存储视频\n\n![image](HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png)\n\n\n```typescript\nconst HlsVideo: React.FC<IHlsVideoProps> = ({\n  debug = false,\n  keyPreset = \"\",\n  enableWorker = true,\n  url = \"\",\n  hlsRef,\n  videoRef,\n  videoProps = {},\n}) => {\n  const defaultVideoProps = React.useMemo(\n    () => ({\n      disablePictureInPicture: true,\n      autoPlay: true,\n      controls: false,\n    }),\n    []\n  );\n  const _videoProps = { ...defaultVideoProps, ...videoProps };\n\n  React.useEffect(() => {\n    const hls = new Hls(config(debug, keyPreset, enableWorker) as any);\n    if (hlsRef) {\n      hlsRef.current = hls;\n    }\n    const video = videoRef.current;\n    if (hls && video && url) {\n      hls.loadSource(url); // 加载m3u8\n      hls.attachMedia(video); // 绑定videoElement和hls实例\n      return () => hls.detachMedia();\n    }\n  }, [url]);\n\n  return (\n    <video\n      style={{ height: \"100%\", width: \"100%\" }}\n      ref={videoRef}\n      {..._videoProps}\n    />\n  );\n};\n```\n\n```typescript\n// @ts-nocheck\nimport Hls from \"hls.js\";\n\nconst KEY_URL = \"/api/jarvis/hls/key\"; // 前端网关配置的用于获取密钥的链接（业务鉴权之类的）\nconst ORIGIN_KEY_URL = \"/api/cloud/key\"; // m3u8返回的通用的用于获取密钥的链接\n\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf));\n}\nfunction _base64ToArrayBuffer(base64: string) {\n  // base64 解码\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // 二进制数组\n  return bytes.buffer;\n}\n\nconst configure = (debug: boolean, keyPreset: string, enableWorker: boolean) => ({\n  debug,\n  enableWorker,\n  // defaultAudioCodec: 'mp4a.40.2',\n  // enableWorker: false,\n  // maxAudioFramesDrift: 23,\n  loader: function (config) {\n    const loader = new Hls.DefaultConfig.loader(config);\n\n    Object.defineProperties(this, {\n      stats: {\n        get: () => loader.stats,\n      },\n      context: {\n        get: () => loader.context,\n      },\n    });\n\n    this.abort = () => loader.abort();\n    this.destroy = () => loader.destroy();\n\n    this.load = (context, config, callbacks) => {\n      const { type } = context;\n      const onSuccess = callbacks.onSuccess;\n      callbacks.onSuccess = (response, stats, context1, networkDetails) => {\n        if (type !== \"manifest\" && context1.url.includes(\"key?devId\")) {\n          // 针对密钥进行base64解密处理\n          const key = keyPreset || JSON.parse(ab2str(response.data)).result.key;\n          response.data = _base64ToArrayBuffer(key);\n        }\n        onSuccess(response, stats, context, networkDetails);\n      };\n      loader.load(context, config, callbacks);\n    };\n  },\n  xhrSetup: function (xhr: XMLHttpRequest, url: string) {\n    // 自定义xhr，替换密钥链接\n    const u = url.includes(ORIGIN_KEY_URL)\n      ? KEY_URL + \"?\" + (url as string).split(\"?\")[1]\n      : url;\n    xhr.open(\"GET\", u, true);\n  },\n});\n\nexport default configure;\n```\n\n## HLS直播延迟原因\n1. 存在安全缓冲时长，客户端应该从M3U8文件中倒数第三个分片开始播放\n2. 服务器更新M3U8文件的间隔，理论上服务器需要大于等于一个EXT-X-TARGETDURATION的时长去更新M3u8文件\n3. CDN缓存机制。若当前源站 M3U8 已经更新到了第四个片段，但是CDN边缘节点还缓存着上一个版本的 M3U8文件（只包含3个片段）。此时就需要等文件的TTL过期，边缘节点才会去获取最新版本的 M3U8 文件。而这个缓存TTL也不能取消，如果每个端上的请求到达CDN边缘节点时都去找源站要最新版本，源站就可能会被流量冲垮。\n4. 服务器处理时间：服务器接收到媒体源数据后，进行切片编码之后再进行传输。\n5. 网络延迟：文件从服务器到客户端中间的网络传输延迟。\n\n## 优化延迟方法\n\n1. 减少客户端安全缓冲时长\n2. 减少服务器更新M3U8文件的间隔\n3. 减小分片长度\n","slug":"HTTP-Live-Streaming-HLS","published":1,"updated":"2024-02-19T10:47:34.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9a000n1xopauctdqdq","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>HLS（HTTP Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分。一是M3U8播放列表，二是TS媒体文件（H.265对应的是FMP4格式的文件）。</p>\n</blockquote>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>基于HTTP协议进行传输，兼容性好</li>\n<li>单个片段包含完整的音视频数据以及字幕信息等，不存在音视频同步问题</li>\n<li>自适应流：可根据网络情况和设备性能动态调整视频质量和比特率</li>\n<li>支持加解密传输</li>\n<li>支持中间插入广告</li>\n<li>播放延迟较大</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>视频直播：HLS是一种流媒体协议，可以实现实时或准实时的视频播放，因此在各种直播平台（如Twitch，YouTube Live等）中都有应用。</li>\n<li>点播服务：除了直播，HLS也可以用于点播服务，用户可以随时选择观看的内容。</li>\n<li>在线教育：在线教育平台可以使用HLS提供实时的课程直播，或者录制好的课程视频。</li>\n<li>网络电视：一些网络电视服务商也使用HLS技术，提供电视节目的在线播放。</li>\n</ul>\n<h2 id=\"核心原理\"><a href=\"#核心原理\" class=\"headerlink\" title=\"核心原理\"></a>核心原理</h2><p>通过将整条流切割成一个小的可以通过HTTP下载的媒体文件（TS片段），然后提供一个配套的媒体列表文件（m3u8）提供给客户端，客户端按照列表顺序去拉取这些媒体文件进行播放，视觉上就是在播放一整段流的效果。由于传输层协议用的标准的HTTP协议，HLS可以方便的透过防火墙或者代理服务器以及利用CDN进行分发加速。</p>\n<p><img src=\"/2024/02/19/HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png\" alt=\"image\"></p>\n<h2 id=\"M3U8索引文件\"><a href=\"#M3U8索引文件\" class=\"headerlink\" title=\"M3U8索引文件\"></a>M3U8索引文件</h2><p>M3U8文件实质是一个播放列表，其可能是一个媒体播放列表（Media PlayList），或者是一个主列表（Master Playlist）。</p>\n<ul>\n<li><p>媒体播放列表：这种类型的M3U8文件包含了一系列的媒体段（通常是TS或fMP4文件）的URL链接，这些媒体段按照在播放列表中的顺序进行播放。对于点播来说，客户端只需要按照顺序下载片段资源，依次播放即可。而对于直播来说，客户端需要定时重新请求该m3u8文件，拉取最新的片段数据。</p>\n<pre><code>#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3 //  HLS 的协议版本号\n#EXT-X-TARGETDURATION:10 // 该标签指定了媒体文件持续时间的最大值,，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次。\n#EXTINF:10,\nhttp://example.com/1.ts\n#EXTINF:10,\nhttp://example.com/2.ts\n#EXTINF:10,\nhttp://example.com/3.ts\n#EXT-X-ENDLIST\n</code></pre></li>\n<li><p>主播放列表：这种类型的M3U8文件并不直接包含媒体内容，而是包含了一系列的媒体播放列表的URL链接。每一个媒体播放列表都代表了同一份媒体内容的不同版本，例如不同的分辨率、不同的码率等。客户端可以根据自身的网络状况和设备性能，从主播放列表中选择最合适的媒体播放列表进行播放。</p>\n<pre><code>#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3   //  HLS 的协议版本号\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,RESOLUTION=720x480\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=1280x720\nhttp://example.com/mid.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,RESOLUTION=1920x1080\nhttp://example.com/high.m3u8\n</code></pre></li>\n</ul>\n<h2 id=\"TS文件\"><a href=\"#TS文件\" class=\"headerlink\" title=\"TS文件\"></a>TS文件</h2><p>TS（Transport Stream）是一种音视频封装格式，全称MPEG2-TS。MPEG-TS主要应用于实时传送的节目，比如实时广播的电视节目。</p>\n<p>TS文件（流）可以分为三层：<strong>TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）</strong>。</p>\n<ul>\n<li>ES层就是音视频数据</li>\n<li>PES层是在音视频数据上加了时间戳等对数据帧的说明信息</li>\n<li>TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。</li>\n</ul>\n<h2 id=\"加解密\"><a href=\"#加解密\" class=\"headerlink\" title=\"加解密\"></a>加解密</h2><p>HLS协议支持对媒体内容进行AES-128或SAMPLE-AES加密，以保护媒体内容的安全。</p>\n<ol>\n<li>加密流程：</li>\n</ol>\n<ul>\n<li>服务端首先生成一个随机的AES密钥。</li>\n<li>使用这个AES密钥对媒体内容进行AES-128或SAMPLE-AES加密，生成加密后的媒体段。</li>\n<li>将AES密钥加密后存储在服务端，同时生成一个可以用于获取AES密钥的URL链接。</li>\n<li>在M3U8播放列表中，对于每一个加密的媒体段，都会添加一个EXT-X-KEY标签，该标签包含了获取AES密钥的URL链接和加密方法。</li>\n</ul>\n<ol start=\"2\">\n<li>解密流程：</li>\n</ol>\n<ul>\n<li>客户端在解析M3U8播放列表时，发现EXT-X-KEY标签，就知道媒体段是加密的。</li>\n<li>客户端通过EXT-X-KEY标签中的URL链接向服务端请求AES密钥。</li>\n<li>服务端验证客户端的请求后，返回加密的AES密钥。</li>\n<li>客户端解密AES密钥，然后使用AES密钥对媒体段进行解密，得到原始的媒体内容。</li>\n</ul>\n<h2 id=\"web端如何使用HLS播放云存储视频\"><a href=\"#web端如何使用HLS播放云存储视频\" class=\"headerlink\" title=\"web端如何使用HLS播放云存储视频\"></a>web端如何使用HLS播放云存储视频</h2><p><img src=\"/2024/02/19/HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png\" alt=\"image\"></p>\n<pre class=\"line-numbers language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> HlsVideo<span class=\"token punctuation\">:</span> React<span class=\"token punctuation\">.</span>FC<span class=\"token operator\">&lt;</span>IHlsVideoProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  debug <span class=\"token operator\">=</span> <span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span>\n  keyPreset <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  enableWorker <span class=\"token operator\">=</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">,</span>\n  url <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  hlsRef<span class=\"token punctuation\">,</span>\n  videoRef<span class=\"token punctuation\">,</span>\n  videoProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> defaultVideoProps <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useMemo</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      disablePictureInPicture<span class=\"token punctuation\">:</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">,</span>\n      autoPlay<span class=\"token punctuation\">:</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">,</span>\n      controls<span class=\"token punctuation\">:</span> <span class=\"token keyword\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> _videoProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>defaultVideoProps<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>videoProps <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  React<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> hls <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Hls</span><span class=\"token punctuation\">(</span><span class=\"token function\">config</span><span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">,</span> keyPreset<span class=\"token punctuation\">,</span> enableWorker<span class=\"token punctuation\">)</span> as <span class=\"token keyword\">any</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hlsRef<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      hlsRef<span class=\"token punctuation\">.</span>current <span class=\"token operator\">=</span> hls<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> video <span class=\"token operator\">=</span> videoRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hls <span class=\"token operator\">&amp;&amp;</span> video <span class=\"token operator\">&amp;&amp;</span> url<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      hls<span class=\"token punctuation\">.</span><span class=\"token function\">loadSource</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 加载m3u8</span>\n      hls<span class=\"token punctuation\">.</span><span class=\"token function\">attachMedia</span><span class=\"token punctuation\">(</span>video<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 绑定videoElement和hls实例</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> hls<span class=\"token punctuation\">.</span><span class=\"token function\">detachMedia</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>url<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>video\n      style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> height<span class=\"token punctuation\">:</span> <span class=\"token string\">\"100%\"</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">:</span> <span class=\"token string\">\"100%\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n      ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>videoRef<span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>_videoProps<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\" spellcheck=\"true\">// @ts-nocheck</span>\n<span class=\"token keyword\">import</span> Hls <span class=\"token keyword\">from</span> <span class=\"token string\">\"hls.js\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> KEY_URL <span class=\"token operator\">=</span> <span class=\"token string\">\"/api/jarvis/hls/key\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 前端网关配置的用于获取密钥的链接（业务鉴权之类的）</span>\n<span class=\"token keyword\">const</span> ORIGIN_KEY_URL <span class=\"token operator\">=</span> <span class=\"token string\">\"/api/cloud/key\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// m3u8返回的通用的用于获取密钥的链接</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">ab2str</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span>fromCharCode<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">_base64ToArrayBuffer</span><span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">:</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// base64 解码</span>\n  <span class=\"token keyword\">const</span> binaryString <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">atob</span><span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> len <span class=\"token operator\">=</span> binaryString<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Uint8Array</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bytes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> binaryString<span class=\"token punctuation\">.</span><span class=\"token function\">charCodeAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">// 二进制数组</span>\n  <span class=\"token keyword\">return</span> bytes<span class=\"token punctuation\">.</span>buffer<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> configure <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>debug<span class=\"token punctuation\">:</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">,</span> keyPreset<span class=\"token punctuation\">:</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">,</span> enableWorker<span class=\"token punctuation\">:</span> <span class=\"token keyword\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  debug<span class=\"token punctuation\">,</span>\n  enableWorker<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// defaultAudioCodec: 'mp4a.40.2',</span>\n  <span class=\"token comment\" spellcheck=\"true\">// enableWorker: false,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// maxAudioFramesDrift: 23,</span>\n  loader<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> loader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Hls<span class=\"token punctuation\">.</span>DefaultConfig<span class=\"token punctuation\">.</span>loader</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperties</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      stats<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> loader<span class=\"token punctuation\">.</span>stats<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      context<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> loader<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>abort <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> loader<span class=\"token punctuation\">.</span><span class=\"token function\">abort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>destroy <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> loader<span class=\"token punctuation\">.</span><span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>load <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> callbacks<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> type <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> context<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> onSuccess <span class=\"token operator\">=</span> callbacks<span class=\"token punctuation\">.</span>onSuccess<span class=\"token punctuation\">;</span>\n      callbacks<span class=\"token punctuation\">.</span>onSuccess <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> stats<span class=\"token punctuation\">,</span> context1<span class=\"token punctuation\">,</span> networkDetails<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>type <span class=\"token operator\">!==</span> <span class=\"token string\">\"manifest\"</span> <span class=\"token operator\">&amp;&amp;</span> context1<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key?devId\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 针对密钥进行base64解密处理</span>\n          <span class=\"token keyword\">const</span> key <span class=\"token operator\">=</span> keyPreset <span class=\"token operator\">||</span> JSON<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token function\">ab2str</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n          response<span class=\"token punctuation\">.</span>data <span class=\"token operator\">=</span> <span class=\"token function\">_base64ToArrayBuffer</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">onSuccess</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> stats<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> networkDetails<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n      loader<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> callbacks<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  xhrSetup<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">:</span> XMLHttpRequest<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">:</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 自定义xhr，替换密钥链接</span>\n    <span class=\"token keyword\">const</span> u <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>ORIGIN_KEY_URL<span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">?</span> KEY_URL <span class=\"token operator\">+</span> <span class=\"token string\">\"?\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>url as <span class=\"token keyword\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">:</span> url<span class=\"token punctuation\">;</span>\n    xhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> configure<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"HLS直播延迟原因\"><a href=\"#HLS直播延迟原因\" class=\"headerlink\" title=\"HLS直播延迟原因\"></a>HLS直播延迟原因</h2><ol>\n<li>存在安全缓冲时长，客户端应该从M3U8文件中倒数第三个分片开始播放</li>\n<li>服务器更新M3U8文件的间隔，理论上服务器需要大于等于一个EXT-X-TARGETDURATION的时长去更新M3u8文件</li>\n<li>CDN缓存机制。若当前源站 M3U8 已经更新到了第四个片段，但是CDN边缘节点还缓存着上一个版本的 M3U8文件（只包含3个片段）。此时就需要等文件的TTL过期，边缘节点才会去获取最新版本的 M3U8 文件。而这个缓存TTL也不能取消，如果每个端上的请求到达CDN边缘节点时都去找源站要最新版本，源站就可能会被流量冲垮。</li>\n<li>服务器处理时间：服务器接收到媒体源数据后，进行切片编码之后再进行传输。</li>\n<li>网络延迟：文件从服务器到客户端中间的网络传输延迟。</li>\n</ol>\n<h2 id=\"优化延迟方法\"><a href=\"#优化延迟方法\" class=\"headerlink\" title=\"优化延迟方法\"></a>优化延迟方法</h2><ol>\n<li>减少客户端安全缓冲时长</li>\n<li>减少服务器更新M3U8文件的间隔</li>\n<li>减小分片长度</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><blockquote>\n<p>HLS（HTTP Live Streaming）是由Apple公司定义的用于实时流传输的协议，HLS基于HTTP协议实现，传输内容包括两部分。一是M3U8播放列表，二是TS媒体文件（H.265对应的是FMP4格式的文件）。</p>\n</blockquote>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>基于HTTP协议进行传输，兼容性好</li>\n<li>单个片段包含完整的音视频数据以及字幕信息等，不存在音视频同步问题</li>\n<li>自适应流：可根据网络情况和设备性能动态调整视频质量和比特率</li>\n<li>支持加解密传输</li>\n<li>支持中间插入广告</li>\n<li>播放延迟较大</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>视频直播：HLS是一种流媒体协议，可以实现实时或准实时的视频播放，因此在各种直播平台（如Twitch，YouTube Live等）中都有应用。</li>\n<li>点播服务：除了直播，HLS也可以用于点播服务，用户可以随时选择观看的内容。</li>\n<li>在线教育：在线教育平台可以使用HLS提供实时的课程直播，或者录制好的课程视频。</li>\n<li>网络电视：一些网络电视服务商也使用HLS技术，提供电视节目的在线播放。</li>\n</ul>\n<h2 id=\"核心原理\"><a href=\"#核心原理\" class=\"headerlink\" title=\"核心原理\"></a>核心原理</h2><p>通过将整条流切割成一个小的可以通过HTTP下载的媒体文件（TS片段），然后提供一个配套的媒体列表文件（m3u8）提供给客户端，客户端按照列表顺序去拉取这些媒体文件进行播放，视觉上就是在播放一整段流的效果。由于传输层协议用的标准的HTTP协议，HLS可以方便的透过防火墙或者代理服务器以及利用CDN进行分发加速。</p>\n<p><img src=\"/2024/02/19/HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png\" alt=\"image\"></p>\n<h2 id=\"M3U8索引文件\"><a href=\"#M3U8索引文件\" class=\"headerlink\" title=\"M3U8索引文件\"></a>M3U8索引文件</h2><p>M3U8文件实质是一个播放列表，其可能是一个媒体播放列表（Media PlayList），或者是一个主列表（Master Playlist）。</p>\n<ul>\n<li><p>媒体播放列表：这种类型的M3U8文件包含了一系列的媒体段（通常是TS或fMP4文件）的URL链接，这些媒体段按照在播放列表中的顺序进行播放。对于点播来说，客户端只需要按照顺序下载片段资源，依次播放即可。而对于直播来说，客户端需要定时重新请求该m3u8文件，拉取最新的片段数据。</p>\n<pre><code>#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3 //  HLS 的协议版本号\n#EXT-X-TARGETDURATION:10 // 该标签指定了媒体文件持续时间的最大值,，播放文件列表中的媒体文件在EXTINF标签中定义的持续时间必须小于或者等于该标签指定的持续时间。该标签在播放列表文件中必须出现一次。\n#EXTINF:10,\nhttp://example.com/1.ts\n#EXTINF:10,\nhttp://example.com/2.ts\n#EXTINF:10,\nhttp://example.com/3.ts\n#EXT-X-ENDLIST\n</code></pre></li>\n<li><p>主播放列表：这种类型的M3U8文件并不直接包含媒体内容，而是包含了一系列的媒体播放列表的URL链接。每一个媒体播放列表都代表了同一份媒体内容的不同版本，例如不同的分辨率、不同的码率等。客户端可以根据自身的网络状况和设备性能，从主播放列表中选择最合适的媒体播放列表进行播放。</p>\n<pre><code>#EXTM3U // 表明该文件是一个 m3u8 文件，必须在文件的第一行\n#EXT-X-VERSION:3   //  HLS 的协议版本号\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,RESOLUTION=720x480\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,RESOLUTION=1280x720\nhttp://example.com/mid.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,RESOLUTION=1920x1080\nhttp://example.com/high.m3u8\n</code></pre></li>\n</ul>\n<h2 id=\"TS文件\"><a href=\"#TS文件\" class=\"headerlink\" title=\"TS文件\"></a>TS文件</h2><p>TS（Transport Stream）是一种音视频封装格式，全称MPEG2-TS。MPEG-TS主要应用于实时传送的节目，比如实时广播的电视节目。</p>\n<p>TS文件（流）可以分为三层：<strong>TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）</strong>。</p>\n<ul>\n<li>ES层就是音视频数据</li>\n<li>PES层是在音视频数据上加了时间戳等对数据帧的说明信息</li>\n<li>TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。</li>\n</ul>\n<h2 id=\"加解密\"><a href=\"#加解密\" class=\"headerlink\" title=\"加解密\"></a>加解密</h2><p>HLS协议支持对媒体内容进行AES-128或SAMPLE-AES加密，以保护媒体内容的安全。</p>\n<ol>\n<li>加密流程：</li>\n</ol>\n<ul>\n<li>服务端首先生成一个随机的AES密钥。</li>\n<li>使用这个AES密钥对媒体内容进行AES-128或SAMPLE-AES加密，生成加密后的媒体段。</li>\n<li>将AES密钥加密后存储在服务端，同时生成一个可以用于获取AES密钥的URL链接。</li>\n<li>在M3U8播放列表中，对于每一个加密的媒体段，都会添加一个EXT-X-KEY标签，该标签包含了获取AES密钥的URL链接和加密方法。</li>\n</ul>\n<ol start=\"2\">\n<li>解密流程：</li>\n</ol>\n<ul>\n<li>客户端在解析M3U8播放列表时，发现EXT-X-KEY标签，就知道媒体段是加密的。</li>\n<li>客户端通过EXT-X-KEY标签中的URL链接向服务端请求AES密钥。</li>\n<li>服务端验证客户端的请求后，返回加密的AES密钥。</li>\n<li>客户端解密AES密钥，然后使用AES密钥对媒体段进行解密，得到原始的媒体内容。</li>\n</ul>\n<h2 id=\"web端如何使用HLS播放云存储视频\"><a href=\"#web端如何使用HLS播放云存储视频\" class=\"headerlink\" title=\"web端如何使用HLS播放云存储视频\"></a>web端如何使用HLS播放云存储视频</h2><p><img src=\"/2024/02/19/HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png\" alt=\"image\"></p>\n<pre><code class=\"typescript\">const HlsVideo: React.FC&lt;IHlsVideoProps&gt; = ({\n  debug = false,\n  keyPreset = &quot;&quot;,\n  enableWorker = true,\n  url = &quot;&quot;,\n  hlsRef,\n  videoRef,\n  videoProps = {},\n}) =&gt; {\n  const defaultVideoProps = React.useMemo(\n    () =&gt; ({\n      disablePictureInPicture: true,\n      autoPlay: true,\n      controls: false,\n    }),\n    []\n  );\n  const _videoProps = { ...defaultVideoProps, ...videoProps };\n\n  React.useEffect(() =&gt; {\n    const hls = new Hls(config(debug, keyPreset, enableWorker) as any);\n    if (hlsRef) {\n      hlsRef.current = hls;\n    }\n    const video = videoRef.current;\n    if (hls &amp;&amp; video &amp;&amp; url) {\n      hls.loadSource(url); // 加载m3u8\n      hls.attachMedia(video); // 绑定videoElement和hls实例\n      return () =&gt; hls.detachMedia();\n    }\n  }, [url]);\n\n  return (\n    &lt;video\n      style={{ height: \"100%\", width: \"100%\" }}\n      ref={videoRef}\n      {..._videoProps}\n    /&gt;\n  );\n};\n</code></pre>\n<pre><code class=\"typescript\">// @ts-nocheck\nimport Hls from &quot;hls.js&quot;;\n\nconst KEY_URL = &quot;/api/jarvis/hls/key&quot;; // 前端网关配置的用于获取密钥的链接（业务鉴权之类的）\nconst ORIGIN_KEY_URL = &quot;/api/cloud/key&quot;; // m3u8返回的通用的用于获取密钥的链接\n\nfunction ab2str(buf) {\n  return String.fromCharCode.apply(null, new Uint8Array(buf));\n}\nfunction _base64ToArrayBuffer(base64: string) {\n  // base64 解码\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i &lt; len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // 二进制数组\n  return bytes.buffer;\n}\n\nconst configure = (debug: boolean, keyPreset: string, enableWorker: boolean) =&gt; ({\n  debug,\n  enableWorker,\n  // defaultAudioCodec: &#39;mp4a.40.2&#39;,\n  // enableWorker: false,\n  // maxAudioFramesDrift: 23,\n  loader: function (config) {\n    const loader = new Hls.DefaultConfig.loader(config);\n\n    Object.defineProperties(this, {\n      stats: {\n        get: () =&gt; loader.stats,\n      },\n      context: {\n        get: () =&gt; loader.context,\n      },\n    });\n\n    this.abort = () =&gt; loader.abort();\n    this.destroy = () =&gt; loader.destroy();\n\n    this.load = (context, config, callbacks) =&gt; {\n      const { type } = context;\n      const onSuccess = callbacks.onSuccess;\n      callbacks.onSuccess = (response, stats, context1, networkDetails) =&gt; {\n        if (type !== &quot;manifest&quot; &amp;&amp; context1.url.includes(&quot;key?devId&quot;)) {\n          // 针对密钥进行base64解密处理\n          const key = keyPreset || JSON.parse(ab2str(response.data)).result.key;\n          response.data = _base64ToArrayBuffer(key);\n        }\n        onSuccess(response, stats, context, networkDetails);\n      };\n      loader.load(context, config, callbacks);\n    };\n  },\n  xhrSetup: function (xhr: XMLHttpRequest, url: string) {\n    // 自定义xhr，替换密钥链接\n    const u = url.includes(ORIGIN_KEY_URL)\n      ? KEY_URL + &quot;?&quot; + (url as string).split(&quot;?&quot;)[1]\n      : url;\n    xhr.open(&quot;GET&quot;, u, true);\n  },\n});\n\nexport default configure;\n</code></pre>\n<h2 id=\"HLS直播延迟原因\"><a href=\"#HLS直播延迟原因\" class=\"headerlink\" title=\"HLS直播延迟原因\"></a>HLS直播延迟原因</h2><ol>\n<li>存在安全缓冲时长，客户端应该从M3U8文件中倒数第三个分片开始播放</li>\n<li>服务器更新M3U8文件的间隔，理论上服务器需要大于等于一个EXT-X-TARGETDURATION的时长去更新M3u8文件</li>\n<li>CDN缓存机制。若当前源站 M3U8 已经更新到了第四个片段，但是CDN边缘节点还缓存着上一个版本的 M3U8文件（只包含3个片段）。此时就需要等文件的TTL过期，边缘节点才会去获取最新版本的 M3U8 文件。而这个缓存TTL也不能取消，如果每个端上的请求到达CDN边缘节点时都去找源站要最新版本，源站就可能会被流量冲垮。</li>\n<li>服务器处理时间：服务器接收到媒体源数据后，进行切片编码之后再进行传输。</li>\n<li>网络延迟：文件从服务器到客户端中间的网络传输延迟。</li>\n</ol>\n<h2 id=\"优化延迟方法\"><a href=\"#优化延迟方法\" class=\"headerlink\" title=\"优化延迟方法\"></a>优化延迟方法</h2><ol>\n<li>减少客户端安全缓冲时长</li>\n<li>减少服务器更新M3U8文件的间隔</li>\n<li>减小分片长度</li>\n</ol>\n"},{"title":"JavaScript高级程序设计笔记","date":"2019-06-01T03:51:41.000Z","_content":"\n### async\njavaScript标签上添加async以及defer属性时，只针对外部引入的js文件。确保相关的js代码依赖问题。\n\n在使用async时，不要在此期间操作dom。\n\n### undefined == null 返回 true\nundefined的值是派生自null值的。\n\n由于typeof null会返回object，所以在定义变量用来保存对象，最好将变量初始化为null而不是其他的值。\n```javascript\nif (car != null){\n// 对 car 对象执行某些操作\n}\n```\n### 函数传参\n\n> ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。\n\n\n```js\n// 引用类型参数传递\n\n\tlet obj = {name:'zhangsan',age:20};\n\tfunction getName(args) {\n\t\targs.name = 'lisi';\n\t\targs = new Object();\n\t\targs.name = 's';\n\t}\n\tgetName(obj);\n\tconsole.log(obj);  // {name:'lisi',age:20}\n\t\n// 基本数据类型参数\n\n\tlet s = 'zhangsannnnn';\n\tfunction changeName(args) {\n\t\targs = 'hahha';\n\t}\n\tchangeName(s);\n\tconsole.log(s);  // zhangsannnnn\n\n```\n> 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\n> ***可以把** ECMAScript 函数的参数想象成局部变量。*\n\n- 对于基本类型的参数传递，相当于在函数内部直接复制一份，虽然值一样，确实两个独立的内存空间。\n- 对于引用类型参数传递，也是将传递的是当前引用变量所保存的内存地址的值复制一份。所以在修改操作相关属性时，会影响到外部变量。而对其进行重新赋值时，会改变函数内部新复制的局部变量的值，并不会影响到外部变量的指向问题。\n\n### Function类型\n\n> 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定。函数一般都是使用函数声明语法定义的。\n\n\n```js\nfunction sum (num1, num2) {\n    return num1 + num2;\n}\n```\n这与下面使用函数表达式定义函数的方式几乎相差无几。\n\n\n```js\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n**不推荐使用Function构造函数，Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，儿前面的参数则枚举出了新函数的函数参数。**\n\n\n```js\nvar sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); // 不推荐\n```\n> 不推荐这种方式创建函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串，调用解析器对性能损耗较大），从而影响性能。不过，这种语法对于理解”函数是对象，函数名是指针“的概念比较直观。\n\n函数名仅仅是指向函数的指针：\n\n\n```js\nfunction sum(num1, num2) {\n    return num1 + num2;\n}\nconsole.log(sum(10,10));  // 20\nlet anotherSum = sum;\nconsole.log(anotherSum(10,10));  // 20\nsum = null;\nconsole.log(anotherSum(10,10));  // 20\n```\n### 函数声明与函数表达式\n\n解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n\n\n```js\nconsole.log(sum(10, 10));  // 20\nfunction sum(sum1, sum2) {\n    return num1 + num2\n}\n```\n> 以上代码完全可以正常运行，因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，及时声明函数的代码在调用它的代码后面，js引擎也能把函数声明提升到顶部。\n\n\n```js\nconsole.log(sum(10,10)); // 报错\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n> 以上代码会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用。\n\n**除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。**\n\n### 函数内部属性\n\n> 在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。\n\n```js\n// 定义一个阶乘函数\nfunction factorial(num) {\n    if(num <= 1) {\n        return 1;\n    }else {\n        return num * factorial(num - 1)\n    }\n}\n```\n定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变得情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起，为了消除这种紧密耦合的现象，可以向下面这样使用arguments.callee：\n\n```js\nfunction factorial(num) {\n    if(num <= 1) {\n        return 1;\n    }else {\n        return num * arguments,callee(num - 1)\n    }\n}\n\n/*\n    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n*/\n\nvar trueFactorial = factorial;\n\nfactorial = function() {\n    return 0;\n}\n\nconsole.log(trueFactorial(5));  // 120\nconsole.log(factorial(5));  // 0\n```\n\n### 函数属性和方法\n\n> 每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。\n\n\n```js\nfunction sayName(name) {\n    console.log(name);\n}\nfunction sum(num1, num2) {\n    return num1 + num2\n}\nfunction sayHi() {\n    console.log(\"hi\");\n}\n\nconsole.log(sayName.length);  // 1\nconsole.log(sum.length);      // 2\nconsole.log(sayHi.length);    // 0\n```\n\n相关方法使用：\n\n- trim方法：会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。\n- random方法：Math.random方法返回大于等于0小于1的一个随机数。\n\n```js\n值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)\n\n// 如果你想选择一个1到10之间的数值：\nvar num = Math.floor(Math.random() * 10 + 1);\n\n// 一个介于2到10之间的值：\nvar num = Math.floor(Math.random() * 9 + 2);\n\nfunction selectFrom(lowerValue, upperValue) {\n    var choices = upperValue - lowerValue + 1;\n    return Math.floor(Math.random() * choices + lowerValue);\n}\nvar num = selectFrom(2, 10);\nconsole.log(num); // 介于2和10之间(包括2和10)的一个数值\n\n```\n### 对象属性和方法\n\n**通过字面量方式定义对象**\n```js\nvar person = {\n    name: 'Bar',\n    age: 20,\n    sayName: function() {\n        console.log(this.name);\n    }\n}\n```\n\n1. 数据属性\n> 数据属性包含一个数据值得位置。在这个位置可以读取和写入。数据属性有四个描述其行为的特性。\n\n- [[Configurable]]： 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面通过字面量直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子那样直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Value]]：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性默认值为undefined。\n\n要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在对象、属性的名字和一个描述符对象。其中，描述符对象属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。例如：\n```js\nvar person = {};\nObject.defineProperty(person, \"name\", {\n    writable: false,  // 不可以修改属性的值\n    value: \"Bar\"\n});\nconsole.log(person.name);  // Bar\nperson.name = \"Jack\";\nconsole.log(person.name);  // Bar\n```\n把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。**而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。**此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：\n```js\nvar person = {};\nObject.defineProperty(person, \"name\", {\n    configurable: false,\n    value: \"Bar\"\n})\n\n// 抛出错误\nObject.defineProperty(person, \"name\", {\n    configurable: true,\n    value: \"Bar\"\n})\n\n// 也就是说，可以多次调用Object.defineProperty()方法修改统一属性，但在把configurable特性设置为false之后就会有限制了。\n```\n2. 访问器属性\n> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有以下4个特性。\n- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。\n- [[Enumerable]]：表示能否通过for-in循环返回属性。\n- [[Get]]：在读取属性时调用的函数。\n- [[Set]]：在写入属性时调用的函数。\n\n同样的，访问器属性也不能直接定义，必须使用Object.defineProperty()来定义。\n```js\nvar book = {\n    _year: 2004,\n    edition: 1\n};\n\nObject.defineProperty(book, \"year\", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newValue) {\n        if(newValue > 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n})\nbook.year = 2005;\nconsole.log(book.edition);  // 2\n```\n> 不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下会报错。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：__defineGetter__()和__defineSetter__()。\n\n```js\nvar book = {\n    _year: 2004,\n    edition: 1\n};\n\n//定义访问器的旧有方法\nbook.__defineGetter__(\"year\", function() {\n    return this._year;\n});\n\nbook.__defineSetter__(\"year\", function(newValue) {\n    if(newValue > 2004) {\n        this._year = newValue;\n        this.edition += newValue - 2004;\n    }\n})\n```\n**由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。** 利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。\n```js\nvar book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function(newValue) {\n            if(newValue > 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n})\n```\n### 创建对象\n> **虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。**\n1. 工厂模式\n\n```js\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        console.log(this.name);\n    }\n    return o;\n}\n\nvar person1 = createPerson(\"Bar\", 20, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n\n// 此函数能够根据接收的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。\n```\n2. 构造函数模式\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        console.log(this.name);\n    }\n}\n\nvar person1 = new Person(\"Bar\", 20, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n\n**特点：**\n\n- 没有显式的创建对象；\n- 直接将属性和方法赋给了this对象；\n- 没有return语句；\n- 函数名Person使用的是大写字母开头；\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n- 1. 创建一个新对象\n- 2. 将构造函数的作用域赋给新对象（因此this指向的就是新对象）\n- 3. 执行构造函数中的代码（为这个新对象添加属性）\n- 4. 返回新对象\n\n*前面例子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person*\n\n```js\nconsole.log(person1.constructor === Person);  // true\nconsole.log(person2.constructor === Person);  // true\n```\n##### 构造函数的问题\n\n> 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了-------ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = new Function(\"console.log(this.name)\"); // 与声明函数在逻辑上是等价的\n}\n\n// 不同实例上的同名函数是不相等的\n\nconsole.log(person1.sayName == person2.sayName);  //false\n```\n创建两个完全同样任务的Function实例的确没有必要。况且有this对象在，根本不用再执行代码前就把函数绑定到特定对象上面。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\nfunction sayName() {\n    console.log(this.name);\n}\n```\n\n##### 原型模式\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 20;\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\n\nvar person1 = new Person();\nperson1.sayName();  // Nicholas\n\nvar person2 = new Person();\nperson2.sayName();  // Nicholas\nconsole.log(person1.sayName == person2.sayName);  //true\n```\n\n##### 原型与in操作符\n\n有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独的使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。\n```js\nfunction Person(){\n}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\nvar person1 = new Person();\nvar person2 = new Person();\nalert(person1.hasOwnProperty(\"name\"));  //false\nalert(\"name\" in person1);  //true\nperson1.name = \"Greg\";\nalert(person1.name); //\"Greg\" ——来自实例\nalert(person1.hasOwnProperty(\"name\")); //true\nalert(\"name\" in person1); //true\nalert(person2.name); //\"Nicholas\" ——来自原型\nalert(person2.hasOwnProperty(\"name\")); //false\nalert(\"name\" in person2); //true\ndelete person1.name;\nalert(person1.name); //\"Nicholas\" ——来自原型\nalert(person1.hasOwnProperty(\"name\")); //false\nalert(\"name\" in person1); //true\n```\n\n通过同时使用hasOwnProperty方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。\n\n```js\nfunction hasPrototypeProperty(object, name) {\n    return !object.hasOwnProperty(name) && (name in object);\n}\n\n```\n由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty返回false，就可以确定属性是原型中的属性。","source":"_posts/JavaScript高级程序设计笔记.md","raw":"---\ntitle: JavaScript高级程序设计笔记\ndate: 2019-06-01 11:51:41\ntags: js\ncategories: 读书笔记\n---\n\n### async\njavaScript标签上添加async以及defer属性时，只针对外部引入的js文件。确保相关的js代码依赖问题。\n\n在使用async时，不要在此期间操作dom。\n\n### undefined == null 返回 true\nundefined的值是派生自null值的。\n\n由于typeof null会返回object，所以在定义变量用来保存对象，最好将变量初始化为null而不是其他的值。\n```javascript\nif (car != null){\n// 对 car 对象执行某些操作\n}\n```\n### 函数传参\n\n> ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。\n\n\n```js\n// 引用类型参数传递\n\n\tlet obj = {name:'zhangsan',age:20};\n\tfunction getName(args) {\n\t\targs.name = 'lisi';\n\t\targs = new Object();\n\t\targs.name = 's';\n\t}\n\tgetName(obj);\n\tconsole.log(obj);  // {name:'lisi',age:20}\n\t\n// 基本数据类型参数\n\n\tlet s = 'zhangsannnnn';\n\tfunction changeName(args) {\n\t\targs = 'hahha';\n\t}\n\tchangeName(s);\n\tconsole.log(s);  // zhangsannnnn\n\n```\n> 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\n> ***可以把** ECMAScript 函数的参数想象成局部变量。*\n\n- 对于基本类型的参数传递，相当于在函数内部直接复制一份，虽然值一样，确实两个独立的内存空间。\n- 对于引用类型参数传递，也是将传递的是当前引用变量所保存的内存地址的值复制一份。所以在修改操作相关属性时，会影响到外部变量。而对其进行重新赋值时，会改变函数内部新复制的局部变量的值，并不会影响到外部变量的指向问题。\n\n### Function类型\n\n> 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定。函数一般都是使用函数声明语法定义的。\n\n\n```js\nfunction sum (num1, num2) {\n    return num1 + num2;\n}\n```\n这与下面使用函数表达式定义函数的方式几乎相差无几。\n\n\n```js\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n**不推荐使用Function构造函数，Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，儿前面的参数则枚举出了新函数的函数参数。**\n\n\n```js\nvar sum = new Function(\"num1\", \"num2\", \"return num1 + num2\"); // 不推荐\n```\n> 不推荐这种方式创建函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串，调用解析器对性能损耗较大），从而影响性能。不过，这种语法对于理解”函数是对象，函数名是指针“的概念比较直观。\n\n函数名仅仅是指向函数的指针：\n\n\n```js\nfunction sum(num1, num2) {\n    return num1 + num2;\n}\nconsole.log(sum(10,10));  // 20\nlet anotherSum = sum;\nconsole.log(anotherSum(10,10));  // 20\nsum = null;\nconsole.log(anotherSum(10,10));  // 20\n```\n### 函数声明与函数表达式\n\n解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n\n\n```js\nconsole.log(sum(10, 10));  // 20\nfunction sum(sum1, sum2) {\n    return num1 + num2\n}\n```\n> 以上代码完全可以正常运行，因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，及时声明函数的代码在调用它的代码后面，js引擎也能把函数声明提升到顶部。\n\n\n```js\nconsole.log(sum(10,10)); // 报错\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n```\n> 以上代码会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用。\n\n**除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。**\n\n### 函数内部属性\n\n> 在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。\n\n```js\n// 定义一个阶乘函数\nfunction factorial(num) {\n    if(num <= 1) {\n        return 1;\n    }else {\n        return num * factorial(num - 1)\n    }\n}\n```\n定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变得情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起，为了消除这种紧密耦合的现象，可以向下面这样使用arguments.callee：\n\n```js\nfunction factorial(num) {\n    if(num <= 1) {\n        return 1;\n    }else {\n        return num * arguments,callee(num - 1)\n    }\n}\n\n/*\n    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n*/\n\nvar trueFactorial = factorial;\n\nfactorial = function() {\n    return 0;\n}\n\nconsole.log(trueFactorial(5));  // 120\nconsole.log(factorial(5));  // 0\n```\n\n### 函数属性和方法\n\n> 每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。\n\n\n```js\nfunction sayName(name) {\n    console.log(name);\n}\nfunction sum(num1, num2) {\n    return num1 + num2\n}\nfunction sayHi() {\n    console.log(\"hi\");\n}\n\nconsole.log(sayName.length);  // 1\nconsole.log(sum.length);      // 2\nconsole.log(sayHi.length);    // 0\n```\n\n相关方法使用：\n\n- trim方法：会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。\n- random方法：Math.random方法返回大于等于0小于1的一个随机数。\n\n```js\n值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)\n\n// 如果你想选择一个1到10之间的数值：\nvar num = Math.floor(Math.random() * 10 + 1);\n\n// 一个介于2到10之间的值：\nvar num = Math.floor(Math.random() * 9 + 2);\n\nfunction selectFrom(lowerValue, upperValue) {\n    var choices = upperValue - lowerValue + 1;\n    return Math.floor(Math.random() * choices + lowerValue);\n}\nvar num = selectFrom(2, 10);\nconsole.log(num); // 介于2和10之间(包括2和10)的一个数值\n\n```\n### 对象属性和方法\n\n**通过字面量方式定义对象**\n```js\nvar person = {\n    name: 'Bar',\n    age: 20,\n    sayName: function() {\n        console.log(this.name);\n    }\n}\n```\n\n1. 数据属性\n> 数据属性包含一个数据值得位置。在这个位置可以读取和写入。数据属性有四个描述其行为的特性。\n\n- [[Configurable]]： 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面通过字面量直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子那样直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。\n- [[Value]]：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性默认值为undefined。\n\n要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在对象、属性的名字和一个描述符对象。其中，描述符对象属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。例如：\n```js\nvar person = {};\nObject.defineProperty(person, \"name\", {\n    writable: false,  // 不可以修改属性的值\n    value: \"Bar\"\n});\nconsole.log(person.name);  // Bar\nperson.name = \"Jack\";\nconsole.log(person.name);  // Bar\n```\n把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。**而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。**此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：\n```js\nvar person = {};\nObject.defineProperty(person, \"name\", {\n    configurable: false,\n    value: \"Bar\"\n})\n\n// 抛出错误\nObject.defineProperty(person, \"name\", {\n    configurable: true,\n    value: \"Bar\"\n})\n\n// 也就是说，可以多次调用Object.defineProperty()方法修改统一属性，但在把configurable特性设置为false之后就会有限制了。\n```\n2. 访问器属性\n> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有以下4个特性。\n- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。\n- [[Enumerable]]：表示能否通过for-in循环返回属性。\n- [[Get]]：在读取属性时调用的函数。\n- [[Set]]：在写入属性时调用的函数。\n\n同样的，访问器属性也不能直接定义，必须使用Object.defineProperty()来定义。\n```js\nvar book = {\n    _year: 2004,\n    edition: 1\n};\n\nObject.defineProperty(book, \"year\", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newValue) {\n        if(newValue > 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n})\nbook.year = 2005;\nconsole.log(book.edition);  // 2\n```\n> 不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下会报错。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：__defineGetter__()和__defineSetter__()。\n\n```js\nvar book = {\n    _year: 2004,\n    edition: 1\n};\n\n//定义访问器的旧有方法\nbook.__defineGetter__(\"year\", function() {\n    return this._year;\n});\n\nbook.__defineSetter__(\"year\", function(newValue) {\n    if(newValue > 2004) {\n        this._year = newValue;\n        this.edition += newValue - 2004;\n    }\n})\n```\n**由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。** 利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。\n```js\nvar book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function(newValue) {\n            if(newValue > 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n})\n```\n### 创建对象\n> **虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。**\n1. 工厂模式\n\n```js\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        console.log(this.name);\n    }\n    return o;\n}\n\nvar person1 = createPerson(\"Bar\", 20, \"Software Engineer\");\nvar person2 = createPerson(\"Greg\", 27, \"Doctor\");\n\n// 此函数能够根据接收的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。\n```\n2. 构造函数模式\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function() {\n        console.log(this.name);\n    }\n}\n\nvar person1 = new Person(\"Bar\", 20, \"Software Engineer\");\nvar person2 = new Person(\"Greg\", 27, \"Doctor\");\n```\n\n**特点：**\n\n- 没有显式的创建对象；\n- 直接将属性和方法赋给了this对象；\n- 没有return语句；\n- 函数名Person使用的是大写字母开头；\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n- 1. 创建一个新对象\n- 2. 将构造函数的作用域赋给新对象（因此this指向的就是新对象）\n- 3. 执行构造函数中的代码（为这个新对象添加属性）\n- 4. 返回新对象\n\n*前面例子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person*\n\n```js\nconsole.log(person1.constructor === Person);  // true\nconsole.log(person2.constructor === Person);  // true\n```\n##### 构造函数的问题\n\n> 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了-------ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = new Function(\"console.log(this.name)\"); // 与声明函数在逻辑上是等价的\n}\n\n// 不同实例上的同名函数是不相等的\n\nconsole.log(person1.sayName == person2.sayName);  //false\n```\n创建两个完全同样任务的Function实例的确没有必要。况且有this对象在，根本不用再执行代码前就把函数绑定到特定对象上面。\n\n```js\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\nfunction sayName() {\n    console.log(this.name);\n}\n```\n\n##### 原型模式\n```js\nfunction Person() {}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 20;\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\n\nvar person1 = new Person();\nperson1.sayName();  // Nicholas\n\nvar person2 = new Person();\nperson2.sayName();  // Nicholas\nconsole.log(person1.sayName == person2.sayName);  //true\n```\n\n##### 原型与in操作符\n\n有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独的使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。\n```js\nfunction Person(){\n}\nPerson.prototype.name = \"Nicholas\";\nPerson.prototype.age = 29;\nPerson.prototype.job = \"Software Engineer\";\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\nvar person1 = new Person();\nvar person2 = new Person();\nalert(person1.hasOwnProperty(\"name\"));  //false\nalert(\"name\" in person1);  //true\nperson1.name = \"Greg\";\nalert(person1.name); //\"Greg\" ——来自实例\nalert(person1.hasOwnProperty(\"name\")); //true\nalert(\"name\" in person1); //true\nalert(person2.name); //\"Nicholas\" ——来自原型\nalert(person2.hasOwnProperty(\"name\")); //false\nalert(\"name\" in person2); //true\ndelete person1.name;\nalert(person1.name); //\"Nicholas\" ——来自原型\nalert(person1.hasOwnProperty(\"name\")); //false\nalert(\"name\" in person1); //true\n```\n\n通过同时使用hasOwnProperty方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。\n\n```js\nfunction hasPrototypeProperty(object, name) {\n    return !object.hasOwnProperty(name) && (name in object);\n}\n\n```\n由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty返回false，就可以确定属性是原型中的属性。","slug":"JavaScript高级程序设计笔记","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9b000r1xophyb9asql","content":"<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>javaScript标签上添加async以及defer属性时，只针对外部引入的js文件。确保相关的js代码依赖问题。</p>\n<p>在使用async时，不要在此期间操作dom。</p>\n<h3 id=\"undefined-null-返回-true\"><a href=\"#undefined-null-返回-true\" class=\"headerlink\" title=\"undefined == null 返回 true\"></a>undefined == null 返回 true</h3><p>undefined的值是派生自null值的。</p>\n<p>由于typeof null会返回object，所以在定义变量用来保存对象，最好将变量初始化为null而不是其他的值。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>car <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token comment\" spellcheck=\"true\">// 对 car 对象执行某些操作</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h3><blockquote>\n<p>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 引用类型参数传递</span>\n\n    <span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span><span class=\"token string\">'zhangsan'</span><span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">:</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        args<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'lisi'</span><span class=\"token punctuation\">;</span>\n        args <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        args<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'s'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// {name:'lisi',age:20}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 基本数据类型参数</span>\n\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">'zhangsannnnn'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">changeName</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        args <span class=\"token operator\">=</span> <span class=\"token string\">'hahha'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">changeName</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// zhangsannnnn</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。<br><strong>*可以把</strong> ECMAScript 函数的参数想象成局部变量。*</p>\n</blockquote>\n<ul>\n<li>对于基本类型的参数传递，相当于在函数内部直接复制一份，虽然值一样，确实两个独立的内存空间。</li>\n<li>对于引用类型参数传递，也是将传递的是当前引用变量所保存的内存地址的值复制一份。所以在修改操作相关属性时，会影响到外部变量。而对其进行重新赋值时，会改变函数内部新复制的局部变量的值，并不会影响到外部变量的指向问题。</li>\n</ul>\n<h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><blockquote>\n<p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定。函数一般都是使用函数声明语法定义的。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> sum <span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>这与下面使用函数表达式定义函数的方式几乎相差无几。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>不推荐使用Function构造函数，Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，儿前面的参数则枚举出了新函数的函数参数。</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"num1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"return num1 + num2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不推荐</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>不推荐这种方式创建函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串，调用解析器对性能损耗较大），从而影响性能。不过，这种语法对于理解”函数是对象，函数名是指针“的概念比较直观。</p>\n</blockquote>\n<p>函数名仅仅是指向函数的指针：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n<span class=\"token keyword\">let</span> anotherSum <span class=\"token operator\">=</span> sum<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">anotherSum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 20</span>\nsum <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">anotherSum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 20</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>sum1<span class=\"token punctuation\">,</span> sum2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>以上代码完全可以正常运行，因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，及时声明函数的代码在调用它的代码后面，js引擎也能把函数声明提升到顶部。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 报错</span>\n<span class=\"token keyword\">var</span> sum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>以上代码会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用。</p>\n</blockquote>\n<p><strong>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</strong></p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><blockquote>\n<p>在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 定义一个阶乘函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变得情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起，为了消除这种紧密耦合的现象，可以向下面这样使用arguments.callee：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num <span class=\"token operator\">*</span> arguments<span class=\"token punctuation\">,</span><span class=\"token function\">callee</span><span class=\"token punctuation\">(</span>num <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n*/</span>\n\n<span class=\"token keyword\">var</span> trueFactorial <span class=\"token operator\">=</span> factorial<span class=\"token punctuation\">;</span>\n\nfactorial <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">trueFactorial</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 120</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 0</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h3><blockquote>\n<p>每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>num1<span class=\"token punctuation\">,</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sayName<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\" spellcheck=\"true\">// 2</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sayHi<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 0</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>相关方法使用：</p>\n<ul>\n<li>trim方法：会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</li>\n<li>random方法：Math.random方法返回大于等于0小于1的一个随机数。</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">值 <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> 可能值的总数 <span class=\"token operator\">+</span> 第一个可能的值<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 如果你想选择一个1到10之间的数值：</span>\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">10</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 一个介于2到10之间的值：</span>\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">9</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">selectFrom</span><span class=\"token punctuation\">(</span>lowerValue<span class=\"token punctuation\">,</span> upperValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> choices <span class=\"token operator\">=</span> upperValue <span class=\"token operator\">-</span> lowerValue <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> choices <span class=\"token operator\">+</span> lowerValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token function\">selectFrom</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 介于2和10之间(包括2和10)的一个数值</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"对象属性和方法\"><a href=\"#对象属性和方法\" class=\"headerlink\" title=\"对象属性和方法\"></a>对象属性和方法</h3><p><strong>通过字面量方式定义对象</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Bar'</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n    sayName<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol>\n<li>数据属性<blockquote>\n<p>数据属性包含一个数据值得位置。在这个位置可以读取和写入。数据属性有四个描述其行为的特性。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>[[Configurable]]： 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面通过字面量直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Value]]：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性默认值为undefined。</li>\n</ul>\n<p>要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在对象、属性的名字和一个描述符对象。其中，描述符对象属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。例如：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\" spellcheck=\"true\">// 不可以修改属性的值</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Bar\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Bar</span>\nperson<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Jack\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Bar</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。<strong>而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。</strong>此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Bar\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 抛出错误</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">,</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    configurable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    value<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Bar\"</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 也就是说，可以多次调用Object.defineProperty()方法修改统一属性，但在把configurable特性设置为false之后就会有限制了。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"2\">\n<li>访问器属性<blockquote>\n<p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有以下4个特性。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li>\n<li>[[Enumerable]]：表示能否通过for-in循环返回属性。</li>\n<li>[[Get]]：在读取属性时调用的函数。</li>\n<li>[[Set]]：在写入属性时调用的函数。</li>\n</ul>\n<p>同样的，访问器属性也不能直接定义，必须使用Object.defineProperty()来定义。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> book <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    _year<span class=\"token punctuation\">:</span> <span class=\"token number\">2004</span><span class=\"token punctuation\">,</span>\n    edition<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>book<span class=\"token punctuation\">,</span> <span class=\"token string\">\"year\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>newValue <span class=\"token operator\">></span> <span class=\"token number\">2004</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>edition <span class=\"token operator\">+</span><span class=\"token operator\">=</span> newValue <span class=\"token operator\">-</span> <span class=\"token number\">2004</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nbook<span class=\"token punctuation\">.</span>year <span class=\"token operator\">=</span> <span class=\"token number\">2005</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>book<span class=\"token punctuation\">.</span>edition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 2</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下会报错。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> book <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    _year<span class=\"token punctuation\">:</span> <span class=\"token number\">2004</span><span class=\"token punctuation\">,</span>\n    edition<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//定义访问器的旧有方法</span>\nbook<span class=\"token punctuation\">.</span><span class=\"token function\">__defineGetter__</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"year\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbook<span class=\"token punctuation\">.</span><span class=\"token function\">__defineSetter__</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"year\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>newValue <span class=\"token operator\">></span> <span class=\"token number\">2004</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>edition <span class=\"token operator\">+</span><span class=\"token operator\">=</span> newValue <span class=\"token operator\">-</span> <span class=\"token number\">2004</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。</strong> 利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> book <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperties</span><span class=\"token punctuation\">(</span>book<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    _year<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token number\">2004</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    edition<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    year<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">get</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">set</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>newValue <span class=\"token operator\">></span> <span class=\"token number\">2004</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_year <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>edition <span class=\"token operator\">+</span><span class=\"token operator\">=</span> newValue <span class=\"token operator\">-</span> <span class=\"token number\">2004</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><blockquote>\n<p><strong>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</strong></p>\n<ol>\n<li>工厂模式</li>\n</ol>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> o<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bar\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token function\">createPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">27</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Doctor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 此函数能够根据接收的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"2\">\n<li>构造函数模式<br><code>`</code>js<br>function Person(name, age, job) {<br> this.name = name;<br> this.age = age;<br> this.job = job;<br> this.sayName = function() {<pre><code> console.log(this.name);\n</code></pre> }<br>}</li>\n</ol>\n<p>var person1 = new Person(“Bar”, 20, “Software Engineer”);<br>var person2 = new Person(“Greg”, 27, “Doctor”);</p>\n<pre><code>\n**特点：**\n\n- 没有显式的创建对象；\n- 直接将属性和方法赋给了this对象；\n- 没有return语句；\n- 函数名Person使用的是大写字母开头；\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n- 1. 创建一个新对象\n- 2. 将构造函数的作用域赋给新对象（因此this指向的就是新对象）\n- 3. 执行构造函数中的代码（为这个新对象添加属性）\n- 4. 返回新对象\n\n*前面例子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person*\n\n```js\nconsole.log(person1.constructor === Person);  // true\nconsole.log(person2.constructor === Person);  // true\n</code></pre><h5 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h5><blockquote>\n<p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了——-ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"console.log(this.name)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 与声明函数在逻辑上是等价的</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 不同实例上的同名函数是不相等的</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//false</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>创建两个完全同样任务的Function实例的确没有必要。况且有this对象在，根本不用再执行代码前就把函数绑定到特定对象上面。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">,</span> job<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> job<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> sayName<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson1<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Nicholas</span>\n\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nperson2<span class=\"token punctuation\">.</span><span class=\"token function\">sayName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// Nicholas</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">==</span> person2<span class=\"token punctuation\">.</span>sayName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"原型与in操作符\"><a href=\"#原型与in操作符\" class=\"headerlink\" title=\"原型与in操作符\"></a>原型与in操作符</h5><p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独的使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Nicholas\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>job <span class=\"token operator\">=</span> <span class=\"token string\">\"Software Engineer\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>sayName <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//false</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span> <span class=\"token keyword\">in</span> person1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//true</span>\nperson1<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"Greg\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"Greg\" ——来自实例</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span> <span class=\"token keyword\">in</span> person1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person2<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"Nicholas\" ——来自原型</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person2<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//false</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span> <span class=\"token keyword\">in</span> person2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span class=\"token keyword\">delete</span> person1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"Nicholas\" ——来自原型</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>person1<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//false</span>\n<span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span> <span class=\"token keyword\">in</span> person1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通过同时使用hasOwnProperty方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">hasPrototypeProperty</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span>object<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty返回false，就可以确定属性是原型中的属性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>javaScript标签上添加async以及defer属性时，只针对外部引入的js文件。确保相关的js代码依赖问题。</p>\n<p>在使用async时，不要在此期间操作dom。</p>\n<h3 id=\"undefined-null-返回-true\"><a href=\"#undefined-null-返回-true\" class=\"headerlink\" title=\"undefined == null 返回 true\"></a>undefined == null 返回 true</h3><p>undefined的值是派生自null值的。</p>\n<p>由于typeof null会返回object，所以在定义变量用来保存对象，最好将变量初始化为null而不是其他的值。</p>\n<pre><code class=\"javascript\">if (car != null){\n// 对 car 对象执行某些操作\n}\n</code></pre>\n<h3 id=\"函数传参\"><a href=\"#函数传参\" class=\"headerlink\" title=\"函数传参\"></a>函数传参</h3><blockquote>\n<p>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</p>\n</blockquote>\n<pre><code class=\"js\">// 引用类型参数传递\n\n    let obj = {name:&#39;zhangsan&#39;,age:20};\n    function getName(args) {\n        args.name = &#39;lisi&#39;;\n        args = new Object();\n        args.name = &#39;s&#39;;\n    }\n    getName(obj);\n    console.log(obj);  // {name:&#39;lisi&#39;,age:20}\n\n// 基本数据类型参数\n\n    let s = &#39;zhangsannnnn&#39;;\n    function changeName(args) {\n        args = &#39;hahha&#39;;\n    }\n    changeName(s);\n    console.log(s);  // zhangsannnnn\n\n</code></pre>\n<blockquote>\n<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用 ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时，会把 这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。<br><strong>*可以把</strong> ECMAScript 函数的参数想象成局部变量。*</p>\n</blockquote>\n<ul>\n<li>对于基本类型的参数传递，相当于在函数内部直接复制一份，虽然值一样，确实两个独立的内存空间。</li>\n<li>对于引用类型参数传递，也是将传递的是当前引用变量所保存的内存地址的值复制一份。所以在修改操作相关属性时，会影响到外部变量。而对其进行重新赋值时，会改变函数内部新复制的局部变量的值，并不会影响到外部变量的指向问题。</li>\n</ul>\n<h3 id=\"Function类型\"><a href=\"#Function类型\" class=\"headerlink\" title=\"Function类型\"></a>Function类型</h3><blockquote>\n<p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，并不会与某个函数绑定。函数一般都是使用函数声明语法定义的。</p>\n</blockquote>\n<pre><code class=\"js\">function sum (num1, num2) {\n    return num1 + num2;\n}\n</code></pre>\n<p>这与下面使用函数表达式定义函数的方式几乎相差无几。</p>\n<pre><code class=\"js\">var sum = function(num1, num2) {\n    return num1 + num2;\n}\n</code></pre>\n<p><strong>不推荐使用Function构造函数，Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，儿前面的参数则枚举出了新函数的函数参数。</strong></p>\n<pre><code class=\"js\">var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;); // 不推荐\n</code></pre>\n<blockquote>\n<p>不推荐这种方式创建函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串，调用解析器对性能损耗较大），从而影响性能。不过，这种语法对于理解”函数是对象，函数名是指针“的概念比较直观。</p>\n</blockquote>\n<p>函数名仅仅是指向函数的指针：</p>\n<pre><code class=\"js\">function sum(num1, num2) {\n    return num1 + num2;\n}\nconsole.log(sum(10,10));  // 20\nlet anotherSum = sum;\nconsole.log(anotherSum(10,10));  // 20\nsum = null;\nconsole.log(anotherSum(10,10));  // 20\n</code></pre>\n<h3 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用；而函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>\n<pre><code class=\"js\">console.log(sum(10, 10));  // 20\nfunction sum(sum1, sum2) {\n    return num1 + num2\n}\n</code></pre>\n<blockquote>\n<p>以上代码完全可以正常运行，因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，js引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，及时声明函数的代码在调用它的代码后面，js引擎也能把函数声明提升到顶部。</p>\n</blockquote>\n<pre><code class=\"js\">console.log(sum(10,10)); // 报错\nvar sum = function(num1, num2) {\n    return num1 + num2;\n}\n</code></pre>\n<blockquote>\n<p>以上代码会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用。</p>\n</blockquote>\n<p><strong>除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。</strong></p>\n<h3 id=\"函数内部属性\"><a href=\"#函数内部属性\" class=\"headerlink\" title=\"函数内部属性\"></a>函数内部属性</h3><blockquote>\n<p>在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</p>\n</blockquote>\n<pre><code class=\"js\">// 定义一个阶乘函数\nfunction factorial(num) {\n    if(num &lt;= 1) {\n        return 1;\n    }else {\n        return num * factorial(num - 1)\n    }\n}\n</code></pre>\n<p>定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变得情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起，为了消除这种紧密耦合的现象，可以向下面这样使用arguments.callee：</p>\n<pre><code class=\"js\">function factorial(num) {\n    if(num &lt;= 1) {\n        return 1;\n    }else {\n        return num * arguments,callee(num - 1)\n    }\n}\n\n/*\n    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。\n*/\n\nvar trueFactorial = factorial;\n\nfactorial = function() {\n    return 0;\n}\n\nconsole.log(trueFactorial(5));  // 120\nconsole.log(factorial(5));  // 0\n</code></pre>\n<h3 id=\"函数属性和方法\"><a href=\"#函数属性和方法\" class=\"headerlink\" title=\"函数属性和方法\"></a>函数属性和方法</h3><blockquote>\n<p>每个函数都包含两个属性：length和prototype。length属性表示函数希望接收的命名参数的个数。</p>\n</blockquote>\n<pre><code class=\"js\">function sayName(name) {\n    console.log(name);\n}\nfunction sum(num1, num2) {\n    return num1 + num2\n}\nfunction sayHi() {\n    console.log(&quot;hi&quot;);\n}\n\nconsole.log(sayName.length);  // 1\nconsole.log(sum.length);      // 2\nconsole.log(sayHi.length);    // 0\n</code></pre>\n<p>相关方法使用：</p>\n<ul>\n<li>trim方法：会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</li>\n<li>random方法：Math.random方法返回大于等于0小于1的一个随机数。</li>\n</ul>\n<pre><code class=\"js\">值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)\n\n// 如果你想选择一个1到10之间的数值：\nvar num = Math.floor(Math.random() * 10 + 1);\n\n// 一个介于2到10之间的值：\nvar num = Math.floor(Math.random() * 9 + 2);\n\nfunction selectFrom(lowerValue, upperValue) {\n    var choices = upperValue - lowerValue + 1;\n    return Math.floor(Math.random() * choices + lowerValue);\n}\nvar num = selectFrom(2, 10);\nconsole.log(num); // 介于2和10之间(包括2和10)的一个数值\n\n</code></pre>\n<h3 id=\"对象属性和方法\"><a href=\"#对象属性和方法\" class=\"headerlink\" title=\"对象属性和方法\"></a>对象属性和方法</h3><p><strong>通过字面量方式定义对象</strong></p>\n<pre><code class=\"js\">var person = {\n    name: &#39;Bar&#39;,\n    age: 20,\n    sayName: function() {\n        console.log(this.name);\n    }\n}\n</code></pre>\n<ol>\n<li>数据属性<blockquote>\n<p>数据属性包含一个数据值得位置。在这个位置可以读取和写入。数据属性有四个描述其行为的特性。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>[[Configurable]]： 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面通过字面量直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Enumerable]]：表示能否通过for-in循环返回属性。像前面例子那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>\n<li>[[Value]]：包含这个属性的数据值。读取属性值得时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性默认值为undefined。</li>\n</ul>\n<p>要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在对象、属性的名字和一个描述符对象。其中，描述符对象属性必须是：configurable、enumerable、writable和value。设置其中一个或多个值，可以修改对应的特性值。例如：</p>\n<pre><code class=\"js\">var person = {};\nObject.defineProperty(person, &quot;name&quot;, {\n    writable: false,  // 不可以修改属性的值\n    value: &quot;Bar&quot;\n});\nconsole.log(person.name);  // Bar\nperson.name = &quot;Jack&quot;;\nconsole.log(person.name);  // Bar\n</code></pre>\n<p>把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。<strong>而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。</strong>此时，再调用Object.defineProperty()方法修改除了writable之外的特性，都会导致错误：</p>\n<pre><code class=\"js\">var person = {};\nObject.defineProperty(person, &quot;name&quot;, {\n    configurable: false,\n    value: &quot;Bar&quot;\n})\n\n// 抛出错误\nObject.defineProperty(person, &quot;name&quot;, {\n    configurable: true,\n    value: &quot;Bar&quot;\n})\n\n// 也就是说，可以多次调用Object.defineProperty()方法修改统一属性，但在把configurable特性设置为false之后就会有限制了。\n</code></pre>\n<ol start=\"2\">\n<li>访问器属性<blockquote>\n<p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有以下4个特性。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li>\n<li>[[Enumerable]]：表示能否通过for-in循环返回属性。</li>\n<li>[[Get]]：在读取属性时调用的函数。</li>\n<li>[[Set]]：在写入属性时调用的函数。</li>\n</ul>\n<p>同样的，访问器属性也不能直接定义，必须使用Object.defineProperty()来定义。</p>\n<pre><code class=\"js\">var book = {\n    _year: 2004,\n    edition: 1\n};\n\nObject.defineProperty(book, &quot;year&quot;, {\n    get: function() {\n        return this._year;\n    },\n    set: function(newValue) {\n        if(newValue &gt; 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n})\nbook.year = 2005;\nconsole.log(book.edition);  // 2\n</code></pre>\n<blockquote>\n<p>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下会报错。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。</p>\n</blockquote>\n<pre><code class=\"js\">var book = {\n    _year: 2004,\n    edition: 1\n};\n\n//定义访问器的旧有方法\nbook.__defineGetter__(&quot;year&quot;, function() {\n    return this._year;\n});\n\nbook.__defineSetter__(&quot;year&quot;, function(newValue) {\n    if(newValue &gt; 2004) {\n        this._year = newValue;\n        this.edition += newValue - 2004;\n    }\n})\n</code></pre>\n<p><strong>由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。</strong> 利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>\n<pre><code class=\"js\">var book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function(newValue) {\n            if(newValue &gt; 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n})\n</code></pre>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><blockquote>\n<p><strong>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。</strong></p>\n<ol>\n<li>工厂模式</li>\n</ol>\n</blockquote>\n<pre><code class=\"js\">function createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        console.log(this.name);\n    }\n    return o;\n}\n\nvar person1 = createPerson(&quot;Bar&quot;, 20, &quot;Software Engineer&quot;);\nvar person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\n// 此函数能够根据接收的参数来构建一个包含所有必要信息的Person对象。可以无数次调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。\n</code></pre>\n<ol start=\"2\">\n<li>构造函数模式<br><code>`</code>js<br>function Person(name, age, job) {<br> this.name = name;<br> this.age = age;<br> this.job = job;<br> this.sayName = function() {<pre><code> console.log(this.name);\n</code></pre> }<br>}</li>\n</ol>\n<p>var person1 = new Person(“Bar”, 20, “Software Engineer”);<br>var person2 = new Person(“Greg”, 27, “Doctor”);</p>\n<pre><code>\n**特点：**\n\n- 没有显式的创建对象；\n- 直接将属性和方法赋给了this对象；\n- 没有return语句；\n- 函数名Person使用的是大写字母开头；\n\n要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\n\n- 1. 创建一个新对象\n- 2. 将构造函数的作用域赋给新对象（因此this指向的就是新对象）\n- 3. 执行构造函数中的代码（为这个新对象添加属性）\n- 4. 返回新对象\n\n*前面例子中，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person*\n\n```js\nconsole.log(person1.constructor === Person);  // true\nconsole.log(person2.constructor === Person);  // true\n</code></pre><h5 id=\"构造函数的问题\"><a href=\"#构造函数的问题\" class=\"headerlink\" title=\"构造函数的问题\"></a>构造函数的问题</h5><blockquote>\n<p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。不要忘了——-ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。</p>\n</blockquote>\n<pre><code class=\"js\">function Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = new Function(&quot;console.log(this.name)&quot;); // 与声明函数在逻辑上是等价的\n}\n\n// 不同实例上的同名函数是不相等的\n\nconsole.log(person1.sayName == person2.sayName);  //false\n</code></pre>\n<p>创建两个完全同样任务的Function实例的确没有必要。况且有this对象在，根本不用再执行代码前就把函数绑定到特定对象上面。</p>\n<pre><code class=\"js\">function Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\nfunction sayName() {\n    console.log(this.name);\n}\n</code></pre>\n<h5 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h5><pre><code class=\"js\">function Person() {}\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 20;\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\n\nvar person1 = new Person();\nperson1.sayName();  // Nicholas\n\nvar person2 = new Person();\nperson2.sayName();  // Nicholas\nconsole.log(person1.sayName == person2.sayName);  //true\n</code></pre>\n<h5 id=\"原型与in操作符\"><a href=\"#原型与in操作符\" class=\"headerlink\" title=\"原型与in操作符\"></a>原型与in操作符</h5><p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独的使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>\n<pre><code class=\"js\">function Person(){\n}\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\nvar person1 = new Person();\nvar person2 = new Person();\nalert(person1.hasOwnProperty(&quot;name&quot;));  //false\nalert(&quot;name&quot; in person1);  //true\nperson1.name = &quot;Greg&quot;;\nalert(person1.name); //&quot;Greg&quot; ——来自实例\nalert(person1.hasOwnProperty(&quot;name&quot;)); //true\nalert(&quot;name&quot; in person1); //true\nalert(person2.name); //&quot;Nicholas&quot; ——来自原型\nalert(person2.hasOwnProperty(&quot;name&quot;)); //false\nalert(&quot;name&quot; in person2); //true\ndelete person1.name;\nalert(person1.name); //&quot;Nicholas&quot; ——来自原型\nalert(person1.hasOwnProperty(&quot;name&quot;)); //false\nalert(&quot;name&quot; in person1); //true\n</code></pre>\n<p>通过同时使用hasOwnProperty方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。</p>\n<pre><code class=\"js\">function hasPrototypeProperty(object, name) {\n    return !object.hasOwnProperty(name) &amp;&amp; (name in object);\n}\n\n</code></pre>\n<p>由于in操作符只要通过对象能够访问到属性就返回true，hasOwnProperty只在属性存在于实例中时才返回true，因此只要in操作符返回true而hasOwnProperty返回false，就可以确定属性是原型中的属性。</p>\n"},{"title":"LeetCode相关题目","date":"2019-03-10T14:18:31.000Z","_content":"\n### 两个数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]\n\n```js\nvar twoSum = function(nums, target) {\n    let hashMap = new Map()\n  // 初始化hashMap\n  for (let i = 0; i < nums.length; i++) {\n    if (!hashMap.has(nums[i])) {\n      hashMap.set(nums[i], i)\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    let diff = target - nums[i]\n    if (hashMap.has(diff) && hashMap.get(diff) !== i) {\n      return [i, hashMap.get(diff)]\n    }\n  }\n};\n```\n\n\n\n### 反转链表\n\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n\n输出: 5->4->3->2->1->NULL\n\n迭代方法：\n\n```js\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nvar reverseList = function(head) {\n    if(head === null) {\n        return null\n    }\n    let p = head;\n    let q = head;  \n    while(head.next != null) {\n        p = head.next;\n        head.next = p.next;\n        p.next = q;\n        q = p; //用来保存下次指针指向的位置\n    }\n    return q\n};\n```\n\n递归方法：\n\n```js\nlet p = null;\nlet q;\nvar reverse = function(head) {\n    if(head === null) {\n        return null\n    }\n    if(head.next === null) {\n        p = head\n        return head\n    }\n    q = reverse(head.next);\n    q.next = head;\n    head.next = null;\n    return head\n}\n\nvar reverseList = function(head) {\n    reverse(head);\n    return p\n}\n```","source":"_posts/LeetCode相关题目.md","raw":"---\ntitle: LeetCode相关题目\ndate: 2019-03-10 22:18:31\ntags: 算法\ncategories: 前端\n---\n\n### 两个数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1]\n\n```js\nvar twoSum = function(nums, target) {\n    let hashMap = new Map()\n  // 初始化hashMap\n  for (let i = 0; i < nums.length; i++) {\n    if (!hashMap.has(nums[i])) {\n      hashMap.set(nums[i], i)\n    }\n  }\n  for (let i = 0; i < nums.length; i++) {\n    let diff = target - nums[i]\n    if (hashMap.has(diff) && hashMap.get(diff) !== i) {\n      return [i, hashMap.get(diff)]\n    }\n  }\n};\n```\n\n\n\n### 反转链表\n\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n\n输出: 5->4->3->2->1->NULL\n\n迭代方法：\n\n```js\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nvar reverseList = function(head) {\n    if(head === null) {\n        return null\n    }\n    let p = head;\n    let q = head;  \n    while(head.next != null) {\n        p = head.next;\n        head.next = p.next;\n        p.next = q;\n        q = p; //用来保存下次指针指向的位置\n    }\n    return q\n};\n```\n\n递归方法：\n\n```js\nlet p = null;\nlet q;\nvar reverse = function(head) {\n    if(head === null) {\n        return null\n    }\n    if(head.next === null) {\n        p = head\n        return head\n    }\n    q = reverse(head.next);\n    q.next = head;\n    head.next = null;\n    return head\n}\n\nvar reverseList = function(head) {\n    reverse(head);\n    return p\n}\n```","slug":"LeetCode相关题目","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9c000u1xop1n7fdfal","content":"<h3 id=\"两个数之和\"><a href=\"#两个数之和\" class=\"headerlink\" title=\"两个数之和\"></a>两个数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例:</p>\n<p>给定 nums = [2, 7, 11, 15], target = 9</p>\n<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>\n<p>所以返回 [0, 1]</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> twoSum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> hashMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 初始化hashMap</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hashMap<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      hashMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> diff <span class=\"token operator\">=</span> target <span class=\"token operator\">-</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hashMap<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>diff<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> hashMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>diff<span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">,</span> hashMap<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><p>反转一个单链表。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>\n<p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>\n<p>迭代方法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">ListNode</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> val<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> reverseList <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> q <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>  \n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        p <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n        p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> q<span class=\"token punctuation\">;</span>\n        q <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//用来保存下次指针指向的位置</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> q\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>递归方法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> q<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> reverse <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        p <span class=\"token operator\">=</span> head\n        <span class=\"token keyword\">return</span> head\n    <span class=\"token punctuation\">}</span>\n    q <span class=\"token operator\">=</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    q<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    head<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> head\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> reverseList <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> p\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"两个数之和\"><a href=\"#两个数之和\" class=\"headerlink\" title=\"两个数之和\"></a>两个数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>\n<p>示例:</p>\n<p>给定 nums = [2, 7, 11, 15], target = 9</p>\n<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>\n<p>所以返回 [0, 1]</p>\n<pre><code class=\"js\">var twoSum = function(nums, target) {\n    let hashMap = new Map()\n  // 初始化hashMap\n  for (let i = 0; i &lt; nums.length; i++) {\n    if (!hashMap.has(nums[i])) {\n      hashMap.set(nums[i], i)\n    }\n  }\n  for (let i = 0; i &lt; nums.length; i++) {\n    let diff = target - nums[i]\n    if (hashMap.has(diff) &amp;&amp; hashMap.get(diff) !== i) {\n      return [i, hashMap.get(diff)]\n    }\n  }\n};\n</code></pre>\n<h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><p>反转一个单链表。</p>\n<p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>\n<p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>\n<p>迭代方法：</p>\n<pre><code class=\"js\">function ListNode(val) {\n    this.val = val;\n    this.next = null;\n}\n\nvar reverseList = function(head) {\n    if(head === null) {\n        return null\n    }\n    let p = head;\n    let q = head;  \n    while(head.next != null) {\n        p = head.next;\n        head.next = p.next;\n        p.next = q;\n        q = p; //用来保存下次指针指向的位置\n    }\n    return q\n};\n</code></pre>\n<p>递归方法：</p>\n<pre><code class=\"js\">let p = null;\nlet q;\nvar reverse = function(head) {\n    if(head === null) {\n        return null\n    }\n    if(head.next === null) {\n        p = head\n        return head\n    }\n    q = reverse(head.next);\n    q.next = head;\n    head.next = null;\n    return head\n}\n\nvar reverseList = function(head) {\n    reverse(head);\n    return p\n}\n</code></pre>\n"},{"title":"MVVM","date":"2018-12-09T04:15:07.000Z","_content":"\n### MVVM的适用范围\n\n1. vue作为MVVM模板的实现库的2种技术\n   - 模板解析\n   - 数据绑定\n2. 模板解析：实现初始化显示\n   - 解析大括号表达式\n   - 解析指令\n3. 数据绑定：实现更新显示\n   - 通过数据劫持实现\n\n从几个例子我们可以看到，MVVM最大的优势是编写前端逻辑非常复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面的逻辑。\n\n但是MVVM不是万能的，它的目的是为了解决复杂的前端逻辑。对于以展示逻辑为主的页面，例如，新闻，博客、文档等，*不能*使用MVVM展示数据，因为这些页面需要被搜索引擎索引，而搜索引擎无法获取使用MVVM并通过API加载的数据。\n\n所以，需要SEO（Search Engine Optimization）的页面，不能使用MVVM展示数据。不需要SEO的页面，如果前端逻辑复杂，就适合使用MVVM展示数据，例如，工具类页面，复杂的表单页面，用户登录后才能操作的页面等等\n\n![](MVVM/c045b16c40f808e480f874a801a7680a.png)","source":"_posts/MVVM.md","raw":"---\ntitle: MVVM\ndate: 2018-12-09 12:15:07\ntags: MVVM相关\ncategories: 前端\n---\n\n### MVVM的适用范围\n\n1. vue作为MVVM模板的实现库的2种技术\n   - 模板解析\n   - 数据绑定\n2. 模板解析：实现初始化显示\n   - 解析大括号表达式\n   - 解析指令\n3. 数据绑定：实现更新显示\n   - 通过数据劫持实现\n\n从几个例子我们可以看到，MVVM最大的优势是编写前端逻辑非常复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面的逻辑。\n\n但是MVVM不是万能的，它的目的是为了解决复杂的前端逻辑。对于以展示逻辑为主的页面，例如，新闻，博客、文档等，*不能*使用MVVM展示数据，因为这些页面需要被搜索引擎索引，而搜索引擎无法获取使用MVVM并通过API加载的数据。\n\n所以，需要SEO（Search Engine Optimization）的页面，不能使用MVVM展示数据。不需要SEO的页面，如果前端逻辑复杂，就适合使用MVVM展示数据，例如，工具类页面，复杂的表单页面，用户登录后才能操作的页面等等\n\n![](MVVM/c045b16c40f808e480f874a801a7680a.png)","slug":"MVVM","published":1,"updated":"2024-02-19T07:42:51.566Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9d000x1xopejjg837l","content":"<h3 id=\"MVVM的适用范围\"><a href=\"#MVVM的适用范围\" class=\"headerlink\" title=\"MVVM的适用范围\"></a>MVVM的适用范围</h3><ol>\n<li>vue作为MVVM模板的实现库的2种技术<ul>\n<li>模板解析</li>\n<li>数据绑定</li>\n</ul>\n</li>\n<li>模板解析：实现初始化显示<ul>\n<li>解析大括号表达式</li>\n<li>解析指令</li>\n</ul>\n</li>\n<li>数据绑定：实现更新显示<ul>\n<li>通过数据劫持实现</li>\n</ul>\n</li>\n</ol>\n<p>从几个例子我们可以看到，MVVM最大的优势是编写前端逻辑非常复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面的逻辑。</p>\n<p>但是MVVM不是万能的，它的目的是为了解决复杂的前端逻辑。对于以展示逻辑为主的页面，例如，新闻，博客、文档等，<em>不能</em>使用MVVM展示数据，因为这些页面需要被搜索引擎索引，而搜索引擎无法获取使用MVVM并通过API加载的数据。</p>\n<p>所以，需要SEO（Search Engine Optimization）的页面，不能使用MVVM展示数据。不需要SEO的页面，如果前端逻辑复杂，就适合使用MVVM展示数据，例如，工具类页面，复杂的表单页面，用户登录后才能操作的页面等等</p>\n<p><img src=\"/2018/12/09/MVVM/c045b16c40f808e480f874a801a7680a.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"MVVM的适用范围\"><a href=\"#MVVM的适用范围\" class=\"headerlink\" title=\"MVVM的适用范围\"></a>MVVM的适用范围</h3><ol>\n<li>vue作为MVVM模板的实现库的2种技术<ul>\n<li>模板解析</li>\n<li>数据绑定</li>\n</ul>\n</li>\n<li>模板解析：实现初始化显示<ul>\n<li>解析大括号表达式</li>\n<li>解析指令</li>\n</ul>\n</li>\n<li>数据绑定：实现更新显示<ul>\n<li>通过数据劫持实现</li>\n</ul>\n</li>\n</ol>\n<p>从几个例子我们可以看到，MVVM最大的优势是编写前端逻辑非常复杂的页面，尤其是需要大量DOM操作的逻辑，利用MVVM可以极大地简化前端页面的逻辑。</p>\n<p>但是MVVM不是万能的，它的目的是为了解决复杂的前端逻辑。对于以展示逻辑为主的页面，例如，新闻，博客、文档等，<em>不能</em>使用MVVM展示数据，因为这些页面需要被搜索引擎索引，而搜索引擎无法获取使用MVVM并通过API加载的数据。</p>\n<p>所以，需要SEO（Search Engine Optimization）的页面，不能使用MVVM展示数据。不需要SEO的页面，如果前端逻辑复杂，就适合使用MVVM展示数据，例如，工具类页面，复杂的表单页面，用户登录后才能操作的页面等等</p>\n<p><img src=\"/2018/12/09/MVVM/c045b16c40f808e480f874a801a7680a.png\" alt></p>\n"},{"title":"NodeJs事件轮询机制","date":"2019-04-26T06:53:19.000Z","_content":"\n### NodeJs 事件轮询机制\n\nNodeJs的事件轮询机制是借助libuv库实现的。\n\n概括事件轮询机制可分为六个阶段：\n\n1. timers定时器阶段：计时和执行到点的定时器回掉函数\n2. pending callbacks：某些系统操作（例如TCP错误类型）的回调函数\n3. idle，prepare：准备工作\n4. poll轮询阶段（轮询队列）：\n   - 如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或者达到系统最大限度。\n   - 如果轮询队列为空\n     1. 如果之前设置过setImmediate函数，则直接进入下一个check阶段\n     2. 如果之前没有设置setImmediate函数，在当前poll阶段等待，直到轮询队列添加回调函数，就去第一个情况执行。或者等到定时器到点了，也会去下一个阶段\n5. check查阶段：执行setImmediate设置的回调函数。\n6. close callbacks 关闭阶段：执行close事件回调函数\n\nprocess.nextTick能在任意阶段优先执行","source":"_posts/NodeJs事件轮询机制.md","raw":"---\ntitle: NodeJs事件轮询机制\ndate: 2019-04-26 14:53:19\ntags: NodeJS\ncategories: 前端\n---\n\n### NodeJs 事件轮询机制\n\nNodeJs的事件轮询机制是借助libuv库实现的。\n\n概括事件轮询机制可分为六个阶段：\n\n1. timers定时器阶段：计时和执行到点的定时器回掉函数\n2. pending callbacks：某些系统操作（例如TCP错误类型）的回调函数\n3. idle，prepare：准备工作\n4. poll轮询阶段（轮询队列）：\n   - 如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或者达到系统最大限度。\n   - 如果轮询队列为空\n     1. 如果之前设置过setImmediate函数，则直接进入下一个check阶段\n     2. 如果之前没有设置setImmediate函数，在当前poll阶段等待，直到轮询队列添加回调函数，就去第一个情况执行。或者等到定时器到点了，也会去下一个阶段\n5. check查阶段：执行setImmediate设置的回调函数。\n6. close callbacks 关闭阶段：执行close事件回调函数\n\nprocess.nextTick能在任意阶段优先执行","slug":"NodeJs事件轮询机制","published":1,"updated":"2024-02-19T07:42:51.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9e00121xop9ve8hy2n","content":"<h3 id=\"NodeJs-事件轮询机制\"><a href=\"#NodeJs-事件轮询机制\" class=\"headerlink\" title=\"NodeJs 事件轮询机制\"></a>NodeJs 事件轮询机制</h3><p>NodeJs的事件轮询机制是借助libuv库实现的。</p>\n<p>概括事件轮询机制可分为六个阶段：</p>\n<ol>\n<li>timers定时器阶段：计时和执行到点的定时器回掉函数</li>\n<li>pending callbacks：某些系统操作（例如TCP错误类型）的回调函数</li>\n<li>idle，prepare：准备工作</li>\n<li>poll轮询阶段（轮询队列）：<ul>\n<li>如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或者达到系统最大限度。</li>\n<li>如果轮询队列为空<ol>\n<li>如果之前设置过setImmediate函数，则直接进入下一个check阶段</li>\n<li>如果之前没有设置setImmediate函数，在当前poll阶段等待，直到轮询队列添加回调函数，就去第一个情况执行。或者等到定时器到点了，也会去下一个阶段</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>check查阶段：执行setImmediate设置的回调函数。</li>\n<li>close callbacks 关闭阶段：执行close事件回调函数</li>\n</ol>\n<p>process.nextTick能在任意阶段优先执行</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"NodeJs-事件轮询机制\"><a href=\"#NodeJs-事件轮询机制\" class=\"headerlink\" title=\"NodeJs 事件轮询机制\"></a>NodeJs 事件轮询机制</h3><p>NodeJs的事件轮询机制是借助libuv库实现的。</p>\n<p>概括事件轮询机制可分为六个阶段：</p>\n<ol>\n<li>timers定时器阶段：计时和执行到点的定时器回掉函数</li>\n<li>pending callbacks：某些系统操作（例如TCP错误类型）的回调函数</li>\n<li>idle，prepare：准备工作</li>\n<li>poll轮询阶段（轮询队列）：<ul>\n<li>如果轮询队列不为空，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或者达到系统最大限度。</li>\n<li>如果轮询队列为空<ol>\n<li>如果之前设置过setImmediate函数，则直接进入下一个check阶段</li>\n<li>如果之前没有设置setImmediate函数，在当前poll阶段等待，直到轮询队列添加回调函数，就去第一个情况执行。或者等到定时器到点了，也会去下一个阶段</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>check查阶段：执行setImmediate设置的回调函数。</li>\n<li>close callbacks 关闭阶段：执行close事件回调函数</li>\n</ol>\n<p>process.nextTick能在任意阶段优先执行</p>\n"},{"title":"Node","date":"2018-12-09T04:26:17.000Z","_content":"\n### **Node**\n\n##### **node采用了单线程**\n\n**单线程的优势：**\n\n1. 不用去在意状态的同步问题。\n2. 没有死锁的情况。\n3. 也没有上下文交换所带来的性能上的开销。\n\n**单线程有以下弱点：**\n\n1. 无法利用多核CPU。\n2. 错误会引起整个应用退出，应用的健壮性值得考验。\n3. 大量的计算占用CPU导致无法继续调用异步I/O。\n\n像浏览器中`JavaScript`与UI公用一个线程一样，`JavaScript`长时间执行会导致UI渲染和响应被中断，在Node中，长时间的CPU占用，也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。\n\n通过HTML5定制的Web Workers的标准，能够创建工作线程来进行计算，以解决`JavaScript`大计算阻塞UI渲染问题。Node采用与Web Workers相同的思路来解决单线程中大计算量的问题：`child_process`。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。\n\n##### **node的应用场景**\n\n1. I/O密集型\n\n   I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。\n\n2. CPU密集型\n\n   - Node可以通过编写C/C++扩展的方式更高效的利用CPU。\n   - 通过子进程方式，将一部分Node进程当做常住服务进程用于计算。\n\n##### **node的异步I/O**\n\n> 在node中，无论是在*nix还是windows平台，内部完成I/O任务的另有线程池。完成整个异步I/O环节的有事件循环、观察者和请求对象等。\n>\n> 请求对象是异步I/O过程的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调函数处理。\n>\n> 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。\n\n##### **node的使用**\n\n> 注意：如果要为服务器环境下的所有js文件使用严格模式的话，一个一个的加`use strict`太麻烦，可以通过给NodeJs传递参数来为所有js文件启动严格模式：\n>\n> ```js\n> node --use_strict demo.js\n> ```\n>\n> 在使用`require()`引入模块的时候，请注意模块的相对路径。因为`main.js`和`hello.js`位于同一个目录，所以我们用了当前目录`.`：\n>\n> ```js\n> var greet = require('./hello'); // 不要忘了写相对目录!\n> ```\n>\n> 如果只写模块名：\n>\n> ```js\n> var greet = require('hello');\n> ```\n>\n> 则Node会依次在内置模块、全局模块和当前模块下查找`hello.js`，你很可能会得到一个错误：\n>\n> ```js\n> module.js\n>     throw err;\n>           ^\n> Error: Cannot find module 'hello'\n>     at Function.Module._resolveFilename\n>     at Function.Module._load\n>     ...\n>     at Function.Module._load\n>     at Function.Module.runMain\n> ```\n>\n> 遇到这个错误，你要检查：\n>\n> - 模块名是否写对了；\n> - 模块文件是否存在；\n> - 相对路径是否写对了。\n\n##### **基本模块**\n\n1. `global`:`JavaScript`有且仅有一个全局对象，在浏览器中叫做`window`对象。而在node环境中，也有唯一的全局对象，叫做`global`，这个对象的属性和方法与浏览器中的`window`不同。\n\n2. `process`也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用信息：\n\n   ```js\n   > process === global.process;\n   true\n   > process.version;\n   'v5.2.0'\n   > process.platform;\n   'darwin'\n   > process.arch;\n   'x64'\n   > process.cwd(); //返回当前工作目录\n   '/Users/michael'\n   > process.chdir('/private/tmp'); // 切换当前工作目录\n   undefined\n   > process.cwd();\n   '/private/tmp'\n   ```\n\n   JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。\n\n   如果我们想要在下一次事件响应中执行代码，可以调用`process.nextTick()`：\n\n   ```js\n   // test.js\n   \n   // process.nextTick()将在下一轮事件循环中调用:\n   process.nextTick(function () {\n       console.log('nextTick callback!');\n   });\n   console.log('nextTick was set!');\n   ```\n\n   用Node执行上面的代码`node test.js`，你会看到，打印输出是：\n\n   ```js\n   nextTick was set!\n   nextTick callback!\n   ```\n\n   这说明传入`process.nextTick()`的函数不是立刻执行，而是要等到下一次事件循环。\n\n   Node.js进程本身的事件就由`process`对象来处理。如果我们响应`exit`事件，就可以在程序即将退出时执行某个回调函数：\n\n   ```js\n   // 程序即将退出时的回调函数:\n   process.on('exit', function (code) {\n       console.log('about to exit with code: ' + code);\n   });\n   ```\n\n3. 判断`JavaScript`的执行环境\n\n   有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\n\n   ```js\n   if (typeof(window) === 'undefined') {\n       console.log('node.js');\n   } else {\n       console.log('browser');\n   }\n   ```\n\n4. fs模块（文件系统模块）\n\n   **fs模块同时提供了异步和同步的方法。**\n\n   **异步读取文件：**\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.readFile('sample.txt', 'utf-8', function (err, data) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log(data);\n       }\n   });\n   ```\n\n   请注意，`sample.txt`文件必须在当前目录下，且文件编码为`utf-8`。\n\n   异步读取时，传入的回调函数接收两个参数，当正常读取时，`err`参数为`null`，`data`参数为读取到的String。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。\n\n   如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？\n\n   下面的例子演示了如何读取一个图片文件：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.readFile('sample.png', function (err, data) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log(data);\n           console.log(data.length + ' bytes');\n       }\n   });\n   ```\n\n   当读取二进制文件时，不传入文件编码时，回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中，`Buffer`对象就是一个包含零个或任意个字节的数组（注意和Array不同）。\n\n   `Buffer`对象可以和String作转换，例如，把一个`Buffer`对象转换成String：\n\n   ```js\n   // Buffer -> String\n   var text = data.toString('utf-8');\n   console.log(text);\n   ```\n\n   或者把一个String转换成`Buffer`：\n\n   ```js\n   // String -> Buffer\n   var buf = Buffer.from(text, 'utf-8');\n   console.log(buf);\n   ```\n\n   **同步读文件**\n\n   除了标准的异步读取模式外，`fs`也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果。\n\n   用`fs`模块同步读取一个文本文件的代码如下：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = fs.readFileSync('sample.txt', 'utf-8');\n   console.log(data);\n   ```\n\n   可见，原异步调用的回调函数的`data`被函数直接返回，函数名需要改为`readFileSync`，其它参数不变。\n\n   如果同步读取文件发生错误，则需要用`try...catch`捕获该错误：\n\n   ```js\n   try {\n       var data = fs.readFileSync('sample.txt', 'utf-8');\n       console.log(data);\n   } catch (err) {\n       // 出错了\n   }\n   ```\n\n   **写文件**\n\n   将数据写入文件是通过`fs.writeFile()`实现的：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = 'Hello, Node.js';\n   fs.writeFile('output.txt', data, function (err) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log('ok.');\n       }\n   });\n   ```\n\n   `writeFile()`的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是`Buffer`，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个`err`参数。\n\n   和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = 'Hello, Node.js';\n   fs.writeFileSync('output.txt', data);\n   ```\n\n   **stat**\n\n   如果我们要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`Stat`对象，能告诉我们文件或目录的详细信息：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.stat('sample.txt', function (err, stat) {\n       if (err) {\n           console.log(err);\n       } else {\n           // 是否是文件:\n           console.log('isFile: ' + stat.isFile());\n           // 是否是目录:\n           console.log('isDirectory: ' + stat.isDirectory());\n           if (stat.isFile()) {\n               // 文件大小:\n               console.log('size: ' + stat.size);\n               // 创建时间, Date对象:\n               console.log('birth time: ' + stat.birthtime);\n               // 修改时间, Date对象:\n               console.log('modified time: ' + stat.mtime);\n           }\n       }\n   });\n   ```\n\n   运行结果如下：\n\n   ```js\n   isFile: true\n   isDirectory: false\n   size: 181\n   birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)\n   modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)\n   ```\n\n   `stat()`也有一个对应的同步函数`statSync()`，请试着改写上述异步代码为同步代码。\n\n   **异步还是同步**\n\n   在`fs`模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？\n\n   由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，*必须使用异步代码*，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。\n\n   服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。\n\n5. stream模块\n\n   在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。\n\n   下面是一个从文件流读取文本内容的示例：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   // 打开一个流:\n   var rs = fs.createReadStream('sample.txt', 'utf-8');\n   \n   rs.on('data', function (chunk) {\n       console.log('DATA:')\n       console.log(chunk);\n   });\n   \n   rs.on('end', function () {\n       console.log('END');\n   });\n   \n   rs.on('error', function (err) {\n       console.log('ERROR: ' + err);\n   });\n   ```\n\n   要注意，`data`事件可能会有多次，每次传递的`chunk`是流的一部分数据。\n\n   要以流的形式写入文件，只需要不断调用`write()`方法，最后以`end()`结束：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var ws1 = fs.createWriteStream('output1.txt', 'utf-8');\n   ws1.write('使用Stream写入文本数据...\\n');\n   ws1.write('END.');\n   ws1.end();\n   \n   var ws2 = fs.createWriteStream('output2.txt');\n   ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));\n   ws2.write(new Buffer('END.', 'utf-8'));\n   ws2.end();\n   ```\n\n   所有可以读取数据的流都继承自`stream.Readable`，所有可以写入的流都继承自`stream.Writable`。\n\n   **pipe**\n\n   就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。\n\n   在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。\n\n   让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var rs = fs.createReadStream('sample.txt');\n   var ws = fs.createWriteStream('copied.txt');\n   \n   rs.pipe(ws);\n   ```\n\n   默认情况下，当`Readable`流的数据读取完毕，`end`事件触发后，将自动关闭`Writable`流。如果我们不希望自动关闭`Writable`流，需要传入参数：\n\n   ```js\n   readable.pipe(writable, { end: false });\n   ```\n\n6. http模块\n\n   **HTTP服务器**\n\n   要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的`http`模块完成了。应用程序并不直接和HTTP协议打交道，而是操作`http`模块提供的`request`和`response`对象。\n\n   `request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；\n\n   `response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。\n\n   用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序`hello.js`，它对于所有请求，都返回`Hello world!`：\n\n   ```js\n   'use strict';\n   \n   // 导入http模块:\n   var http = require('http');\n   \n   // 创建http server，并传入回调函数:\n   var server = http.createServer(function (request, response) {\n       // 回调函数接收request和response对象,\n       // 获得HTTP请求的method和url:\n       console.log(request.method + ': ' + request.url);\n       // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\n       response.writeHead(200, {'Content-Type': 'text/html'});\n       // 将HTTP响应的HTML内容写入response:\n       response.end('<h1>Hello world!</h1>');\n   });\n   \n   // 让服务器监听8080端口:\n   server.listen(8080);\n   \n   console.log('Server is running at http://127.0.0.1:8080/');\n   ```\n\n   在命令提示符下运行该程序，可以看到以下输出：\n\n   ```js\n   $ node hello.js \n   Server is running at http://127.0.0.1:8080/\n   ```\n\n   **文件服务器**\n\n   让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析`request.url`中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\n\n   解析URL需要用到Node.js提供的`url`模块，它使用起来非常简单，通过`parse()`将一个字符串解析为一个`Url`对象：\n\n   ```js\n   'use strict';\n   \n   var url = require('url');\n   \n   console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));\n   ```\n\n   结果如下：\n\n   ```js\n   Url {\n     protocol: 'http:',\n     slashes: true,\n     auth: 'user:pass',\n     host: 'host.com:8080',\n     port: '8080',\n     hostname: 'host.com',\n     hash: '#hash',\n     search: '?query=string',\n     query: 'query=string',\n     pathname: '/path/to/file',\n     path: '/path/to/file?query=string',\n     href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }\n   ```\n\n   处理本地文件目录需要使用Node.js提供的`path`模块，它可以方便地构造目录：\n\n   ```js\n   'use strict';\n   \n   var path = require('path');\n   \n   // 解析当前目录:\n   var workDir = path.resolve('.'); // '/Users/michael'\n   \n   // 组合完整的文件路径:当前目录+'pub'+'index.html':\n   var filePath = path.join(workDir, 'pub', 'index.html');\n   // '/Users/michael/pub/index.html'\n   ```\n\n   使用`path`模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于`C:\\Users\\michael\\static\\index.html`，这样，我们就不关心怎么拼接路径了。\n\n   最后，我们实现一个文件服务器`file_server.js`：\n\n   ```js\n   'use strict';\n   \n   var\n       fs = require('fs'),\n       url = require('url'),\n       path = require('path'),\n       http = require('http');\n   \n   // 从命令行参数获取root目录，默认是当前目录:\n   var root = path.resolve(process.argv[2] || '.');\n   \n   console.log('Static root dir: ' + root);\n   \n   // 创建服务器:\n   var server = http.createServer(function (request, response) {\n       // 获得URL的path，类似 '/css/bootstrap.css':\n       var pathname = url.parse(request.url).pathname;\n       // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':\n       var filepath = path.join(root, pathname);\n       // 获取文件状态:\n       fs.stat(filepath, function (err, stats) {\n           if (!err && stats.isFile()) {\n               // 没有出错并且文件存在:\n               console.log('200 ' + request.url);\n               // 发送200响应:\n               response.writeHead(200);\n               // 将文件流导向response:\n               fs.createReadStream(filepath).pipe(response);\n           } else {\n               // 出错了或者文件不存在:\n               console.log('404 ' + request.url);\n               // 发送404响应:\n               response.writeHead(404);\n               response.end('404 Not Found');\n           }\n       });\n   });\n   \n   server.listen(8080);\n   \n   console.log('Server is running at http://127.0.0.1:8080/');\n   ```\n\n   没有必要手动读取文件内容。由于`response`对象本身是一个`Writable Stream`，直接用`pipe()`方法就实现了自动读取文件内容并输出到HTTP响应。\n\n   在命令行运行`node file_server.js /path/to/dir`，把`/path/to/dir`改成你本地的一个有效的目录，然后在浏览器中输入`http://localhost:8080/index.html`：\n\n7. crypto模块\n\n   crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。","source":"_posts/Node.md","raw":"---\ntitle: Node\ndate: 2018-12-09 12:26:17\ntags: NodeJS\ncategories: 前端\n---\n\n### **Node**\n\n##### **node采用了单线程**\n\n**单线程的优势：**\n\n1. 不用去在意状态的同步问题。\n2. 没有死锁的情况。\n3. 也没有上下文交换所带来的性能上的开销。\n\n**单线程有以下弱点：**\n\n1. 无法利用多核CPU。\n2. 错误会引起整个应用退出，应用的健壮性值得考验。\n3. 大量的计算占用CPU导致无法继续调用异步I/O。\n\n像浏览器中`JavaScript`与UI公用一个线程一样，`JavaScript`长时间执行会导致UI渲染和响应被中断，在Node中，长时间的CPU占用，也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。\n\n通过HTML5定制的Web Workers的标准，能够创建工作线程来进行计算，以解决`JavaScript`大计算阻塞UI渲染问题。Node采用与Web Workers相同的思路来解决单线程中大计算量的问题：`child_process`。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。\n\n##### **node的应用场景**\n\n1. I/O密集型\n\n   I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。\n\n2. CPU密集型\n\n   - Node可以通过编写C/C++扩展的方式更高效的利用CPU。\n   - 通过子进程方式，将一部分Node进程当做常住服务进程用于计算。\n\n##### **node的异步I/O**\n\n> 在node中，无论是在*nix还是windows平台，内部完成I/O任务的另有线程池。完成整个异步I/O环节的有事件循环、观察者和请求对象等。\n>\n> 请求对象是异步I/O过程的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调函数处理。\n>\n> 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。\n\n##### **node的使用**\n\n> 注意：如果要为服务器环境下的所有js文件使用严格模式的话，一个一个的加`use strict`太麻烦，可以通过给NodeJs传递参数来为所有js文件启动严格模式：\n>\n> ```js\n> node --use_strict demo.js\n> ```\n>\n> 在使用`require()`引入模块的时候，请注意模块的相对路径。因为`main.js`和`hello.js`位于同一个目录，所以我们用了当前目录`.`：\n>\n> ```js\n> var greet = require('./hello'); // 不要忘了写相对目录!\n> ```\n>\n> 如果只写模块名：\n>\n> ```js\n> var greet = require('hello');\n> ```\n>\n> 则Node会依次在内置模块、全局模块和当前模块下查找`hello.js`，你很可能会得到一个错误：\n>\n> ```js\n> module.js\n>     throw err;\n>           ^\n> Error: Cannot find module 'hello'\n>     at Function.Module._resolveFilename\n>     at Function.Module._load\n>     ...\n>     at Function.Module._load\n>     at Function.Module.runMain\n> ```\n>\n> 遇到这个错误，你要检查：\n>\n> - 模块名是否写对了；\n> - 模块文件是否存在；\n> - 相对路径是否写对了。\n\n##### **基本模块**\n\n1. `global`:`JavaScript`有且仅有一个全局对象，在浏览器中叫做`window`对象。而在node环境中，也有唯一的全局对象，叫做`global`，这个对象的属性和方法与浏览器中的`window`不同。\n\n2. `process`也是Node.js提供的一个对象，它代表当前Node.js进程。通过`process`对象可以拿到许多有用信息：\n\n   ```js\n   > process === global.process;\n   true\n   > process.version;\n   'v5.2.0'\n   > process.platform;\n   'darwin'\n   > process.arch;\n   'x64'\n   > process.cwd(); //返回当前工作目录\n   '/Users/michael'\n   > process.chdir('/private/tmp'); // 切换当前工作目录\n   undefined\n   > process.cwd();\n   '/private/tmp'\n   ```\n\n   JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。\n\n   如果我们想要在下一次事件响应中执行代码，可以调用`process.nextTick()`：\n\n   ```js\n   // test.js\n   \n   // process.nextTick()将在下一轮事件循环中调用:\n   process.nextTick(function () {\n       console.log('nextTick callback!');\n   });\n   console.log('nextTick was set!');\n   ```\n\n   用Node执行上面的代码`node test.js`，你会看到，打印输出是：\n\n   ```js\n   nextTick was set!\n   nextTick callback!\n   ```\n\n   这说明传入`process.nextTick()`的函数不是立刻执行，而是要等到下一次事件循环。\n\n   Node.js进程本身的事件就由`process`对象来处理。如果我们响应`exit`事件，就可以在程序即将退出时执行某个回调函数：\n\n   ```js\n   // 程序即将退出时的回调函数:\n   process.on('exit', function (code) {\n       console.log('about to exit with code: ' + code);\n   });\n   ```\n\n3. 判断`JavaScript`的执行环境\n\n   有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：\n\n   ```js\n   if (typeof(window) === 'undefined') {\n       console.log('node.js');\n   } else {\n       console.log('browser');\n   }\n   ```\n\n4. fs模块（文件系统模块）\n\n   **fs模块同时提供了异步和同步的方法。**\n\n   **异步读取文件：**\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.readFile('sample.txt', 'utf-8', function (err, data) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log(data);\n       }\n   });\n   ```\n\n   请注意，`sample.txt`文件必须在当前目录下，且文件编码为`utf-8`。\n\n   异步读取时，传入的回调函数接收两个参数，当正常读取时，`err`参数为`null`，`data`参数为读取到的String。当读取发生错误时，`err`参数代表一个错误对象，`data`为`undefined`。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。\n\n   如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？\n\n   下面的例子演示了如何读取一个图片文件：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.readFile('sample.png', function (err, data) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log(data);\n           console.log(data.length + ' bytes');\n       }\n   });\n   ```\n\n   当读取二进制文件时，不传入文件编码时，回调函数的`data`参数将返回一个`Buffer`对象。在Node.js中，`Buffer`对象就是一个包含零个或任意个字节的数组（注意和Array不同）。\n\n   `Buffer`对象可以和String作转换，例如，把一个`Buffer`对象转换成String：\n\n   ```js\n   // Buffer -> String\n   var text = data.toString('utf-8');\n   console.log(text);\n   ```\n\n   或者把一个String转换成`Buffer`：\n\n   ```js\n   // String -> Buffer\n   var buf = Buffer.from(text, 'utf-8');\n   console.log(buf);\n   ```\n\n   **同步读文件**\n\n   除了标准的异步读取模式外，`fs`也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果。\n\n   用`fs`模块同步读取一个文本文件的代码如下：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = fs.readFileSync('sample.txt', 'utf-8');\n   console.log(data);\n   ```\n\n   可见，原异步调用的回调函数的`data`被函数直接返回，函数名需要改为`readFileSync`，其它参数不变。\n\n   如果同步读取文件发生错误，则需要用`try...catch`捕获该错误：\n\n   ```js\n   try {\n       var data = fs.readFileSync('sample.txt', 'utf-8');\n       console.log(data);\n   } catch (err) {\n       // 出错了\n   }\n   ```\n\n   **写文件**\n\n   将数据写入文件是通过`fs.writeFile()`实现的：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = 'Hello, Node.js';\n   fs.writeFile('output.txt', data, function (err) {\n       if (err) {\n           console.log(err);\n       } else {\n           console.log('ok.');\n       }\n   });\n   ```\n\n   `writeFile()`的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是`Buffer`，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个`err`参数。\n\n   和`readFile()`类似，`writeFile()`也有一个同步方法，叫`writeFileSync()`：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var data = 'Hello, Node.js';\n   fs.writeFileSync('output.txt', data);\n   ```\n\n   **stat**\n\n   如果我们要获取文件大小，创建时间等信息，可以使用`fs.stat()`，它返回一个`Stat`对象，能告诉我们文件或目录的详细信息：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   fs.stat('sample.txt', function (err, stat) {\n       if (err) {\n           console.log(err);\n       } else {\n           // 是否是文件:\n           console.log('isFile: ' + stat.isFile());\n           // 是否是目录:\n           console.log('isDirectory: ' + stat.isDirectory());\n           if (stat.isFile()) {\n               // 文件大小:\n               console.log('size: ' + stat.size);\n               // 创建时间, Date对象:\n               console.log('birth time: ' + stat.birthtime);\n               // 修改时间, Date对象:\n               console.log('modified time: ' + stat.mtime);\n           }\n       }\n   });\n   ```\n\n   运行结果如下：\n\n   ```js\n   isFile: true\n   isDirectory: false\n   size: 181\n   birth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)\n   modified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)\n   ```\n\n   `stat()`也有一个对应的同步函数`statSync()`，请试着改写上述异步代码为同步代码。\n\n   **异步还是同步**\n\n   在`fs`模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？\n\n   由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，*必须使用异步代码*，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。\n\n   服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。\n\n5. stream模块\n\n   在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：`data`事件表示流的数据已经可以读取了，`end`事件表示这个流已经到末尾了，没有数据可以读取了，`error`事件表示出错了。\n\n   下面是一个从文件流读取文本内容的示例：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   // 打开一个流:\n   var rs = fs.createReadStream('sample.txt', 'utf-8');\n   \n   rs.on('data', function (chunk) {\n       console.log('DATA:')\n       console.log(chunk);\n   });\n   \n   rs.on('end', function () {\n       console.log('END');\n   });\n   \n   rs.on('error', function (err) {\n       console.log('ERROR: ' + err);\n   });\n   ```\n\n   要注意，`data`事件可能会有多次，每次传递的`chunk`是流的一部分数据。\n\n   要以流的形式写入文件，只需要不断调用`write()`方法，最后以`end()`结束：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var ws1 = fs.createWriteStream('output1.txt', 'utf-8');\n   ws1.write('使用Stream写入文本数据...\\n');\n   ws1.write('END.');\n   ws1.end();\n   \n   var ws2 = fs.createWriteStream('output2.txt');\n   ws2.write(new Buffer('使用Stream写入二进制数据...\\n', 'utf-8'));\n   ws2.write(new Buffer('END.', 'utf-8'));\n   ws2.end();\n   ```\n\n   所有可以读取数据的流都继承自`stream.Readable`，所有可以写入的流都继承自`stream.Writable`。\n\n   **pipe**\n\n   就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个`Readable`流和一个`Writable`流串起来后，所有的数据自动从`Readable`流进入`Writable`流，这种操作叫`pipe`。\n\n   在Node.js中，`Readable`流有一个`pipe()`方法，就是用来干这件事的。\n\n   让我们用`pipe()`把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：\n\n   ```js\n   'use strict';\n   \n   var fs = require('fs');\n   \n   var rs = fs.createReadStream('sample.txt');\n   var ws = fs.createWriteStream('copied.txt');\n   \n   rs.pipe(ws);\n   ```\n\n   默认情况下，当`Readable`流的数据读取完毕，`end`事件触发后，将自动关闭`Writable`流。如果我们不希望自动关闭`Writable`流，需要传入参数：\n\n   ```js\n   readable.pipe(writable, { end: false });\n   ```\n\n6. http模块\n\n   **HTTP服务器**\n\n   要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的`http`模块完成了。应用程序并不直接和HTTP协议打交道，而是操作`http`模块提供的`request`和`response`对象。\n\n   `request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；\n\n   `response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。\n\n   用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序`hello.js`，它对于所有请求，都返回`Hello world!`：\n\n   ```js\n   'use strict';\n   \n   // 导入http模块:\n   var http = require('http');\n   \n   // 创建http server，并传入回调函数:\n   var server = http.createServer(function (request, response) {\n       // 回调函数接收request和response对象,\n       // 获得HTTP请求的method和url:\n       console.log(request.method + ': ' + request.url);\n       // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\n       response.writeHead(200, {'Content-Type': 'text/html'});\n       // 将HTTP响应的HTML内容写入response:\n       response.end('<h1>Hello world!</h1>');\n   });\n   \n   // 让服务器监听8080端口:\n   server.listen(8080);\n   \n   console.log('Server is running at http://127.0.0.1:8080/');\n   ```\n\n   在命令提示符下运行该程序，可以看到以下输出：\n\n   ```js\n   $ node hello.js \n   Server is running at http://127.0.0.1:8080/\n   ```\n\n   **文件服务器**\n\n   让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析`request.url`中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。\n\n   解析URL需要用到Node.js提供的`url`模块，它使用起来非常简单，通过`parse()`将一个字符串解析为一个`Url`对象：\n\n   ```js\n   'use strict';\n   \n   var url = require('url');\n   \n   console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash'));\n   ```\n\n   结果如下：\n\n   ```js\n   Url {\n     protocol: 'http:',\n     slashes: true,\n     auth: 'user:pass',\n     host: 'host.com:8080',\n     port: '8080',\n     hostname: 'host.com',\n     hash: '#hash',\n     search: '?query=string',\n     query: 'query=string',\n     pathname: '/path/to/file',\n     path: '/path/to/file?query=string',\n     href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' }\n   ```\n\n   处理本地文件目录需要使用Node.js提供的`path`模块，它可以方便地构造目录：\n\n   ```js\n   'use strict';\n   \n   var path = require('path');\n   \n   // 解析当前目录:\n   var workDir = path.resolve('.'); // '/Users/michael'\n   \n   // 组合完整的文件路径:当前目录+'pub'+'index.html':\n   var filePath = path.join(workDir, 'pub', 'index.html');\n   // '/Users/michael/pub/index.html'\n   ```\n\n   使用`path`模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于`C:\\Users\\michael\\static\\index.html`，这样，我们就不关心怎么拼接路径了。\n\n   最后，我们实现一个文件服务器`file_server.js`：\n\n   ```js\n   'use strict';\n   \n   var\n       fs = require('fs'),\n       url = require('url'),\n       path = require('path'),\n       http = require('http');\n   \n   // 从命令行参数获取root目录，默认是当前目录:\n   var root = path.resolve(process.argv[2] || '.');\n   \n   console.log('Static root dir: ' + root);\n   \n   // 创建服务器:\n   var server = http.createServer(function (request, response) {\n       // 获得URL的path，类似 '/css/bootstrap.css':\n       var pathname = url.parse(request.url).pathname;\n       // 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':\n       var filepath = path.join(root, pathname);\n       // 获取文件状态:\n       fs.stat(filepath, function (err, stats) {\n           if (!err && stats.isFile()) {\n               // 没有出错并且文件存在:\n               console.log('200 ' + request.url);\n               // 发送200响应:\n               response.writeHead(200);\n               // 将文件流导向response:\n               fs.createReadStream(filepath).pipe(response);\n           } else {\n               // 出错了或者文件不存在:\n               console.log('404 ' + request.url);\n               // 发送404响应:\n               response.writeHead(404);\n               response.end('404 Not Found');\n           }\n       });\n   });\n   \n   server.listen(8080);\n   \n   console.log('Server is running at http://127.0.0.1:8080/');\n   ```\n\n   没有必要手动读取文件内容。由于`response`对象本身是一个`Writable Stream`，直接用`pipe()`方法就实现了自动读取文件内容并输出到HTTP响应。\n\n   在命令行运行`node file_server.js /path/to/dir`，把`/path/to/dir`改成你本地的一个有效的目录，然后在浏览器中输入`http://localhost:8080/index.html`：\n\n7. crypto模块\n\n   crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。","slug":"Node","published":1,"updated":"2024-02-19T07:42:51.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9f00151xop7v1qd5ej","content":"<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a><strong>Node</strong></h3><h5 id=\"node采用了单线程\"><a href=\"#node采用了单线程\" class=\"headerlink\" title=\"node采用了单线程\"></a><strong>node采用了单线程</strong></h5><p><strong>单线程的优势：</strong></p>\n<ol>\n<li>不用去在意状态的同步问题。</li>\n<li>没有死锁的情况。</li>\n<li>也没有上下文交换所带来的性能上的开销。</li>\n</ol>\n<p><strong>单线程有以下弱点：</strong></p>\n<ol>\n<li>无法利用多核CPU。</li>\n<li>错误会引起整个应用退出，应用的健壮性值得考验。</li>\n<li>大量的计算占用CPU导致无法继续调用异步I/O。</li>\n</ol>\n<p>像浏览器中<code>JavaScript</code>与UI公用一个线程一样，<code>JavaScript</code>长时间执行会导致UI渲染和响应被中断，在Node中，长时间的CPU占用，也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>\n<p>通过HTML5定制的Web Workers的标准，能够创建工作线程来进行计算，以解决<code>JavaScript</code>大计算阻塞UI渲染问题。Node采用与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。</p>\n<h5 id=\"node的应用场景\"><a href=\"#node的应用场景\" class=\"headerlink\" title=\"node的应用场景\"></a><strong>node的应用场景</strong></h5><ol>\n<li><p>I/O密集型</p>\n<p>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p>\n</li>\n<li><p>CPU密集型</p>\n<ul>\n<li>Node可以通过编写C/C++扩展的方式更高效的利用CPU。</li>\n<li>通过子进程方式，将一部分Node进程当做常住服务进程用于计算。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"node的异步I-O\"><a href=\"#node的异步I-O\" class=\"headerlink\" title=\"node的异步I/O\"></a><strong>node的异步I/O</strong></h5><blockquote>\n<p>在node中，无论是在*nix还是windows平台，内部完成I/O任务的另有线程池。完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>\n<p>请求对象是异步I/O过程的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调函数处理。</p>\n<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>\n</blockquote>\n<h5 id=\"node的使用\"><a href=\"#node的使用\" class=\"headerlink\" title=\"node的使用\"></a><strong>node的使用</strong></h5><blockquote>\n<p>注意：如果要为服务器环境下的所有js文件使用严格模式的话，一个一个的加<code>use strict</code>太麻烦，可以通过给NodeJs传递参数来为所有js文件启动严格模式：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">node <span class=\"token operator\">--</span>use_strict demo<span class=\"token punctuation\">.</span>js\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> greet <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./hello'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 不要忘了写相对目录!</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果只写模块名：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> greet <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>js\n    <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n          <span class=\"token operator\">^</span>\nError<span class=\"token punctuation\">:</span> Cannot find module <span class=\"token string\">'hello'</span>\n    at Function<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span>_resolveFilename\n    at Function<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span>_load\n    <span class=\"token operator\">...</span>\n    at Function<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span>_load\n    at Function<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">.</span>runMain\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>遇到这个错误，你要检查：</p>\n<ul>\n<li>模块名是否写对了；</li>\n<li>模块文件是否存在；</li>\n<li>相对路径是否写对了。</li>\n</ul>\n</blockquote>\n<h5 id=\"基本模块\"><a href=\"#基本模块\" class=\"headerlink\" title=\"基本模块\"></a><strong>基本模块</strong></h5><ol>\n<li><p><code>global</code>:<code>JavaScript</code>有且仅有一个全局对象，在浏览器中叫做<code>window</code>对象。而在node环境中，也有唯一的全局对象，叫做<code>global</code>，这个对象的属性和方法与浏览器中的<code>window</code>不同。</p>\n</li>\n<li><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">></span> process <span class=\"token operator\">===</span> global<span class=\"token punctuation\">.</span>process<span class=\"token punctuation\">;</span>\n<span class=\"token boolean\">true</span>\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span>version<span class=\"token punctuation\">;</span>\n<span class=\"token string\">'v5.2.0'</span>\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span>platform<span class=\"token punctuation\">;</span>\n<span class=\"token string\">'darwin'</span>\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span>arch<span class=\"token punctuation\">;</span>\n<span class=\"token string\">'x64'</span>\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span><span class=\"token function\">cwd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//返回当前工作目录</span>\n<span class=\"token string\">'/Users/michael'</span>\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span><span class=\"token function\">chdir</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/private/tmp'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 切换当前工作目录</span>\nundefined\n<span class=\"token operator\">></span> process<span class=\"token punctuation\">.</span><span class=\"token function\">cwd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token string\">'/private/tmp'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>\n<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// test.js</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// process.nextTick()将在下一轮事件循环中调用:</span>\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick callback!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nextTick was set!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">nextTick was <span class=\"token keyword\">set</span><span class=\"token operator\">!</span>\nnextTick callback<span class=\"token operator\">!</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>\n<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 程序即将退出时的回调函数:</span>\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'exit'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>code<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'about to exit with code: '</span> <span class=\"token operator\">+</span> code<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>判断<code>JavaScript</code>的执行环境</p>\n<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'browser'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>fs模块（文件系统模块）</p>\n<p><strong>fs模块同时提供了异步和同步的方法。</strong></p>\n<p><strong>异步读取文件：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>\n<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。</p>\n<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>\n<p>下面的例子演示了如何读取一个图片文件：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.png'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token string\">' bytes'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>\n<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// Buffer -> String</span>\n<span class=\"token keyword\">var</span> text <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>或者把一个String转换成<code>Buffer</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// String -> Buffer</span>\n<span class=\"token keyword\">var</span> buf <span class=\"token operator\">=</span> Buffer<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>同步读文件</strong></p>\n<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>\n<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>\n<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 出错了</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>写文件</strong></p>\n<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, Node.js'</span><span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output.txt'</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ok.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>\n<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, Node.js'</span><span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output.txt'</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>stat</strong></p>\n<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">stat</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> stat<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 是否是文件:</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'isFile: '</span> <span class=\"token operator\">+</span> stat<span class=\"token punctuation\">.</span><span class=\"token function\">isFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 是否是目录:</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'isDirectory: '</span> <span class=\"token operator\">+</span> stat<span class=\"token punctuation\">.</span><span class=\"token function\">isDirectory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stat<span class=\"token punctuation\">.</span><span class=\"token function\">isFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 文件大小:</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'size: '</span> <span class=\"token operator\">+</span> stat<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 创建时间, Date对象:</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'birth time: '</span> <span class=\"token operator\">+</span> stat<span class=\"token punctuation\">.</span>birthtime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 修改时间, Date对象:</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'modified time: '</span> <span class=\"token operator\">+</span> stat<span class=\"token punctuation\">.</span>mtime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>运行结果如下：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">isFile<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\nisDirectory<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\nsize<span class=\"token punctuation\">:</span> <span class=\"token number\">181</span>\nbirth time<span class=\"token punctuation\">:</span> Fri Dec <span class=\"token number\">11</span> <span class=\"token number\">2015</span> <span class=\"token number\">09</span><span class=\"token punctuation\">:</span><span class=\"token number\">43</span><span class=\"token punctuation\">:</span><span class=\"token number\">41</span> GMT<span class=\"token operator\">+</span><span class=\"token number\">0800</span> <span class=\"token punctuation\">(</span>CST<span class=\"token punctuation\">)</span>\nmodified time<span class=\"token punctuation\">:</span> Fri Dec <span class=\"token number\">11</span> <span class=\"token number\">2015</span> <span class=\"token number\">12</span><span class=\"token punctuation\">:</span><span class=\"token number\">09</span><span class=\"token punctuation\">:</span><span class=\"token number\">00</span> GMT<span class=\"token operator\">+</span><span class=\"token number\">0800</span> <span class=\"token punctuation\">(</span>CST<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>\n<p><strong>异步还是同步</strong></p>\n<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>\n<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>\n<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>\n</li>\n<li><p>stream模块</p>\n<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<p>下面是一个从文件流读取文本内容的示例：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 打开一个流:</span>\n<span class=\"token keyword\">var</span> rs <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createReadStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrs<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'DATA:'</span><span class=\"token punctuation\">)</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>chunk<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrs<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'END'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrs<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ERROR: '</span> <span class=\"token operator\">+</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>\n<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> ws1 <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createWriteStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output1.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws1<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用Stream写入文本数据...\\n'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws1<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'END.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws1<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> ws2 <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createWriteStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'output2.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws2<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token string\">'使用Stream写入二进制数据...\\n'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws2<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Buffer</span><span class=\"token punctuation\">(</span><span class=\"token string\">'END.'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nws2<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>\n<p><strong>pipe</strong></p>\n<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>\n<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> rs <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createReadStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'sample.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> ws <span class=\"token operator\">=</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">createWriteStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">'copied.txt'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrs<span class=\"token punctuation\">.</span><span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>ws<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>默认情况下，当<code>Readable</code>流的数据读取完毕，<code>end</code>事件触发后，将自动关闭<code>Writable</code>流。如果我们不希望自动关闭<code>Writable</code>流，需要传入参数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">readable<span class=\"token punctuation\">.</span><span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>writable<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> end<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>http模块</p>\n<p><strong>HTTP服务器</strong></p>\n<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>\n<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>\n<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>\n<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 导入http模块:</span>\n<span class=\"token keyword\">var</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建http server，并传入回调函数:</span>\n<span class=\"token keyword\">var</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 回调函数接收request和response对象,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得HTTP请求的method和url:</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">+</span> <span class=\"token string\">': '</span> <span class=\"token operator\">+</span> request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span>\n    response<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Content-Type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'text/html'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 将HTTP响应的HTML内容写入response:</span>\n    response<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;h1>Hello world!&lt;/h1>'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 让服务器监听8080端口:</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server is running at http://127.0.0.1:8080/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在命令提示符下运行该程序，可以看到以下输出：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">$ node hello<span class=\"token punctuation\">.</span>js \nServer is running at http<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span><span class=\"token number\">127.0</span><span class=\"token punctuation\">.</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">:</span><span class=\"token number\">8080</span><span class=\"token operator\">/</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>文件服务器</strong></p>\n<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>\n<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'url'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果如下：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Url <span class=\"token punctuation\">{</span>\n  protocol<span class=\"token punctuation\">:</span> <span class=\"token string\">'http:'</span><span class=\"token punctuation\">,</span>\n  slashes<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  auth<span class=\"token punctuation\">:</span> <span class=\"token string\">'user:pass'</span><span class=\"token punctuation\">,</span>\n  host<span class=\"token punctuation\">:</span> <span class=\"token string\">'host.com:8080'</span><span class=\"token punctuation\">,</span>\n  port<span class=\"token punctuation\">:</span> <span class=\"token string\">'8080'</span><span class=\"token punctuation\">,</span>\n  hostname<span class=\"token punctuation\">:</span> <span class=\"token string\">'host.com'</span><span class=\"token punctuation\">,</span>\n  hash<span class=\"token punctuation\">:</span> <span class=\"token string\">'#hash'</span><span class=\"token punctuation\">,</span>\n  search<span class=\"token punctuation\">:</span> <span class=\"token string\">'?query=string'</span><span class=\"token punctuation\">,</span>\n  query<span class=\"token punctuation\">:</span> <span class=\"token string\">'query=string'</span><span class=\"token punctuation\">,</span>\n  pathname<span class=\"token punctuation\">:</span> <span class=\"token string\">'/path/to/file'</span><span class=\"token punctuation\">,</span>\n  path<span class=\"token punctuation\">:</span> <span class=\"token string\">'/path/to/file?query=string'</span><span class=\"token punctuation\">,</span>\n  href<span class=\"token punctuation\">:</span> <span class=\"token string\">'http://user:pass@host.com:8080/path/to/file?query=string#hash'</span> <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 解析当前目录:</span>\n<span class=\"token keyword\">var</span> workDir <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// '/Users/michael'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 组合完整的文件路径:当前目录+'pub'+'index.html':</span>\n<span class=\"token keyword\">var</span> filePath <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>workDir<span class=\"token punctuation\">,</span> <span class=\"token string\">'pub'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'index.html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// '/Users/michael/pub/index.html'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\\Users\\michael\\static\\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>\n<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">'use strict'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span>\n    fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    url <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'url'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 从命令行参数获取root目录，默认是当前目录:</span>\n<span class=\"token keyword\">var</span> root <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>argv<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Static root dir: '</span> <span class=\"token operator\">+</span> root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 创建服务器:</span>\n<span class=\"token keyword\">var</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得URL的path，类似 '/css/bootstrap.css':</span>\n    <span class=\"token keyword\">var</span> pathname <span class=\"token operator\">=</span> url<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>pathname<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获得对应的本地文件路径，类似 '/srv/www/css/bootstrap.css':</span>\n    <span class=\"token keyword\">var</span> filepath <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> pathname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 获取文件状态:</span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">stat</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> stats<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>err <span class=\"token operator\">&amp;&amp;</span> stats<span class=\"token punctuation\">.</span><span class=\"token function\">isFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 没有出错并且文件存在:</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'200 '</span> <span class=\"token operator\">+</span> request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 发送200响应:</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 将文件流导向response:</span>\n            fs<span class=\"token punctuation\">.</span><span class=\"token function\">createReadStream</span><span class=\"token punctuation\">(</span>filepath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 出错了或者文件不存在:</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'404 '</span> <span class=\"token operator\">+</span> request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 发送404响应:</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">404</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            response<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">'404 Not Found'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">8080</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Server is running at http://127.0.0.1:8080/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>\n<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>\n</li>\n<li><p>crypto模块</p>\n<p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a><strong>Node</strong></h3><h5 id=\"node采用了单线程\"><a href=\"#node采用了单线程\" class=\"headerlink\" title=\"node采用了单线程\"></a><strong>node采用了单线程</strong></h5><p><strong>单线程的优势：</strong></p>\n<ol>\n<li>不用去在意状态的同步问题。</li>\n<li>没有死锁的情况。</li>\n<li>也没有上下文交换所带来的性能上的开销。</li>\n</ol>\n<p><strong>单线程有以下弱点：</strong></p>\n<ol>\n<li>无法利用多核CPU。</li>\n<li>错误会引起整个应用退出，应用的健壮性值得考验。</li>\n<li>大量的计算占用CPU导致无法继续调用异步I/O。</li>\n</ol>\n<p>像浏览器中<code>JavaScript</code>与UI公用一个线程一样，<code>JavaScript</code>长时间执行会导致UI渲染和响应被中断，在Node中，长时间的CPU占用，也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。</p>\n<p>通过HTML5定制的Web Workers的标准，能够创建工作线程来进行计算，以解决<code>JavaScript</code>大计算阻塞UI渲染问题。Node采用与Web Workers相同的思路来解决单线程中大计算量的问题：<code>child_process</code>。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。</p>\n<h5 id=\"node的应用场景\"><a href=\"#node的应用场景\" class=\"headerlink\" title=\"node的应用场景\"></a><strong>node的应用场景</strong></h5><ol>\n<li><p>I/O密集型</p>\n<p>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。</p>\n</li>\n<li><p>CPU密集型</p>\n<ul>\n<li>Node可以通过编写C/C++扩展的方式更高效的利用CPU。</li>\n<li>通过子进程方式，将一部分Node进程当做常住服务进程用于计算。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"node的异步I-O\"><a href=\"#node的异步I-O\" class=\"headerlink\" title=\"node的异步I/O\"></a><strong>node的异步I/O</strong></h5><blockquote>\n<p>在node中，无论是在*nix还是windows平台，内部完成I/O任务的另有线程池。完成整个异步I/O环节的有事件循环、观察者和请求对象等。</p>\n<p>请求对象是异步I/O过程的中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调函数处理。</p>\n<p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>\n</blockquote>\n<h5 id=\"node的使用\"><a href=\"#node的使用\" class=\"headerlink\" title=\"node的使用\"></a><strong>node的使用</strong></h5><blockquote>\n<p>注意：如果要为服务器环境下的所有js文件使用严格模式的话，一个一个的加<code>use strict</code>太麻烦，可以通过给NodeJs传递参数来为所有js文件启动严格模式：</p>\n<pre><code class=\"js\">node --use_strict demo.js\n</code></pre>\n<p>在使用<code>require()</code>引入模块的时候，请注意模块的相对路径。因为<code>main.js</code>和<code>hello.js</code>位于同一个目录，所以我们用了当前目录<code>.</code>：</p>\n<pre><code class=\"js\">var greet = require(&#39;./hello&#39;); // 不要忘了写相对目录!\n</code></pre>\n<p>如果只写模块名：</p>\n<pre><code class=\"js\">var greet = require(&#39;hello&#39;);\n</code></pre>\n<p>则Node会依次在内置模块、全局模块和当前模块下查找<code>hello.js</code>，你很可能会得到一个错误：</p>\n<pre><code class=\"js\">module.js\n    throw err;\n          ^\nError: Cannot find module &#39;hello&#39;\n    at Function.Module._resolveFilename\n    at Function.Module._load\n    ...\n    at Function.Module._load\n    at Function.Module.runMain\n</code></pre>\n<p>遇到这个错误，你要检查：</p>\n<ul>\n<li>模块名是否写对了；</li>\n<li>模块文件是否存在；</li>\n<li>相对路径是否写对了。</li>\n</ul>\n</blockquote>\n<h5 id=\"基本模块\"><a href=\"#基本模块\" class=\"headerlink\" title=\"基本模块\"></a><strong>基本模块</strong></h5><ol>\n<li><p><code>global</code>:<code>JavaScript</code>有且仅有一个全局对象，在浏览器中叫做<code>window</code>对象。而在node环境中，也有唯一的全局对象，叫做<code>global</code>，这个对象的属性和方法与浏览器中的<code>window</code>不同。</p>\n</li>\n<li><p><code>process</code>也是Node.js提供的一个对象，它代表当前Node.js进程。通过<code>process</code>对象可以拿到许多有用信息：</p>\n<pre><code class=\"js\">&gt; process === global.process;\ntrue\n&gt; process.version;\n&#39;v5.2.0&#39;\n&gt; process.platform;\n&#39;darwin&#39;\n&gt; process.arch;\n&#39;x64&#39;\n&gt; process.cwd(); //返回当前工作目录\n&#39;/Users/michael&#39;\n&gt; process.chdir(&#39;/private/tmp&#39;); // 切换当前工作目录\nundefined\n&gt; process.cwd();\n&#39;/private/tmp&#39;\n</code></pre>\n<p>JavaScript程序是由事件驱动执行的单线程模型，Node.js也不例外。Node.js不断执行响应事件的JavaScript函数，直到没有任何响应事件的函数可以执行时，Node.js就退出了。</p>\n<p>如果我们想要在下一次事件响应中执行代码，可以调用<code>process.nextTick()</code>：</p>\n<pre><code class=\"js\">// test.js\n\n// process.nextTick()将在下一轮事件循环中调用:\nprocess.nextTick(function () {\n    console.log(&#39;nextTick callback!&#39;);\n});\nconsole.log(&#39;nextTick was set!&#39;);\n</code></pre>\n<p>用Node执行上面的代码<code>node test.js</code>，你会看到，打印输出是：</p>\n<pre><code class=\"js\">nextTick was set!\nnextTick callback!\n</code></pre>\n<p>这说明传入<code>process.nextTick()</code>的函数不是立刻执行，而是要等到下一次事件循环。</p>\n<p>Node.js进程本身的事件就由<code>process</code>对象来处理。如果我们响应<code>exit</code>事件，就可以在程序即将退出时执行某个回调函数：</p>\n<pre><code class=\"js\">// 程序即将退出时的回调函数:\nprocess.on(&#39;exit&#39;, function (code) {\n    console.log(&#39;about to exit with code: &#39; + code);\n});\n</code></pre>\n</li>\n<li><p>判断<code>JavaScript</code>的执行环境</p>\n<p>有很多JavaScript代码既能在浏览器中执行，也能在Node环境执行，但有些时候，程序本身需要判断自己到底是在什么环境下执行的，常用的方式就是根据浏览器和Node环境提供的全局变量名称来判断：</p>\n<pre><code class=\"js\">if (typeof(window) === &#39;undefined&#39;) {\n    console.log(&#39;node.js&#39;);\n} else {\n    console.log(&#39;browser&#39;);\n}\n</code></pre>\n</li>\n<li><p>fs模块（文件系统模块）</p>\n<p><strong>fs模块同时提供了异步和同步的方法。</strong></p>\n<p><strong>异步读取文件：</strong></p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nfs.readFile(&#39;sample.txt&#39;, &#39;utf-8&#39;, function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n    }\n});\n</code></pre>\n<p>请注意，<code>sample.txt</code>文件必须在当前目录下，且文件编码为<code>utf-8</code>。</p>\n<p>异步读取时，传入的回调函数接收两个参数，当正常读取时，<code>err</code>参数为<code>null</code>，<code>data</code>参数为读取到的String。当读取发生错误时，<code>err</code>参数代表一个错误对象，<code>data</code>为<code>undefined</code>。这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。</p>\n<p>如果我们要读取的文件不是文本文件，而是二进制文件，怎么办？</p>\n<p>下面的例子演示了如何读取一个图片文件：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nfs.readFile(&#39;sample.png&#39;, function (err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n        console.log(data.length + &#39; bytes&#39;);\n    }\n});\n</code></pre>\n<p>当读取二进制文件时，不传入文件编码时，回调函数的<code>data</code>参数将返回一个<code>Buffer</code>对象。在Node.js中，<code>Buffer</code>对象就是一个包含零个或任意个字节的数组（注意和Array不同）。</p>\n<p><code>Buffer</code>对象可以和String作转换，例如，把一个<code>Buffer</code>对象转换成String：</p>\n<pre><code class=\"js\">// Buffer -&gt; String\nvar text = data.toString(&#39;utf-8&#39;);\nconsole.log(text);\n</code></pre>\n<p>或者把一个String转换成<code>Buffer</code>：</p>\n<pre><code class=\"js\">// String -&gt; Buffer\nvar buf = Buffer.from(text, &#39;utf-8&#39;);\nconsole.log(buf);\n</code></pre>\n<p><strong>同步读文件</strong></p>\n<p>除了标准的异步读取模式外，<code>fs</code>也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<code>Sync</code>后缀，并且不接收回调函数，函数直接返回结果。</p>\n<p>用<code>fs</code>模块同步读取一个文本文件的代码如下：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nvar data = fs.readFileSync(&#39;sample.txt&#39;, &#39;utf-8&#39;);\nconsole.log(data);\n</code></pre>\n<p>可见，原异步调用的回调函数的<code>data</code>被函数直接返回，函数名需要改为<code>readFileSync</code>，其它参数不变。</p>\n<p>如果同步读取文件发生错误，则需要用<code>try...catch</code>捕获该错误：</p>\n<pre><code class=\"js\">try {\n    var data = fs.readFileSync(&#39;sample.txt&#39;, &#39;utf-8&#39;);\n    console.log(data);\n} catch (err) {\n    // 出错了\n}\n</code></pre>\n<p><strong>写文件</strong></p>\n<p>将数据写入文件是通过<code>fs.writeFile()</code>实现的：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nvar data = &#39;Hello, Node.js&#39;;\nfs.writeFile(&#39;output.txt&#39;, data, function (err) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(&#39;ok.&#39;);\n    }\n});\n</code></pre>\n<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是<code>Buffer</code>，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个<code>err</code>参数。</p>\n<p>和<code>readFile()</code>类似，<code>writeFile()</code>也有一个同步方法，叫<code>writeFileSync()</code>：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nvar data = &#39;Hello, Node.js&#39;;\nfs.writeFileSync(&#39;output.txt&#39;, data);\n</code></pre>\n<p><strong>stat</strong></p>\n<p>如果我们要获取文件大小，创建时间等信息，可以使用<code>fs.stat()</code>，它返回一个<code>Stat</code>对象，能告诉我们文件或目录的详细信息：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nfs.stat(&#39;sample.txt&#39;, function (err, stat) {\n    if (err) {\n        console.log(err);\n    } else {\n        // 是否是文件:\n        console.log(&#39;isFile: &#39; + stat.isFile());\n        // 是否是目录:\n        console.log(&#39;isDirectory: &#39; + stat.isDirectory());\n        if (stat.isFile()) {\n            // 文件大小:\n            console.log(&#39;size: &#39; + stat.size);\n            // 创建时间, Date对象:\n            console.log(&#39;birth time: &#39; + stat.birthtime);\n            // 修改时间, Date对象:\n            console.log(&#39;modified time: &#39; + stat.mtime);\n        }\n    }\n});\n</code></pre>\n<p>运行结果如下：</p>\n<pre><code class=\"js\">isFile: true\nisDirectory: false\nsize: 181\nbirth time: Fri Dec 11 2015 09:43:41 GMT+0800 (CST)\nmodified time: Fri Dec 11 2015 12:09:00 GMT+0800 (CST)\n</code></pre>\n<p><code>stat()</code>也有一个对应的同步函数<code>statSync()</code>，请试着改写上述异步代码为同步代码。</p>\n<p><strong>异步还是同步</strong></p>\n<p>在<code>fs</code>模块中，提供同步方法是为了方便使用。那我们到底是应该用异步方法还是同步方法呢？</p>\n<p>由于Node环境执行的JavaScript代码是服务器端代码，所以，绝大部分需要在服务器运行期反复执行业务逻辑的代码，<em>必须使用异步代码</em>，否则，同步代码在执行时期，服务器将停止响应，因为JavaScript只有一个执行线程。</p>\n<p>服务器启动时如果需要读取配置文件，或者结束时需要写入到状态文件时，可以使用同步代码，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。</p>\n</li>\n<li><p>stream模块</p>\n<p>在Node.js中，流也是一个对象，我们只需要响应流的事件就可以了：<code>data</code>事件表示流的数据已经可以读取了，<code>end</code>事件表示这个流已经到末尾了，没有数据可以读取了，<code>error</code>事件表示出错了。</p>\n<p>下面是一个从文件流读取文本内容的示例：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\n// 打开一个流:\nvar rs = fs.createReadStream(&#39;sample.txt&#39;, &#39;utf-8&#39;);\n\nrs.on(&#39;data&#39;, function (chunk) {\n    console.log(&#39;DATA:&#39;)\n    console.log(chunk);\n});\n\nrs.on(&#39;end&#39;, function () {\n    console.log(&#39;END&#39;);\n});\n\nrs.on(&#39;error&#39;, function (err) {\n    console.log(&#39;ERROR: &#39; + err);\n});\n</code></pre>\n<p>要注意，<code>data</code>事件可能会有多次，每次传递的<code>chunk</code>是流的一部分数据。</p>\n<p>要以流的形式写入文件，只需要不断调用<code>write()</code>方法，最后以<code>end()</code>结束：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nvar ws1 = fs.createWriteStream(&#39;output1.txt&#39;, &#39;utf-8&#39;);\nws1.write(&#39;使用Stream写入文本数据...\\n&#39;);\nws1.write(&#39;END.&#39;);\nws1.end();\n\nvar ws2 = fs.createWriteStream(&#39;output2.txt&#39;);\nws2.write(new Buffer(&#39;使用Stream写入二进制数据...\\n&#39;, &#39;utf-8&#39;));\nws2.write(new Buffer(&#39;END.&#39;, &#39;utf-8&#39;));\nws2.end();\n</code></pre>\n<p>所有可以读取数据的流都继承自<code>stream.Readable</code>，所有可以写入的流都继承自<code>stream.Writable</code>。</p>\n<p><strong>pipe</strong></p>\n<p>就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个<code>Readable</code>流和一个<code>Writable</code>流串起来后，所有的数据自动从<code>Readable</code>流进入<code>Writable</code>流，这种操作叫<code>pipe</code>。</p>\n<p>在Node.js中，<code>Readable</code>流有一个<code>pipe()</code>方法，就是用来干这件事的。</p>\n<p>让我们用<code>pipe()</code>把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar fs = require(&#39;fs&#39;);\n\nvar rs = fs.createReadStream(&#39;sample.txt&#39;);\nvar ws = fs.createWriteStream(&#39;copied.txt&#39;);\n\nrs.pipe(ws);\n</code></pre>\n<p>默认情况下，当<code>Readable</code>流的数据读取完毕，<code>end</code>事件触发后，将自动关闭<code>Writable</code>流。如果我们不希望自动关闭<code>Writable</code>流，需要传入参数：</p>\n<pre><code class=\"js\">readable.pipe(writable, { end: false });\n</code></pre>\n</li>\n<li><p>http模块</p>\n<p><strong>HTTP服务器</strong></p>\n<p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的<code>http</code>模块完成了。应用程序并不直接和HTTP协议打交道，而是操作<code>http</code>模块提供的<code>request</code>和<code>response</code>对象。</p>\n<p><code>request</code>对象封装了HTTP请求，我们调用<code>request</code>对象的属性和方法就可以拿到所有HTTP请求的信息；</p>\n<p><code>response</code>对象封装了HTTP响应，我们操作<code>response</code>对象的方法，就可以把HTTP响应返回给浏览器。</p>\n<p>用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序<code>hello.js</code>，它对于所有请求，都返回<code>Hello world!</code>：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\n// 导入http模块:\nvar http = require(&#39;http&#39;);\n\n// 创建http server，并传入回调函数:\nvar server = http.createServer(function (request, response) {\n    // 回调函数接收request和response对象,\n    // 获得HTTP请求的method和url:\n    console.log(request.method + &#39;: &#39; + request.url);\n    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:\n    response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/html&#39;});\n    // 将HTTP响应的HTML内容写入response:\n    response.end(&#39;&lt;h1&gt;Hello world!&lt;/h1&gt;&#39;);\n});\n\n// 让服务器监听8080端口:\nserver.listen(8080);\n\nconsole.log(&#39;Server is running at http://127.0.0.1:8080/&#39;);\n</code></pre>\n<p>在命令提示符下运行该程序，可以看到以下输出：</p>\n<pre><code class=\"js\">$ node hello.js \nServer is running at http://127.0.0.1:8080/\n</code></pre>\n<p><strong>文件服务器</strong></p>\n<p>让我们继续扩展一下上面的Web程序。我们可以设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析<code>request.url</code>中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p>\n<p>解析URL需要用到Node.js提供的<code>url</code>模块，它使用起来非常简单，通过<code>parse()</code>将一个字符串解析为一个<code>Url</code>对象：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar url = require(&#39;url&#39;);\n\nconsole.log(url.parse(&#39;http://user:pass@host.com:8080/path/to/file?query=string#hash&#39;));\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"js\">Url {\n  protocol: &#39;http:&#39;,\n  slashes: true,\n  auth: &#39;user:pass&#39;,\n  host: &#39;host.com:8080&#39;,\n  port: &#39;8080&#39;,\n  hostname: &#39;host.com&#39;,\n  hash: &#39;#hash&#39;,\n  search: &#39;?query=string&#39;,\n  query: &#39;query=string&#39;,\n  pathname: &#39;/path/to/file&#39;,\n  path: &#39;/path/to/file?query=string&#39;,\n  href: &#39;http://user:pass@host.com:8080/path/to/file?query=string#hash&#39; }\n</code></pre>\n<p>处理本地文件目录需要使用Node.js提供的<code>path</code>模块，它可以方便地构造目录：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar path = require(&#39;path&#39;);\n\n// 解析当前目录:\nvar workDir = path.resolve(&#39;.&#39;); // &#39;/Users/michael&#39;\n\n// 组合完整的文件路径:当前目录+&#39;pub&#39;+&#39;index.html&#39;:\nvar filePath = path.join(workDir, &#39;pub&#39;, &#39;index.html&#39;);\n// &#39;/Users/michael/pub/index.html&#39;\n</code></pre>\n<p>使用<code>path</code>模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\\Users\\michael\\static\\index.html</code>，这样，我们就不关心怎么拼接路径了。</p>\n<p>最后，我们实现一个文件服务器<code>file_server.js</code>：</p>\n<pre><code class=\"js\">&#39;use strict&#39;;\n\nvar\n    fs = require(&#39;fs&#39;),\n    url = require(&#39;url&#39;),\n    path = require(&#39;path&#39;),\n    http = require(&#39;http&#39;);\n\n// 从命令行参数获取root目录，默认是当前目录:\nvar root = path.resolve(process.argv[2] || &#39;.&#39;);\n\nconsole.log(&#39;Static root dir: &#39; + root);\n\n// 创建服务器:\nvar server = http.createServer(function (request, response) {\n    // 获得URL的path，类似 &#39;/css/bootstrap.css&#39;:\n    var pathname = url.parse(request.url).pathname;\n    // 获得对应的本地文件路径，类似 &#39;/srv/www/css/bootstrap.css&#39;:\n    var filepath = path.join(root, pathname);\n    // 获取文件状态:\n    fs.stat(filepath, function (err, stats) {\n        if (!err &amp;&amp; stats.isFile()) {\n            // 没有出错并且文件存在:\n            console.log(&#39;200 &#39; + request.url);\n            // 发送200响应:\n            response.writeHead(200);\n            // 将文件流导向response:\n            fs.createReadStream(filepath).pipe(response);\n        } else {\n            // 出错了或者文件不存在:\n            console.log(&#39;404 &#39; + request.url);\n            // 发送404响应:\n            response.writeHead(404);\n            response.end(&#39;404 Not Found&#39;);\n        }\n    });\n});\n\nserver.listen(8080);\n\nconsole.log(&#39;Server is running at http://127.0.0.1:8080/&#39;);\n</code></pre>\n<p>没有必要手动读取文件内容。由于<code>response</code>对象本身是一个<code>Writable Stream</code>，直接用<code>pipe()</code>方法就实现了自动读取文件内容并输出到HTTP响应。</p>\n<p>在命令行运行<code>node file_server.js /path/to/dir</code>，把<code>/path/to/dir</code>改成你本地的一个有效的目录，然后在浏览器中输入<code>http://localhost:8080/index.html</code>：</p>\n</li>\n<li><p>crypto模块</p>\n<p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过cypto这个模块暴露为JavaScript接口，这样用起来方便，运行速度也快。</p>\n</li>\n</ol>\n"},{"title":"Vuex","date":"2018-12-09T04:16:43.000Z","_content":"\n### vuex\n\n> 使用 Vuex 并不意味着你需要将**所有的**状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。\n\n> 每一个应用的核心就是store（仓库）。\"store\"基本上就是一个容器，它包含着应用中的大部分状态（state）。\n>\n> 1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n> 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n安装：\n\n```js\nnpm install vuex --save\n```\n\n使用：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex);\n```\n\n##### State\n\n初始化创建一个store：\n\n```js\nconst store = new Vuex.store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state){\n          state.count++   \n        }\n    }\n})\n```\n\n触发状态state变更\n\n```js\nstore.commit('increment');\n```\n\n###### 在模块化开发模式中使用\n\nVuex通过`store`选项，提供了一种机制将状态从跟组件注入到每一个子组件（需要调用Vue.use(Vuex)）:\n\n```js\nnew Vue({\n    el: '#app',\n    // 把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件中\n    store,\n    router,\n    components: { APP },\n    template: '<App/>'\n})\n```\n\n> 由于Vuex的状态存储是响应式的，从`store`实例中读取状态最简单的方法就是在计算属性中返回某个状态。\n\n```js\n<template>\n  <div>\n    <h1>{{ msg }}{{ count }}</h1>\n    <button @click=\"increment\">add</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'HelloWorld',\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  },\n  computed: {\n    count () {// 通过在根实例中注册store选项，且子组件中能够通过this.$store访问到。\n      return this.$store.state.count\n    }\n  },\n  methods: {\n    increment () {\n      this.$store.commit('increment');\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n</style>\n```\n\n###### mapState辅助函数\n\n当一个组件需要获取多个状态时，将这些状态都声明为计算属性显得有些多余，为了解决这个问题，我们可以使用`mapState`辅助函数来帮助我们生成计算属性。\n\n在使用之前需要先导入：\n\n```js\nimport { mapState } from 'vuex'\n```\n\n接下来就是使用：\n\n```js\nexport default {\n    // ...\n    data () {\n        return {\n            str: '年龄'\n        }\n    }\n    computed: mapState({\n        count: 'count', //第一种写法\n        sex: state => state.sex, //第二种写法\n        age (state) { //如果想要使用this,必须使用常规函数才能获取\n            return this.str + ':' + state.age  //this指向vue实例\n        }\n    })\n}\n```\n\n##### Getter\n\n有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n\n如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 接受 state 作为其第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n我们可以很容易地在任何组件中使用它：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount //doneTodosCount是与store中的gettters中的类似方法名的函数对应\n  }\n}\n```\n\n注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\n\n```js\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n\n注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n\n###### mapGetters辅助函数\n\n辅助方法仅仅是将store中的getter映射到局部计算属性，与mapState类似：\n\n```js\n<div>{{ doneTodos }}</div> <!-- 使用getters属性进行数据处理 -->\n<div>{{ count }}</div>\ncomputed: {\n    ...mapState(['count', 'todos']),\n    ...mapGetters(['doneTodos'])\n},\n```\n\n##### Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法：\n\n```js\nstore.commit('increment')\n```\n\n###### 提交载荷（Payload）\n\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\n```js\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n###### 对象风格的提交方式\n\n提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：\n\n```js\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n\n```js\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n###### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。\n\n###### Mutation必须是同步函数\n\n一条重要的原则就是要记住 **mutation 必须是同步函数**。为什么？请参考下面的例子：\n\n```js\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n###### 在组件中提交Mutation\n\n你可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）。\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n**mutation 都是同步事务**：\n\n```js\nstore.commit('increment')\n// 任何由 \"increment\" 导致的状态变更都应该在此刻完成。\n```\n\n##### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态。\n- Action 可以包含任意异步操作。\n\n让我们来注册一个简单的 action：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。当我们在之后介绍到 [Modules](https://vuex.vuejs.org/zh/guide/modules.html) 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n实践中，我们会经常用到 ES2015 的 [参数解构](https://github.com/lukehoban/es6features#destructuring) 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：\n\n```js\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n###### 分发action\n\nAction 通过 `store.dispatch` 方法触发：\n\n```js\nstore.dispatch('increment')\n```\n\n乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 **mutation 必须同步执行**这个限制么？Action 就不受约束！我们可以在 action 内部执行**异步**操作：\n\n```js\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n\nActions 支持同样的载荷方式和对象方式进行分发：\n\n```js\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\n###### 在组件中分发action\n\n你在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 `store`）：\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n###### 组合action\n\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n首先，你需要明白 `store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，并且 `store.dispatch` 仍旧返回 Promise：\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n\n现在你可以：\n\n```js\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n在另外一个 action 中也可以：\n\n```js\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n最后，如果我们利用 [async / await](https://tc39.github.io/ecmascript-asyncawait/)，我们可以如下组合 action：\n\n```js\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n##### Module\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n###### 模块的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。\n\n```js\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n\n同样，对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`：\n\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\n```js\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n###### 命名空间\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n启用了命名空间的 getter 和 action 会收到局部化的 `getter`，`dispatch` 和 `commit`。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 `namespaced` 属性后不需要修改模块内的代码。\n\n**在带命名空间的模块内访问全局内容**\n\n如果你希望使用全局 state 和 getter，`rootState` 和 `rootGetter` 会作为第三和第四参数传入 getter，也会通过 `context` 对象的属性传入 action。\n\n若需要在全局命名空间内分发 action 或提交 mutation，将 `{ root: true }` 作为第三参数传给 `dispatch` 或 `commit` 即可。\n\n```js\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n**在带命名空间的模块注册全局action**\n\n若需要在带命名空间的模块注册全局 action，你可添加 `root: true`，并将这个 action 的定义放在函数 `handler` 中。例如：\n\n```js\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n**带命名空间的绑定函数**\n\n当使用 `mapState`, `mapGetters`, `mapActions` 和 `mapMutations` 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：\n\n```js\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n\n对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：\n\n```js\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n\n而且，你可以通过使用 `createNamespacedHelpers` 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：\n\n```js\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```\n\n###### 模块重用\n\n有时我们可能需要创建一个模块的多个实例，例如：\n\n- 创建多个 store，他们公用同一个模块 (例如当 `runInNewContext` 选项是 `false` 或 `'once'` 时，为了[在服务端渲染中避免有状态的单例](https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons))\n- 在一个 store 中多次注册同一个模块\n\n如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。\n\n实际上这和 Vue 组件内的 `data` 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：\n\n```js\nconst MyReusableModule = {\n  state () {\n    return {\n      foo: 'bar'\n    }\n  },\n  // mutation, action 和 getter 等等...\n}\n```\n\n###### 项目结构\n\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n\n```shell\n├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n```\n\n##### 原理\n\n![](Vuex/ef5b88bd404de9f080415eceb994a780.png)","source":"_posts/Vuex.md","raw":"---\ntitle: Vuex\ndate: 2018-12-09 12:16:43\ntags: Vue\ncategories: 前端\n---\n\n### vuex\n\n> 使用 Vuex 并不意味着你需要将**所有的**状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。\n\n> 每一个应用的核心就是store（仓库）。\"store\"基本上就是一个容器，它包含着应用中的大部分状态（state）。\n>\n> 1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n> 2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n安装：\n\n```js\nnpm install vuex --save\n```\n\n使用：\n\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(Vuex);\n```\n\n##### State\n\n初始化创建一个store：\n\n```js\nconst store = new Vuex.store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state){\n          state.count++   \n        }\n    }\n})\n```\n\n触发状态state变更\n\n```js\nstore.commit('increment');\n```\n\n###### 在模块化开发模式中使用\n\nVuex通过`store`选项，提供了一种机制将状态从跟组件注入到每一个子组件（需要调用Vue.use(Vuex)）:\n\n```js\nnew Vue({\n    el: '#app',\n    // 把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件中\n    store,\n    router,\n    components: { APP },\n    template: '<App/>'\n})\n```\n\n> 由于Vuex的状态存储是响应式的，从`store`实例中读取状态最简单的方法就是在计算属性中返回某个状态。\n\n```js\n<template>\n  <div>\n    <h1>{{ msg }}{{ count }}</h1>\n    <button @click=\"increment\">add</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'HelloWorld',\n  data () {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  },\n  computed: {\n    count () {// 通过在根实例中注册store选项，且子组件中能够通过this.$store访问到。\n      return this.$store.state.count\n    }\n  },\n  methods: {\n    increment () {\n      this.$store.commit('increment');\n    }\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n</style>\n```\n\n###### mapState辅助函数\n\n当一个组件需要获取多个状态时，将这些状态都声明为计算属性显得有些多余，为了解决这个问题，我们可以使用`mapState`辅助函数来帮助我们生成计算属性。\n\n在使用之前需要先导入：\n\n```js\nimport { mapState } from 'vuex'\n```\n\n接下来就是使用：\n\n```js\nexport default {\n    // ...\n    data () {\n        return {\n            str: '年龄'\n        }\n    }\n    computed: mapState({\n        count: 'count', //第一种写法\n        sex: state => state.sex, //第二种写法\n        age (state) { //如果想要使用this,必须使用常规函数才能获取\n            return this.str + ':' + state.age  //this指向vue实例\n        }\n    })\n}\n```\n\n##### Getter\n\n有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n\n如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 接受 state 作为其第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n我们可以很容易地在任何组件中使用它：\n\n```js\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount //doneTodosCount是与store中的gettters中的类似方法名的函数对应\n  }\n}\n```\n\n注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\n\n```js\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n\n注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n\n###### mapGetters辅助函数\n\n辅助方法仅仅是将store中的getter映射到局部计算属性，与mapState类似：\n\n```js\n<div>{{ doneTodos }}</div> <!-- 使用getters属性进行数据处理 -->\n<div>{{ count }}</div>\ncomputed: {\n    ...mapState(['count', 'todos']),\n    ...mapGetters(['doneTodos'])\n},\n```\n\n##### Mutation\n\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 `increment` 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 **store.commit** 方法：\n\n```js\nstore.commit('increment')\n```\n\n###### 提交载荷（Payload）\n\n你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：\n\n```js\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit('increment', 10)\n```\n\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：\n\n```js\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n###### 对象风格的提交方式\n\n提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：\n\n```js\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n\n```js\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n###### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。\n\n###### Mutation必须是同步函数\n\n一条重要的原则就是要记住 **mutation 必须是同步函数**。为什么？请参考下面的例子：\n\n```js\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n\n现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n###### 在组件中提交Mutation\n\n你可以在组件中使用 `this.$store.commit('xxx')` 提交 mutation，或者使用 `mapMutations` 辅助函数将组件中的 methods 映射为 `store.commit` 调用（需要在根节点注入 `store`）。\n\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n**mutation 都是同步事务**：\n\n```js\nstore.commit('increment')\n// 任何由 \"increment\" 导致的状态变更都应该在此刻完成。\n```\n\n##### Action\n\nAction 类似于 mutation，不同在于：\n\n- Action 提交的是 mutation，而不是直接变更状态。\n- Action 可以包含任意异步操作。\n\n让我们来注册一个简单的 action：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。当我们在之后介绍到 [Modules](https://vuex.vuejs.org/zh/guide/modules.html) 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n实践中，我们会经常用到 ES2015 的 [参数解构](https://github.com/lukehoban/es6features#destructuring) 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：\n\n```js\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n###### 分发action\n\nAction 通过 `store.dispatch` 方法触发：\n\n```js\nstore.dispatch('increment')\n```\n\n乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 **mutation 必须同步执行**这个限制么？Action 就不受约束！我们可以在 action 内部执行**异步**操作：\n\n```js\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n\nActions 支持同样的载荷方式和对象方式进行分发：\n\n```js\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n\n###### 在组件中分发action\n\n你在组件中使用 `this.$store.dispatch('xxx')` 分发 action，或者使用 `mapActions` 辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 `store`）：\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n###### 组合action\n\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n首先，你需要明白 `store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，并且 `store.dispatch` 仍旧返回 Promise：\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n\n现在你可以：\n\n```js\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n在另外一个 action 中也可以：\n\n```js\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n最后，如果我们利用 [async / await](https://tc39.github.io/ecmascript-asyncawait/)，我们可以如下组合 action：\n\n```js\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n##### Module\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n###### 模块的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是**模块的局部状态对象**。\n\n```js\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n\n同样，对于模块内部的 action，局部状态通过 `context.state` 暴露出来，根节点状态则为 `context.rootState`：\n\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\n```js\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n###### 命名空间\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n启用了命名空间的 getter 和 action 会收到局部化的 `getter`，`dispatch` 和 `commit`。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 `namespaced` 属性后不需要修改模块内的代码。\n\n**在带命名空间的模块内访问全局内容**\n\n如果你希望使用全局 state 和 getter，`rootState` 和 `rootGetter` 会作为第三和第四参数传入 getter，也会通过 `context` 对象的属性传入 action。\n\n若需要在全局命名空间内分发 action 或提交 mutation，将 `{ root: true }` 作为第三参数传给 `dispatch` 或 `commit` 即可。\n\n```js\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n**在带命名空间的模块注册全局action**\n\n若需要在带命名空间的模块注册全局 action，你可添加 `root: true`，并将这个 action 的定义放在函数 `handler` 中。例如：\n\n```js\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n**带命名空间的绑定函数**\n\n当使用 `mapState`, `mapGetters`, `mapActions` 和 `mapMutations` 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：\n\n```js\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n\n对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：\n\n```js\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n\n而且，你可以通过使用 `createNamespacedHelpers` 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：\n\n```js\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```\n\n###### 模块重用\n\n有时我们可能需要创建一个模块的多个实例，例如：\n\n- 创建多个 store，他们公用同一个模块 (例如当 `runInNewContext` 选项是 `false` 或 `'once'` 时，为了[在服务端渲染中避免有状态的单例](https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons))\n- 在一个 store 中多次注册同一个模块\n\n如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。\n\n实际上这和 Vue 组件内的 `data` 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：\n\n```js\nconst MyReusableModule = {\n  state () {\n    return {\n      foo: 'bar'\n    }\n  },\n  // mutation, action 和 getter 等等...\n}\n```\n\n###### 项目结构\n\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n\n```shell\n├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n```\n\n##### 原理\n\n![](Vuex/ef5b88bd404de9f080415eceb994a780.png)","slug":"Vuex","published":1,"updated":"2024-02-19T07:42:51.568Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9f00181xopfly9gs17","content":"<h3 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h3><blockquote>\n<p>使用 Vuex 并不意味着你需要将<strong>所有的</strong>状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>\n</blockquote>\n<blockquote>\n<p>每一个应用的核心就是store（仓库）。”store”基本上就是一个容器，它包含着应用中的大部分状态（state）。</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n</blockquote>\n<p>安装：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">npm install vuex <span class=\"token operator\">--</span>save\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span>\n<span class=\"token keyword\">import</span> Vuex <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Vuex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h5><p>初始化创建一个store：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>   \n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>触发状态state变更</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h6 id=\"在模块化开发模式中使用\"><a href=\"#在模块化开发模式中使用\" class=\"headerlink\" title=\"在模块化开发模式中使用\"></a>在模块化开发模式中使用</h6><p>Vuex通过<code>store</code>选项，提供了一种机制将状态从跟组件注入到每一个子组件（需要调用Vue.use(Vuex)）:</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    el<span class=\"token punctuation\">:</span> <span class=\"token string\">'#app'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件中</span>\n    store<span class=\"token punctuation\">,</span>\n    router<span class=\"token punctuation\">,</span>\n    components<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> APP <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;App/>'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>由于Vuex的状态存储是响应式的，从<code>store</code>实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>template<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> msg <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> count <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>button @click<span class=\"token operator\">=</span><span class=\"token string\">\"increment\"</span><span class=\"token operator\">></span>add<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>template<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span>script<span class=\"token operator\">></span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'HelloWorld'</span><span class=\"token punctuation\">,</span>\n  data <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      msg<span class=\"token punctuation\">:</span> <span class=\"token string\">'Welcome to Your Vue.js App'</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">// 通过在根实例中注册store选项，且子组件中能够通过this.$store访问到。</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> Add <span class=\"token string\">\"scoped\"</span> attribute to limit CSS to <span class=\"token keyword\">this</span> component only <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>style scoped<span class=\"token operator\">></span>\n\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>style<span class=\"token operator\">></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h6><p>当一个组件需要获取多个状态时，将这些状态都声明为计算属性显得有些多余，为了解决这个问题，我们可以使用<code>mapState</code>辅助函数来帮助我们生成计算属性。</p>\n<p>在使用之前需要先导入：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapState <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>接下来就是使用：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    data <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n            str<span class=\"token punctuation\">:</span> <span class=\"token string\">'年龄'</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    computed<span class=\"token punctuation\">:</span> <span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        count<span class=\"token punctuation\">:</span> <span class=\"token string\">'count'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//第一种写法</span>\n        sex<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>sex<span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//第二种写法</span>\n        age <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//如果想要使用this,必须使用常规函数才能获取</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>str <span class=\"token operator\">+</span> <span class=\"token string\">':'</span> <span class=\"token operator\">+</span> state<span class=\"token punctuation\">.</span>age  <span class=\"token comment\" spellcheck=\"true\">//this指向vue实例</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h5><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  doneTodosCount <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=</span><span class=\"token operator\">></span> todo<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>Getter 接受 state 作为其第一个参数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    todos<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">{</span> id<span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span> done<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    doneTodos<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=</span><span class=\"token operator\">></span> todo<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以很容易地在任何组件中使用它：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  doneTodosCount <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span>doneTodosCount <span class=\"token comment\" spellcheck=\"true\">//doneTodosCount是与store中的gettters中的类似方法名的函数对应</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  getTodoById<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>todo <span class=\"token operator\">=</span><span class=\"token operator\">></span> todo<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nstore<span class=\"token punctuation\">.</span>getters<span class=\"token punctuation\">.</span><span class=\"token function\">getTodoById</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> { id: 2, text: '...', done: false }</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<h6 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h6><p>辅助方法仅仅是将store中的getter映射到局部计算属性，与mapState类似：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> doneTodos <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 使用getters属性进行数据处理 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> count <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\ncomputed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'count'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'todos'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapGetters</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'doneTodos'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h5><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 变更状态</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h6 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h6><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\nmutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> n\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// ...</span>\nmutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>amount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"对象风格的提交方式\"><a href=\"#对象风格的提交方式\" class=\"headerlink\" title=\"对象风格的提交方式\"></a>对象风格的提交方式</h6><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span><span class=\"token operator\">=</span> payload<span class=\"token punctuation\">.</span>amount\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h6><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// mutation-types.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> SOME_MUTATION <span class=\"token operator\">=</span> <span class=\"token string\">'SOME_MUTATION'</span>\n<span class=\"token comment\" spellcheck=\"true\">// store.js</span>\n<span class=\"token keyword\">import</span> Vuex <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> SOME_MUTATION <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./mutation-types'</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>\n    <span class=\"token punctuation\">[</span>SOME_MUTATION<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// mutate state</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>\n<h6 id=\"Mutation必须是同步函数\"><a href=\"#Mutation必须是同步函数\" class=\"headerlink\" title=\"Mutation必须是同步函数\"></a>Mutation必须是同步函数</h6><p>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong>。为什么？请参考下面的例子：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  someMutation <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    api<span class=\"token punctuation\">.</span><span class=\"token function\">callAsyncMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h6 id=\"在组件中提交Mutation\"><a href=\"#在组件中提交Mutation\" class=\"headerlink\" title=\"在组件中提交Mutation\"></a>在组件中提交Mutation</h6><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapMutations <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapMutations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// `mapMutations` 也支持载荷：</span>\n      <span class=\"token string\">'incrementBy'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapMutations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      add<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>mutation 都是同步事务</strong>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// 任何由 \"increment\" 导致的状态变更都应该在此刻完成。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h5 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h5><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n</ul>\n<p>让我们来注册一个简单的 action：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      context<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <a href=\"https://vuex.vuejs.org/zh/guide/modules.html\" target=\"_blank\" rel=\"noopener\">Modules</a> 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<p>实践中，我们会经常用到 ES2015 的 <a href=\"https://github.com/lukehoban/es6features#destructuring\" target=\"_blank\" rel=\"noopener\">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  increment <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"分发action\"><a href=\"#分发action\" class=\"headerlink\" title=\"分发action\"></a>分发action</h6><p>Action 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 <strong>mutation 必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  incrementAsync <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 以载荷形式分发</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'incrementAsync'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 以对象形式分发</span>\nstore<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token punctuation\">:</span> <span class=\"token string\">'incrementAsync'</span><span class=\"token punctuation\">,</span>\n  amount<span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"在组件中分发action\"><a href=\"#在组件中分发action\" class=\"headerlink\" title=\"在组件中分发action\"></a>在组件中分发action</h6><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> mapActions <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'increment'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// `mapActions` 也支持载荷：</span>\n      <span class=\"token string\">'incrementBy'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      add<span class=\"token punctuation\">:</span> <span class=\"token string\">'increment'</span> <span class=\"token comment\" spellcheck=\"true\">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"组合action\"><a href=\"#组合action\" class=\"headerlink\" title=\"组合action\"></a>组合action</h6><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  actionA <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someMutation'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在你可以：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">store<span class=\"token punctuation\">.</span><span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>在另外一个 action 中也可以：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  actionB <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someOtherMutation'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最后，如果我们利用 <a href=\"https://tc39.github.io/ecmascript-asyncawait/\" target=\"_blank\" rel=\"noopener\">async / await</a>，我们可以如下组合 action：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 假设 getData() 和 getOtherData() 返回的是 Promise</span>\n\nactions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">async</span> actionA <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'gotData'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">async</span> actionB <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'actionA'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 等待 actionA 完成</span>\n    <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'gotOtherData'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getOtherData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h5><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> moduleB <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> moduleA<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> moduleB\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>a <span class=\"token comment\" spellcheck=\"true\">// -> moduleA 的状态</span>\nstore<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>b <span class=\"token comment\" spellcheck=\"true\">// -> moduleB 的状态</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h6><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> count<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    increment <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 这里的 `state` 对象是模块的局部状态</span>\n      state<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    doubleCount <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    incrementIfOddOnRootSum <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> state<span class=\"token punctuation\">,</span> commit<span class=\"token punctuation\">,</span> rootState <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> rootState<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'increment'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> moduleA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n  getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    sumWithRootCount <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> getters<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> rootState<span class=\"token punctuation\">.</span>count\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h6><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> store <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vuex<span class=\"token punctuation\">.</span>Store</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    account<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 模块内容（module assets）</span>\n      state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>\n      getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        isAdmin <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/isAdmin']</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        login <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> dispatch('account/login')</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      mutations<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        login <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> commit('account/login')</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// 嵌套模块</span>\n      modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 继承父模块的命名空间</span>\n        myPage<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            profile <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/profile']</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 进一步嵌套命名空间</span>\n        posts<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n          state<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n          getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            popular <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> getters['account/posts/popular']</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>\n<p><strong>在带命名空间的模块内访问全局内容</strong></p>\n<p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetter</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p>\n<p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  foo<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n    getters<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 在这个模块的 getter 中，`getters` 被局部化了</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>\n      someGetter <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> getters<span class=\"token punctuation\">,</span> rootState<span class=\"token punctuation\">,</span> rootGetters<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        getters<span class=\"token punctuation\">.</span>someOtherGetter <span class=\"token comment\" spellcheck=\"true\">// -> 'foo/someOtherGetter'</span>\n        rootGetters<span class=\"token punctuation\">.</span>someOtherGetter <span class=\"token comment\" spellcheck=\"true\">// -> 'someOtherGetter'</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      someOtherGetter<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n    actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 在这个模块中， dispatch 和 commit 也被局部化了</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>\n      someAction <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> dispatch<span class=\"token punctuation\">,</span> commit<span class=\"token punctuation\">,</span> getters<span class=\"token punctuation\">,</span> rootGetters <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        getters<span class=\"token punctuation\">.</span>someGetter <span class=\"token comment\" spellcheck=\"true\">// -> 'foo/someGetter'</span>\n        rootGetters<span class=\"token punctuation\">.</span>someGetter <span class=\"token comment\" spellcheck=\"true\">// -> 'someGetter'</span>\n\n        <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someOtherAction'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> 'foo/someOtherAction'</span>\n        <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someOtherAction'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> root<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> 'someOtherAction'</span>\n\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someMutation'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> 'foo/someMutation'</span>\n        <span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someMutation'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> root<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -> 'someMutation'</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      someOtherAction <span class=\"token punctuation\">(</span>ctx<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>在带命名空间的模块注册全局action</strong></p>\n<p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 <code>handler</code> 中。例如：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    someOtherAction <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>dispatch<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'someAction'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  modules<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      namespaced<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n\n      actions<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        someAction<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n          root<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n          handler <span class=\"token punctuation\">(</span>namespacedContext<span class=\"token punctuation\">,</span> payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// -> 'someAction'</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>带命名空间的绑定函数</strong></p>\n<p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>some<span class=\"token punctuation\">.</span>nested<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>some<span class=\"token punctuation\">.</span>nested<span class=\"token punctuation\">.</span>module<span class=\"token punctuation\">.</span>b\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\nmethods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'some/nested/module/foo'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// -> this['some/nested/module/foo']()</span>\n    <span class=\"token string\">'some/nested/module/bar'</span> <span class=\"token comment\" spellcheck=\"true\">// -> this['some/nested/module/bar']()</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some/nested/module'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    a<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>b\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\nmethods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some/nested/module'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">// -> this.foo()</span>\n    <span class=\"token string\">'bar'</span> <span class=\"token comment\" spellcheck=\"true\">// -> this.bar()</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>而且，你可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> createNamespacedHelpers <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'vuex'</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> mapState<span class=\"token punctuation\">,</span> mapActions <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">createNamespacedHelpers</span><span class=\"token punctuation\">(</span><span class=\"token string\">'some/nested/module'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在 `some/nested/module` 中查找</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      a<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">,</span>\n      b<span class=\"token punctuation\">:</span> state <span class=\"token operator\">=</span><span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>b\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  methods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 在 `some/nested/module` 中查找</span>\n    <span class=\"token operator\">...</span><span class=\"token function\">mapActions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'bar'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"模块重用\"><a href=\"#模块重用\" class=\"headerlink\" title=\"模块重用\"></a>模块重用</h6><p>有时我们可能需要创建一个模块的多个实例，例如：</p>\n<ul>\n<li>创建多个 store，他们公用同一个模块 (例如当 <code>runInNewContext</code> 选项是 <code>false</code> 或 <code>&#39;once&#39;</code> 时，为了<a href=\"https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons\" target=\"_blank\" rel=\"noopener\">在服务端渲染中避免有状态的单例</a>)</li>\n<li>在一个 store 中多次注册同一个模块</li>\n</ul>\n<p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p>\n<p>实际上这和 Vue 组件内的 <code>data</code> 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> MyReusableModule <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      foo<span class=\"token punctuation\">:</span> <span class=\"token string\">'bar'</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\" spellcheck=\"true\">// mutation, action 和 getter 等等...</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h6><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>\n<ol>\n<li>应用层级的状态应该集中到单个 store 对象中。</li>\n<li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li>\n<li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li>\n</ol>\n<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p>\n<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h5><p><img src=\"/2018/12/09/Vuex/ef5b88bd404de9f080415eceb994a780.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vuex\"><a href=\"#vuex\" class=\"headerlink\" title=\"vuex\"></a>vuex</h3><blockquote>\n<p>使用 Vuex 并不意味着你需要将<strong>所有的</strong>状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>\n</blockquote>\n<blockquote>\n<p>每一个应用的核心就是store（仓库）。”store”基本上就是一个容器，它包含着应用中的大部分状态（state）。</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n</blockquote>\n<p>安装：</p>\n<pre><code class=\"js\">npm install vuex --save\n</code></pre>\n<p>使用：</p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nVue.use(Vuex);\n</code></pre>\n<h5 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h5><p>初始化创建一个store：</p>\n<pre><code class=\"js\">const store = new Vuex.store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state){\n          state.count++   \n        }\n    }\n})\n</code></pre>\n<p>触发状态state变更</p>\n<pre><code class=\"js\">store.commit(&#39;increment&#39;);\n</code></pre>\n<h6 id=\"在模块化开发模式中使用\"><a href=\"#在模块化开发模式中使用\" class=\"headerlink\" title=\"在模块化开发模式中使用\"></a>在模块化开发模式中使用</h6><p>Vuex通过<code>store</code>选项，提供了一种机制将状态从跟组件注入到每一个子组件（需要调用Vue.use(Vuex)）:</p>\n<pre><code class=\"js\">new Vue({\n    el: &#39;#app&#39;,\n    // 把store对象提供给“store”选项，这可以把store的实例注入到所有的子组件中\n    store,\n    router,\n    components: { APP },\n    template: &#39;&lt;App/&gt;&#39;\n})\n</code></pre>\n<blockquote>\n<p>由于Vuex的状态存储是响应式的，从<code>store</code>实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p>\n</blockquote>\n<pre><code class=\"js\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;h1&gt;{{ msg }}{{ count }}&lt;/h1&gt;\n    &lt;button @click=&quot;increment&quot;&gt;add&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  name: &#39;HelloWorld&#39;,\n  data () {\n    return {\n      msg: &#39;Welcome to Your Vue.js App&#39;\n    }\n  },\n  computed: {\n    count () {// 通过在根实例中注册store选项，且子组件中能够通过this.$store访问到。\n      return this.$store.state.count\n    }\n  },\n  methods: {\n    increment () {\n      this.$store.commit(&#39;increment&#39;);\n    }\n  }\n}\n&lt;/script&gt;\n\n&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n</code></pre>\n<h6 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h6><p>当一个组件需要获取多个状态时，将这些状态都声明为计算属性显得有些多余，为了解决这个问题，我们可以使用<code>mapState</code>辅助函数来帮助我们生成计算属性。</p>\n<p>在使用之前需要先导入：</p>\n<pre><code class=\"js\">import { mapState } from &#39;vuex&#39;\n</code></pre>\n<p>接下来就是使用：</p>\n<pre><code class=\"js\">export default {\n    // ...\n    data () {\n        return {\n            str: &#39;年龄&#39;\n        }\n    }\n    computed: mapState({\n        count: &#39;count&#39;, //第一种写法\n        sex: state =&gt; state.sex, //第二种写法\n        age (state) { //如果想要使用this,必须使用常规函数才能获取\n            return this.str + &#39;:&#39; + state.age  //this指向vue实例\n        }\n    })\n}\n</code></pre>\n<h5 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h5><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre><code class=\"js\">computed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo =&gt; todo.done).length\n  }\n}\n</code></pre>\n<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>Getter 接受 state 作为其第一个参数：</p>\n<pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n</code></pre>\n<p>我们可以很容易地在任何组件中使用它：</p>\n<pre><code class=\"js\">computed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount //doneTodosCount是与store中的gettters中的类似方法名的函数对应\n  }\n}\n</code></pre>\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<pre><code class=\"js\">getters: {\n  // ...\n  getTodoById: (state) =&gt; (id) =&gt; {\n    return state.todos.find(todo =&gt; todo.id === id)\n  }\n}\nstore.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }\n</code></pre>\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<h6 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h6><p>辅助方法仅仅是将store中的getter映射到局部计算属性，与mapState类似：</p>\n<pre><code class=\"js\">&lt;div&gt;{{ doneTodos }}&lt;/div&gt; &lt;!-- 使用getters属性进行数据处理 --&gt;\n&lt;div&gt;{{ count }}&lt;/div&gt;\ncomputed: {\n    ...mapState([&#39;count&#39;, &#39;todos&#39;]),\n    ...mapGetters([&#39;doneTodos&#39;])\n},\n</code></pre>\n<h5 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h5><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n</code></pre>\n<p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <strong>store.commit</strong> 方法：</p>\n<pre><code class=\"js\">store.commit(&#39;increment&#39;)\n</code></pre>\n<h6 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h6><p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre><code class=\"js\">// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\nstore.commit(&#39;increment&#39;, 10)\n</code></pre>\n<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre><code class=\"js\">// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\nstore.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre>\n<h6 id=\"对象风格的提交方式\"><a href=\"#对象风格的提交方式\" class=\"headerlink\" title=\"对象风格的提交方式\"></a>对象风格的提交方式</h6><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>\n<pre><code class=\"js\">store.commit({\n  type: &#39;increment&#39;,\n  amount: 10\n})\n</code></pre>\n<p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>\n<pre><code class=\"js\">mutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre>\n<h6 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h6><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<pre><code class=\"js\">// mutation-types.js\nexport const SOME_MUTATION = &#39;SOME_MUTATION&#39;\n// store.js\nimport Vuex from &#39;vuex&#39;\nimport { SOME_MUTATION } from &#39;./mutation-types&#39;\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n</code></pre>\n<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>\n<h6 id=\"Mutation必须是同步函数\"><a href=\"#Mutation必须是同步函数\" class=\"headerlink\" title=\"Mutation必须是同步函数\"></a>Mutation必须是同步函数</h6><p>一条重要的原则就是要记住 <strong>mutation 必须是同步函数</strong>。为什么？请参考下面的例子：</p>\n<pre><code class=\"js\">mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() =&gt; {\n      state.count++\n    })\n  }\n}\n</code></pre>\n<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h6 id=\"在组件中提交Mutation\"><a href=\"#在组件中提交Mutation\" class=\"headerlink\" title=\"在组件中提交Mutation\"></a>在组件中提交Mutation</h6><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>\n<pre><code class=\"js\">import { mapMutations } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n\n      // `mapMutations` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapMutations({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre>\n<p><strong>mutation 都是同步事务</strong>：</p>\n<pre><code class=\"js\">store.commit(&#39;increment&#39;)\n// 任何由 &quot;increment&quot; 导致的状态变更都应该在此刻完成。\n</code></pre>\n<h5 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h5><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n</ul>\n<p>让我们来注册一个简单的 action：</p>\n<pre><code class=\"js\">const store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit(&#39;increment&#39;)\n    }\n  }\n})\n</code></pre>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <a href=\"https://vuex.vuejs.org/zh/guide/modules.html\" target=\"_blank\" rel=\"noopener\">Modules</a> 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<p>实践中，我们会经常用到 ES2015 的 <a href=\"https://github.com/lukehoban/es6features#destructuring\" target=\"_blank\" rel=\"noopener\">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre><code class=\"js\">actions: {\n  increment ({ commit }) {\n    commit(&#39;increment&#39;)\n  }\n}\n</code></pre>\n<h6 id=\"分发action\"><a href=\"#分发action\" class=\"headerlink\" title=\"分发action\"></a>分发action</h6><p>Action 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre><code class=\"js\">store.dispatch(&#39;increment&#39;)\n</code></pre>\n<p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 <strong>mutation 必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p>\n<pre><code class=\"js\">actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() =&gt; {\n      commit(&#39;increment&#39;)\n    }, 1000)\n  }\n}\n</code></pre>\n<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<pre><code class=\"js\">// 以载荷形式分发\nstore.dispatch(&#39;incrementAsync&#39;, {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: &#39;incrementAsync&#39;,\n  amount: 10\n})\n</code></pre>\n<h6 id=\"在组件中分发action\"><a href=\"#在组件中分发action\" class=\"headerlink\" title=\"在组件中分发action\"></a>在组件中分发action</h6><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>\n<pre><code class=\"js\">import { mapActions } from &#39;vuex&#39;\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n\n      // `mapActions` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapActions({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre>\n<h6 id=\"组合action\"><a href=\"#组合action\" class=\"headerlink\" title=\"组合action\"></a>组合action</h6><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<pre><code class=\"js\">actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        commit(&#39;someMutation&#39;)\n        resolve()\n      }, 1000)\n    })\n  }\n}\n</code></pre>\n<p>现在你可以：</p>\n<pre><code class=\"js\">store.dispatch(&#39;actionA&#39;).then(() =&gt; {\n  // ...\n})\n</code></pre>\n<p>在另外一个 action 中也可以：</p>\n<pre><code class=\"js\">actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch(&#39;actionA&#39;).then(() =&gt; {\n      commit(&#39;someOtherMutation&#39;)\n    })\n  }\n}\n</code></pre>\n<p>最后，如果我们利用 <a href=\"https://tc39.github.io/ecmascript-asyncawait/\" target=\"_blank\" rel=\"noopener\">async / await</a>，我们可以如下组合 action：</p>\n<pre><code class=\"js\">// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit(&#39;gotData&#39;, await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成\n    commit(&#39;gotOtherData&#39;, await getOtherData())\n  }\n}\n</code></pre>\n<h5 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h5><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre><code class=\"js\">const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre>\n<h6 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h6><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p>\n<pre><code class=\"js\">const moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n</code></pre>\n<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre><code class=\"js\">const moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit(&#39;increment&#39;)\n      }\n    }\n  }\n}\n</code></pre>\n<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre><code class=\"js\">const moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n</code></pre>\n<h6 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h6><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre><code class=\"js\">const store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -&gt; getters[&#39;account/isAdmin&#39;]\n      },\n      actions: {\n        login () { ... } // -&gt; dispatch(&#39;account/login&#39;)\n      },\n      mutations: {\n        login () { ... } // -&gt; commit(&#39;account/login&#39;)\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -&gt; getters[&#39;account/profile&#39;]\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -&gt; getters[&#39;account/posts/popular&#39;]\n          }\n        }\n      }\n    }\n  }\n})\n</code></pre>\n<p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>\n<p><strong>在带命名空间的模块内访问全局内容</strong></p>\n<p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetter</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p>\n<p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p>\n<pre><code class=\"js\">modules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -&gt; &#39;foo/someOtherGetter&#39;\n        rootGetters.someOtherGetter // -&gt; &#39;someOtherGetter&#39;\n      },\n      someOtherGetter: state =&gt; { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -&gt; &#39;foo/someGetter&#39;\n        rootGetters.someGetter // -&gt; &#39;someGetter&#39;\n\n        dispatch(&#39;someOtherAction&#39;) // -&gt; &#39;foo/someOtherAction&#39;\n        dispatch(&#39;someOtherAction&#39;, null, { root: true }) // -&gt; &#39;someOtherAction&#39;\n\n        commit(&#39;someMutation&#39;) // -&gt; &#39;foo/someMutation&#39;\n        commit(&#39;someMutation&#39;, null, { root: true }) // -&gt; &#39;someMutation&#39;\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n</code></pre>\n<p><strong>在带命名空间的模块注册全局action</strong></p>\n<p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 <code>handler</code> 中。例如：</p>\n<pre><code class=\"js\">{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch(&#39;someAction&#39;)\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -&gt; &#39;someAction&#39;\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p><strong>带命名空间的绑定函数</strong></p>\n<p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre><code class=\"js\">computed: {\n  ...mapState({\n    a: state =&gt; state.some.nested.module.a,\n    b: state =&gt; state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    &#39;some/nested/module/foo&#39;, // -&gt; this[&#39;some/nested/module/foo&#39;]()\n    &#39;some/nested/module/bar&#39; // -&gt; this[&#39;some/nested/module/bar&#39;]()\n  ])\n}\n</code></pre>\n<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre><code class=\"js\">computed: {\n  ...mapState(&#39;some/nested/module&#39;, {\n    a: state =&gt; state.a,\n    b: state =&gt; state.b\n  })\n},\nmethods: {\n  ...mapActions(&#39;some/nested/module&#39;, [\n    &#39;foo&#39;, // -&gt; this.foo()\n    &#39;bar&#39; // -&gt; this.bar()\n  ])\n}\n</code></pre>\n<p>而且，你可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre><code class=\"js\">import { createNamespacedHelpers } from &#39;vuex&#39;\n\nconst { mapState, mapActions } = createNamespacedHelpers(&#39;some/nested/module&#39;)\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state =&gt; state.a,\n      b: state =&gt; state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      &#39;foo&#39;,\n      &#39;bar&#39;\n    ])\n  }\n}\n</code></pre>\n<h6 id=\"模块重用\"><a href=\"#模块重用\" class=\"headerlink\" title=\"模块重用\"></a>模块重用</h6><p>有时我们可能需要创建一个模块的多个实例，例如：</p>\n<ul>\n<li>创建多个 store，他们公用同一个模块 (例如当 <code>runInNewContext</code> 选项是 <code>false</code> 或 <code>&#39;once&#39;</code> 时，为了<a href=\"https://ssr.vuejs.org/en/structure.html#avoid-stateful-singletons\" target=\"_blank\" rel=\"noopener\">在服务端渲染中避免有状态的单例</a>)</li>\n<li>在一个 store 中多次注册同一个模块</li>\n</ul>\n<p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。</p>\n<p>实际上这和 Vue 组件内的 <code>data</code> 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p>\n<pre><code class=\"js\">const MyReusableModule = {\n  state () {\n    return {\n      foo: &#39;bar&#39;\n    }\n  },\n  // mutation, action 和 getter 等等...\n}\n</code></pre>\n<h6 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h6><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>\n<ol>\n<li>应用层级的状态应该集中到单个 store 对象中。</li>\n<li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li>\n<li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li>\n</ol>\n<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p>\n<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>\n<pre><code class=\"shell\">├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n</code></pre>\n<h5 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h5><p><img src=\"/2018/12/09/Vuex/ef5b88bd404de9f080415eceb994a780.png\" alt></p>\n"},{"title":"Vue与React异同","date":"2019-04-28T04:34:49.000Z","_content":"\n### vue与React异同\n\n##### 相同点\n\n1. 都有组件化开发和Virtual DOM\n2. 都支持props进行父子组件间数据通信\n3. 都支持数据驱动视图，不直接操作真实DOM，更新状态数据界面就自动更新\n4. 都支持服务器端渲染\n5. 都有支持native的方案，React的React Native，Vue的Weex\n\n##### 不同点\n\n1. 数据绑定：vue实现了数据的双向绑定，react数据流是单向的\n2. 组件的写法不一样，React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript了，即'all in js'；vue推荐的做法是webpack+vue+loader的单文件组件格式，即html,css,js写在同一个文件\n3. state对象在react应用中不可变的，需要使用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue\u0001对象中管理\n4. virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对与React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制\n5. React严格上只针对MVC的view层，Vue则是MVVM模式","source":"_posts/Vue与React异同.md","raw":"---\ntitle: Vue与React异同\ndate: 2019-04-28 12:34:49\ntags: Vue\ncategories: 前端\n---\n\n### vue与React异同\n\n##### 相同点\n\n1. 都有组件化开发和Virtual DOM\n2. 都支持props进行父子组件间数据通信\n3. 都支持数据驱动视图，不直接操作真实DOM，更新状态数据界面就自动更新\n4. 都支持服务器端渲染\n5. 都有支持native的方案，React的React Native，Vue的Weex\n\n##### 不同点\n\n1. 数据绑定：vue实现了数据的双向绑定，react数据流是单向的\n2. 组件的写法不一样，React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript了，即'all in js'；vue推荐的做法是webpack+vue+loader的单文件组件格式，即html,css,js写在同一个文件\n3. state对象在react应用中不可变的，需要使用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue\u0001对象中管理\n4. virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对与React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制\n5. React严格上只针对MVC的view层，Vue则是MVVM模式","slug":"Vue与React异同","published":1,"updated":"2024-02-19T07:42:51.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9g001b1xop09aacfko","content":"<h3 id=\"vue与React异同\"><a href=\"#vue与React异同\" class=\"headerlink\" title=\"vue与React异同\"></a>vue与React异同</h3><h5 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h5><ol>\n<li>都有组件化开发和Virtual DOM</li>\n<li>都支持props进行父子组件间数据通信</li>\n<li>都支持数据驱动视图，不直接操作真实DOM，更新状态数据界面就自动更新</li>\n<li>都支持服务器端渲染</li>\n<li>都有支持native的方案，React的React Native，Vue的Weex</li>\n</ol>\n<h5 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h5><ol>\n<li>数据绑定：vue实现了数据的双向绑定，react数据流是单向的</li>\n<li>组件的写法不一样，React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript了，即’all in js’；vue推荐的做法是webpack+vue+loader的单文件组件格式，即html,css,js写在同一个文件</li>\n<li>state对象在react应用中不可变的，需要使用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue\u0001对象中管理</li>\n<li>virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对与React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>\n<li>React严格上只针对MVC的view层，Vue则是MVVM模式</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue与React异同\"><a href=\"#vue与React异同\" class=\"headerlink\" title=\"vue与React异同\"></a>vue与React异同</h3><h5 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h5><ol>\n<li>都有组件化开发和Virtual DOM</li>\n<li>都支持props进行父子组件间数据通信</li>\n<li>都支持数据驱动视图，不直接操作真实DOM，更新状态数据界面就自动更新</li>\n<li>都支持服务器端渲染</li>\n<li>都有支持native的方案，React的React Native，Vue的Weex</li>\n</ol>\n<h5 id=\"不同点\"><a href=\"#不同点\" class=\"headerlink\" title=\"不同点\"></a>不同点</h5><ol>\n<li>数据绑定：vue实现了数据的双向绑定，react数据流是单向的</li>\n<li>组件的写法不一样，React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript了，即’all in js’；vue推荐的做法是webpack+vue+loader的单文件组件格式，即html,css,js写在同一个文件</li>\n<li>state对象在react应用中不可变的，需要使用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue\u0001对象中管理</li>\n<li>virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对与React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li>\n<li>React严格上只针对MVC的view层，Vue则是MVVM模式</li>\n</ol>\n"},{"title":"Vue数据绑定Dep与Watcher之间的关系","date":"2019-11-29T02:54:08.000Z","_content":"\n### Vue数据绑定dep与Watcher之间的关系\n\n- ##### **Dep**\n\n  1. 实例创建时机：初始化时，给data的属性进行数据劫持时创建的。\n\n  2. 个数：与data中的属性一一对应。\n\n  3. 结构：\n\n     id: 标识\n\n     Subs: [] n个相关的watcher的容器\n\n- ##### **Watcher**\n\n  1. 实例创建的时机：初始化解析大括号表达式/一般指令时创建\n\n  2. 个数：与模板中表达式（包括一般指令单不包括事件指令）一一对应\n\n  3. 结构：\n\n     this.cb = cb; // 用于更新界面的回调\n\n     this.vm = vm; // vm\n\n     this.exp = exp; // 对应的表达式\n\n     this.depIds = {depid, dep}; //相关的n个dep的容器对象\n\n     this.value = this.get(); // 当前表达式对应的value\n\n- ##### **Dep与Watcher之间的关系**\n\n  - 多对多的关系\n\n    data属性 --> Dep -->n个Watcher（模板中有多个表达式使用了此属性： {{name}}/v-text=\"name\"）\n\n    表达式 --> Watcher --> n个Dep（多层表达式： a.b.c）\n\n  - 什么时候建立\n\n    初始化解析模板中的表达式创建Watcher对象时建立","source":"_posts/Vue数据绑定Dep与Watcher之间的关系.md","raw":"---\ntitle: Vue数据绑定Dep与Watcher之间的关系\ndate: 2019-11-29 10:54:08\ntags: Vue\ncategories: 前端\n---\n\n### Vue数据绑定dep与Watcher之间的关系\n\n- ##### **Dep**\n\n  1. 实例创建时机：初始化时，给data的属性进行数据劫持时创建的。\n\n  2. 个数：与data中的属性一一对应。\n\n  3. 结构：\n\n     id: 标识\n\n     Subs: [] n个相关的watcher的容器\n\n- ##### **Watcher**\n\n  1. 实例创建的时机：初始化解析大括号表达式/一般指令时创建\n\n  2. 个数：与模板中表达式（包括一般指令单不包括事件指令）一一对应\n\n  3. 结构：\n\n     this.cb = cb; // 用于更新界面的回调\n\n     this.vm = vm; // vm\n\n     this.exp = exp; // 对应的表达式\n\n     this.depIds = {depid, dep}; //相关的n个dep的容器对象\n\n     this.value = this.get(); // 当前表达式对应的value\n\n- ##### **Dep与Watcher之间的关系**\n\n  - 多对多的关系\n\n    data属性 --> Dep -->n个Watcher（模板中有多个表达式使用了此属性： {{name}}/v-text=\"name\"）\n\n    表达式 --> Watcher --> n个Dep（多层表达式： a.b.c）\n\n  - 什么时候建立\n\n    初始化解析模板中的表达式创建Watcher对象时建立","slug":"Vue数据绑定Dep与Watcher之间的关系","published":1,"updated":"2024-02-19T07:42:51.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9m001e1xopd5qfhqxx","content":"<h3 id=\"Vue数据绑定dep与Watcher之间的关系\"><a href=\"#Vue数据绑定dep与Watcher之间的关系\" class=\"headerlink\" title=\"Vue数据绑定dep与Watcher之间的关系\"></a>Vue数据绑定dep与Watcher之间的关系</h3><ul>\n<li><h5 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a><strong>Dep</strong></h5><ol>\n<li><p>实例创建时机：初始化时，给data的属性进行数据劫持时创建的。</p>\n</li>\n<li><p>个数：与data中的属性一一对应。</p>\n</li>\n<li><p>结构：</p>\n<p>id: 标识</p>\n<p>Subs: [] n个相关的watcher的容器</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a><strong>Watcher</strong></h5><ol>\n<li><p>实例创建的时机：初始化解析大括号表达式/一般指令时创建</p>\n</li>\n<li><p>个数：与模板中表达式（包括一般指令单不包括事件指令）一一对应</p>\n</li>\n<li><p>结构：</p>\n<p>this.cb = cb; // 用于更新界面的回调</p>\n<p>this.vm = vm; // vm</p>\n<p>this.exp = exp; // 对应的表达式</p>\n<p>this.depIds = {depid, dep}; //相关的n个dep的容器对象</p>\n<p>this.value = this.get(); // 当前表达式对应的value</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"Dep与Watcher之间的关系\"><a href=\"#Dep与Watcher之间的关系\" class=\"headerlink\" title=\"Dep与Watcher之间的关系\"></a><strong>Dep与Watcher之间的关系</strong></h5><ul>\n<li><p>多对多的关系</p>\n<p>data属性 –&gt; Dep –&gt;n个Watcher（模板中有多个表达式使用了此属性： /v-text=”name”）</p>\n<p>表达式 –&gt; Watcher –&gt; n个Dep（多层表达式： a.b.c）</p>\n</li>\n<li><p>什么时候建立</p>\n<p>初始化解析模板中的表达式创建Watcher对象时建立</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Vue数据绑定dep与Watcher之间的关系\"><a href=\"#Vue数据绑定dep与Watcher之间的关系\" class=\"headerlink\" title=\"Vue数据绑定dep与Watcher之间的关系\"></a>Vue数据绑定dep与Watcher之间的关系</h3><ul>\n<li><h5 id=\"Dep\"><a href=\"#Dep\" class=\"headerlink\" title=\"Dep\"></a><strong>Dep</strong></h5><ol>\n<li><p>实例创建时机：初始化时，给data的属性进行数据劫持时创建的。</p>\n</li>\n<li><p>个数：与data中的属性一一对应。</p>\n</li>\n<li><p>结构：</p>\n<p>id: 标识</p>\n<p>Subs: [] n个相关的watcher的容器</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"Watcher\"><a href=\"#Watcher\" class=\"headerlink\" title=\"Watcher\"></a><strong>Watcher</strong></h5><ol>\n<li><p>实例创建的时机：初始化解析大括号表达式/一般指令时创建</p>\n</li>\n<li><p>个数：与模板中表达式（包括一般指令单不包括事件指令）一一对应</p>\n</li>\n<li><p>结构：</p>\n<p>this.cb = cb; // 用于更新界面的回调</p>\n<p>this.vm = vm; // vm</p>\n<p>this.exp = exp; // 对应的表达式</p>\n<p>this.depIds = {depid, dep}; //相关的n个dep的容器对象</p>\n<p>this.value = this.get(); // 当前表达式对应的value</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"Dep与Watcher之间的关系\"><a href=\"#Dep与Watcher之间的关系\" class=\"headerlink\" title=\"Dep与Watcher之间的关系\"></a><strong>Dep与Watcher之间的关系</strong></h5><ul>\n<li><p>多对多的关系</p>\n<p>data属性 –&gt; Dep –&gt;n个Watcher（模板中有多个表达式使用了此属性： /v-text=”name”）</p>\n<p>表达式 –&gt; Watcher –&gt; n个Dep（多层表达式： a.b.c）</p>\n</li>\n<li><p>什么时候建立</p>\n<p>初始化解析模板中的表达式创建Watcher对象时建立</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"WebRtc Internals工具使用","date":"2024-02-19T05:56:05.000Z","_content":"\n> 以chrome浏览器来说明，在地址栏输入chrome://webrtc-internals/即可打开调试工具\n\n![image-20220125103700660](WebRtc Internals工具使用/image-20220125103700660.png)\n\n## Create Dump（保存日志）\n\n可以将该页面的log数据进行本地化存储，方便分享和留档。\n\n## Read Stats From（读取状态日志）\n\nWebRTC读取状态日志分为2中：\n\n- Standardized：符合W3C的新标准，基于promise模式\n- Legacy Non-Standard：废弃的google定义的旧标准，基于callback模式\n\n![截屏2022-01-25 上午10.49.46](WebRtc Internals工具使用/截屏2022-01-25 上午10.49.46.png)\n\n## GetUserMedia Requests（GetUserMedia调用日志）\n\ngetUserMedia是浏览器获取用户本地摄像头和麦克风的接口，具体使用方法：`navigator.mediaDevices.getUserMedia`。GetUserMedia Requests的Tab中可以看到近期调用这个api的记录，每调用一次就会多一条。\n\n![image-20220125110844187](WebRtc Internals工具使用/image-20220125110844187.png)\n\n## RTCPeerConnection（监控信息）\n\n除了GetUserMedia Requests，其他Tab每一个都对应一个PeerConnection对象。\n\n![image-20220125111712303](WebRtc Internals工具使用/image-20220125111712303.png)\n\n![image-20220125111731747](WebRtc Internals工具使用/image-20220125111731747.png)\n\n#### 构造PeerConnection实例的参数\n\n最上面圈起来的那块是构造PeerConnection的参数配置\n\n#### PeerConnection事件\n\n- addTrack（建立音频轨道）\n\n![image-20220125113409121](WebRtc Internals工具使用/image-20220125113409121.png)\n\n- createOffer（生成offer）\n\n  ![image-20220125113538013](WebRtc Internals工具使用/image-20220125113538013.png)\n\n- setLocalDescription（设置local sdp）\n\n  ![image-20220125143155721](WebRtc Internals工具使用/image-20220125143155721.png)\n\n- iceconnectionstatechange（ICE的连接状态发生变化）\n\n  ![image-20220125165024993](WebRtc Internals工具使用/image-20220125165024993.png)\n\n- connectionstatechange（PeerConnection的连接状态发生变化）\n\n  ![image-20220125165043733](WebRtc Internals工具使用/image-20220125165043733.png)\n\n- icecandidate（收集本地的candidate）\n\n  ![image-20220125164803760](WebRtc Internals工具使用/image-20220125164803760.png)\n\n- setRemoteDescription（设置remote sdp）\n\n  ![image-20220125162500220](WebRtc Internals工具使用/image-20220125162500220.png)\n\n- signalingstatechange（信令状态的回调）\n\n  ![image-20220125164612639](WebRtc Internals工具使用/image-20220125164612639.png)\n\n  ![image-20220125164622944](WebRtc Internals工具使用/image-20220125164622944.png)\n\n- addIceCandidate（将对端的candidate添加到PeerConnection中）\n\n  ![image-20220125163342091](WebRtc Internals工具使用/image-20220125163342091.png)\n\n- 如果出现error也可以在Event这块看到：\n\n![image-20220125162859189](WebRtc Internals工具使用/image-20220125162859189.png)\n\n## 流数据（数据格式&图表格式）\n\n流数据主要关注四行就够了（上行数据、下行数据）\n\n- inbound-rtp：下行数据，也就是从远端接收到的数据，可以分为音频和视频\n\n- outbound-rtp：上行数据，代表发送给远端的数据，可以分为音频和视频\n\n  ![image-20220125170026281](WebRtc Internals工具使用/image-20220125170026281.png)\n\n  ![image-20220125170242142](WebRtc Internals工具使用/image-20220125170242142.png)\n\n  #### 展开后可以看到\n\n  - ##### 下行数据（接收到的）\n\n    ![image-20220125171344267](WebRtc Internals工具使用/image-20220125171344267.png)\n\n    ![image-20220125172427718](WebRtc Internals工具使用/image-20220125172427718.png)\n\n    ![image-20220125171812419](WebRtc Internals工具使用/image-20220125171812419.png)\n\n    ![image-20220125172507453](WebRtc Internals工具使用/image-20220125172507453.png)\n\n  - ##### 上行数据（发送的）\n\n    ![image-20220125172252449](WebRtc Internals工具使用/image-20220125172252449.png)\n\n    ![image-20220125172315264](WebRtc Internals工具使用/image-20220125172315264.png)\n\n## 问题排查\n\n- ##### 拉流画面黑屏\n\n  需要查看video的inbound-rtp的下行数据包是否有接收到，或者帧解码是否成功。\n\n- ##### 拉流没有声音\n\n  需要查看audio的inbound-rtp接收到的数据是否存在问题","source":"_posts/WebRtc-Internals工具使用.md","raw":"---\ntitle: WebRtc Internals工具使用\ndate: 2024-02-19 13:56:05\ntags: 音视频\ncategories: 前端\n---\n\n> 以chrome浏览器来说明，在地址栏输入chrome://webrtc-internals/即可打开调试工具\n\n![image-20220125103700660](WebRtc Internals工具使用/image-20220125103700660.png)\n\n## Create Dump（保存日志）\n\n可以将该页面的log数据进行本地化存储，方便分享和留档。\n\n## Read Stats From（读取状态日志）\n\nWebRTC读取状态日志分为2中：\n\n- Standardized：符合W3C的新标准，基于promise模式\n- Legacy Non-Standard：废弃的google定义的旧标准，基于callback模式\n\n![截屏2022-01-25 上午10.49.46](WebRtc Internals工具使用/截屏2022-01-25 上午10.49.46.png)\n\n## GetUserMedia Requests（GetUserMedia调用日志）\n\ngetUserMedia是浏览器获取用户本地摄像头和麦克风的接口，具体使用方法：`navigator.mediaDevices.getUserMedia`。GetUserMedia Requests的Tab中可以看到近期调用这个api的记录，每调用一次就会多一条。\n\n![image-20220125110844187](WebRtc Internals工具使用/image-20220125110844187.png)\n\n## RTCPeerConnection（监控信息）\n\n除了GetUserMedia Requests，其他Tab每一个都对应一个PeerConnection对象。\n\n![image-20220125111712303](WebRtc Internals工具使用/image-20220125111712303.png)\n\n![image-20220125111731747](WebRtc Internals工具使用/image-20220125111731747.png)\n\n#### 构造PeerConnection实例的参数\n\n最上面圈起来的那块是构造PeerConnection的参数配置\n\n#### PeerConnection事件\n\n- addTrack（建立音频轨道）\n\n![image-20220125113409121](WebRtc Internals工具使用/image-20220125113409121.png)\n\n- createOffer（生成offer）\n\n  ![image-20220125113538013](WebRtc Internals工具使用/image-20220125113538013.png)\n\n- setLocalDescription（设置local sdp）\n\n  ![image-20220125143155721](WebRtc Internals工具使用/image-20220125143155721.png)\n\n- iceconnectionstatechange（ICE的连接状态发生变化）\n\n  ![image-20220125165024993](WebRtc Internals工具使用/image-20220125165024993.png)\n\n- connectionstatechange（PeerConnection的连接状态发生变化）\n\n  ![image-20220125165043733](WebRtc Internals工具使用/image-20220125165043733.png)\n\n- icecandidate（收集本地的candidate）\n\n  ![image-20220125164803760](WebRtc Internals工具使用/image-20220125164803760.png)\n\n- setRemoteDescription（设置remote sdp）\n\n  ![image-20220125162500220](WebRtc Internals工具使用/image-20220125162500220.png)\n\n- signalingstatechange（信令状态的回调）\n\n  ![image-20220125164612639](WebRtc Internals工具使用/image-20220125164612639.png)\n\n  ![image-20220125164622944](WebRtc Internals工具使用/image-20220125164622944.png)\n\n- addIceCandidate（将对端的candidate添加到PeerConnection中）\n\n  ![image-20220125163342091](WebRtc Internals工具使用/image-20220125163342091.png)\n\n- 如果出现error也可以在Event这块看到：\n\n![image-20220125162859189](WebRtc Internals工具使用/image-20220125162859189.png)\n\n## 流数据（数据格式&图表格式）\n\n流数据主要关注四行就够了（上行数据、下行数据）\n\n- inbound-rtp：下行数据，也就是从远端接收到的数据，可以分为音频和视频\n\n- outbound-rtp：上行数据，代表发送给远端的数据，可以分为音频和视频\n\n  ![image-20220125170026281](WebRtc Internals工具使用/image-20220125170026281.png)\n\n  ![image-20220125170242142](WebRtc Internals工具使用/image-20220125170242142.png)\n\n  #### 展开后可以看到\n\n  - ##### 下行数据（接收到的）\n\n    ![image-20220125171344267](WebRtc Internals工具使用/image-20220125171344267.png)\n\n    ![image-20220125172427718](WebRtc Internals工具使用/image-20220125172427718.png)\n\n    ![image-20220125171812419](WebRtc Internals工具使用/image-20220125171812419.png)\n\n    ![image-20220125172507453](WebRtc Internals工具使用/image-20220125172507453.png)\n\n  - ##### 上行数据（发送的）\n\n    ![image-20220125172252449](WebRtc Internals工具使用/image-20220125172252449.png)\n\n    ![image-20220125172315264](WebRtc Internals工具使用/image-20220125172315264.png)\n\n## 问题排查\n\n- ##### 拉流画面黑屏\n\n  需要查看video的inbound-rtp的下行数据包是否有接收到，或者帧解码是否成功。\n\n- ##### 拉流没有声音\n\n  需要查看audio的inbound-rtp接收到的数据是否存在问题","slug":"WebRtc-Internals工具使用","published":1,"updated":"2024-02-19T07:42:51.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9p001h1xop12gy1zqf","content":"<blockquote>\n<p>以chrome浏览器来说明，在地址栏输入chrome://webrtc-internals/即可打开调试工具</p>\n</blockquote>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125103700660.png\" alt=\"image-20220125103700660\"></p>\n<h2 id=\"Create-Dump（保存日志）\"><a href=\"#Create-Dump（保存日志）\" class=\"headerlink\" title=\"Create Dump（保存日志）\"></a>Create Dump（保存日志）</h2><p>可以将该页面的log数据进行本地化存储，方便分享和留档。</p>\n<h2 id=\"Read-Stats-From（读取状态日志）\"><a href=\"#Read-Stats-From（读取状态日志）\" class=\"headerlink\" title=\"Read Stats From（读取状态日志）\"></a>Read Stats From（读取状态日志）</h2><p>WebRTC读取状态日志分为2中：</p>\n<ul>\n<li>Standardized：符合W3C的新标准，基于promise模式</li>\n<li>Legacy Non-Standard：废弃的google定义的旧标准，基于callback模式</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/截屏2022-01-25 上午10.49.46.png\" alt=\"截屏2022-01-25 上午10.49.46\"></p>\n<h2 id=\"GetUserMedia-Requests（GetUserMedia调用日志）\"><a href=\"#GetUserMedia-Requests（GetUserMedia调用日志）\" class=\"headerlink\" title=\"GetUserMedia Requests（GetUserMedia调用日志）\"></a>GetUserMedia Requests（GetUserMedia调用日志）</h2><p>getUserMedia是浏览器获取用户本地摄像头和麦克风的接口，具体使用方法：<code>navigator.mediaDevices.getUserMedia</code>。GetUserMedia Requests的Tab中可以看到近期调用这个api的记录，每调用一次就会多一条。</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125110844187.png\" alt=\"image-20220125110844187\"></p>\n<h2 id=\"RTCPeerConnection（监控信息）\"><a href=\"#RTCPeerConnection（监控信息）\" class=\"headerlink\" title=\"RTCPeerConnection（监控信息）\"></a>RTCPeerConnection（监控信息）</h2><p>除了GetUserMedia Requests，其他Tab每一个都对应一个PeerConnection对象。</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125111712303.png\" alt=\"image-20220125111712303\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125111731747.png\" alt=\"image-20220125111731747\"></p>\n<h4 id=\"构造PeerConnection实例的参数\"><a href=\"#构造PeerConnection实例的参数\" class=\"headerlink\" title=\"构造PeerConnection实例的参数\"></a>构造PeerConnection实例的参数</h4><p>最上面圈起来的那块是构造PeerConnection的参数配置</p>\n<h4 id=\"PeerConnection事件\"><a href=\"#PeerConnection事件\" class=\"headerlink\" title=\"PeerConnection事件\"></a>PeerConnection事件</h4><ul>\n<li>addTrack（建立音频轨道）</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125113409121.png\" alt=\"image-20220125113409121\"></p>\n<ul>\n<li><p>createOffer（生成offer）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125113538013.png\" alt=\"image-20220125113538013\"></p>\n</li>\n<li><p>setLocalDescription（设置local sdp）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125143155721.png\" alt=\"image-20220125143155721\"></p>\n</li>\n<li><p>iceconnectionstatechange（ICE的连接状态发生变化）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125165024993.png\" alt=\"image-20220125165024993\"></p>\n</li>\n<li><p>connectionstatechange（PeerConnection的连接状态发生变化）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125165043733.png\" alt=\"image-20220125165043733\"></p>\n</li>\n<li><p>icecandidate（收集本地的candidate）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164803760.png\" alt=\"image-20220125164803760\"></p>\n</li>\n<li><p>setRemoteDescription（设置remote sdp）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125162500220.png\" alt=\"image-20220125162500220\"></p>\n</li>\n<li><p>signalingstatechange（信令状态的回调）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164612639.png\" alt=\"image-20220125164612639\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164622944.png\" alt=\"image-20220125164622944\"></p>\n</li>\n<li><p>addIceCandidate（将对端的candidate添加到PeerConnection中）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125163342091.png\" alt=\"image-20220125163342091\"></p>\n</li>\n<li><p>如果出现error也可以在Event这块看到：</p>\n</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125162859189.png\" alt=\"image-20220125162859189\"></p>\n<h2 id=\"流数据（数据格式-amp-图表格式）\"><a href=\"#流数据（数据格式-amp-图表格式）\" class=\"headerlink\" title=\"流数据（数据格式&amp;图表格式）\"></a>流数据（数据格式&amp;图表格式）</h2><p>流数据主要关注四行就够了（上行数据、下行数据）</p>\n<ul>\n<li><p>inbound-rtp：下行数据，也就是从远端接收到的数据，可以分为音频和视频</p>\n</li>\n<li><p>outbound-rtp：上行数据，代表发送给远端的数据，可以分为音频和视频</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125170026281.png\" alt=\"image-20220125170026281\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125170242142.png\" alt=\"image-20220125170242142\"></p>\n<h4 id=\"展开后可以看到\"><a href=\"#展开后可以看到\" class=\"headerlink\" title=\"展开后可以看到\"></a>展开后可以看到</h4><ul>\n<li><h5 id=\"下行数据（接收到的）\"><a href=\"#下行数据（接收到的）\" class=\"headerlink\" title=\"下行数据（接收到的）\"></a>下行数据（接收到的）</h5><p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125171344267.png\" alt=\"image-20220125171344267\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172427718.png\" alt=\"image-20220125172427718\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125171812419.png\" alt=\"image-20220125171812419\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172507453.png\" alt=\"image-20220125172507453\"></p>\n</li>\n<li><h5 id=\"上行数据（发送的）\"><a href=\"#上行数据（发送的）\" class=\"headerlink\" title=\"上行数据（发送的）\"></a>上行数据（发送的）</h5><p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172252449.png\" alt=\"image-20220125172252449\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172315264.png\" alt=\"image-20220125172315264\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><ul>\n<li><h5 id=\"拉流画面黑屏\"><a href=\"#拉流画面黑屏\" class=\"headerlink\" title=\"拉流画面黑屏\"></a>拉流画面黑屏</h5><p>需要查看video的inbound-rtp的下行数据包是否有接收到，或者帧解码是否成功。</p>\n</li>\n<li><h5 id=\"拉流没有声音\"><a href=\"#拉流没有声音\" class=\"headerlink\" title=\"拉流没有声音\"></a>拉流没有声音</h5><p>需要查看audio的inbound-rtp接收到的数据是否存在问题</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>以chrome浏览器来说明，在地址栏输入chrome://webrtc-internals/即可打开调试工具</p>\n</blockquote>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125103700660.png\" alt=\"image-20220125103700660\"></p>\n<h2 id=\"Create-Dump（保存日志）\"><a href=\"#Create-Dump（保存日志）\" class=\"headerlink\" title=\"Create Dump（保存日志）\"></a>Create Dump（保存日志）</h2><p>可以将该页面的log数据进行本地化存储，方便分享和留档。</p>\n<h2 id=\"Read-Stats-From（读取状态日志）\"><a href=\"#Read-Stats-From（读取状态日志）\" class=\"headerlink\" title=\"Read Stats From（读取状态日志）\"></a>Read Stats From（读取状态日志）</h2><p>WebRTC读取状态日志分为2中：</p>\n<ul>\n<li>Standardized：符合W3C的新标准，基于promise模式</li>\n<li>Legacy Non-Standard：废弃的google定义的旧标准，基于callback模式</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/截屏2022-01-25 上午10.49.46.png\" alt=\"截屏2022-01-25 上午10.49.46\"></p>\n<h2 id=\"GetUserMedia-Requests（GetUserMedia调用日志）\"><a href=\"#GetUserMedia-Requests（GetUserMedia调用日志）\" class=\"headerlink\" title=\"GetUserMedia Requests（GetUserMedia调用日志）\"></a>GetUserMedia Requests（GetUserMedia调用日志）</h2><p>getUserMedia是浏览器获取用户本地摄像头和麦克风的接口，具体使用方法：<code>navigator.mediaDevices.getUserMedia</code>。GetUserMedia Requests的Tab中可以看到近期调用这个api的记录，每调用一次就会多一条。</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125110844187.png\" alt=\"image-20220125110844187\"></p>\n<h2 id=\"RTCPeerConnection（监控信息）\"><a href=\"#RTCPeerConnection（监控信息）\" class=\"headerlink\" title=\"RTCPeerConnection（监控信息）\"></a>RTCPeerConnection（监控信息）</h2><p>除了GetUserMedia Requests，其他Tab每一个都对应一个PeerConnection对象。</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125111712303.png\" alt=\"image-20220125111712303\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125111731747.png\" alt=\"image-20220125111731747\"></p>\n<h4 id=\"构造PeerConnection实例的参数\"><a href=\"#构造PeerConnection实例的参数\" class=\"headerlink\" title=\"构造PeerConnection实例的参数\"></a>构造PeerConnection实例的参数</h4><p>最上面圈起来的那块是构造PeerConnection的参数配置</p>\n<h4 id=\"PeerConnection事件\"><a href=\"#PeerConnection事件\" class=\"headerlink\" title=\"PeerConnection事件\"></a>PeerConnection事件</h4><ul>\n<li>addTrack（建立音频轨道）</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125113409121.png\" alt=\"image-20220125113409121\"></p>\n<ul>\n<li><p>createOffer（生成offer）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125113538013.png\" alt=\"image-20220125113538013\"></p>\n</li>\n<li><p>setLocalDescription（设置local sdp）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125143155721.png\" alt=\"image-20220125143155721\"></p>\n</li>\n<li><p>iceconnectionstatechange（ICE的连接状态发生变化）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125165024993.png\" alt=\"image-20220125165024993\"></p>\n</li>\n<li><p>connectionstatechange（PeerConnection的连接状态发生变化）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125165043733.png\" alt=\"image-20220125165043733\"></p>\n</li>\n<li><p>icecandidate（收集本地的candidate）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164803760.png\" alt=\"image-20220125164803760\"></p>\n</li>\n<li><p>setRemoteDescription（设置remote sdp）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125162500220.png\" alt=\"image-20220125162500220\"></p>\n</li>\n<li><p>signalingstatechange（信令状态的回调）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164612639.png\" alt=\"image-20220125164612639\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125164622944.png\" alt=\"image-20220125164622944\"></p>\n</li>\n<li><p>addIceCandidate（将对端的candidate添加到PeerConnection中）</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125163342091.png\" alt=\"image-20220125163342091\"></p>\n</li>\n<li><p>如果出现error也可以在Event这块看到：</p>\n</li>\n</ul>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125162859189.png\" alt=\"image-20220125162859189\"></p>\n<h2 id=\"流数据（数据格式-amp-图表格式）\"><a href=\"#流数据（数据格式-amp-图表格式）\" class=\"headerlink\" title=\"流数据（数据格式&amp;图表格式）\"></a>流数据（数据格式&amp;图表格式）</h2><p>流数据主要关注四行就够了（上行数据、下行数据）</p>\n<ul>\n<li><p>inbound-rtp：下行数据，也就是从远端接收到的数据，可以分为音频和视频</p>\n</li>\n<li><p>outbound-rtp：上行数据，代表发送给远端的数据，可以分为音频和视频</p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125170026281.png\" alt=\"image-20220125170026281\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125170242142.png\" alt=\"image-20220125170242142\"></p>\n<h4 id=\"展开后可以看到\"><a href=\"#展开后可以看到\" class=\"headerlink\" title=\"展开后可以看到\"></a>展开后可以看到</h4><ul>\n<li><h5 id=\"下行数据（接收到的）\"><a href=\"#下行数据（接收到的）\" class=\"headerlink\" title=\"下行数据（接收到的）\"></a>下行数据（接收到的）</h5><p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125171344267.png\" alt=\"image-20220125171344267\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172427718.png\" alt=\"image-20220125172427718\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125171812419.png\" alt=\"image-20220125171812419\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172507453.png\" alt=\"image-20220125172507453\"></p>\n</li>\n<li><h5 id=\"上行数据（发送的）\"><a href=\"#上行数据（发送的）\" class=\"headerlink\" title=\"上行数据（发送的）\"></a>上行数据（发送的）</h5><p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172252449.png\" alt=\"image-20220125172252449\"></p>\n<p><img src=\"/2024/02/19/WebRtc-Internals%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/image-20220125172315264.png\" alt=\"image-20220125172315264\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><ul>\n<li><h5 id=\"拉流画面黑屏\"><a href=\"#拉流画面黑屏\" class=\"headerlink\" title=\"拉流画面黑屏\"></a>拉流画面黑屏</h5><p>需要查看video的inbound-rtp的下行数据包是否有接收到，或者帧解码是否成功。</p>\n</li>\n<li><h5 id=\"拉流没有声音\"><a href=\"#拉流没有声音\" class=\"headerlink\" title=\"拉流没有声音\"></a>拉流没有声音</h5><p>需要查看audio的inbound-rtp接收到的数据是否存在问题</p>\n</li>\n</ul>\n"},{"title":"axios","date":"2018-12-09T04:35:48.000Z","_content":"\n### axios\n\n**基于promise用于浏览器和node.js的http客户端**\n\n##### 特点\n\n- 支持浏览器和node.js\n- 支持promise\n- 能拦截请求和响应\n- 能转换请求和响应数据\n- 能取消请求\n- 自动转换JSON数据\n- 浏览器端支持防止CSRF(跨站请求伪造)\n\n##### 安装\n\n```bash\nnpm install axios\n```\n\n##### 例子\n\n发起一个`GET`请求\n\n```js\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n发起一个`POST`请求\n\n```js\naxios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n同时发起多个请求\n\n```js\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n```","source":"_posts/axios.md","raw":"---\ntitle: axios\ndate: 2018-12-09 12:35:48\ntags: axios\ncategories: 前端\n---\n\n### axios\n\n**基于promise用于浏览器和node.js的http客户端**\n\n##### 特点\n\n- 支持浏览器和node.js\n- 支持promise\n- 能拦截请求和响应\n- 能转换请求和响应数据\n- 能取消请求\n- 自动转换JSON数据\n- 浏览器端支持防止CSRF(跨站请求伪造)\n\n##### 安装\n\n```bash\nnpm install axios\n```\n\n##### 例子\n\n发起一个`GET`请求\n\n```js\n// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get('/user', {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n发起一个`POST`请求\n\n```js\naxios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n\n同时发起多个请求\n\n```js\nfunction getUserAccount() {\n  return axios.get('/user/12345');\n}\n\nfunction getUserPermissions() {\n  return axios.get('/user/12345/permissions');\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n```","slug":"axios","published":1,"updated":"2024-02-19T07:42:51.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9s001j1xopgqi26ph3","content":"<h3 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h3><p><strong>基于promise用于浏览器和node.js的http客户端</strong></p>\n<h5 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>支持浏览器和node.js</li>\n<li>支持promise</li>\n<li>能拦截请求和响应</li>\n<li>能转换请求和响应数据</li>\n<li>能取消请求</li>\n<li>自动转换JSON数据</li>\n<li>浏览器端支持防止CSRF(跨站请求伪造)</li>\n</ul>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> axios\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h5><p>发起一个<code>GET</code>请求</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// Make a request for a user with a given ID</span>\naxios<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user?ID=12345'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// Optionally the request above could also be done as</span>\naxios<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    params<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      ID<span class=\"token punctuation\">:</span> <span class=\"token number\">12345</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>发起一个<code>POST</code>请求</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">axios<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'Fred'</span><span class=\"token punctuation\">,</span>\n    lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">'Flintstone'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>同时发起多个请求</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">getUserAccount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> axios<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user/12345'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUserPermissions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> axios<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/user/12345/permissions'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\naxios<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token function\">getUserAccount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">getUserPermissions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>axios<span class=\"token punctuation\">.</span><span class=\"token function\">spread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>acct<span class=\"token punctuation\">,</span> perms<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Both requests are now complete</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h3><p><strong>基于promise用于浏览器和node.js的http客户端</strong></p>\n<h5 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h5><ul>\n<li>支持浏览器和node.js</li>\n<li>支持promise</li>\n<li>能拦截请求和响应</li>\n<li>能转换请求和响应数据</li>\n<li>能取消请求</li>\n<li>自动转换JSON数据</li>\n<li>浏览器端支持防止CSRF(跨站请求伪造)</li>\n</ul>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><pre><code class=\"bash\">npm install axios\n</code></pre>\n<h5 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h5><p>发起一个<code>GET</code>请求</p>\n<pre><code class=\"js\">// Make a request for a user with a given ID\naxios.get(&#39;/user?ID=12345&#39;)\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// Optionally the request above could also be done as\naxios.get(&#39;/user&#39;, {\n    params: {\n      ID: 12345\n    }\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n</code></pre>\n<p>发起一个<code>POST</code>请求</p>\n<pre><code class=\"js\">axios.post(&#39;/user&#39;, {\n    firstName: &#39;Fred&#39;,\n    lastName: &#39;Flintstone&#39;\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n</code></pre>\n<p>同时发起多个请求</p>\n<pre><code class=\"js\">function getUserAccount() {\n  return axios.get(&#39;/user/12345&#39;);\n}\n\nfunction getUserPermissions() {\n  return axios.get(&#39;/user/12345/permissions&#39;);\n}\n\naxios.all([getUserAccount(), getUserPermissions()])\n  .then(axios.spread(function (acct, perms) {\n    // Both requests are now complete\n  }));\n</code></pre>\n"},{"title":"call、apply使用与区别","date":"2018-10-05T08:55:01.000Z","_content":"\n### call、apply使用与区别\n\njavaScript中的每个Function对象都有一个apply()方法和call()方法，两者作用一样，唯一的不同点就是参数不同，语法：\n\n**call**：方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数列表）。\n\n```javascript\nfunction.call(thisObject,arg1,arg2,arg3,...);\n```\n\n举例：\n\n```javascript\n//改变this指向\nwindow.a='哈哈';\ndocument.a='嘿嘿';\nvar s={a:'嘻嘻'};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.call(); //'哈哈'\nchangea.call(window); //'哈哈'\nchangea.call(document); //'嘿嘿'\nchangea.call(s); //'嘻嘻'\nchangea.call(this); //'哈哈'\n\n//调用匿名函数\nlet Persons=[\n    {\n        name:'张三',\n        age:20\n    },\n    {\n        name:'李四',\n        age:30\n    }\n]\nfor(let i=0;i<Persons.length;i++){\n    (function(i){\n        this.say=function(){\n            console.log(i+'我叫'+this.name+'今年'+this.age+'岁');\n        }\n    }).call(Persons[i],i)\n}\nPersons[0].say(); //0我叫张三今年20岁\nPersons[1].say(); //1我叫李四今年30岁\n```\n\n**apply:**方法调用一个具有给定this值的函数，以及作为一个数组（或者类似数组对象）提供的参数。\n\n```javascript\nfunction.apply(thisObj,[argsArray]);\n```\n\n举例：\n\n```javascript\n//改变this指向\nwindow.a='哈哈';\ndocument.a='嘿嘿';\nvar s={a:'嘻嘻'};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.apply(); //'哈哈'\nchangea.apply(window); //'哈哈'\nchangea.apply(document); //'嘿嘿'\nchangea.apply(s); //'嘻嘻'\nchangea.apply(this); //'哈哈'\n```\n\n*使用apply将数组添加到另一个数组*:\n\n> 我们可以使用`push`将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组。如果那不是我们想要的怎么办？在这种情况下，`concat`确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。 但是我们想要附加到我们现有的阵列......那么现在呢？ 写一个循环？当然不是吗？\n\n```javascript\nlet arr1=[1,2];\nlet arr2=[3,4,5];\n//如果使用push\narr1.push(arr2);\nconsole.log(arr1); //[1,2,[3,4,5]]\n//可以看到，得到的并不是我们想要的一维的数组\narr1.push.apply(arr1,arr2);\nconsole.log(arr1); //[1,2,3,4,5]\n```\n\n**两者传递参数差异：**\n\n```javascript\nfunction change(name,age){\n    console.log(name,age);\n}\nchange.call(this,'张三',20); //张三 20\nchange.apply(this,['张三',20]) //张三 20\n```\n\n### call、apply以及bind异同点\n\n- 相同点\n    * 都可以用来改变this指向问题。\n- 不同点\n    * call和apply都是调用即执行，而bind不会立即执行。\n    * call和apply传递的参数不一样，call传递参数是一个参数列表，而apply第二个参数需要是一个数组。\n****\n**实现原理**\n\n- call\n\n```js\n    // call实现原理\n\tFunction.prototype._call = function (context) {\n\t\t\n\t\t// context是否存在\n\t\tif(!context) {\n\t\t\tcontext = window !== 'undefined' ? window : global;\n\t\t}\n\n\t\tcontext.fn = this; // this代表函数实例本身，将函数实例添加到context对象的属性中\n\t\tlet rest = [...arguments].splice(1);  // 获取到去除context外的所有参数\n\t\tlet result = context.fn(...rest);  // 隐式绑定this，此时调用fn函数内部this指向context\n\t\tdelete context.fn;\n\t\treturn result\n\t}\n\t\n\tlet ooo = {\n\t\tname: '张三'\n\t}\n\tfunction getName() {\n\t\tconsole.log(this.name,arguments);\n\t}\n\tconsole.log(getName._call(ooo,1,2,3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```\n- apply\n\n\n```js\n    // apply实现原理\n\tFunction.prototype._apply = function (context, arr) {\n\n\t\t// context是否存在\n\t\tif(!context) {\n\t\t\tcontext = window !== 'undefined' ? window : global;\n\t\t}\n\n\t\tcontext.fn = this;  // this代表函数实例本身\n\t\tlet result;\n\t\tif(arr === undefined || arr === null) {\n\t\t\tresult = context.fn(arr);\n\t\t}else if(typeof arr === 'object') {\n\t\t\tresult = context.fn(...arr);\n\t\t}\n\t\tdelete context.fn;\n\t\treturn result\n\t}\n\tlet ooo = {\n\t\tname: '张三'\n\t}\n\tfunction getName() {\n\t\tconsole.log(this.name,arguments);\n\t}\n\tconsole.log(getName._apply(ooo,[1,2])); // 张三 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```\n- bind\n\n\n```js\n    // bind实现原理\n\tFunction.prototype._bind = function (context) {\n\t\tif(typeof this !== 'function') {\n\t\t\tthrow new TypeError(\"not a function\");\n\t\t}\n\t\tlet self = this;\n\n\t\tlet rest = [...arguments].splice(1);  // 获取bind所有参数\n\t\tfunction Fn(){};\n\t\tFn.prototype = this.prototype;\n\t\tlet bound = function() {\n\t\t\tlet args = [...rest,...arguments]; // 获取到bind传入的参数以及执行函数传入的参数\n\t\t\tcontext = this instanceof Fn ? this : context || this;  // 谁调用bound函数，this就指向谁\n\t\t\treturn self.apply(context,args);\n\t\t}\n\n\t\t// 原型链\n\t\tbound.prototype = new Fn();\n\t\treturn bound\n\t}\n\t\n\tlet ooo = {\n\t\t\tname: '张三'\n\t\t}\n\t\tfunction getName() {\n\t\t\tconsole.log(this.name,arguments);\n\t\t}\n\t\t\n\t\tconsole.log(getName._bind(ooo,1,2)(3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```","source":"_posts/call、apply使用与区别.md","raw":"---\ntitle: call、apply使用与区别\ndate: 2018-10-05 16:55:01\ntags: js\ncategories: 前端\n---\n\n### call、apply使用与区别\n\njavaScript中的每个Function对象都有一个apply()方法和call()方法，两者作用一样，唯一的不同点就是参数不同，语法：\n\n**call**：方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数列表）。\n\n```javascript\nfunction.call(thisObject,arg1,arg2,arg3,...);\n```\n\n举例：\n\n```javascript\n//改变this指向\nwindow.a='哈哈';\ndocument.a='嘿嘿';\nvar s={a:'嘻嘻'};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.call(); //'哈哈'\nchangea.call(window); //'哈哈'\nchangea.call(document); //'嘿嘿'\nchangea.call(s); //'嘻嘻'\nchangea.call(this); //'哈哈'\n\n//调用匿名函数\nlet Persons=[\n    {\n        name:'张三',\n        age:20\n    },\n    {\n        name:'李四',\n        age:30\n    }\n]\nfor(let i=0;i<Persons.length;i++){\n    (function(i){\n        this.say=function(){\n            console.log(i+'我叫'+this.name+'今年'+this.age+'岁');\n        }\n    }).call(Persons[i],i)\n}\nPersons[0].say(); //0我叫张三今年20岁\nPersons[1].say(); //1我叫李四今年30岁\n```\n\n**apply:**方法调用一个具有给定this值的函数，以及作为一个数组（或者类似数组对象）提供的参数。\n\n```javascript\nfunction.apply(thisObj,[argsArray]);\n```\n\n举例：\n\n```javascript\n//改变this指向\nwindow.a='哈哈';\ndocument.a='嘿嘿';\nvar s={a:'嘻嘻'};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.apply(); //'哈哈'\nchangea.apply(window); //'哈哈'\nchangea.apply(document); //'嘿嘿'\nchangea.apply(s); //'嘻嘻'\nchangea.apply(this); //'哈哈'\n```\n\n*使用apply将数组添加到另一个数组*:\n\n> 我们可以使用`push`将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组。如果那不是我们想要的怎么办？在这种情况下，`concat`确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。 但是我们想要附加到我们现有的阵列......那么现在呢？ 写一个循环？当然不是吗？\n\n```javascript\nlet arr1=[1,2];\nlet arr2=[3,4,5];\n//如果使用push\narr1.push(arr2);\nconsole.log(arr1); //[1,2,[3,4,5]]\n//可以看到，得到的并不是我们想要的一维的数组\narr1.push.apply(arr1,arr2);\nconsole.log(arr1); //[1,2,3,4,5]\n```\n\n**两者传递参数差异：**\n\n```javascript\nfunction change(name,age){\n    console.log(name,age);\n}\nchange.call(this,'张三',20); //张三 20\nchange.apply(this,['张三',20]) //张三 20\n```\n\n### call、apply以及bind异同点\n\n- 相同点\n    * 都可以用来改变this指向问题。\n- 不同点\n    * call和apply都是调用即执行，而bind不会立即执行。\n    * call和apply传递的参数不一样，call传递参数是一个参数列表，而apply第二个参数需要是一个数组。\n****\n**实现原理**\n\n- call\n\n```js\n    // call实现原理\n\tFunction.prototype._call = function (context) {\n\t\t\n\t\t// context是否存在\n\t\tif(!context) {\n\t\t\tcontext = window !== 'undefined' ? window : global;\n\t\t}\n\n\t\tcontext.fn = this; // this代表函数实例本身，将函数实例添加到context对象的属性中\n\t\tlet rest = [...arguments].splice(1);  // 获取到去除context外的所有参数\n\t\tlet result = context.fn(...rest);  // 隐式绑定this，此时调用fn函数内部this指向context\n\t\tdelete context.fn;\n\t\treturn result\n\t}\n\t\n\tlet ooo = {\n\t\tname: '张三'\n\t}\n\tfunction getName() {\n\t\tconsole.log(this.name,arguments);\n\t}\n\tconsole.log(getName._call(ooo,1,2,3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```\n- apply\n\n\n```js\n    // apply实现原理\n\tFunction.prototype._apply = function (context, arr) {\n\n\t\t// context是否存在\n\t\tif(!context) {\n\t\t\tcontext = window !== 'undefined' ? window : global;\n\t\t}\n\n\t\tcontext.fn = this;  // this代表函数实例本身\n\t\tlet result;\n\t\tif(arr === undefined || arr === null) {\n\t\t\tresult = context.fn(arr);\n\t\t}else if(typeof arr === 'object') {\n\t\t\tresult = context.fn(...arr);\n\t\t}\n\t\tdelete context.fn;\n\t\treturn result\n\t}\n\tlet ooo = {\n\t\tname: '张三'\n\t}\n\tfunction getName() {\n\t\tconsole.log(this.name,arguments);\n\t}\n\tconsole.log(getName._apply(ooo,[1,2])); // 张三 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```\n- bind\n\n\n```js\n    // bind实现原理\n\tFunction.prototype._bind = function (context) {\n\t\tif(typeof this !== 'function') {\n\t\t\tthrow new TypeError(\"not a function\");\n\t\t}\n\t\tlet self = this;\n\n\t\tlet rest = [...arguments].splice(1);  // 获取bind所有参数\n\t\tfunction Fn(){};\n\t\tFn.prototype = this.prototype;\n\t\tlet bound = function() {\n\t\t\tlet args = [...rest,...arguments]; // 获取到bind传入的参数以及执行函数传入的参数\n\t\t\tcontext = this instanceof Fn ? this : context || this;  // 谁调用bound函数，this就指向谁\n\t\t\treturn self.apply(context,args);\n\t\t}\n\n\t\t// 原型链\n\t\tbound.prototype = new Fn();\n\t\treturn bound\n\t}\n\t\n\tlet ooo = {\n\t\t\tname: '张三'\n\t\t}\n\t\tfunction getName() {\n\t\t\tconsole.log(this.name,arguments);\n\t\t}\n\t\t\n\t\tconsole.log(getName._bind(ooo,1,2)(3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n```","slug":"call、apply使用与区别","published":1,"updated":"2024-02-19T07:42:51.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9w001n1xop0uesdqmq","content":"<h3 id=\"call、apply使用与区别\"><a href=\"#call、apply使用与区别\" class=\"headerlink\" title=\"call、apply使用与区别\"></a>call、apply使用与区别</h3><p>javaScript中的每个Function对象都有一个apply()方法和call()方法，两者作用一样，唯一的不同点就是参数不同，语法：</p>\n<p><strong>call</strong>：方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数列表）。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>thisObject<span class=\"token punctuation\">,</span>arg1<span class=\"token punctuation\">,</span>arg2<span class=\"token punctuation\">,</span>arg3<span class=\"token punctuation\">,</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>举例：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//改变this指向</span>\nwindow<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token string\">'哈哈'</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token string\">'嘿嘿'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">:</span><span class=\"token string\">'嘻嘻'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">changea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'嘿嘿'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'嘻嘻'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//调用匿名函数</span>\n<span class=\"token keyword\">let</span> Persons<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span>\n        age<span class=\"token punctuation\">:</span><span class=\"token number\">20</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span><span class=\"token string\">'李四'</span><span class=\"token punctuation\">,</span>\n        age<span class=\"token punctuation\">:</span><span class=\"token number\">30</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>Persons<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>say<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token string\">'我叫'</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">'今年'</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">+</span><span class=\"token string\">'岁'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Persons<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nPersons<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//0我叫张三今年20岁</span>\nPersons<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">say</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1我叫李四今年30岁</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>apply:</strong>方法调用一个具有给定this值的函数，以及作为一个数组（或者类似数组对象）提供的参数。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>thisObj<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span>argsArray<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>举例：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//改变this指向</span>\nwindow<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token string\">'哈哈'</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token string\">'嘿嘿'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> s<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">:</span><span class=\"token string\">'嘻嘻'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">changea</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'嘿嘿'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'嘻嘻'</span>\nchangea<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'哈哈'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em>使用apply将数组添加到另一个数组</em>:</p>\n<blockquote>\n<p>我们可以使用<code>push</code>将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组。如果那不是我们想要的怎么办？在这种情况下，<code>concat</code>确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。 但是我们想要附加到我们现有的阵列……那么现在呢？ 写一个循环？当然不是吗？</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> arr1<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> arr2<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//如果使用push</span>\narr1<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,[3,4,5]]</span>\n<span class=\"token comment\" spellcheck=\"true\">//可以看到，得到的并不是我们想要的一维的数组</span>\narr1<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">,</span>arr2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>两者传递参数差异：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">change</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nchange<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//张三 20</span>\nchange<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//张三 20</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"call、apply以及bind异同点\"><a href=\"#call、apply以及bind异同点\" class=\"headerlink\" title=\"call、apply以及bind异同点\"></a>call、apply以及bind异同点</h3><ul>\n<li>相同点<ul>\n<li>都可以用来改变this指向问题。</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>call和apply都是调用即执行，而bind不会立即执行。</li>\n<li>call和apply传递的参数不一样，call传递参数是一个参数列表，而apply第二个参数需要是一个数组。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>实现原理</strong></p>\n<ul>\n<li>call</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token comment\" spellcheck=\"true\">// call实现原理</span>\n    Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_call <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// context是否存在</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            context <span class=\"token operator\">=</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token operator\">?</span> window <span class=\"token punctuation\">:</span> global<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        context<span class=\"token punctuation\">.</span>fn <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// this代表函数实例本身，将函数实例添加到context对象的属性中</span>\n        <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取到去除context外的所有参数</span>\n        <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>rest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 隐式绑定this，此时调用fn函数内部this指向context</span>\n        <span class=\"token keyword\">delete</span> context<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> ooo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span> <span class=\"token string\">'张三'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>getName<span class=\"token punctuation\">.</span><span class=\"token function\">_call</span><span class=\"token punctuation\">(</span>ooo<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>apply</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token comment\" spellcheck=\"true\">// apply实现原理</span>\n    Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_apply <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// context是否存在</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            context <span class=\"token operator\">=</span> window <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token operator\">?</span> window <span class=\"token punctuation\">:</span> global<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        context<span class=\"token punctuation\">.</span>fn <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// this代表函数实例本身</span>\n        <span class=\"token keyword\">let</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr <span class=\"token operator\">===</span> undefined <span class=\"token operator\">||</span> arr <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> arr <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">delete</span> context<span class=\"token punctuation\">.</span>fn<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> ooo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span> <span class=\"token string\">'张三'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>getName<span class=\"token punctuation\">.</span><span class=\"token function\">_apply</span><span class=\"token punctuation\">(</span>ooo<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 张三 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>bind</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token comment\" spellcheck=\"true\">// bind实现原理</span>\n    Function<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>_bind <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> <span class=\"token keyword\">this</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"not a function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">let</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 获取bind所有参数</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">Fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        Fn<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> bound <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>rest<span class=\"token punctuation\">,</span><span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 获取到bind传入的参数以及执行函数传入的参数</span>\n            context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Fn</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">this</span> <span class=\"token punctuation\">:</span> context <span class=\"token operator\">||</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 谁调用bound函数，this就指向谁</span>\n            <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span>args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 原型链</span>\n        bound<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> bound\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> ooo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            name<span class=\"token punctuation\">:</span> <span class=\"token string\">'张三'</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>getName<span class=\"token punctuation\">.</span><span class=\"token function\">_bind</span><span class=\"token punctuation\">(</span>ooo<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"call、apply使用与区别\"><a href=\"#call、apply使用与区别\" class=\"headerlink\" title=\"call、apply使用与区别\"></a>call、apply使用与区别</h3><p>javaScript中的每个Function对象都有一个apply()方法和call()方法，两者作用一样，唯一的不同点就是参数不同，语法：</p>\n<p><strong>call</strong>：方法调用一个函数，其具有一个指定的this值和分别地提供的参数（参数列表）。</p>\n<pre><code class=\"javascript\">function.call(thisObject,arg1,arg2,arg3,...);\n</code></pre>\n<p>举例：</p>\n<pre><code class=\"javascript\">//改变this指向\nwindow.a=&#39;哈哈&#39;;\ndocument.a=&#39;嘿嘿&#39;;\nvar s={a:&#39;嘻嘻&#39;};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.call(); //&#39;哈哈&#39;\nchangea.call(window); //&#39;哈哈&#39;\nchangea.call(document); //&#39;嘿嘿&#39;\nchangea.call(s); //&#39;嘻嘻&#39;\nchangea.call(this); //&#39;哈哈&#39;\n\n//调用匿名函数\nlet Persons=[\n    {\n        name:&#39;张三&#39;,\n        age:20\n    },\n    {\n        name:&#39;李四&#39;,\n        age:30\n    }\n]\nfor(let i=0;i&lt;Persons.length;i++){\n    (function(i){\n        this.say=function(){\n            console.log(i+&#39;我叫&#39;+this.name+&#39;今年&#39;+this.age+&#39;岁&#39;);\n        }\n    }).call(Persons[i],i)\n}\nPersons[0].say(); //0我叫张三今年20岁\nPersons[1].say(); //1我叫李四今年30岁\n</code></pre>\n<p><strong>apply:</strong>方法调用一个具有给定this值的函数，以及作为一个数组（或者类似数组对象）提供的参数。</p>\n<pre><code class=\"javascript\">function.apply(thisObj,[argsArray]);\n</code></pre>\n<p>举例：</p>\n<pre><code class=\"javascript\">//改变this指向\nwindow.a=&#39;哈哈&#39;;\ndocument.a=&#39;嘿嘿&#39;;\nvar s={a:&#39;嘻嘻&#39;};\nfunction changea(){\n    console.log(this.a);\n}\nchangea.apply(); //&#39;哈哈&#39;\nchangea.apply(window); //&#39;哈哈&#39;\nchangea.apply(document); //&#39;嘿嘿&#39;\nchangea.apply(s); //&#39;嘻嘻&#39;\nchangea.apply(this); //&#39;哈哈&#39;\n</code></pre>\n<p><em>使用apply将数组添加到另一个数组</em>:</p>\n<blockquote>\n<p>我们可以使用<code>push</code>将元素追加到数组中。并且，因为push接受可变数量的参数，我们也可以一次推送多个元素。但是，如果我们传递一个数组来推送，它实际上会将该数组作为单个元素添加，而不是单独添加元素，因此我们最终得到一个数组内的数组。如果那不是我们想要的怎么办？在这种情况下，<code>concat</code>确实具有我们想要的行为，但它实际上并不附加到现有数组，而是创建并返回一个新数组。 但是我们想要附加到我们现有的阵列……那么现在呢？ 写一个循环？当然不是吗？</p>\n</blockquote>\n<pre><code class=\"javascript\">let arr1=[1,2];\nlet arr2=[3,4,5];\n//如果使用push\narr1.push(arr2);\nconsole.log(arr1); //[1,2,[3,4,5]]\n//可以看到，得到的并不是我们想要的一维的数组\narr1.push.apply(arr1,arr2);\nconsole.log(arr1); //[1,2,3,4,5]\n</code></pre>\n<p><strong>两者传递参数差异：</strong></p>\n<pre><code class=\"javascript\">function change(name,age){\n    console.log(name,age);\n}\nchange.call(this,&#39;张三&#39;,20); //张三 20\nchange.apply(this,[&#39;张三&#39;,20]) //张三 20\n</code></pre>\n<h3 id=\"call、apply以及bind异同点\"><a href=\"#call、apply以及bind异同点\" class=\"headerlink\" title=\"call、apply以及bind异同点\"></a>call、apply以及bind异同点</h3><ul>\n<li>相同点<ul>\n<li>都可以用来改变this指向问题。</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>call和apply都是调用即执行，而bind不会立即执行。</li>\n<li>call和apply传递的参数不一样，call传递参数是一个参数列表，而apply第二个参数需要是一个数组。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>实现原理</strong></p>\n<ul>\n<li>call</li>\n</ul>\n<pre><code class=\"js\">    // call实现原理\n    Function.prototype._call = function (context) {\n\n        // context是否存在\n        if(!context) {\n            context = window !== &#39;undefined&#39; ? window : global;\n        }\n\n        context.fn = this; // this代表函数实例本身，将函数实例添加到context对象的属性中\n        let rest = [...arguments].splice(1);  // 获取到去除context外的所有参数\n        let result = context.fn(...rest);  // 隐式绑定this，此时调用fn函数内部this指向context\n        delete context.fn;\n        return result\n    }\n\n    let ooo = {\n        name: &#39;张三&#39;\n    }\n    function getName() {\n        console.log(this.name,arguments);\n    }\n    console.log(getName._call(ooo,1,2,3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n</code></pre>\n<ul>\n<li>apply</li>\n</ul>\n<pre><code class=\"js\">    // apply实现原理\n    Function.prototype._apply = function (context, arr) {\n\n        // context是否存在\n        if(!context) {\n            context = window !== &#39;undefined&#39; ? window : global;\n        }\n\n        context.fn = this;  // this代表函数实例本身\n        let result;\n        if(arr === undefined || arr === null) {\n            result = context.fn(arr);\n        }else if(typeof arr === &#39;object&#39;) {\n            result = context.fn(...arr);\n        }\n        delete context.fn;\n        return result\n    }\n    let ooo = {\n        name: &#39;张三&#39;\n    }\n    function getName() {\n        console.log(this.name,arguments);\n    }\n    console.log(getName._apply(ooo,[1,2])); // 张三 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n</code></pre>\n<ul>\n<li>bind</li>\n</ul>\n<pre><code class=\"js\">    // bind实现原理\n    Function.prototype._bind = function (context) {\n        if(typeof this !== &#39;function&#39;) {\n            throw new TypeError(&quot;not a function&quot;);\n        }\n        let self = this;\n\n        let rest = [...arguments].splice(1);  // 获取bind所有参数\n        function Fn(){};\n        Fn.prototype = this.prototype;\n        let bound = function() {\n            let args = [...rest,...arguments]; // 获取到bind传入的参数以及执行函数传入的参数\n            context = this instanceof Fn ? this : context || this;  // 谁调用bound函数，this就指向谁\n            return self.apply(context,args);\n        }\n\n        // 原型链\n        bound.prototype = new Fn();\n        return bound\n    }\n\n    let ooo = {\n            name: &#39;张三&#39;\n        }\n        function getName() {\n            console.log(this.name,arguments);\n        }\n\n        console.log(getName._bind(ooo,1,2)(3)); // 张三 Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n</code></pre>\n"},{"title":"css层叠上下文、层叠等级、层叠顺序以及z-index","date":"2020-08-05T08:11:04.000Z","_content":"\n##### **css层叠上下文、层叠等级、层叠顺序以及z-index**\n\n- **层叠上下文**\n\n  > 层叠上下文是HTML中的一个三维概念。分为x轴、y轴、z轴，层叠上下文就是对这些HTML元素的三维构想。\n  >\n  > 满足一下任意一个条件及可形成层叠上下文：\n  >\n  > - 文档的根元素`<html>`\n  > - position值不为static（z-index值不为auto的元素）\n  > - flex容器的子元素（z-index值不为auto的元素）\n  > - grid容器的子元素（z-index值不为auto的元素）\n  > - opacity值小于1的元素\n  > - mix-blend-mode值不为normal的元素\n  > - css3属性（值不为none）\n  >   - transform\n  >   - filter\n  >   - perspective\n  >   - clip-path\n  >   - mask/mask-image/mask-border\n  > - isolation属性值为isolate的元素\n  > - -webkit-overflow-scrolling属性值为touch的元素\n  > - will-change\n  > - contain值为layout、paint或包含它们其中之一的合成值\n\n- **层叠等级**\n\n  > 层叠等级：\n  >\n  > - 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。\n  > - 在其他普通元素中，它描述的是这些普通元素在Z轴上的上下顺序。\n  > - 层叠等级的比较只有在当前层叠上下文中才有意义。不同层叠上下文的层叠等级比较是没有意义的。\n\n- **层叠顺序**\n\n  > 层叠顺序：表示元素发生层叠时按照特定的元素规则在Z轴上垂直显示。（层叠上下文和层叠等级是一种概念，而层叠顺序是一种规则）\n  >\n  > ![image-20200805170444733](./css层叠上下文、层叠等级、层叠顺序以及z-index/image-20200805170444733.png)\n\n- **比较流程**\n\n  > 1. 首先看比较的两个元素是否处在一个层叠上下文中\n  >\n  >    - 如果是，则谁的层叠等级大(层叠等级通过层叠顺序图来判断)，则谁在上边。\n  >\n  >    - 如果不是，则比较它们所处的层叠上下文的层叠等级\n  >\n  > 2. 当两个元素层叠等级相同、层叠顺序相同时，在dom结构中，后面的元素的层叠等级在前面的元素之上。\n  >\n  > ","source":"_posts/css层叠上下文、层叠等级、层叠顺序以及z-index.md","raw":"---\ntitle: css层叠上下文、层叠等级、层叠顺序以及z-index\ndate: 2020-08-05 16:11:04\ntags: css\ncategories: 前端\n---\n\n##### **css层叠上下文、层叠等级、层叠顺序以及z-index**\n\n- **层叠上下文**\n\n  > 层叠上下文是HTML中的一个三维概念。分为x轴、y轴、z轴，层叠上下文就是对这些HTML元素的三维构想。\n  >\n  > 满足一下任意一个条件及可形成层叠上下文：\n  >\n  > - 文档的根元素`<html>`\n  > - position值不为static（z-index值不为auto的元素）\n  > - flex容器的子元素（z-index值不为auto的元素）\n  > - grid容器的子元素（z-index值不为auto的元素）\n  > - opacity值小于1的元素\n  > - mix-blend-mode值不为normal的元素\n  > - css3属性（值不为none）\n  >   - transform\n  >   - filter\n  >   - perspective\n  >   - clip-path\n  >   - mask/mask-image/mask-border\n  > - isolation属性值为isolate的元素\n  > - -webkit-overflow-scrolling属性值为touch的元素\n  > - will-change\n  > - contain值为layout、paint或包含它们其中之一的合成值\n\n- **层叠等级**\n\n  > 层叠等级：\n  >\n  > - 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。\n  > - 在其他普通元素中，它描述的是这些普通元素在Z轴上的上下顺序。\n  > - 层叠等级的比较只有在当前层叠上下文中才有意义。不同层叠上下文的层叠等级比较是没有意义的。\n\n- **层叠顺序**\n\n  > 层叠顺序：表示元素发生层叠时按照特定的元素规则在Z轴上垂直显示。（层叠上下文和层叠等级是一种概念，而层叠顺序是一种规则）\n  >\n  > ![image-20200805170444733](./css层叠上下文、层叠等级、层叠顺序以及z-index/image-20200805170444733.png)\n\n- **比较流程**\n\n  > 1. 首先看比较的两个元素是否处在一个层叠上下文中\n  >\n  >    - 如果是，则谁的层叠等级大(层叠等级通过层叠顺序图来判断)，则谁在上边。\n  >\n  >    - 如果不是，则比较它们所处的层叠上下文的层叠等级\n  >\n  > 2. 当两个元素层叠等级相同、层叠顺序相同时，在dom结构中，后面的元素的层叠等级在前面的元素之上。\n  >\n  > ","slug":"css层叠上下文、层叠等级、层叠顺序以及z-index","published":1,"updated":"2024-02-19T07:42:51.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdr9z001q1xopf4z25vr7","content":"<h5 id=\"css层叠上下文、层叠等级、层叠顺序以及z-index\"><a href=\"#css层叠上下文、层叠等级、层叠顺序以及z-index\" class=\"headerlink\" title=\"css层叠上下文、层叠等级、层叠顺序以及z-index\"></a><strong>css层叠上下文、层叠等级、层叠顺序以及z-index</strong></h5><ul>\n<li><p><strong>层叠上下文</strong></p>\n<blockquote>\n<p>层叠上下文是HTML中的一个三维概念。分为x轴、y轴、z轴，层叠上下文就是对这些HTML元素的三维构想。</p>\n<p>满足一下任意一个条件及可形成层叠上下文：</p>\n<ul>\n<li>文档的根元素<code>&lt;html&gt;</code></li>\n<li>position值不为static（z-index值不为auto的元素）</li>\n<li>flex容器的子元素（z-index值不为auto的元素）</li>\n<li>grid容器的子元素（z-index值不为auto的元素）</li>\n<li>opacity值小于1的元素</li>\n<li>mix-blend-mode值不为normal的元素</li>\n<li>css3属性（值不为none）<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask/mask-image/mask-border</li>\n</ul>\n</li>\n<li>isolation属性值为isolate的元素</li>\n<li>-webkit-overflow-scrolling属性值为touch的元素</li>\n<li>will-change</li>\n<li>contain值为layout、paint或包含它们其中之一的合成值</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>层叠等级</strong></p>\n<blockquote>\n<p>层叠等级：</p>\n<ul>\n<li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。</li>\n<li>在其他普通元素中，它描述的是这些普通元素在Z轴上的上下顺序。</li>\n<li>层叠等级的比较只有在当前层叠上下文中才有意义。不同层叠上下文的层叠等级比较是没有意义的。</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>层叠顺序</strong></p>\n<blockquote>\n<p>层叠顺序：表示元素发生层叠时按照特定的元素规则在Z轴上垂直显示。（层叠上下文和层叠等级是一种概念，而层叠顺序是一种规则）</p>\n<p><img src=\"/2020/08/05/css%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E5%B1%82%E5%8F%A0%E7%AD%89%E7%BA%A7%E3%80%81%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8Az-index/image-20200805170444733.png\" alt=\"image-20200805170444733\"></p>\n</blockquote>\n</li>\n<li><p><strong>比较流程</strong></p>\n<blockquote>\n<ol>\n<li><p>首先看比较的两个元素是否处在一个层叠上下文中</p>\n<ul>\n<li><p>如果是，则谁的层叠等级大(层叠等级通过层叠顺序图来判断)，则谁在上边。</p>\n</li>\n<li><p>如果不是，则比较它们所处的层叠上下文的层叠等级</p>\n</li>\n</ul>\n</li>\n<li><p>当两个元素层叠等级相同、层叠顺序相同时，在dom结构中，后面的元素的层叠等级在前面的元素之上。</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"css层叠上下文、层叠等级、层叠顺序以及z-index\"><a href=\"#css层叠上下文、层叠等级、层叠顺序以及z-index\" class=\"headerlink\" title=\"css层叠上下文、层叠等级、层叠顺序以及z-index\"></a><strong>css层叠上下文、层叠等级、层叠顺序以及z-index</strong></h5><ul>\n<li><p><strong>层叠上下文</strong></p>\n<blockquote>\n<p>层叠上下文是HTML中的一个三维概念。分为x轴、y轴、z轴，层叠上下文就是对这些HTML元素的三维构想。</p>\n<p>满足一下任意一个条件及可形成层叠上下文：</p>\n<ul>\n<li>文档的根元素<code>&lt;html&gt;</code></li>\n<li>position值不为static（z-index值不为auto的元素）</li>\n<li>flex容器的子元素（z-index值不为auto的元素）</li>\n<li>grid容器的子元素（z-index值不为auto的元素）</li>\n<li>opacity值小于1的元素</li>\n<li>mix-blend-mode值不为normal的元素</li>\n<li>css3属性（值不为none）<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask/mask-image/mask-border</li>\n</ul>\n</li>\n<li>isolation属性值为isolate的元素</li>\n<li>-webkit-overflow-scrolling属性值为touch的元素</li>\n<li>will-change</li>\n<li>contain值为layout、paint或包含它们其中之一的合成值</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>层叠等级</strong></p>\n<blockquote>\n<p>层叠等级：</p>\n<ul>\n<li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。</li>\n<li>在其他普通元素中，它描述的是这些普通元素在Z轴上的上下顺序。</li>\n<li>层叠等级的比较只有在当前层叠上下文中才有意义。不同层叠上下文的层叠等级比较是没有意义的。</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>层叠顺序</strong></p>\n<blockquote>\n<p>层叠顺序：表示元素发生层叠时按照特定的元素规则在Z轴上垂直显示。（层叠上下文和层叠等级是一种概念，而层叠顺序是一种规则）</p>\n<p><img src=\"/2020/08/05/css%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E5%B1%82%E5%8F%A0%E7%AD%89%E7%BA%A7%E3%80%81%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E4%BB%A5%E5%8F%8Az-index/image-20200805170444733.png\" alt=\"image-20200805170444733\"></p>\n</blockquote>\n</li>\n<li><p><strong>比较流程</strong></p>\n<blockquote>\n<ol>\n<li><p>首先看比较的两个元素是否处在一个层叠上下文中</p>\n<ul>\n<li><p>如果是，则谁的层叠等级大(层叠等级通过层叠顺序图来判断)，则谁在上边。</p>\n</li>\n<li><p>如果不是，则比较它们所处的层叠上下文的层叠等级</p>\n</li>\n</ul>\n</li>\n<li><p>当两个元素层叠等级相同、层叠顺序相同时，在dom结构中，后面的元素的层叠等级在前面的元素之上。</p>\n</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n"},{"title":"css3新增的常见属性","date":"2018-10-11T10:51:38.000Z","_content":"\n### css3新增属性\n\n1. ##### css3 边框\n\n   - border-radius：该属性允许为元素添加圆角边框\n\n     > 语法：\n     >\n     > ```css\n     > border-radius:1-4 length;\n     > ```\n     >\n     > 1-4：四个方向，可以只设置一个所有都生效。\n\n   - box-shadow：为方框添加一个或多个阴影\n\n     > 语法：\n     >\n     > ```css\n     > box-shadow: h-shadow v-shadow blur spread color inset;\n     > ```\n     >\n     > h-shadow：水平阴影的位置。（必需）\n     >\n     > v-shadow：垂直阴影的位置。（必需）\n     >\n     > blur：模糊距离。（可选）\n     >\n     > spread：阴影的尺寸。（可选）\n     >\n     > color：阴影的颜色。（可选）\n     >\n     > inset：将外部阴影改为内部阴影。（可选）\n\n   - border-image：该属性规定用于边框的图片\n\n     > 定义和用法：\n     >\n     > border-image 属性是一个简写属性，用于设置以下属性：\n     >\n     > - border-image-source：用在边框的图片的路径\n     > - border-image-slice：图片边框向内偏移。\n     > - border-image-width：图片边框的宽度。\n     > - border-image-outset：边框图像区域超出边框的量。\n     > - border-image-repeat：图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。\n\n2. ##### css3 背景\n\n   - background-size：规定背景图片的尺寸。\n\n     > 语法：\n     >\n     > ```css\n     > background-size:length|percentage|cover|contain;\n     > ```\n     >\n     > | 值         | 描述                                                         |\n     > | ---------- | ------------------------------------------------------------ |\n     > | length     | 设置背景图片的高度和宽度，第一个值设置宽度，第二个设置高度。如果只设置一个值，则第二个值被设为auto |\n     > | percentage | 以父元素的百分比来设置背景图片的宽高。同上                   |\n     > | cover      | 把北京图像扩展至足够大，以使背景图像完全覆盖背景区域         |\n     > | contain    | 把图像扩展至最大尺寸，以使其宽高完全适应内容区域             |\n     >\n     >\n\n   - background-clip：规定背景的绘制区域。\n\n     > 语法：\n     >\n     > ```css\n     > background-clip:border-box|padding-box|content-box;\n     > ```\n     >\n     > | 值          | 描述                 |\n     > | ----------- | -------------------- |\n     > | border-box  | 背景被裁剪到边框盒   |\n     > | padding-box | 背景被裁剪到内边距框 |\n     > | content-box | 背景被裁剪到内容框   |\n\n   - background-origin：规定背景图片的定位区域。\n\n     > 语法：\n     >\n     > ```css\n     > background-origin:padding-box|border-box|content-box;\n     > ```\n     >\n     > | 值          | 描述                           |\n     > | ----------- | ------------------------------ |\n     > | padding-box | 背景图像相对于内边距框来定位。 |\n     > | border-box  | 背景图像相对于边框盒来定位。   |\n     > | content-box | 背景图像相对于内容框来定位。   |\n\n3. ##### css3 文本效果\n\n   - text-shadow：向文本添加阴影\n\n     > 语法：\n     >\n     > ```css\n     > text-shadow: h-shadow v-shadow blur color;\n     > ```\n     >\n     > | 值         | 描述                             |\n     > | ---------- | -------------------------------- |\n     > | *h-shadow* | 必需。水平阴影的位置。允许负值。 |\n     > | *v-shadow* | 必需。垂直阴影的位置。允许负值。 |\n     > | *blur*     | 可选。模糊的距离。               |\n     > | *color*    | 可选。阴影的颜色。               |\n\n   - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行。\n\n     > 语法：\n     >\n     > ```css\n     > word-wrap: normal|break-word;\n     > ```\n     >\n     > | 值         | 描述                                         |\n     > | ---------- | -------------------------------------------- |\n     > | normal     | 只在允许的断字点换行（浏览器保持默认处理）。 |\n     > | break-word | 在长单词或 URL 地址内部进行换行。            |\n\n4. ##### css3 字体\n\n   @font-face规则：使用这个规则后，可以将想要使用的字体放到服务器中，它会在需要时被用户自动下载到本地计算机。\n\n   ```css\n   @font-face{\n    font-family: myfirstFont;\t\t/*必需规定的字体的名称*/\n    src:url('Sansation_Light.ttf'),\t/*定义字体的URL*/\n        url('Sansation_Light.eot'); /* IE9+ */\n   }\n   div{\n       font-family:myfirstFont;\t/*使用自己定义的字体*/\n   }\n   ```\n\n5. ##### css3 2D转换\n\n   - transform：向元素应用2D或3D转换\n\n     ## 实例\n\n     旋转 div 元素：\n\n     ```css\n     div\n     {\n     transform:rotate(7deg);\n     -ms-transform:rotate(7deg); \t/* IE 9 */\n     -moz-transform:rotate(7deg); \t/* Firefox */\n     -webkit-transform:rotate(7deg); /* Safari 和 Chrome */\n     -o-transform:rotate(7deg); \t/* Opera */\n     }\n     ```\n\n   - transform-origin：允许改变被转换元素的位置（必需配合transform使用）\n\n     > 语法：\n     >\n     > ```css\n     > transform-origin: x-axis y-axis z-axis;\n     > ```\n     >\n     > | 值     | 描述                                                         |\n     > | ------ | ------------------------------------------------------------ |\n     > | x-axis | 定义视图被置于 X 轴的何处。可能的值：leftcenterright*length**%* |\n     > | y-axis | 定义视图被置于 Y 轴的何处。可能的值：topcenterbottom*length**%* |\n     > | z-axis | 定义视图被置于 Z 轴的何处。可能的值：*length*                |\n     >\n     > ## 实例\n     >\n     > 设置旋转元素的基点位置：\n     >\n     > ```css\n     > div\n     > {\n     > transform: rotate(45deg);\n     > transform-origin:20% 40%;\n     > \n     > -ms-transform: rotate(45deg); \t\t/* IE 9 */\n     > -ms-transform-origin:20% 40%; \t\t/* IE 9 */\n     > \n     > -webkit-transform: rotate(45deg);\t/* Safari 和 Chrome */\n     > -webkit-transform-origin:20% 40%;\t/* Safari 和 Chrome */\n     > \n     > -moz-transform: rotate(45deg);\t\t/* Firefox */\n     > -moz-transform-origin:20% 40%;\t\t/* Firefox */\n     > \n     > -o-transform: rotate(45deg);\t\t/* Opera */\n     > -o-transform-origin:20% 40%;\t\t/* Opera */\n     > }\n     > ```\n\n   - translate(x,y)：定义 2D 转换，沿着 X 和 Y 轴移动元素。\n\n   - rotate(angle)：定义 2D 旋转，在参数中规定角度。\n\n   - scale(x,y)：定义 2D 缩放转换，改变元素的宽度和高度。\n\n   - skew(x-angle,y-angle)：定义 2D 倾斜转换，沿着 X 和 Y 轴。\n\n   - matrix(*n*,*n*,*n*,*n*,*n*,*n*)：定义 2D 转换，使用六个值的矩阵。\n\n6. ##### css3 3D转换\n\n   - transform-style：规定被嵌套元素如何在 3D 空间中显示\n\n     > 语法：\n     >\n     > ```css\n     > transform-style: flat|preserve-3d;\n     > ```\n     >\n     > | 值          | 描述                       |\n     > | ----------- | -------------------------- |\n     > | flat        | 子元素将不保留其 3D 位置。 |\n     > | preserve-3d | 子元素将保留其 3D 位置。   |\n     >\n     > ## 实例\n     >\n     > 使被转换的子元素保留其 3D 转换：\n     >\n     > ```css\n     > div\n     > {\n     > transform: rotateY(60deg);\n     > transform-style: preserve-3d;\n     > -webkit-transform: rotateY(60deg);\t/* Safari 和 Chrome */\n     > -webkit-transform-style: preserve-3d;\t/* Safari 和 Chrome */\n     > }\n     > ```\n\n   - perspective：规定 3D 元素的透视效果(目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性)\n\n     > 语法：\n     >\n     > ```css\n     > perspective: number|none;\n     > ```\n     >\n     > | 值       | 描述                            |\n     > | -------- | ------------------------------- |\n     > | *number* | 元素距离视图的距离，以像素计。  |\n     > | none     | 默认值。与 0 相同。不设置透视。 |\n     >\n     > ## 实例\n     >\n     > 设置元素被查看位置的视图：\n     >\n     > ```css\n     > div\n     > {\n     > perspective: 500;\n     > -webkit-perspective: 500; /* Safari 和 Chrome */\n     > }\n     > ```\n\n   - perspective-origin：规定 3D 元素的底部位置\n\n     > 语法:\n     >\n     > ```css\n     > perspective-origin: x-axis y-axis;\n     > ```\n     >\n     > | 值       | 描述                                                         |\n     > | -------- | ------------------------------------------------------------ |\n     > | *x-axis* | 定义该视图在 x 轴上的位置。默认值：50%。可能的值：leftcenterright*length**%* |\n     > | *y-axis* | 定义该视图在 y 轴上的位置。默认值：50%。可能的值：topcenterbottom*length**%* |\n     >\n     > ## 实例\n     >\n     > 设置 3D 元素的基点位置：\n     >\n     > ```css\n     > div\n     > {\n     > perspective:150;\n     > perspective-origin: 10% 10%;\n     > -webkit-perspective:150;\t/* Safari 和 Chrome */\n     > -webkit-perspective-origin: 10% 10%;\t/* Safari 和 Chrome */\n     > }\n     > ```\n\n   - backface-visibility：定义元素在不面对屏幕时是否可见\n\n     >语法:\n     >\n     >```css\n     >backface-visibility: visible|hidden;\n     >```\n     >\n     >| 值      | 描述             |\n     >| ------- | ---------------- |\n     >| visible | 背面是可见的。   |\n     >| hidden  | 背面是不可见的。 |\n     >\n     >## 实例\n     >\n     >隐藏被旋转的 div 元素的背面：\n     >\n     >```css\n     >div\n     >{\n     >backface-visibility:hidden;\n     >-webkit-backface-visibility:hidden;\t/* Chrome 和 Safari */\n     >-moz-backface-visibility:hidden; \t/* Firefox */\n     >-ms-backface-visibility:hidden; \t/* Internet Explorer */\n     >}\n     >```\n\n7. ##### css3 过渡\n\n   - transition：简写属性，用于在一个属性中设置四个过渡属性。\n\n     > 语法：\n     >\n     > ```css\n     > transition: property duration timing-function delay;\n     > ```\n     >\n     > | 值                         | 描述                                |\n     > | -------------------------- | ----------------------------------- |\n     > | transition-property        | 规定设置过渡效果的 CSS 属性的名称。 |\n     > | transition-duration        | 规定完成过渡效果需要多少秒或毫秒。  |\n     > | transition-timing-function | 规定速度效果的速度曲线。            |\n     > | transition-delay           | 定义过渡效果何时开始。              |\n     >\n     > ### 实例\n     >\n     > 应用于宽度属性的过渡效果，时长为 2 秒：\n     >\n     > ```css\n     > div\n     > {\n     > transition: width 2s;\n     > -moz-transition: width 2s;\t/* Firefox 4 */\n     > -webkit-transition: width 2s;\t/* Safari 和 Chrome */\n     > -o-transition: width 2s;\t/* Opera */\n     > }\n     > div:hover\n     > {\n     > width:300px;\n     > }\n     > ```\n\n8. ##### css3 动画\n\n   - @keyframes：规定动画\n\n     > 语法：\n     >\n     > ```css\n     > @keyframes animationname {\n     >     keyframes-selector {'css-styles';}\n     > }\n     > ```\n     >\n     > | 值                   | 描述                                                         |\n     > | -------------------- | ------------------------------------------------------------ |\n     > | *animationname*      | 必需。定义动画的名称。                                       |\n     > | *keyframes-selector* | 必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同） |\n     > | *css-styles*         | 必需。一个或多个合法的 CSS 样式属性。                        |\n\n   - animation：所有动画属性的简写属性，除了 animation-play-state 属性。\n\n     > 语法：\n     >\n     > ```css\n     > animation: name duration timing-function delay iteration-count direction;\n     > ```\n     >\n     > | 值                          | 描述                                     |\n     > | --------------------------- | ---------------------------------------- |\n     > | *animation-name*            | 规定需要绑定到选择器的 keyframe 名称。。 |\n     > | *animation-duration*        | 规定完成动画所花费的时间，以秒或毫秒计。 |\n     > | *animation-timing-function* | 规定动画的速度曲线。                     |\n     > | *animation-delay*           | 规定在动画开始之前的延迟。               |\n     > | *animation-iteration-count* | 规定动画应该播放的次数。                 |\n     > | *animation-direction*       | 规定是否应该轮流反向播放动画。           |\n     >\n     > ## 实例\n     >\n     > ```css\n     > @keyframes myfirst\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-moz-keyframes myfirst /* Firefox */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-webkit-keyframes myfirst /* Safari 和 Chrome */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-o-keyframes myfirst /* Opera */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > div\n     > {\n     > animation: myfirst 5s;\n     > -moz-animation: myfirst 5s;\t/* Firefox */\n     > -webkit-animation: myfirst 5s;\t/* Safari 和 Chrome */\n     > -o-animation: myfirst 5s;\t/* Opera */\n     > }\n     > ```\n\n9. ##### css3多列\n\n   - column-count：属性规定元素应该被分隔的列数。\n\n     > 语法：\n     >\n     > ```css\n     > column-count: number|auto;\n     > ```\n     >\n     > | 值       | 描述                                      |\n     > | -------- | ----------------------------------------- |\n     > | *number* | 元素内容将被划分的最佳列数。              |\n     > | auto     | 由其他属性决定列数，比如 \"column-width\"。 |\n     >\n     > ### 实例\n     >\n     > 把 div 元素中的文本分隔为三列：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-count:3; \t/* Firefox */\n     > -webkit-column-count:3; /* Safari 和 Chrome */\n     > column-count:3;\n     > }\n     > ```\n\n   - column-gap：属性规定列之间的间隔。\n\n     > 语法：\n     >\n     > ```css\n     > column-gap: length|normal;\n     > ```\n     >\n     > | 值       | 描述                                               |\n     > | -------- | -------------------------------------------------- |\n     > | *length* | 把列间的间隔设置为指定的长度。                     |\n     > | normal   | 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。 |\n     >\n     > ### 实例\n     >\n     > 规定列之间 40 像素的间隔：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-gap:40px;\t\t/* Firefox */\n     > -webkit-column-gap:40px;\t/* Safari 和 Chrome */\n     > column-gap:40px;\n     > }\n     > ```\n\n   - column-rule：属性设置列之间的宽度、样式和颜色规则。\n\n     > 语法：\n     >\n     > ```css\n     > column-rule: column-rule-width column-rule-style column-rule-color;\n     > ```\n     >\n     > | 值                  | 描述                   |\n     > | ------------------- | ---------------------- |\n     > | *column-rule-width* | 设置列之间的宽度规则。 |\n     > | *column-rule-style* | 设置列之间的样式规则。 |\n     > | *column-rule-color* | 设置列之间的颜色规则。 |\n     >\n     > ### 实例\n     >\n     > 规定列之间的宽度、样式和颜色规则：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-rule:3px outset #ff0000;\t/* Firefox */\n     > -webkit-column-rule:3px outset #ff0000;\t/* Safari and Chrome */\n     > column-rule:3px outset #ff0000;\n     > }\n     > ```\n\n10. ##### css3 用户界面\n\n    - resize：resize ：属性规定是否可由用户调整元素尺寸。\n\n      > 语法：\n      >\n      > ```css\n      > resize: none|both|horizontal|vertical;\n      > ```\n      >\n      > | 值         | 描述                         |\n      > | ---------- | ---------------------------- |\n      > | none       | 用户无法调整元素的尺寸。     |\n      > | both       | 用户可调整元素的高度和宽度。 |\n      > | horizontal | 用户可调整元素的宽度。       |\n      > | vertical   | 用户可调整元素的高度。       |\n      >\n      > ## 实例\n      >\n      > 规定可以由用户调整 div 元素的大小：\n      >\n      > ```css\n      > div\n      > {\n      > resize:both;\n      > overflow:auto;\n      > }\n      > ```\n\n    - box-sizing：属性允许您以确切的方式定义适应某个区域的具体内容。\n\n      > 语法：\n      >\n      > ```css\n      > box-sizing: content-box|border-box|inherit;\n      > ```\n      >\n      > | 值          | 描述                                                         |\n      > | ----------- | ------------------------------------------------------------ |\n      > | content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n      > | border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n      > | inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |\n      >\n      > ## 实例\n      >\n      > 规定两个并排的带边框的框：\n      >\n      > ```css\n      > div\n      > {\n      > box-sizing:border-box;\n      > -moz-box-sizing:border-box; /* Firefox */\n      > -webkit-box-sizing:border-box; /* Safari */\n      > width:50%;\n      > float:left;\n      > }\n      > ```\n\n    - outline-offset：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\n\n      > 语法：\n      >\n      > ```css\n      > outline-offset: length|inherit;\n      > ```\n      >\n      > | 值       | 描述                                         |\n      > | -------- | -------------------------------------------- |\n      > | *length* | 轮廓与边框边缘的距离。                       |\n      > | inherit  | 规定应从父元素继承 outline-offset 属性的值。 |\n      >\n      > ## 实例\n      >\n      > 规定边框边缘之外 15 像素处的轮廓：\n      >\n      > ```css\n      > div\n      > {\n      > border:2px solid black;\n      > outline:2px solid red;\n      > outline-offset:15px;\n      > }\n      > ```\n      >\n      > 轮廓在两方面与边框不同：\n      >\n      > - 轮廓不占用空间\n      > - 轮廓可能是非矩形\n\n**transition与animation最大的区别：**\n\ntransition需要事件触发，animation不需要。","source":"_posts/css3新增的常见属性.md","raw":"---\ntitle: css3新增的常见属性\ndate: 2018-10-11 18:51:38\ntags: css\ncategories: 前端\n---\n\n### css3新增属性\n\n1. ##### css3 边框\n\n   - border-radius：该属性允许为元素添加圆角边框\n\n     > 语法：\n     >\n     > ```css\n     > border-radius:1-4 length;\n     > ```\n     >\n     > 1-4：四个方向，可以只设置一个所有都生效。\n\n   - box-shadow：为方框添加一个或多个阴影\n\n     > 语法：\n     >\n     > ```css\n     > box-shadow: h-shadow v-shadow blur spread color inset;\n     > ```\n     >\n     > h-shadow：水平阴影的位置。（必需）\n     >\n     > v-shadow：垂直阴影的位置。（必需）\n     >\n     > blur：模糊距离。（可选）\n     >\n     > spread：阴影的尺寸。（可选）\n     >\n     > color：阴影的颜色。（可选）\n     >\n     > inset：将外部阴影改为内部阴影。（可选）\n\n   - border-image：该属性规定用于边框的图片\n\n     > 定义和用法：\n     >\n     > border-image 属性是一个简写属性，用于设置以下属性：\n     >\n     > - border-image-source：用在边框的图片的路径\n     > - border-image-slice：图片边框向内偏移。\n     > - border-image-width：图片边框的宽度。\n     > - border-image-outset：边框图像区域超出边框的量。\n     > - border-image-repeat：图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。\n\n2. ##### css3 背景\n\n   - background-size：规定背景图片的尺寸。\n\n     > 语法：\n     >\n     > ```css\n     > background-size:length|percentage|cover|contain;\n     > ```\n     >\n     > | 值         | 描述                                                         |\n     > | ---------- | ------------------------------------------------------------ |\n     > | length     | 设置背景图片的高度和宽度，第一个值设置宽度，第二个设置高度。如果只设置一个值，则第二个值被设为auto |\n     > | percentage | 以父元素的百分比来设置背景图片的宽高。同上                   |\n     > | cover      | 把北京图像扩展至足够大，以使背景图像完全覆盖背景区域         |\n     > | contain    | 把图像扩展至最大尺寸，以使其宽高完全适应内容区域             |\n     >\n     >\n\n   - background-clip：规定背景的绘制区域。\n\n     > 语法：\n     >\n     > ```css\n     > background-clip:border-box|padding-box|content-box;\n     > ```\n     >\n     > | 值          | 描述                 |\n     > | ----------- | -------------------- |\n     > | border-box  | 背景被裁剪到边框盒   |\n     > | padding-box | 背景被裁剪到内边距框 |\n     > | content-box | 背景被裁剪到内容框   |\n\n   - background-origin：规定背景图片的定位区域。\n\n     > 语法：\n     >\n     > ```css\n     > background-origin:padding-box|border-box|content-box;\n     > ```\n     >\n     > | 值          | 描述                           |\n     > | ----------- | ------------------------------ |\n     > | padding-box | 背景图像相对于内边距框来定位。 |\n     > | border-box  | 背景图像相对于边框盒来定位。   |\n     > | content-box | 背景图像相对于内容框来定位。   |\n\n3. ##### css3 文本效果\n\n   - text-shadow：向文本添加阴影\n\n     > 语法：\n     >\n     > ```css\n     > text-shadow: h-shadow v-shadow blur color;\n     > ```\n     >\n     > | 值         | 描述                             |\n     > | ---------- | -------------------------------- |\n     > | *h-shadow* | 必需。水平阴影的位置。允许负值。 |\n     > | *v-shadow* | 必需。垂直阴影的位置。允许负值。 |\n     > | *blur*     | 可选。模糊的距离。               |\n     > | *color*    | 可选。阴影的颜色。               |\n\n   - word-wrap：允许对长的不可分割的单词进行分割并换行到下一行。\n\n     > 语法：\n     >\n     > ```css\n     > word-wrap: normal|break-word;\n     > ```\n     >\n     > | 值         | 描述                                         |\n     > | ---------- | -------------------------------------------- |\n     > | normal     | 只在允许的断字点换行（浏览器保持默认处理）。 |\n     > | break-word | 在长单词或 URL 地址内部进行换行。            |\n\n4. ##### css3 字体\n\n   @font-face规则：使用这个规则后，可以将想要使用的字体放到服务器中，它会在需要时被用户自动下载到本地计算机。\n\n   ```css\n   @font-face{\n    font-family: myfirstFont;\t\t/*必需规定的字体的名称*/\n    src:url('Sansation_Light.ttf'),\t/*定义字体的URL*/\n        url('Sansation_Light.eot'); /* IE9+ */\n   }\n   div{\n       font-family:myfirstFont;\t/*使用自己定义的字体*/\n   }\n   ```\n\n5. ##### css3 2D转换\n\n   - transform：向元素应用2D或3D转换\n\n     ## 实例\n\n     旋转 div 元素：\n\n     ```css\n     div\n     {\n     transform:rotate(7deg);\n     -ms-transform:rotate(7deg); \t/* IE 9 */\n     -moz-transform:rotate(7deg); \t/* Firefox */\n     -webkit-transform:rotate(7deg); /* Safari 和 Chrome */\n     -o-transform:rotate(7deg); \t/* Opera */\n     }\n     ```\n\n   - transform-origin：允许改变被转换元素的位置（必需配合transform使用）\n\n     > 语法：\n     >\n     > ```css\n     > transform-origin: x-axis y-axis z-axis;\n     > ```\n     >\n     > | 值     | 描述                                                         |\n     > | ------ | ------------------------------------------------------------ |\n     > | x-axis | 定义视图被置于 X 轴的何处。可能的值：leftcenterright*length**%* |\n     > | y-axis | 定义视图被置于 Y 轴的何处。可能的值：topcenterbottom*length**%* |\n     > | z-axis | 定义视图被置于 Z 轴的何处。可能的值：*length*                |\n     >\n     > ## 实例\n     >\n     > 设置旋转元素的基点位置：\n     >\n     > ```css\n     > div\n     > {\n     > transform: rotate(45deg);\n     > transform-origin:20% 40%;\n     > \n     > -ms-transform: rotate(45deg); \t\t/* IE 9 */\n     > -ms-transform-origin:20% 40%; \t\t/* IE 9 */\n     > \n     > -webkit-transform: rotate(45deg);\t/* Safari 和 Chrome */\n     > -webkit-transform-origin:20% 40%;\t/* Safari 和 Chrome */\n     > \n     > -moz-transform: rotate(45deg);\t\t/* Firefox */\n     > -moz-transform-origin:20% 40%;\t\t/* Firefox */\n     > \n     > -o-transform: rotate(45deg);\t\t/* Opera */\n     > -o-transform-origin:20% 40%;\t\t/* Opera */\n     > }\n     > ```\n\n   - translate(x,y)：定义 2D 转换，沿着 X 和 Y 轴移动元素。\n\n   - rotate(angle)：定义 2D 旋转，在参数中规定角度。\n\n   - scale(x,y)：定义 2D 缩放转换，改变元素的宽度和高度。\n\n   - skew(x-angle,y-angle)：定义 2D 倾斜转换，沿着 X 和 Y 轴。\n\n   - matrix(*n*,*n*,*n*,*n*,*n*,*n*)：定义 2D 转换，使用六个值的矩阵。\n\n6. ##### css3 3D转换\n\n   - transform-style：规定被嵌套元素如何在 3D 空间中显示\n\n     > 语法：\n     >\n     > ```css\n     > transform-style: flat|preserve-3d;\n     > ```\n     >\n     > | 值          | 描述                       |\n     > | ----------- | -------------------------- |\n     > | flat        | 子元素将不保留其 3D 位置。 |\n     > | preserve-3d | 子元素将保留其 3D 位置。   |\n     >\n     > ## 实例\n     >\n     > 使被转换的子元素保留其 3D 转换：\n     >\n     > ```css\n     > div\n     > {\n     > transform: rotateY(60deg);\n     > transform-style: preserve-3d;\n     > -webkit-transform: rotateY(60deg);\t/* Safari 和 Chrome */\n     > -webkit-transform-style: preserve-3d;\t/* Safari 和 Chrome */\n     > }\n     > ```\n\n   - perspective：规定 3D 元素的透视效果(目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性)\n\n     > 语法：\n     >\n     > ```css\n     > perspective: number|none;\n     > ```\n     >\n     > | 值       | 描述                            |\n     > | -------- | ------------------------------- |\n     > | *number* | 元素距离视图的距离，以像素计。  |\n     > | none     | 默认值。与 0 相同。不设置透视。 |\n     >\n     > ## 实例\n     >\n     > 设置元素被查看位置的视图：\n     >\n     > ```css\n     > div\n     > {\n     > perspective: 500;\n     > -webkit-perspective: 500; /* Safari 和 Chrome */\n     > }\n     > ```\n\n   - perspective-origin：规定 3D 元素的底部位置\n\n     > 语法:\n     >\n     > ```css\n     > perspective-origin: x-axis y-axis;\n     > ```\n     >\n     > | 值       | 描述                                                         |\n     > | -------- | ------------------------------------------------------------ |\n     > | *x-axis* | 定义该视图在 x 轴上的位置。默认值：50%。可能的值：leftcenterright*length**%* |\n     > | *y-axis* | 定义该视图在 y 轴上的位置。默认值：50%。可能的值：topcenterbottom*length**%* |\n     >\n     > ## 实例\n     >\n     > 设置 3D 元素的基点位置：\n     >\n     > ```css\n     > div\n     > {\n     > perspective:150;\n     > perspective-origin: 10% 10%;\n     > -webkit-perspective:150;\t/* Safari 和 Chrome */\n     > -webkit-perspective-origin: 10% 10%;\t/* Safari 和 Chrome */\n     > }\n     > ```\n\n   - backface-visibility：定义元素在不面对屏幕时是否可见\n\n     >语法:\n     >\n     >```css\n     >backface-visibility: visible|hidden;\n     >```\n     >\n     >| 值      | 描述             |\n     >| ------- | ---------------- |\n     >| visible | 背面是可见的。   |\n     >| hidden  | 背面是不可见的。 |\n     >\n     >## 实例\n     >\n     >隐藏被旋转的 div 元素的背面：\n     >\n     >```css\n     >div\n     >{\n     >backface-visibility:hidden;\n     >-webkit-backface-visibility:hidden;\t/* Chrome 和 Safari */\n     >-moz-backface-visibility:hidden; \t/* Firefox */\n     >-ms-backface-visibility:hidden; \t/* Internet Explorer */\n     >}\n     >```\n\n7. ##### css3 过渡\n\n   - transition：简写属性，用于在一个属性中设置四个过渡属性。\n\n     > 语法：\n     >\n     > ```css\n     > transition: property duration timing-function delay;\n     > ```\n     >\n     > | 值                         | 描述                                |\n     > | -------------------------- | ----------------------------------- |\n     > | transition-property        | 规定设置过渡效果的 CSS 属性的名称。 |\n     > | transition-duration        | 规定完成过渡效果需要多少秒或毫秒。  |\n     > | transition-timing-function | 规定速度效果的速度曲线。            |\n     > | transition-delay           | 定义过渡效果何时开始。              |\n     >\n     > ### 实例\n     >\n     > 应用于宽度属性的过渡效果，时长为 2 秒：\n     >\n     > ```css\n     > div\n     > {\n     > transition: width 2s;\n     > -moz-transition: width 2s;\t/* Firefox 4 */\n     > -webkit-transition: width 2s;\t/* Safari 和 Chrome */\n     > -o-transition: width 2s;\t/* Opera */\n     > }\n     > div:hover\n     > {\n     > width:300px;\n     > }\n     > ```\n\n8. ##### css3 动画\n\n   - @keyframes：规定动画\n\n     > 语法：\n     >\n     > ```css\n     > @keyframes animationname {\n     >     keyframes-selector {'css-styles';}\n     > }\n     > ```\n     >\n     > | 值                   | 描述                                                         |\n     > | -------------------- | ------------------------------------------------------------ |\n     > | *animationname*      | 必需。定义动画的名称。                                       |\n     > | *keyframes-selector* | 必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同） |\n     > | *css-styles*         | 必需。一个或多个合法的 CSS 样式属性。                        |\n\n   - animation：所有动画属性的简写属性，除了 animation-play-state 属性。\n\n     > 语法：\n     >\n     > ```css\n     > animation: name duration timing-function delay iteration-count direction;\n     > ```\n     >\n     > | 值                          | 描述                                     |\n     > | --------------------------- | ---------------------------------------- |\n     > | *animation-name*            | 规定需要绑定到选择器的 keyframe 名称。。 |\n     > | *animation-duration*        | 规定完成动画所花费的时间，以秒或毫秒计。 |\n     > | *animation-timing-function* | 规定动画的速度曲线。                     |\n     > | *animation-delay*           | 规定在动画开始之前的延迟。               |\n     > | *animation-iteration-count* | 规定动画应该播放的次数。                 |\n     > | *animation-direction*       | 规定是否应该轮流反向播放动画。           |\n     >\n     > ## 实例\n     >\n     > ```css\n     > @keyframes myfirst\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-moz-keyframes myfirst /* Firefox */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-webkit-keyframes myfirst /* Safari 和 Chrome */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > \n     > @-o-keyframes myfirst /* Opera */\n     > {\n     > from {background: red;}\n     > to {background: yellow;}\n     > }\n     > div\n     > {\n     > animation: myfirst 5s;\n     > -moz-animation: myfirst 5s;\t/* Firefox */\n     > -webkit-animation: myfirst 5s;\t/* Safari 和 Chrome */\n     > -o-animation: myfirst 5s;\t/* Opera */\n     > }\n     > ```\n\n9. ##### css3多列\n\n   - column-count：属性规定元素应该被分隔的列数。\n\n     > 语法：\n     >\n     > ```css\n     > column-count: number|auto;\n     > ```\n     >\n     > | 值       | 描述                                      |\n     > | -------- | ----------------------------------------- |\n     > | *number* | 元素内容将被划分的最佳列数。              |\n     > | auto     | 由其他属性决定列数，比如 \"column-width\"。 |\n     >\n     > ### 实例\n     >\n     > 把 div 元素中的文本分隔为三列：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-count:3; \t/* Firefox */\n     > -webkit-column-count:3; /* Safari 和 Chrome */\n     > column-count:3;\n     > }\n     > ```\n\n   - column-gap：属性规定列之间的间隔。\n\n     > 语法：\n     >\n     > ```css\n     > column-gap: length|normal;\n     > ```\n     >\n     > | 值       | 描述                                               |\n     > | -------- | -------------------------------------------------- |\n     > | *length* | 把列间的间隔设置为指定的长度。                     |\n     > | normal   | 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。 |\n     >\n     > ### 实例\n     >\n     > 规定列之间 40 像素的间隔：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-gap:40px;\t\t/* Firefox */\n     > -webkit-column-gap:40px;\t/* Safari 和 Chrome */\n     > column-gap:40px;\n     > }\n     > ```\n\n   - column-rule：属性设置列之间的宽度、样式和颜色规则。\n\n     > 语法：\n     >\n     > ```css\n     > column-rule: column-rule-width column-rule-style column-rule-color;\n     > ```\n     >\n     > | 值                  | 描述                   |\n     > | ------------------- | ---------------------- |\n     > | *column-rule-width* | 设置列之间的宽度规则。 |\n     > | *column-rule-style* | 设置列之间的样式规则。 |\n     > | *column-rule-color* | 设置列之间的颜色规则。 |\n     >\n     > ### 实例\n     >\n     > 规定列之间的宽度、样式和颜色规则：\n     >\n     > ```css\n     > div\n     > {\n     > -moz-column-rule:3px outset #ff0000;\t/* Firefox */\n     > -webkit-column-rule:3px outset #ff0000;\t/* Safari and Chrome */\n     > column-rule:3px outset #ff0000;\n     > }\n     > ```\n\n10. ##### css3 用户界面\n\n    - resize：resize ：属性规定是否可由用户调整元素尺寸。\n\n      > 语法：\n      >\n      > ```css\n      > resize: none|both|horizontal|vertical;\n      > ```\n      >\n      > | 值         | 描述                         |\n      > | ---------- | ---------------------------- |\n      > | none       | 用户无法调整元素的尺寸。     |\n      > | both       | 用户可调整元素的高度和宽度。 |\n      > | horizontal | 用户可调整元素的宽度。       |\n      > | vertical   | 用户可调整元素的高度。       |\n      >\n      > ## 实例\n      >\n      > 规定可以由用户调整 div 元素的大小：\n      >\n      > ```css\n      > div\n      > {\n      > resize:both;\n      > overflow:auto;\n      > }\n      > ```\n\n    - box-sizing：属性允许您以确切的方式定义适应某个区域的具体内容。\n\n      > 语法：\n      >\n      > ```css\n      > box-sizing: content-box|border-box|inherit;\n      > ```\n      >\n      > | 值          | 描述                                                         |\n      > | ----------- | ------------------------------------------------------------ |\n      > | content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n      > | border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n      > | inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |\n      >\n      > ## 实例\n      >\n      > 规定两个并排的带边框的框：\n      >\n      > ```css\n      > div\n      > {\n      > box-sizing:border-box;\n      > -moz-box-sizing:border-box; /* Firefox */\n      > -webkit-box-sizing:border-box; /* Safari */\n      > width:50%;\n      > float:left;\n      > }\n      > ```\n\n    - outline-offset：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。\n\n      > 语法：\n      >\n      > ```css\n      > outline-offset: length|inherit;\n      > ```\n      >\n      > | 值       | 描述                                         |\n      > | -------- | -------------------------------------------- |\n      > | *length* | 轮廓与边框边缘的距离。                       |\n      > | inherit  | 规定应从父元素继承 outline-offset 属性的值。 |\n      >\n      > ## 实例\n      >\n      > 规定边框边缘之外 15 像素处的轮廓：\n      >\n      > ```css\n      > div\n      > {\n      > border:2px solid black;\n      > outline:2px solid red;\n      > outline-offset:15px;\n      > }\n      > ```\n      >\n      > 轮廓在两方面与边框不同：\n      >\n      > - 轮廓不占用空间\n      > - 轮廓可能是非矩形\n\n**transition与animation最大的区别：**\n\ntransition需要事件触发，animation不需要。","slug":"css3新增的常见属性","published":1,"updated":"2024-02-19T07:42:51.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdra3001u1xop7307c4i4","content":"<h3 id=\"css3新增属性\"><a href=\"#css3新增属性\" class=\"headerlink\" title=\"css3新增属性\"></a>css3新增属性</h3><ol>\n<li><h5 id=\"css3-边框\"><a href=\"#css3-边框\" class=\"headerlink\" title=\"css3 边框\"></a>css3 边框</h5><ul>\n<li><p>border-radius：该属性允许为元素添加圆角边框</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">border-radius</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>-<span class=\"token number\">4</span> length<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>1-4：四个方向，可以只设置一个所有都生效。</p>\n</blockquote>\n</li>\n<li><p>box-shadow：为方框添加一个或多个阴影</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">box-shadow</span><span class=\"token punctuation\">:</span> h-shadow v-shadow blur spread color inset<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>h-shadow：水平阴影的位置。（必需）</p>\n<p>v-shadow：垂直阴影的位置。（必需）</p>\n<p>blur：模糊距离。（可选）</p>\n<p>spread：阴影的尺寸。（可选）</p>\n<p>color：阴影的颜色。（可选）</p>\n<p>inset：将外部阴影改为内部阴影。（可选）</p>\n</blockquote>\n</li>\n<li><p>border-image：该属性规定用于边框的图片</p>\n<blockquote>\n<p>定义和用法：</p>\n<p>border-image 属性是一个简写属性，用于设置以下属性：</p>\n<ul>\n<li>border-image-source：用在边框的图片的路径</li>\n<li>border-image-slice：图片边框向内偏移。</li>\n<li>border-image-width：图片边框的宽度。</li>\n<li>border-image-outset：边框图像区域超出边框的量。</li>\n<li>border-image-repeat：图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-背景\"><a href=\"#css3-背景\" class=\"headerlink\" title=\"css3 背景\"></a>css3 背景</h5><ul>\n<li><p>background-size：规定背景图片的尺寸。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">background-size</span><span class=\"token punctuation\">:</span>length|percentage|cover|contain<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值         | 描述                                                         |<br>| ———- | ———————————————————— |<br>| length     | 设置背景图片的高度和宽度，第一个值设置宽度，第二个设置高度。如果只设置一个值，则第二个值被设为auto |<br>| percentage | 以父元素的百分比来设置背景图片的宽高。同上                   |<br>| cover      | 把北京图像扩展至足够大，以使背景图像完全覆盖背景区域         |<br>| contain    | 把图像扩展至最大尺寸，以使其宽高完全适应内容区域             |</p>\n</blockquote>\n</li>\n<li><p>background-clip：规定背景的绘制区域。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">background-clip</span><span class=\"token punctuation\">:</span>border-box|padding-box|content-box<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值          | 描述                 |<br>| ———– | ——————– |<br>| border-box  | 背景被裁剪到边框盒   |<br>| padding-box | 背景被裁剪到内边距框 |<br>| content-box | 背景被裁剪到内容框   |</p>\n</blockquote>\n</li>\n<li><p>background-origin：规定背景图片的定位区域。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">background-origin</span><span class=\"token punctuation\">:</span>padding-box|border-box|content-box<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值          | 描述                           |<br>| ———– | —————————— |<br>| padding-box | 背景图像相对于内边距框来定位。 |<br>| border-box  | 背景图像相对于边框盒来定位。   |<br>| content-box | 背景图像相对于内容框来定位。   |</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-文本效果\"><a href=\"#css3-文本效果\" class=\"headerlink\" title=\"css3 文本效果\"></a>css3 文本效果</h5><ul>\n<li><p>text-shadow：向文本添加阴影</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">text-shadow</span><span class=\"token punctuation\">:</span> h-shadow v-shadow blur color<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值         | 描述                             |<br>| ———- | ——————————– |<br>| <em>h-shadow</em> | 必需。水平阴影的位置。允许负值。 |<br>| <em>v-shadow</em> | 必需。垂直阴影的位置。允许负值。 |<br>| <em>blur</em>     | 可选。模糊的距离。               |<br>| <em>color</em>    | 可选。阴影的颜色。               |</p>\n</blockquote>\n</li>\n<li><p>word-wrap：允许对长的不可分割的单词进行分割并换行到下一行。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">word-wrap</span><span class=\"token punctuation\">:</span> normal|break-word<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值         | 描述                                         |<br>| ———- | ——————————————– |<br>| normal     | 只在允许的断字点换行（浏览器保持默认处理）。 |<br>| break-word | 在长单词或 URL 地址内部进行换行。            |</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-字体\"><a href=\"#css3-字体\" class=\"headerlink\" title=\"css3 字体\"></a>css3 字体</h5><p>@font-face规则：使用这个规则后，可以将想要使用的字体放到服务器中，它会在需要时被用户自动下载到本地计算机。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token atrule\"><span class=\"token rule\">@font-face</span></span><span class=\"token punctuation\">{</span>\n <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span> myfirstFont<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/*必需规定的字体的名称*/</span>\n <span class=\"token property\">src</span><span class=\"token punctuation\">:</span><span class=\"token url\">url('Sansation_Light.ttf')</span>,    <span class=\"token comment\" spellcheck=\"true\">/*定义字体的URL*/</span>\n     <span class=\"token url\">url('Sansation_Light.eot')</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* IE9+ */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">div</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">font-family</span><span class=\"token punctuation\">:</span>myfirstFont<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/*使用自己定义的字体*/</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><h5 id=\"css3-2D转换\"><a href=\"#css3-2D转换\" class=\"headerlink\" title=\"css3 2D转换\"></a>css3 2D转换</h5><ul>\n<li><p>transform：向元素应用2D或3D转换</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>旋转 div 元素：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">transform</span><span class=\"token punctuation\">:</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">-ms-transform</span><span class=\"token punctuation\">:</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* IE 9 */</span>\n<span class=\"token property\">-moz-transform</span><span class=\"token punctuation\">:</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-transform</span><span class=\"token punctuation\">:</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-o-transform</span><span class=\"token punctuation\">:</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>transform-origin：允许改变被转换元素的位置（必需配合transform使用）</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">transform-origin</span><span class=\"token punctuation\">:</span> x-axis y-axis z-axis<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值     | 描述                                                         |<br>| —— | ———————————————————— |<br>| x-axis | 定义视图被置于 X 轴的何处。可能的值：leftcenterright<em>length**%</em> |<br>| y-axis | 定义视图被置于 Y 轴的何处。可能的值：topcenterbottom<em>length**%</em> |<br>| z-axis | 定义视图被置于 Z 轴的何处。可能的值：<em>length</em>                |</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置旋转元素的基点位置：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">transform-origin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20%</span> <span class=\"token number\">40%</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token property\">-ms-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\" spellcheck=\"true\">/* IE 9 */</span>\n<span class=\"token property\">-ms-transform-origin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20%</span> <span class=\"token number\">40%</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\" spellcheck=\"true\">/* IE 9 */</span>\n\n<span class=\"token property\">-webkit-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-webkit-transform-origin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20%</span> <span class=\"token number\">40%</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n\n<span class=\"token property\">-moz-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-moz-transform-origin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20%</span> <span class=\"token number\">40%</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n\n<span class=\"token property\">-o-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span><span class=\"token number\">45</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token property\">-o-transform-origin</span><span class=\"token punctuation\">:</span><span class=\"token number\">20%</span> <span class=\"token number\">40%</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>translate(x,y)：定义 2D 转换，沿着 X 和 Y 轴移动元素。</p>\n</li>\n<li><p>rotate(angle)：定义 2D 旋转，在参数中规定角度。</p>\n</li>\n<li><p>scale(x,y)：定义 2D 缩放转换，改变元素的宽度和高度。</p>\n</li>\n<li><p>skew(x-angle,y-angle)：定义 2D 倾斜转换，沿着 X 和 Y 轴。</p>\n</li>\n<li><p>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)：定义 2D 转换，使用六个值的矩阵。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-3D转换\"><a href=\"#css3-3D转换\" class=\"headerlink\" title=\"css3 3D转换\"></a>css3 3D转换</h5><ul>\n<li><p>transform-style：规定被嵌套元素如何在 3D 空间中显示</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">transform-style</span><span class=\"token punctuation\">:</span> flat|preserve-<span class=\"token number\">3</span>d<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值          | 描述                       |<br>| ———– | ————————– |<br>| flat        | 子元素将不保留其 3D 位置。 |<br>| preserve-3d | 子元素将保留其 3D 位置。   |</p>\n<h2 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>使被转换的子元素保留其 3D 转换：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotateY</span><span class=\"token punctuation\">(</span><span class=\"token number\">60</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">transform-style</span><span class=\"token punctuation\">:</span> preserve-<span class=\"token number\">3</span>d<span class=\"token punctuation\">;</span>\n<span class=\"token property\">-webkit-transform</span><span class=\"token punctuation\">:</span> <span class=\"token function\">rotateY</span><span class=\"token punctuation\">(</span><span class=\"token number\">60</span>deg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-webkit-transform-style</span><span class=\"token punctuation\">:</span> preserve-<span class=\"token number\">3</span>d<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>perspective：规定 3D 元素的透视效果(目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性)</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">perspective</span><span class=\"token punctuation\">:</span> number|none<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值       | 描述                            |<br>| ——– | ——————————- |<br>| <em>number</em> | 元素距离视图的距离，以像素计。  |<br>| none     | 默认值。与 0 相同。不设置透视。 |</p>\n<h2 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置元素被查看位置的视图：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">perspective</span><span class=\"token punctuation\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">-webkit-perspective</span><span class=\"token punctuation\">:</span> <span class=\"token number\">500</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>perspective-origin：规定 3D 元素的底部位置</p>\n<blockquote>\n<p>语法:</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">perspective-origin</span><span class=\"token punctuation\">:</span> x-axis y-axis<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值       | 描述                                                         |<br>| ——– | ———————————————————— |<br>| <em>x-axis</em> | 定义该视图在 x 轴上的位置。默认值：50%。可能的值：leftcenterright<em>length**%</em> |<br>| <em>y-axis</em> | 定义该视图在 y 轴上的位置。默认值：50%。可能的值：topcenterbottom<em>length**%</em> |</p>\n<h2 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置 3D 元素的基点位置：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">perspective</span><span class=\"token punctuation\">:</span><span class=\"token number\">150</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">perspective-origin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10%</span> <span class=\"token number\">10%</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">-webkit-perspective</span><span class=\"token punctuation\">:</span><span class=\"token number\">150</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-webkit-perspective-origin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10%</span> <span class=\"token number\">10%</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>backface-visibility：定义元素在不面对屏幕时是否可见</p>\n<blockquote>\n<p>语法:</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">backface-visibility</span><span class=\"token punctuation\">:</span> visible|hidden<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值      | 描述             |<br>| ——- | —————- |<br>| visible | 背面是可见的。   |<br>| hidden  | 背面是不可见的。 |</p>\n<h2 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>隐藏被旋转的 div 元素的背面：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">backface-visibility</span><span class=\"token punctuation\">:</span>hidden<span class=\"token punctuation\">;</span>\n<span class=\"token property\">-webkit-backface-visibility</span><span class=\"token punctuation\">:</span>hidden<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Chrome 和 Safari */</span>\n<span class=\"token property\">-moz-backface-visibility</span><span class=\"token punctuation\">:</span>hidden<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-ms-backface-visibility</span><span class=\"token punctuation\">:</span>hidden<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Internet Explorer */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-过渡\"><a href=\"#css3-过渡\" class=\"headerlink\" title=\"css3 过渡\"></a>css3 过渡</h5><ul>\n<li><p>transition：简写属性，用于在一个属性中设置四个过渡属性。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">transition</span><span class=\"token punctuation\">:</span> property duration timing-function delay<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值                         | 描述                                |<br>| ————————– | ———————————– |<br>| transition-property        | 规定设置过渡效果的 CSS 属性的名称。 |<br>| transition-duration        | 规定完成过渡效果需要多少秒或毫秒。  |<br>| transition-timing-function | 规定速度效果的速度曲线。            |<br>| transition-delay           | 定义过渡效果何时开始。              |</p>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>应用于宽度属性的过渡效果，时长为 2 秒：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">transition</span><span class=\"token punctuation\">:</span> width <span class=\"token number\">2</span>s<span class=\"token punctuation\">;</span>\n<span class=\"token property\">-moz-transition</span><span class=\"token punctuation\">:</span> width <span class=\"token number\">2</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Firefox 4 */</span>\n<span class=\"token property\">-webkit-transition</span><span class=\"token punctuation\">:</span> width <span class=\"token number\">2</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-o-transition</span><span class=\"token punctuation\">:</span> width <span class=\"token number\">2</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">div<span class=\"token pseudo-class\">:hover</span>\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-动画\"><a href=\"#css3-动画\" class=\"headerlink\" title=\"css3 动画\"></a>css3 动画</h5><ul>\n<li><p>@keyframes：规定动画</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token atrule\"><span class=\"token rule\">@keyframes</span> animationname</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token selector\">keyframes-selector </span><span class=\"token punctuation\">{</span><span class=\"token string\">'css-styles'</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>| 值                   | 描述                                                         |<br>| ——————– | ———————————————————— |<br>| <em>animationname</em>      | 必需。定义动画的名称。                                       |<br>| <em>keyframes-selector</em> | 必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同） |<br>| <em>css-styles</em>         | 必需。一个或多个合法的 CSS 样式属性。                        |</p>\n</blockquote>\n</li>\n<li><p>animation：所有动画属性的简写属性，除了 animation-play-state 属性。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">animation</span><span class=\"token punctuation\">:</span> name duration timing-function delay iteration-count direction<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值                          | 描述                                     |<br>| ————————— | —————————————- |<br>| <em>animation-name</em>            | 规定需要绑定到选择器的 keyframe 名称。。 |<br>| <em>animation-duration</em>        | 规定完成动画所花费的时间，以秒或毫秒计。 |<br>| <em>animation-timing-function</em> | 规定动画的速度曲线。                     |<br>| <em>animation-delay</em>           | 规定在动画开始之前的延迟。               |<br>| <em>animation-iteration-count</em> | 规定动画应该播放的次数。                 |<br>| <em>animation-direction</em>       | 规定是否应该轮流反向播放动画。           |</p>\n<h2 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h2><pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token atrule\"><span class=\"token rule\">@keyframes</span> myfirst</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token selector\">from </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">to </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> yellow<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n@-moz-keyframes myfirst <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token selector\">from </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">to </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> yellow<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n@-webkit-keyframes myfirst <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token selector\">from </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">to </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> yellow<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n@-o-keyframes myfirst <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token selector\">from </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> red<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">to </span><span class=\"token punctuation\">{</span><span class=\"token property\">background</span><span class=\"token punctuation\">:</span> yellow<span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">animation</span><span class=\"token punctuation\">:</span> myfirst <span class=\"token number\">5</span>s<span class=\"token punctuation\">;</span>\n<span class=\"token property\">-moz-animation</span><span class=\"token punctuation\">:</span> myfirst <span class=\"token number\">5</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-animation</span><span class=\"token punctuation\">:</span> myfirst <span class=\"token number\">5</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">-o-animation</span><span class=\"token punctuation\">:</span> myfirst <span class=\"token number\">5</span>s<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Opera */</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3多列\"><a href=\"#css3多列\" class=\"headerlink\" title=\"css3多列\"></a>css3多列</h5><ul>\n<li><p>column-count：属性规定元素应该被分隔的列数。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">column-count</span><span class=\"token punctuation\">:</span> number|auto<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值       | 描述                                      |<br>| ——– | —————————————– |<br>| <em>number</em> | 元素内容将被划分的最佳列数。              |<br>| auto     | 由其他属性决定列数，比如 “column-width”。 |</p>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>把 div 元素中的文本分隔为三列：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">-moz-column-count</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-column-count</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">column-count</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>column-gap：属性规定列之间的间隔。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">column-gap</span><span class=\"token punctuation\">:</span> length|normal<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值       | 描述                                               |<br>| ——– | ————————————————– |<br>| <em>length</em> | 把列间的间隔设置为指定的长度。                     |<br>| normal   | 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。 |</p>\n<h3 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>规定列之间 40 像素的间隔：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">-moz-column-gap</span><span class=\"token punctuation\">:</span><span class=\"token number\">40</span>px<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-column-gap</span><span class=\"token punctuation\">:</span><span class=\"token number\">40</span>px<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari 和 Chrome */</span>\n<span class=\"token property\">column-gap</span><span class=\"token punctuation\">:</span><span class=\"token number\">40</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>column-rule：属性设置列之间的宽度、样式和颜色规则。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">column-rule</span><span class=\"token punctuation\">:</span> column-rule-width column-rule-style column-rule-color<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值                  | 描述                   |<br>| ——————- | ———————- |<br>| <em>column-rule-width</em> | 设置列之间的宽度规则。 |<br>| <em>column-rule-style</em> | 设置列之间的样式规则。 |<br>| <em>column-rule-color</em> | 设置列之间的颜色规则。 |</p>\n<h3 id=\"实例-10\"><a href=\"#实例-10\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>规定列之间的宽度、样式和颜色规则：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">-moz-column-rule</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span>px outset <span class=\"token hexcode\">#ff0000</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-column-rule</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span>px outset <span class=\"token hexcode\">#ff0000</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Safari and Chrome */</span>\n<span class=\"token property\">column-rule</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span>px outset <span class=\"token hexcode\">#ff0000</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-用户界面\"><a href=\"#css3-用户界面\" class=\"headerlink\" title=\"css3 用户界面\"></a>css3 用户界面</h5><ul>\n<li><p>resize：resize ：属性规定是否可由用户调整元素尺寸。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">resize</span><span class=\"token punctuation\">:</span> none|both|horizontal|vertical<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值         | 描述                         |<br>| ———- | —————————- |<br>| none       | 用户无法调整元素的尺寸。     |<br>| both       | 用户可调整元素的高度和宽度。 |<br>| horizontal | 用户可调整元素的宽度。       |<br>| vertical   | 用户可调整元素的高度。       |</p>\n<h2 id=\"实例-11\"><a href=\"#实例-11\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定可以由用户调整 div 元素的大小：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">resize</span><span class=\"token punctuation\">:</span>both<span class=\"token punctuation\">;</span>\n<span class=\"token property\">overflow</span><span class=\"token punctuation\">:</span>auto<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>box-sizing：属性允许您以确切的方式定义适应某个区域的具体内容。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span> content-box|border-box|inherit<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值          | 描述                                                         |<br>| ———– | ———————————————————— |<br>| content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |<br>| border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |<br>| inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |</p>\n<h2 id=\"实例-12\"><a href=\"#实例-12\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定两个并排的带边框的框：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span>border-box<span class=\"token punctuation\">;</span>\n<span class=\"token property\">-moz-box-sizing</span><span class=\"token punctuation\">:</span>border-box<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* Firefox */</span>\n<span class=\"token property\">-webkit-box-sizing</span><span class=\"token punctuation\">:</span>border-box<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* Safari */</span>\n<span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">50%</span><span class=\"token punctuation\">;</span>\n<span class=\"token property\">float</span><span class=\"token punctuation\">:</span>left<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>outline-offset：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>\n<blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">outline-offset</span><span class=\"token punctuation\">:</span> length|inherit<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>| 值       | 描述                                         |<br>| ——– | ——————————————– |<br>| <em>length</em> | 轮廓与边框边缘的距离。                       |<br>| inherit  | 规定应从父元素继承 outline-offset 属性的值。 |</p>\n<h2 id=\"实例-13\"><a href=\"#实例-13\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定边框边缘之外 15 像素处的轮廓：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">div\n</span><span class=\"token punctuation\">{</span>\n<span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span>px solid black<span class=\"token punctuation\">;</span>\n<span class=\"token property\">outline</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span>px solid red<span class=\"token punctuation\">;</span>\n<span class=\"token property\">outline-offset</span><span class=\"token punctuation\">:</span><span class=\"token number\">15</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>轮廓在两方面与边框不同：</p>\n<ul>\n<li>轮廓不占用空间</li>\n<li>轮廓可能是非矩形</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>transition与animation最大的区别：</strong></p>\n<p>transition需要事件触发，animation不需要。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"css3新增属性\"><a href=\"#css3新增属性\" class=\"headerlink\" title=\"css3新增属性\"></a>css3新增属性</h3><ol>\n<li><h5 id=\"css3-边框\"><a href=\"#css3-边框\" class=\"headerlink\" title=\"css3 边框\"></a>css3 边框</h5><ul>\n<li><p>border-radius：该属性允许为元素添加圆角边框</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">border-radius:1-4 length;\n</code></pre>\n<p>1-4：四个方向，可以只设置一个所有都生效。</p>\n</blockquote>\n</li>\n<li><p>box-shadow：为方框添加一个或多个阴影</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">box-shadow: h-shadow v-shadow blur spread color inset;\n</code></pre>\n<p>h-shadow：水平阴影的位置。（必需）</p>\n<p>v-shadow：垂直阴影的位置。（必需）</p>\n<p>blur：模糊距离。（可选）</p>\n<p>spread：阴影的尺寸。（可选）</p>\n<p>color：阴影的颜色。（可选）</p>\n<p>inset：将外部阴影改为内部阴影。（可选）</p>\n</blockquote>\n</li>\n<li><p>border-image：该属性规定用于边框的图片</p>\n<blockquote>\n<p>定义和用法：</p>\n<p>border-image 属性是一个简写属性，用于设置以下属性：</p>\n<ul>\n<li>border-image-source：用在边框的图片的路径</li>\n<li>border-image-slice：图片边框向内偏移。</li>\n<li>border-image-width：图片边框的宽度。</li>\n<li>border-image-outset：边框图像区域超出边框的量。</li>\n<li>border-image-repeat：图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-背景\"><a href=\"#css3-背景\" class=\"headerlink\" title=\"css3 背景\"></a>css3 背景</h5><ul>\n<li><p>background-size：规定背景图片的尺寸。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">background-size:length|percentage|cover|contain;\n</code></pre>\n<p>| 值         | 描述                                                         |<br>| ———- | ———————————————————— |<br>| length     | 设置背景图片的高度和宽度，第一个值设置宽度，第二个设置高度。如果只设置一个值，则第二个值被设为auto |<br>| percentage | 以父元素的百分比来设置背景图片的宽高。同上                   |<br>| cover      | 把北京图像扩展至足够大，以使背景图像完全覆盖背景区域         |<br>| contain    | 把图像扩展至最大尺寸，以使其宽高完全适应内容区域             |</p>\n</blockquote>\n</li>\n<li><p>background-clip：规定背景的绘制区域。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">background-clip:border-box|padding-box|content-box;\n</code></pre>\n<p>| 值          | 描述                 |<br>| ———– | ——————– |<br>| border-box  | 背景被裁剪到边框盒   |<br>| padding-box | 背景被裁剪到内边距框 |<br>| content-box | 背景被裁剪到内容框   |</p>\n</blockquote>\n</li>\n<li><p>background-origin：规定背景图片的定位区域。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">background-origin:padding-box|border-box|content-box;\n</code></pre>\n<p>| 值          | 描述                           |<br>| ———– | —————————— |<br>| padding-box | 背景图像相对于内边距框来定位。 |<br>| border-box  | 背景图像相对于边框盒来定位。   |<br>| content-box | 背景图像相对于内容框来定位。   |</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-文本效果\"><a href=\"#css3-文本效果\" class=\"headerlink\" title=\"css3 文本效果\"></a>css3 文本效果</h5><ul>\n<li><p>text-shadow：向文本添加阴影</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">text-shadow: h-shadow v-shadow blur color;\n</code></pre>\n<p>| 值         | 描述                             |<br>| ———- | ——————————– |<br>| <em>h-shadow</em> | 必需。水平阴影的位置。允许负值。 |<br>| <em>v-shadow</em> | 必需。垂直阴影的位置。允许负值。 |<br>| <em>blur</em>     | 可选。模糊的距离。               |<br>| <em>color</em>    | 可选。阴影的颜色。               |</p>\n</blockquote>\n</li>\n<li><p>word-wrap：允许对长的不可分割的单词进行分割并换行到下一行。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">word-wrap: normal|break-word;\n</code></pre>\n<p>| 值         | 描述                                         |<br>| ———- | ——————————————– |<br>| normal     | 只在允许的断字点换行（浏览器保持默认处理）。 |<br>| break-word | 在长单词或 URL 地址内部进行换行。            |</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-字体\"><a href=\"#css3-字体\" class=\"headerlink\" title=\"css3 字体\"></a>css3 字体</h5><p>@font-face规则：使用这个规则后，可以将想要使用的字体放到服务器中，它会在需要时被用户自动下载到本地计算机。</p>\n<pre><code class=\"css\">@font-face{\n font-family: myfirstFont;        /*必需规定的字体的名称*/\n src:url(&#39;Sansation_Light.ttf&#39;),    /*定义字体的URL*/\n     url(&#39;Sansation_Light.eot&#39;); /* IE9+ */\n}\ndiv{\n    font-family:myfirstFont;    /*使用自己定义的字体*/\n}\n</code></pre>\n</li>\n<li><h5 id=\"css3-2D转换\"><a href=\"#css3-2D转换\" class=\"headerlink\" title=\"css3 2D转换\"></a>css3 2D转换</h5><ul>\n<li><p>transform：向元素应用2D或3D转换</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>旋转 div 元素：</p>\n<pre><code class=\"css\">div\n{\ntransform:rotate(7deg);\n-ms-transform:rotate(7deg);     /* IE 9 */\n-moz-transform:rotate(7deg);     /* Firefox */\n-webkit-transform:rotate(7deg); /* Safari 和 Chrome */\n-o-transform:rotate(7deg);     /* Opera */\n}\n</code></pre>\n</li>\n<li><p>transform-origin：允许改变被转换元素的位置（必需配合transform使用）</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">transform-origin: x-axis y-axis z-axis;\n</code></pre>\n<p>| 值     | 描述                                                         |<br>| —— | ———————————————————— |<br>| x-axis | 定义视图被置于 X 轴的何处。可能的值：leftcenterright<em>length**%</em> |<br>| y-axis | 定义视图被置于 Y 轴的何处。可能的值：topcenterbottom<em>length**%</em> |<br>| z-axis | 定义视图被置于 Z 轴的何处。可能的值：<em>length</em>                |</p>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置旋转元素的基点位置：</p>\n<pre><code class=\"css\">div\n{\ntransform: rotate(45deg);\ntransform-origin:20% 40%;\n\n-ms-transform: rotate(45deg);         /* IE 9 */\n-ms-transform-origin:20% 40%;         /* IE 9 */\n\n-webkit-transform: rotate(45deg);    /* Safari 和 Chrome */\n-webkit-transform-origin:20% 40%;    /* Safari 和 Chrome */\n\n-moz-transform: rotate(45deg);        /* Firefox */\n-moz-transform-origin:20% 40%;        /* Firefox */\n\n-o-transform: rotate(45deg);        /* Opera */\n-o-transform-origin:20% 40%;        /* Opera */\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>translate(x,y)：定义 2D 转换，沿着 X 和 Y 轴移动元素。</p>\n</li>\n<li><p>rotate(angle)：定义 2D 旋转，在参数中规定角度。</p>\n</li>\n<li><p>scale(x,y)：定义 2D 缩放转换，改变元素的宽度和高度。</p>\n</li>\n<li><p>skew(x-angle,y-angle)：定义 2D 倾斜转换，沿着 X 和 Y 轴。</p>\n</li>\n<li><p>matrix(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)：定义 2D 转换，使用六个值的矩阵。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-3D转换\"><a href=\"#css3-3D转换\" class=\"headerlink\" title=\"css3 3D转换\"></a>css3 3D转换</h5><ul>\n<li><p>transform-style：规定被嵌套元素如何在 3D 空间中显示</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">transform-style: flat|preserve-3d;\n</code></pre>\n<p>| 值          | 描述                       |<br>| ———– | ————————– |<br>| flat        | 子元素将不保留其 3D 位置。 |<br>| preserve-3d | 子元素将保留其 3D 位置。   |</p>\n<h2 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>使被转换的子元素保留其 3D 转换：</p>\n<pre><code class=\"css\">div\n{\ntransform: rotateY(60deg);\ntransform-style: preserve-3d;\n-webkit-transform: rotateY(60deg);    /* Safari 和 Chrome */\n-webkit-transform-style: preserve-3d;    /* Safari 和 Chrome */\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>perspective：规定 3D 元素的透视效果(目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性)</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">perspective: number|none;\n</code></pre>\n<p>| 值       | 描述                            |<br>| ——– | ——————————- |<br>| <em>number</em> | 元素距离视图的距离，以像素计。  |<br>| none     | 默认值。与 0 相同。不设置透视。 |</p>\n<h2 id=\"实例-3\"><a href=\"#实例-3\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置元素被查看位置的视图：</p>\n<pre><code class=\"css\">div\n{\nperspective: 500;\n-webkit-perspective: 500; /* Safari 和 Chrome */\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>perspective-origin：规定 3D 元素的底部位置</p>\n<blockquote>\n<p>语法:</p>\n<pre><code class=\"css\">perspective-origin: x-axis y-axis;\n</code></pre>\n<p>| 值       | 描述                                                         |<br>| ——– | ———————————————————— |<br>| <em>x-axis</em> | 定义该视图在 x 轴上的位置。默认值：50%。可能的值：leftcenterright<em>length**%</em> |<br>| <em>y-axis</em> | 定义该视图在 y 轴上的位置。默认值：50%。可能的值：topcenterbottom<em>length**%</em> |</p>\n<h2 id=\"实例-4\"><a href=\"#实例-4\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>设置 3D 元素的基点位置：</p>\n<pre><code class=\"css\">div\n{\nperspective:150;\nperspective-origin: 10% 10%;\n-webkit-perspective:150;    /* Safari 和 Chrome */\n-webkit-perspective-origin: 10% 10%;    /* Safari 和 Chrome */\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>backface-visibility：定义元素在不面对屏幕时是否可见</p>\n<blockquote>\n<p>语法:</p>\n<pre><code class=\"css\">backface-visibility: visible|hidden;\n</code></pre>\n<p>| 值      | 描述             |<br>| ——- | —————- |<br>| visible | 背面是可见的。   |<br>| hidden  | 背面是不可见的。 |</p>\n<h2 id=\"实例-5\"><a href=\"#实例-5\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>隐藏被旋转的 div 元素的背面：</p>\n<pre><code class=\"css\">div\n{\nbackface-visibility:hidden;\n-webkit-backface-visibility:hidden;    /* Chrome 和 Safari */\n-moz-backface-visibility:hidden;     /* Firefox */\n-ms-backface-visibility:hidden;     /* Internet Explorer */\n}\n</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-过渡\"><a href=\"#css3-过渡\" class=\"headerlink\" title=\"css3 过渡\"></a>css3 过渡</h5><ul>\n<li><p>transition：简写属性，用于在一个属性中设置四个过渡属性。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">transition: property duration timing-function delay;\n</code></pre>\n<p>| 值                         | 描述                                |<br>| ————————– | ———————————– |<br>| transition-property        | 规定设置过渡效果的 CSS 属性的名称。 |<br>| transition-duration        | 规定完成过渡效果需要多少秒或毫秒。  |<br>| transition-timing-function | 规定速度效果的速度曲线。            |<br>| transition-delay           | 定义过渡效果何时开始。              |</p>\n<h3 id=\"实例-6\"><a href=\"#实例-6\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>应用于宽度属性的过渡效果，时长为 2 秒：</p>\n<pre><code class=\"css\">div\n{\ntransition: width 2s;\n-moz-transition: width 2s;    /* Firefox 4 */\n-webkit-transition: width 2s;    /* Safari 和 Chrome */\n-o-transition: width 2s;    /* Opera */\n}\ndiv:hover\n{\nwidth:300px;\n}\n</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-动画\"><a href=\"#css3-动画\" class=\"headerlink\" title=\"css3 动画\"></a>css3 动画</h5><ul>\n<li><p>@keyframes：规定动画</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">@keyframes animationname {\n    keyframes-selector {&#39;css-styles&#39;;}\n}\n</code></pre>\n<p>| 值                   | 描述                                                         |<br>| ——————– | ———————————————————— |<br>| <em>animationname</em>      | 必需。定义动画的名称。                                       |<br>| <em>keyframes-selector</em> | 必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同） |<br>| <em>css-styles</em>         | 必需。一个或多个合法的 CSS 样式属性。                        |</p>\n</blockquote>\n</li>\n<li><p>animation：所有动画属性的简写属性，除了 animation-play-state 属性。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">animation: name duration timing-function delay iteration-count direction;\n</code></pre>\n<p>| 值                          | 描述                                     |<br>| ————————— | —————————————- |<br>| <em>animation-name</em>            | 规定需要绑定到选择器的 keyframe 名称。。 |<br>| <em>animation-duration</em>        | 规定完成动画所花费的时间，以秒或毫秒计。 |<br>| <em>animation-timing-function</em> | 规定动画的速度曲线。                     |<br>| <em>animation-delay</em>           | 规定在动画开始之前的延迟。               |<br>| <em>animation-iteration-count</em> | 规定动画应该播放的次数。                 |<br>| <em>animation-direction</em>       | 规定是否应该轮流反向播放动画。           |</p>\n<h2 id=\"实例-7\"><a href=\"#实例-7\" class=\"headerlink\" title=\"实例\"></a>实例</h2><pre><code class=\"css\">@keyframes myfirst\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-moz-keyframes myfirst /* Firefox */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-webkit-keyframes myfirst /* Safari 和 Chrome */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\n\n@-o-keyframes myfirst /* Opera */\n{\nfrom {background: red;}\nto {background: yellow;}\n}\ndiv\n{\nanimation: myfirst 5s;\n-moz-animation: myfirst 5s;    /* Firefox */\n-webkit-animation: myfirst 5s;    /* Safari 和 Chrome */\n-o-animation: myfirst 5s;    /* Opera */\n}\n</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3多列\"><a href=\"#css3多列\" class=\"headerlink\" title=\"css3多列\"></a>css3多列</h5><ul>\n<li><p>column-count：属性规定元素应该被分隔的列数。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">column-count: number|auto;\n</code></pre>\n<p>| 值       | 描述                                      |<br>| ——– | —————————————– |<br>| <em>number</em> | 元素内容将被划分的最佳列数。              |<br>| auto     | 由其他属性决定列数，比如 “column-width”。 |</p>\n<h3 id=\"实例-8\"><a href=\"#实例-8\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>把 div 元素中的文本分隔为三列：</p>\n<pre><code class=\"css\">div\n{\n-moz-column-count:3;     /* Firefox */\n-webkit-column-count:3; /* Safari 和 Chrome */\ncolumn-count:3;\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>column-gap：属性规定列之间的间隔。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">column-gap: length|normal;\n</code></pre>\n<p>| 值       | 描述                                               |<br>| ——– | ————————————————– |<br>| <em>length</em> | 把列间的间隔设置为指定的长度。                     |<br>| normal   | 规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。 |</p>\n<h3 id=\"实例-9\"><a href=\"#实例-9\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>规定列之间 40 像素的间隔：</p>\n<pre><code class=\"css\">div\n{\n-moz-column-gap:40px;        /* Firefox */\n-webkit-column-gap:40px;    /* Safari 和 Chrome */\ncolumn-gap:40px;\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>column-rule：属性设置列之间的宽度、样式和颜色规则。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">column-rule: column-rule-width column-rule-style column-rule-color;\n</code></pre>\n<p>| 值                  | 描述                   |<br>| ——————- | ———————- |<br>| <em>column-rule-width</em> | 设置列之间的宽度规则。 |<br>| <em>column-rule-style</em> | 设置列之间的样式规则。 |<br>| <em>column-rule-color</em> | 设置列之间的颜色规则。 |</p>\n<h3 id=\"实例-10\"><a href=\"#实例-10\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>规定列之间的宽度、样式和颜色规则：</p>\n<pre><code class=\"css\">div\n{\n-moz-column-rule:3px outset #ff0000;    /* Firefox */\n-webkit-column-rule:3px outset #ff0000;    /* Safari and Chrome */\ncolumn-rule:3px outset #ff0000;\n}\n</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><h5 id=\"css3-用户界面\"><a href=\"#css3-用户界面\" class=\"headerlink\" title=\"css3 用户界面\"></a>css3 用户界面</h5><ul>\n<li><p>resize：resize ：属性规定是否可由用户调整元素尺寸。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">resize: none|both|horizontal|vertical;\n</code></pre>\n<p>| 值         | 描述                         |<br>| ———- | —————————- |<br>| none       | 用户无法调整元素的尺寸。     |<br>| both       | 用户可调整元素的高度和宽度。 |<br>| horizontal | 用户可调整元素的宽度。       |<br>| vertical   | 用户可调整元素的高度。       |</p>\n<h2 id=\"实例-11\"><a href=\"#实例-11\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定可以由用户调整 div 元素的大小：</p>\n<pre><code class=\"css\">div\n{\nresize:both;\noverflow:auto;\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>box-sizing：属性允许您以确切的方式定义适应某个区域的具体内容。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">box-sizing: content-box|border-box|inherit;\n</code></pre>\n<p>| 值          | 描述                                                         |<br>| ———– | ———————————————————— |<br>| content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |<br>| border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |<br>| inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |</p>\n<h2 id=\"实例-12\"><a href=\"#实例-12\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定两个并排的带边框的框：</p>\n<pre><code class=\"css\">div\n{\nbox-sizing:border-box;\n-moz-box-sizing:border-box; /* Firefox */\n-webkit-box-sizing:border-box; /* Safari */\nwidth:50%;\nfloat:left;\n}\n</code></pre>\n</blockquote>\n</li>\n<li><p>outline-offset：属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p>\n<blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">outline-offset: length|inherit;\n</code></pre>\n<p>| 值       | 描述                                         |<br>| ——– | ——————————————– |<br>| <em>length</em> | 轮廓与边框边缘的距离。                       |<br>| inherit  | 规定应从父元素继承 outline-offset 属性的值。 |</p>\n<h2 id=\"实例-13\"><a href=\"#实例-13\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>规定边框边缘之外 15 像素处的轮廓：</p>\n<pre><code class=\"css\">div\n{\nborder:2px solid black;\noutline:2px solid red;\noutline-offset:15px;\n}\n</code></pre>\n<p>轮廓在两方面与边框不同：</p>\n<ul>\n<li>轮廓不占用空间</li>\n<li>轮廓可能是非矩形</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>transition与animation最大的区别：</strong></p>\n<p>transition需要事件触发，animation不需要。</p>\n"},{"title":"css盒模型","date":"2018-10-11T09:58:23.000Z","_content":"\n### css盒模型\n\n**css盒模型组成：content区域+margin+padding+border。**\n\n> **css3的box-sizing：**\n>\n> ## 语法\n>\n> ```css\n> box-sizing: content-box|border-box|inherit;\n> ```\n>\n> | 值          | 描述                                                         |\n> | ----------- | ------------------------------------------------------------ |\n> | content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n> | border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n> | inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |\n\n\n\n##### css的盒模型分为两种\n\n1. W3C标准盒模型\n2. IE标准盒模型\n\n市面上大多数浏览器都采用W3C标准的盒模型。\n\n由于标准不同，所以就产生了两种盒模型。\n\n```html\n<style>\n\t.hz{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tbox-sizing: content-box;\t/*标准模式：content-box  怪异模式：border-box*/\n\t\t\tbackground:red;\n\t\t\tmargin:10px;\n\t\t\tpadding:10px;\n\t\t\tborder:1px solid #ccc;\n\t\t}\n</style>\n<div class=\"hz\">\t\t\n</div>\n```\n\n\n\n1. ##### 标准盒模型\n\n   一个块元素的总宽度/总高度=width/height+padding+margin+border\n\n   ![](css盒模型/0754b65440c0fe40808b6481d881c0d2.png)\n\n2. ##### 怪异盒模型\n\n   一个块元素的总宽度/总高度=width/height+margin=内容区宽度/高度+padding+margin+border\n\n![](css盒模型/7018d20d4024c8748094ee6c656cbc13.png)","source":"_posts/css盒模型.md","raw":"---\ntitle: css盒模型\ndate: 2018-10-11 17:58:23\ntags: css\ncategories: 前端\n---\n\n### css盒模型\n\n**css盒模型组成：content区域+margin+padding+border。**\n\n> **css3的box-sizing：**\n>\n> ## 语法\n>\n> ```css\n> box-sizing: content-box|border-box|inherit;\n> ```\n>\n> | 值          | 描述                                                         |\n> | ----------- | ------------------------------------------------------------ |\n> | content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n> | border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n> | inherit     | 规定应从父元素继承 box-sizing 属性的值。                     |\n\n\n\n##### css的盒模型分为两种\n\n1. W3C标准盒模型\n2. IE标准盒模型\n\n市面上大多数浏览器都采用W3C标准的盒模型。\n\n由于标准不同，所以就产生了两种盒模型。\n\n```html\n<style>\n\t.hz{\n\t\t\twidth:100px;\n\t\t\theight:100px;\n\t\t\tbox-sizing: content-box;\t/*标准模式：content-box  怪异模式：border-box*/\n\t\t\tbackground:red;\n\t\t\tmargin:10px;\n\t\t\tpadding:10px;\n\t\t\tborder:1px solid #ccc;\n\t\t}\n</style>\n<div class=\"hz\">\t\t\n</div>\n```\n\n\n\n1. ##### 标准盒模型\n\n   一个块元素的总宽度/总高度=width/height+padding+margin+border\n\n   ![](css盒模型/0754b65440c0fe40808b6481d881c0d2.png)\n\n2. ##### 怪异盒模型\n\n   一个块元素的总宽度/总高度=width/height+margin=内容区宽度/高度+padding+margin+border\n\n![](css盒模型/7018d20d4024c8748094ee6c656cbc13.png)","slug":"css盒模型","published":1,"updated":"2024-02-19T07:42:51.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdra6001x1xop7zdeccjn","content":"<h3 id=\"css盒模型\"><a href=\"#css盒模型\" class=\"headerlink\" title=\"css盒模型\"></a>css盒模型</h3><p><strong>css盒模型组成：content区域+margin+padding+border。</strong></p>\n<blockquote>\n<p><strong>css3的box-sizing：</strong></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span> content-box|border-box|inherit<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content-box</td>\n<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>\n</tr>\n<tr>\n<td>border-box</td>\n<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应从父元素继承 box-sizing 属性的值。</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h5 id=\"css的盒模型分为两种\"><a href=\"#css的盒模型分为两种\" class=\"headerlink\" title=\"css的盒模型分为两种\"></a>css的盒模型分为两种</h5><ol>\n<li>W3C标准盒模型</li>\n<li>IE标准盒模型</li>\n</ol>\n<p>市面上大多数浏览器都采用W3C标准的盒模型。</p>\n<p>由于标准不同，所以就产生了两种盒模型。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>style</span><span class=\"token punctuation\">></span></span><span class=\"token style language-css\">\n    <span class=\"token selector\"><span class=\"token class\">.hz</span></span><span class=\"token punctuation\">{</span>\n            <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">box-sizing</span><span class=\"token punctuation\">:</span> content-box<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/*标准模式：content-box  怪异模式：border-box*/</span>\n            <span class=\"token property\">background</span><span class=\"token punctuation\">:</span>red<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span><span class=\"token number\">10</span>px<span class=\"token punctuation\">;</span>\n            <span class=\"token property\">border</span><span class=\"token punctuation\">:</span><span class=\"token number\">1</span>px solid <span class=\"token hexcode\">#ccc</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>style</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>hz<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>        \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol>\n<li><h5 id=\"标准盒模型\"><a href=\"#标准盒模型\" class=\"headerlink\" title=\"标准盒模型\"></a>标准盒模型</h5><p>一个块元素的总宽度/总高度=width/height+padding+margin+border</p>\n<p><img src=\"/2018/10/11/css%E7%9B%92%E6%A8%A1%E5%9E%8B/0754b65440c0fe40808b6481d881c0d2.png\" alt></p>\n</li>\n<li><h5 id=\"怪异盒模型\"><a href=\"#怪异盒模型\" class=\"headerlink\" title=\"怪异盒模型\"></a>怪异盒模型</h5><p>一个块元素的总宽度/总高度=width/height+margin=内容区宽度/高度+padding+margin+border</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/11/css%E7%9B%92%E6%A8%A1%E5%9E%8B/7018d20d4024c8748094ee6c656cbc13.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"css盒模型\"><a href=\"#css盒模型\" class=\"headerlink\" title=\"css盒模型\"></a>css盒模型</h3><p><strong>css盒模型组成：content区域+margin+padding+border。</strong></p>\n<blockquote>\n<p><strong>css3的box-sizing：</strong></p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre><code class=\"css\">box-sizing: content-box|border-box|inherit;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content-box</td>\n<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>\n</tr>\n<tr>\n<td>border-box</td>\n<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应从父元素继承 box-sizing 属性的值。</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h5 id=\"css的盒模型分为两种\"><a href=\"#css的盒模型分为两种\" class=\"headerlink\" title=\"css的盒模型分为两种\"></a>css的盒模型分为两种</h5><ol>\n<li>W3C标准盒模型</li>\n<li>IE标准盒模型</li>\n</ol>\n<p>市面上大多数浏览器都采用W3C标准的盒模型。</p>\n<p>由于标准不同，所以就产生了两种盒模型。</p>\n<pre><code class=\"html\">&lt;style&gt;\n    .hz{\n            width:100px;\n            height:100px;\n            box-sizing: content-box;    /*标准模式：content-box  怪异模式：border-box*/\n            background:red;\n            margin:10px;\n            padding:10px;\n            border:1px solid #ccc;\n        }\n&lt;/style&gt;\n&lt;div class=&quot;hz&quot;&gt;        \n&lt;/div&gt;\n</code></pre>\n<ol>\n<li><h5 id=\"标准盒模型\"><a href=\"#标准盒模型\" class=\"headerlink\" title=\"标准盒模型\"></a>标准盒模型</h5><p>一个块元素的总宽度/总高度=width/height+padding+margin+border</p>\n<p><img src=\"/2018/10/11/css%E7%9B%92%E6%A8%A1%E5%9E%8B/0754b65440c0fe40808b6481d881c0d2.png\" alt></p>\n</li>\n<li><h5 id=\"怪异盒模型\"><a href=\"#怪异盒模型\" class=\"headerlink\" title=\"怪异盒模型\"></a>怪异盒模型</h5><p>一个块元素的总宽度/总高度=width/height+margin=内容区宽度/高度+padding+margin+border</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/11/css%E7%9B%92%E6%A8%A1%E5%9E%8B/7018d20d4024c8748094ee6c656cbc13.png\" alt></p>\n"},{"title":"css性能调优","date":"2018-10-11T03:27:12.000Z","_content":"\n### css性能调优\n\n1. ##### 通过style标签的相关调优\n\n   使用link标签引入css文件，而不是用@import，原因是link标签放在head标签中，在页面加载前将相关css样式渲染到浏览器，@import则在页面加载之后进行渲染。\n\n2. ##### 避免使用表达式\n\n   避免使用expression相关表达式。\n\n3. ##### css缩写\n\n   例如：margin:20px;（上下左右都设置20px）\n\n4. ##### css声明\n\n   ```css\n   .div1{\n       width:200px;\n       height:200px;\n   }\n   .div2{\n       width:200px;\n       height:200px;\n   }\n   .div3{\n       width:200px;\n       height:200px;\n   }\n   /*声明优化*/\n   .div1 .div2 .div3{\n       width:200px;\n       height:200px;\n   }\n   ```\n\n5. ##### css选择器\n\n   1. 浏览器的匹配规则是：从右到左匹配查找。\n\n   2. 避免过长的规则例如：div>table>tr>td .classname等等。\n   3. 避免使用：[hidden=\"true\"]。\n   4. 尽量使用继承，避免重复的样式。\n\n   > 参考其他资料得到的一个效率排序：\n   >\n   > 1.id选择器（#myid）\n   > 2.类选择器（.myclassname）\n   > 3.标签选择器（div,h1,p）\n   > 4.相邻选择器（h1+p）\n   > 5.子选择器（ul < li）\n   > 6.后代选择器（li a）\n   > 7.通配符选择器（*）\n   > 8.属性选择器（a[rel=\"external\"]）\n   > 9.伪类选择器（a:hover,li:nth-child）\n","source":"_posts/css性能调优.md","raw":"---\ntitle: css性能调优\ndate: 2018-10-11 11:27:12\ntags: 前端性能相关\ncategories: 前端\n---\n\n### css性能调优\n\n1. ##### 通过style标签的相关调优\n\n   使用link标签引入css文件，而不是用@import，原因是link标签放在head标签中，在页面加载前将相关css样式渲染到浏览器，@import则在页面加载之后进行渲染。\n\n2. ##### 避免使用表达式\n\n   避免使用expression相关表达式。\n\n3. ##### css缩写\n\n   例如：margin:20px;（上下左右都设置20px）\n\n4. ##### css声明\n\n   ```css\n   .div1{\n       width:200px;\n       height:200px;\n   }\n   .div2{\n       width:200px;\n       height:200px;\n   }\n   .div3{\n       width:200px;\n       height:200px;\n   }\n   /*声明优化*/\n   .div1 .div2 .div3{\n       width:200px;\n       height:200px;\n   }\n   ```\n\n5. ##### css选择器\n\n   1. 浏览器的匹配规则是：从右到左匹配查找。\n\n   2. 避免过长的规则例如：div>table>tr>td .classname等等。\n   3. 避免使用：[hidden=\"true\"]。\n   4. 尽量使用继承，避免重复的样式。\n\n   > 参考其他资料得到的一个效率排序：\n   >\n   > 1.id选择器（#myid）\n   > 2.类选择器（.myclassname）\n   > 3.标签选择器（div,h1,p）\n   > 4.相邻选择器（h1+p）\n   > 5.子选择器（ul < li）\n   > 6.后代选择器（li a）\n   > 7.通配符选择器（*）\n   > 8.属性选择器（a[rel=\"external\"]）\n   > 9.伪类选择器（a:hover,li:nth-child）\n","slug":"css性能调优","published":1,"updated":"2024-02-19T07:42:51.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdraa00211xopar72c3gv","content":"<h3 id=\"css性能调优\"><a href=\"#css性能调优\" class=\"headerlink\" title=\"css性能调优\"></a>css性能调优</h3><ol>\n<li><h5 id=\"通过style标签的相关调优\"><a href=\"#通过style标签的相关调优\" class=\"headerlink\" title=\"通过style标签的相关调优\"></a>通过style标签的相关调优</h5><p>使用link标签引入css文件，而不是用@import，原因是link标签放在head标签中，在页面加载前将相关css样式渲染到浏览器，@import则在页面加载之后进行渲染。</p>\n</li>\n<li><h5 id=\"避免使用表达式\"><a href=\"#避免使用表达式\" class=\"headerlink\" title=\"避免使用表达式\"></a>避免使用表达式</h5><p>避免使用expression相关表达式。</p>\n</li>\n<li><h5 id=\"css缩写\"><a href=\"#css缩写\" class=\"headerlink\" title=\"css缩写\"></a>css缩写</h5><p>例如：margin:20px;（上下左右都设置20px）</p>\n</li>\n<li><h5 id=\"css声明\"><a href=\"#css声明\" class=\"headerlink\" title=\"css声明\"></a>css声明</h5><pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div1</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\"><span class=\"token class\">.div2</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\"><span class=\"token class\">.div3</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*声明优化*/</span>\n<span class=\"token selector\"><span class=\"token class\">.div1</span> <span class=\"token class\">.div2</span> <span class=\"token class\">.div3</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><h5 id=\"css选择器\"><a href=\"#css选择器\" class=\"headerlink\" title=\"css选择器\"></a>css选择器</h5><ol>\n<li><p>浏览器的匹配规则是：从右到左匹配查找。</p>\n</li>\n<li><p>避免过长的规则例如：div&gt;table&gt;tr&gt;td .classname等等。</p>\n</li>\n<li>避免使用：[hidden=”true”]。</li>\n<li>尽量使用继承，避免重复的样式。</li>\n</ol>\n<blockquote>\n<p>参考其他资料得到的一个效率排序：</p>\n<p>1.id选择器（#myid）<br>2.类选择器（.myclassname）<br>3.标签选择器（div,h1,p）<br>4.相邻选择器（h1+p）<br>5.子选择器（ul &lt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（*）<br>8.属性选择器（a[rel=”external”]）<br>9.伪类选择器（a:hover,li:nth-child）</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"css性能调优\"><a href=\"#css性能调优\" class=\"headerlink\" title=\"css性能调优\"></a>css性能调优</h3><ol>\n<li><h5 id=\"通过style标签的相关调优\"><a href=\"#通过style标签的相关调优\" class=\"headerlink\" title=\"通过style标签的相关调优\"></a>通过style标签的相关调优</h5><p>使用link标签引入css文件，而不是用@import，原因是link标签放在head标签中，在页面加载前将相关css样式渲染到浏览器，@import则在页面加载之后进行渲染。</p>\n</li>\n<li><h5 id=\"避免使用表达式\"><a href=\"#避免使用表达式\" class=\"headerlink\" title=\"避免使用表达式\"></a>避免使用表达式</h5><p>避免使用expression相关表达式。</p>\n</li>\n<li><h5 id=\"css缩写\"><a href=\"#css缩写\" class=\"headerlink\" title=\"css缩写\"></a>css缩写</h5><p>例如：margin:20px;（上下左右都设置20px）</p>\n</li>\n<li><h5 id=\"css声明\"><a href=\"#css声明\" class=\"headerlink\" title=\"css声明\"></a>css声明</h5><pre><code class=\"css\">.div1{\n    width:200px;\n    height:200px;\n}\n.div2{\n    width:200px;\n    height:200px;\n}\n.div3{\n    width:200px;\n    height:200px;\n}\n/*声明优化*/\n.div1 .div2 .div3{\n    width:200px;\n    height:200px;\n}\n</code></pre>\n</li>\n<li><h5 id=\"css选择器\"><a href=\"#css选择器\" class=\"headerlink\" title=\"css选择器\"></a>css选择器</h5><ol>\n<li><p>浏览器的匹配规则是：从右到左匹配查找。</p>\n</li>\n<li><p>避免过长的规则例如：div&gt;table&gt;tr&gt;td .classname等等。</p>\n</li>\n<li>避免使用：[hidden=”true”]。</li>\n<li>尽量使用继承，避免重复的样式。</li>\n</ol>\n<blockquote>\n<p>参考其他资料得到的一个效率排序：</p>\n<p>1.id选择器（#myid）<br>2.类选择器（.myclassname）<br>3.标签选择器（div,h1,p）<br>4.相邻选择器（h1+p）<br>5.子选择器（ul &lt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（*）<br>8.属性选择器（a[rel=”external”]）<br>9.伪类选择器（a:hover,li:nth-child）</p>\n</blockquote>\n</li>\n</ol>\n"},{"title":"flex布局","date":"2018-10-12T05:17:17.000Z","_content":"\n### flex布局\n\n> 参考菜鸟教程\n\nflex布局意为“弹性布局”，任何容器都可指定为flex布局。\n\n```css\n.div{\n    display:flex;\n}\n/*行内元素*/\n.div{\n    display:inline-flex;\n}\n/*Webkit内核的浏览器*/\n.div{\n    display:-webkit-flex;\n    display:flex;\n}\n```\n\n**注意：设为flex布局以后，子元素的float、clear和vertical-align属性将失效。**\n\n采用Flex布局的元素，称为Flex容器，它的所有子元素自动成为容器成员，称为flex项目。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png)\n\n> 说明：容器存在两根轴：水平的主轴和垂直的交叉轴。项目默认沿主轴排列。\n\n##### flex-direction属性\n\n> flex-direction属性决定主轴的方向（项目的排列方向）\n\n语法：\n\n```css\n.div{\n    flex-direction:row | row-reverse | column | column-reverse;\n}\n```\n\n- row：主轴为水平方向，左为起点。\n- row-reverse：主轴为水平方向，右为起点。\n- column：主轴为垂直方向，上为起点。\n- column-reverse：主轴为垂直方向，下为起点。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png)\n\n##### flex-wrap属性\n\n> flex-wrap属性决定元素在一条轴线上排不下如何换行。\n\n语法：\n\n```css\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n##### flex-flow\n\n> flex-flow属性是flex-direction和flex-wrap属性的简写，默认值row nowrap。\n\n##### justify-content属性\n\n> justify-content属性规定项目在主轴上的对其方式。\n\n语法：\n\n```css\n.div{\n    justify-content:flex-start | flex-end | center | space-between | space-around\n}\n```\n\n- flex-start：左对齐。\n- flex-end：右对齐。\n- center：居中。\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。（注意：项目之间的间隔比项目与两边边框的间隔大一倍）\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png)\n\n##### align-items属性\n\n> align-items属性规定项目在交叉轴上如何对齐。\n\n语法：\n\n```css\n.div{\n    align-items:flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n- flex-start：假设交叉轴从上到下，从上开始对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline：项目的第一行文字的基线对齐。\n- stretch：如果项目未设置高度或为auto，将铺满整个容器高度。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png)\n\n##### align-content属性\n\n> align-content属性定义多根轴线的对齐方式，若只有一根轴线，不起作用。\n\n语法：\n\n```css\n.div{\n    align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n![](https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png)\n\n##### 项目属性\n\n1. order属性：定义项目的排列顺序。数值越小排列越靠前，默认0。\n\n   ```css\n   .item{\n       order:<integer>;\n   }\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png)\n\n2. flex-grow属性：定义项目的放大比例，默认0。\n\n   ```css\n   .item{\n       flex-grow:<number>; /*default 0*/\n   }\n   /*如果项目的值相同，则均分。*/\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png)\n\n3. flex-shrink属性：定义项目的缩小比例，默认1。(负值对该属性无效)\n\n   ```css\n   .item{\n       flex-shrink:<number>; /*default 1*/\n   }\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg)\n\n4. flex-basis属性：定义再分配多余空间时，项目占据的主轴空间。默认auto。\n\n   ```css\n   .item{\n       flex-basis:<length> | auto; /*default auto*/\n   }\n   ```\n\n5. flex属性：该属性时flex-grow、flex-shrink、flex-basis属性的简写。\n\n   ```css\n   .item{\n       flex:none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n   }\n   ```\n\n   **建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。**\n\n6. align-self属性：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n   ```css\n   .item{\n       align-self:auto| flex-start | flex-end | center | baseline | stretch;\n   }\n   ```\n\n   **该属性可能取6个值，除了auto，其他都与align-items属性完全一致。**\n\n","source":"_posts/flex布局.md","raw":"---\ntitle: flex布局\ndate: 2018-10-12 13:17:17\ntags: css\ncategories: 前端\n---\n\n### flex布局\n\n> 参考菜鸟教程\n\nflex布局意为“弹性布局”，任何容器都可指定为flex布局。\n\n```css\n.div{\n    display:flex;\n}\n/*行内元素*/\n.div{\n    display:inline-flex;\n}\n/*Webkit内核的浏览器*/\n.div{\n    display:-webkit-flex;\n    display:flex;\n}\n```\n\n**注意：设为flex布局以后，子元素的float、clear和vertical-align属性将失效。**\n\n采用Flex布局的元素，称为Flex容器，它的所有子元素自动成为容器成员，称为flex项目。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png)\n\n> 说明：容器存在两根轴：水平的主轴和垂直的交叉轴。项目默认沿主轴排列。\n\n##### flex-direction属性\n\n> flex-direction属性决定主轴的方向（项目的排列方向）\n\n语法：\n\n```css\n.div{\n    flex-direction:row | row-reverse | column | column-reverse;\n}\n```\n\n- row：主轴为水平方向，左为起点。\n- row-reverse：主轴为水平方向，右为起点。\n- column：主轴为垂直方向，上为起点。\n- column-reverse：主轴为垂直方向，下为起点。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png)\n\n##### flex-wrap属性\n\n> flex-wrap属性决定元素在一条轴线上排不下如何换行。\n\n语法：\n\n```css\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n##### flex-flow\n\n> flex-flow属性是flex-direction和flex-wrap属性的简写，默认值row nowrap。\n\n##### justify-content属性\n\n> justify-content属性规定项目在主轴上的对其方式。\n\n语法：\n\n```css\n.div{\n    justify-content:flex-start | flex-end | center | space-between | space-around\n}\n```\n\n- flex-start：左对齐。\n- flex-end：右对齐。\n- center：居中。\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。（注意：项目之间的间隔比项目与两边边框的间隔大一倍）\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png)\n\n##### align-items属性\n\n> align-items属性规定项目在交叉轴上如何对齐。\n\n语法：\n\n```css\n.div{\n    align-items:flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n- flex-start：假设交叉轴从上到下，从上开始对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline：项目的第一行文字的基线对齐。\n- stretch：如果项目未设置高度或为auto，将铺满整个容器高度。\n\n![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png)\n\n##### align-content属性\n\n> align-content属性定义多根轴线的对齐方式，若只有一根轴线，不起作用。\n\n语法：\n\n```css\n.div{\n    align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n![](https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png)\n\n##### 项目属性\n\n1. order属性：定义项目的排列顺序。数值越小排列越靠前，默认0。\n\n   ```css\n   .item{\n       order:<integer>;\n   }\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png)\n\n2. flex-grow属性：定义项目的放大比例，默认0。\n\n   ```css\n   .item{\n       flex-grow:<number>; /*default 0*/\n   }\n   /*如果项目的值相同，则均分。*/\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png)\n\n3. flex-shrink属性：定义项目的缩小比例，默认1。(负值对该属性无效)\n\n   ```css\n   .item{\n       flex-shrink:<number>; /*default 1*/\n   }\n   ```\n\n   ![参考菜鸟教程](https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg)\n\n4. flex-basis属性：定义再分配多余空间时，项目占据的主轴空间。默认auto。\n\n   ```css\n   .item{\n       flex-basis:<length> | auto; /*default auto*/\n   }\n   ```\n\n5. flex属性：该属性时flex-grow、flex-shrink、flex-basis属性的简写。\n\n   ```css\n   .item{\n       flex:none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n   }\n   ```\n\n   **建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。**\n\n6. align-self属性：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n   ```css\n   .item{\n       align-self:auto| flex-start | flex-end | center | baseline | stretch;\n   }\n   ```\n\n   **该属性可能取6个值，除了auto，其他都与align-items属性完全一致。**\n\n","slug":"flex布局","published":1,"updated":"2024-02-19T07:42:51.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrab00231xop69udhlbg","content":"<h3 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h3><blockquote>\n<p>参考菜鸟教程</p>\n</blockquote>\n<p>flex布局意为“弹性布局”，任何容器都可指定为flex布局。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span>flex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*行内元素*/</span>\n<span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span>inline-flex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*Webkit内核的浏览器*/</span>\n<span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span>-webkit-flex<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">display</span><span class=\"token punctuation\">:</span>flex<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>注意：设为flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></p>\n<p>采用Flex布局的元素，称为Flex容器，它的所有子元素自动成为容器成员，称为flex项目。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png\" alt=\"参考菜鸟教程\"></p>\n<blockquote>\n<p>说明：容器存在两根轴：水平的主轴和垂直的交叉轴。项目默认沿主轴排列。</p>\n</blockquote>\n<h5 id=\"flex-direction属性\"><a href=\"#flex-direction属性\" class=\"headerlink\" title=\"flex-direction属性\"></a>flex-direction属性</h5><blockquote>\n<p>flex-direction属性决定主轴的方向（项目的排列方向）</p>\n</blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">flex-direction</span><span class=\"token punctuation\">:</span>row | row-reverse | column | column-reverse<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>row：主轴为水平方向，左为起点。</li>\n<li>row-reverse：主轴为水平方向，右为起点。</li>\n<li>column：主轴为垂直方向，上为起点。</li>\n<li>column-reverse：主轴为垂直方向，下为起点。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"flex-wrap属性\"><a href=\"#flex-wrap属性\" class=\"headerlink\" title=\"flex-wrap属性\"></a>flex-wrap属性</h5><blockquote>\n<p>flex-wrap属性决定元素在一条轴线上排不下如何换行。</p>\n</blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.box</span></span><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">flex-wrap</span><span class=\"token punctuation\">:</span> nowrap | wrap | wrap-reverse<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h5 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a>flex-flow</h5><blockquote>\n<p>flex-flow属性是flex-direction和flex-wrap属性的简写，默认值row nowrap。</p>\n</blockquote>\n<h5 id=\"justify-content属性\"><a href=\"#justify-content属性\" class=\"headerlink\" title=\"justify-content属性\"></a>justify-content属性</h5><blockquote>\n<p>justify-content属性规定项目在主轴上的对其方式。</p>\n</blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">justify-content</span><span class=\"token punctuation\">:</span>flex-start | flex-end | center | space-between | space-around\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>flex-start：左对齐。</li>\n<li>flex-end：右对齐。</li>\n<li>center：居中。</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。（注意：项目之间的间隔比项目与两边边框的间隔大一倍）</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"align-items属性\"><a href=\"#align-items属性\" class=\"headerlink\" title=\"align-items属性\"></a>align-items属性</h5><blockquote>\n<p>align-items属性规定项目在交叉轴上如何对齐。</p>\n</blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">align-items</span><span class=\"token punctuation\">:</span>flex-start | flex-end | center | baseline | stretch<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>flex-start：假设交叉轴从上到下，从上开始对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline：项目的第一行文字的基线对齐。</li>\n<li>stretch：如果项目未设置高度或为auto，将铺满整个容器高度。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"align-content属性\"><a href=\"#align-content属性\" class=\"headerlink\" title=\"align-content属性\"></a>align-content属性</h5><blockquote>\n<p>align-content属性定义多根轴线的对齐方式，若只有一根轴线，不起作用。</p>\n</blockquote>\n<p>语法：</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">align-content</span><span class=\"token punctuation\">:</span>flex-start | flex-end | center | space-between | space-around | stretch<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png\" alt></p>\n<h5 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a>项目属性</h5><ol>\n<li><p>order属性：定义项目的排列顺序。数值越小排列越靠前，默认0。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">order</span><span class=\"token punctuation\">:</span>&lt;integer><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-grow属性：定义项目的放大比例，默认0。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">flex-grow</span><span class=\"token punctuation\">:</span>&lt;number><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/*default 0*/</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*如果项目的值相同，则均分。*/</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-shrink属性：定义项目的缩小比例，默认1。(负值对该属性无效)</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">flex-shrink</span><span class=\"token punctuation\">:</span>&lt;number><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/*default 1*/</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-basis属性：定义再分配多余空间时，项目占据的主轴空间。默认auto。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">flex-basis</span><span class=\"token punctuation\">:</span>&lt;length> | auto<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/*default auto*/</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>flex属性：该属性时flex-grow、flex-shrink、flex-basis属性的简写。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">flex</span><span class=\"token punctuation\">:</span>none | [ &lt;<span class=\"token string\">'flex-grow'</span>> &lt;<span class=\"token string\">'flex-shrink'</span>>? || &lt;<span class=\"token string\">'flex-basis'</span>> ]\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</strong></p>\n</li>\n<li><p>align-self属性：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.item</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">align-self</span><span class=\"token punctuation\">:</span>auto| flex-start | flex-end | center | baseline | stretch<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</strong></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"flex布局\"><a href=\"#flex布局\" class=\"headerlink\" title=\"flex布局\"></a>flex布局</h3><blockquote>\n<p>参考菜鸟教程</p>\n</blockquote>\n<p>flex布局意为“弹性布局”，任何容器都可指定为flex布局。</p>\n<pre><code class=\"css\">.div{\n    display:flex;\n}\n/*行内元素*/\n.div{\n    display:inline-flex;\n}\n/*Webkit内核的浏览器*/\n.div{\n    display:-webkit-flex;\n    display:flex;\n}\n</code></pre>\n<p><strong>注意：设为flex布局以后，子元素的float、clear和vertical-align属性将失效。</strong></p>\n<p>采用Flex布局的元素，称为Flex容器，它的所有子元素自动成为容器成员，称为flex项目。</p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png\" alt=\"参考菜鸟教程\"></p>\n<blockquote>\n<p>说明：容器存在两根轴：水平的主轴和垂直的交叉轴。项目默认沿主轴排列。</p>\n</blockquote>\n<h5 id=\"flex-direction属性\"><a href=\"#flex-direction属性\" class=\"headerlink\" title=\"flex-direction属性\"></a>flex-direction属性</h5><blockquote>\n<p>flex-direction属性决定主轴的方向（项目的排列方向）</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">.div{\n    flex-direction:row | row-reverse | column | column-reverse;\n}\n</code></pre>\n<ul>\n<li>row：主轴为水平方向，左为起点。</li>\n<li>row-reverse：主轴为水平方向，右为起点。</li>\n<li>column：主轴为垂直方向，上为起点。</li>\n<li>column-reverse：主轴为垂直方向，下为起点。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"flex-wrap属性\"><a href=\"#flex-wrap属性\" class=\"headerlink\" title=\"flex-wrap属性\"></a>flex-wrap属性</h5><blockquote>\n<p>flex-wrap属性决定元素在一条轴线上排不下如何换行。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n</code></pre>\n<ul>\n<li>nowrap（默认）：不换行。</li>\n<li>wrap：换行，第一行在上方。</li>\n<li>wrap-reverse：换行，第一行在下方。</li>\n</ul>\n<h5 id=\"flex-flow\"><a href=\"#flex-flow\" class=\"headerlink\" title=\"flex-flow\"></a>flex-flow</h5><blockquote>\n<p>flex-flow属性是flex-direction和flex-wrap属性的简写，默认值row nowrap。</p>\n</blockquote>\n<h5 id=\"justify-content属性\"><a href=\"#justify-content属性\" class=\"headerlink\" title=\"justify-content属性\"></a>justify-content属性</h5><blockquote>\n<p>justify-content属性规定项目在主轴上的对其方式。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">.div{\n    justify-content:flex-start | flex-end | center | space-between | space-around\n}\n</code></pre>\n<ul>\n<li>flex-start：左对齐。</li>\n<li>flex-end：右对齐。</li>\n<li>center：居中。</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。（注意：项目之间的间隔比项目与两边边框的间隔大一倍）</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"align-items属性\"><a href=\"#align-items属性\" class=\"headerlink\" title=\"align-items属性\"></a>align-items属性</h5><blockquote>\n<p>align-items属性规定项目在交叉轴上如何对齐。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">.div{\n    align-items:flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<ul>\n<li>flex-start：假设交叉轴从上到下，从上开始对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline：项目的第一行文字的基线对齐。</li>\n<li>stretch：如果项目未设置高度或为auto，将铺满整个容器高度。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png\" alt=\"参考菜鸟教程\"></p>\n<h5 id=\"align-content属性\"><a href=\"#align-content属性\" class=\"headerlink\" title=\"align-content属性\"></a>align-content属性</h5><blockquote>\n<p>align-content属性定义多根轴线的对齐方式，若只有一根轴线，不起作用。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"css\">.div{\n    align-content:flex-start | flex-end | center | space-between | space-around | stretch;\n}\n</code></pre>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png\" alt></p>\n<h5 id=\"项目属性\"><a href=\"#项目属性\" class=\"headerlink\" title=\"项目属性\"></a>项目属性</h5><ol>\n<li><p>order属性：定义项目的排列顺序。数值越小排列越靠前，默认0。</p>\n<pre><code class=\"css\">.item{\n    order:&lt;integer&gt;;\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-grow属性：定义项目的放大比例，默认0。</p>\n<pre><code class=\"css\">.item{\n    flex-grow:&lt;number&gt;; /*default 0*/\n}\n/*如果项目的值相同，则均分。*/\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-shrink属性：定义项目的缩小比例，默认1。(负值对该属性无效)</p>\n<pre><code class=\"css\">.item{\n    flex-shrink:&lt;number&gt;; /*default 1*/\n}\n</code></pre>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg\" alt=\"参考菜鸟教程\"></p>\n</li>\n<li><p>flex-basis属性：定义再分配多余空间时，项目占据的主轴空间。默认auto。</p>\n<pre><code class=\"css\">.item{\n    flex-basis:&lt;length&gt; | auto; /*default auto*/\n}\n</code></pre>\n</li>\n<li><p>flex属性：该属性时flex-grow、flex-shrink、flex-basis属性的简写。</p>\n<pre><code class=\"css\">.item{\n    flex:none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}\n</code></pre>\n<p><strong>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</strong></p>\n</li>\n<li><p>align-self属性：允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性。默认值auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>\n<pre><code class=\"css\">.item{\n    align-self:auto| flex-start | flex-end | center | baseline | stretch;\n}\n</code></pre>\n<p><strong>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</strong></p>\n</li>\n</ol>\n"},{"title":"git使用","date":"2018-10-19T03:38:39.000Z","_content":"\n### git使用\n\n##### 安装完成后\n\n打开命令行窗口或（终端）\n\n**设置用户名**\n\n```shell\ngit config --global user.name 'username'\n```\n\n**设置用户邮箱**\n\n```shell\ngit config --global user.email 'user@163.com'\n```\n\n**查看设置**\n\n```shell\ngit config --list\n```\n\n*注意：`git config --global`参数设置后，表明这台机器上的所有Git仓库都会使用这个配置，当然也可以指定某个仓库设置不同的用户名邮箱*\n\n##### 创建仓库（repository）\n\n什么是仓库：你可以将其理解为一个简单的目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除、Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。\n\n```shell\nmkdir newRep\ncd newRep\n```\n\n**创建完仓库后**\n\n```shell\ngit init //将这个目录变成Git可以管理的仓库\n```\n\n**将需要上传的文件放到当前文件夹下**\n\n1. 工作区：就是当前的文件目录，在工作去有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。\n\n   git的版本库\n\n2. 暂存区\n\n3. 仓库\n\n![](git使用/d3c801894031d80480e26efe7008a949.png)\n\n**将文件添加到暂存区**\n\n```shell\ngit add filename1.txt\ngit add filename2.txt filename3.txt\n```\n\n**将文件提交到仓库**\n\n```shell\ngit commit -m '描述信息'\n```\n\n*多次使用`add`添加多个文件，`commit`可以一次提交多个文件*\n\n**查看仓库当前状态**\n\n```shell\ngit status\t//可以查看需要上传的文件是否修改了\ngit diff filename.txt  //查看修改后的文件与之前的文件的不同之处\n```\n\n*修改后的文件上传的话，需要重新进行`add`和`commit`*\n\n##### 版本回退\n\n**查看提交历史**\n\n```shell\ngit log\n```\n\n*在git中，用`HEAD`表示当前版本，上一个版本就是\t`HEAD^`，上上个版本就是`HEAD^^`，当然往上100个版本不可能写100个^，可以写成`HEAD~100`*\n\n**回到上个版本中**\n\n```shell\ngit reset --hard HEAD^\t//使用git reset命令可以回退版本\n```\n\n*`HEAD`也可以是通过`git log`命令查看到的每次提交的id，这样就可以在不同的版本之间来回的切换了。*\n\n```shell\ngit reflog //用来记录你的每一次命令\n```\n\n##### 撤销修改\n\n```shell\ngit checkout -- readme.txt\n```\n\n意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n##### 删除文件\n\n```shell\ngit rm filename.txt \n```\n\n##### 远程仓库\n\n**首先创建SSH Key。**\n\n在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有`id_rsa`和`id_rsa.pub`这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n```shell\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到`.ssh`目录，里面有`id_rsa`和`id_rsa.pub`两个文件，这两个就是SSH Key的秘钥对，`id_rsa`是私钥，不能泄露出去，`id_rsa.pub`是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴`id_rsa.pub`文件的内容\n\n##### 将本地仓库内容推送到GitHub仓库中\n\n```shell\ngit remote add origin git@github.com:yymfp/blog.git  //关联远程库  yymfp改成自己的GitHub用户名\ngit push -u origin master\n```\n\n*由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。*\n\n要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n\n关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##### 从远程库克隆\n\n```shell\ngit clone git@github.com:yymfp/仓库名.git\n```\n\n*GitHub给出的地址不止一个，还可以用`https://github.com/michaelliao/gitskills.git`这样的地址。实际上，Git支持多种协议，默认的`git://`使用ssh，但也可以使用`https`等其他协议。*\n\n*使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。*\n\n##### 创建与合并分支\n\n创建新的分支：\n\n```shell\ngit checkout -b dev \nSwitched to a new branch 'dev'\n```\n\n`git checkout`命令加上`-b`表示创建并切换，相当于以下两条命令：\n\n```shell\ngit branch dev\ngit checkout dev\nSwitched to branch 'dev'\n```\n\n然后`git branch`查看当前分支","source":"_posts/git使用.md","raw":"---\ntitle: git使用\ndate: 2018-10-19 11:38:39\ntags: git\ncategories: git\n---\n\n### git使用\n\n##### 安装完成后\n\n打开命令行窗口或（终端）\n\n**设置用户名**\n\n```shell\ngit config --global user.name 'username'\n```\n\n**设置用户邮箱**\n\n```shell\ngit config --global user.email 'user@163.com'\n```\n\n**查看设置**\n\n```shell\ngit config --list\n```\n\n*注意：`git config --global`参数设置后，表明这台机器上的所有Git仓库都会使用这个配置，当然也可以指定某个仓库设置不同的用户名邮箱*\n\n##### 创建仓库（repository）\n\n什么是仓库：你可以将其理解为一个简单的目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除、Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。\n\n```shell\nmkdir newRep\ncd newRep\n```\n\n**创建完仓库后**\n\n```shell\ngit init //将这个目录变成Git可以管理的仓库\n```\n\n**将需要上传的文件放到当前文件夹下**\n\n1. 工作区：就是当前的文件目录，在工作去有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库。\n\n   git的版本库\n\n2. 暂存区\n\n3. 仓库\n\n![](git使用/d3c801894031d80480e26efe7008a949.png)\n\n**将文件添加到暂存区**\n\n```shell\ngit add filename1.txt\ngit add filename2.txt filename3.txt\n```\n\n**将文件提交到仓库**\n\n```shell\ngit commit -m '描述信息'\n```\n\n*多次使用`add`添加多个文件，`commit`可以一次提交多个文件*\n\n**查看仓库当前状态**\n\n```shell\ngit status\t//可以查看需要上传的文件是否修改了\ngit diff filename.txt  //查看修改后的文件与之前的文件的不同之处\n```\n\n*修改后的文件上传的话，需要重新进行`add`和`commit`*\n\n##### 版本回退\n\n**查看提交历史**\n\n```shell\ngit log\n```\n\n*在git中，用`HEAD`表示当前版本，上一个版本就是\t`HEAD^`，上上个版本就是`HEAD^^`，当然往上100个版本不可能写100个^，可以写成`HEAD~100`*\n\n**回到上个版本中**\n\n```shell\ngit reset --hard HEAD^\t//使用git reset命令可以回退版本\n```\n\n*`HEAD`也可以是通过`git log`命令查看到的每次提交的id，这样就可以在不同的版本之间来回的切换了。*\n\n```shell\ngit reflog //用来记录你的每一次命令\n```\n\n##### 撤销修改\n\n```shell\ngit checkout -- readme.txt\n```\n\n意思就是，把`readme.txt`文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是`readme.txt`自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是`readme.txt`已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次`git commit`或`git add`时的状态。\n\n`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\n\n##### 删除文件\n\n```shell\ngit rm filename.txt \n```\n\n##### 远程仓库\n\n**首先创建SSH Key。**\n\n在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有`id_rsa`和`id_rsa.pub`这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n```shell\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n\n如果一切顺利的话，可以在用户主目录里找到`.ssh`目录，里面有`id_rsa`和`id_rsa.pub`两个文件，这两个就是SSH Key的秘钥对，`id_rsa`是私钥，不能泄露出去，`id_rsa.pub`是公钥，可以放心地告诉任何人。\n\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴`id_rsa.pub`文件的内容\n\n##### 将本地仓库内容推送到GitHub仓库中\n\n```shell\ngit remote add origin git@github.com:yymfp/blog.git  //关联远程库  yymfp改成自己的GitHub用户名\ngit push -u origin master\n```\n\n*由于远程库是空的，我们第一次推送`master`分支时，加上了`-u`参数，Git不但会把本地的`master`分支内容推送的远程新的`master`分支，还会把本地的`master`分支和远程的`master`分支关联起来，在以后的推送或者拉取时就可以简化命令。*\n\n要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n\n关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；\n\n此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；\n\n分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！\n\n##### 从远程库克隆\n\n```shell\ngit clone git@github.com:yymfp/仓库名.git\n```\n\n*GitHub给出的地址不止一个，还可以用`https://github.com/michaelliao/gitskills.git`这样的地址。实际上，Git支持多种协议，默认的`git://`使用ssh，但也可以使用`https`等其他协议。*\n\n*使用`https`除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用`ssh`协议而只能用`https`。*\n\n##### 创建与合并分支\n\n创建新的分支：\n\n```shell\ngit checkout -b dev \nSwitched to a new branch 'dev'\n```\n\n`git checkout`命令加上`-b`表示创建并切换，相当于以下两条命令：\n\n```shell\ngit branch dev\ngit checkout dev\nSwitched to branch 'dev'\n```\n\n然后`git branch`查看当前分支","slug":"git使用","published":1,"updated":"2024-02-19T07:42:51.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrad00261xop7thqfot6","content":"<h3 id=\"git使用\"><a href=\"#git使用\" class=\"headerlink\" title=\"git使用\"></a>git使用</h3><h5 id=\"安装完成后\"><a href=\"#安装完成后\" class=\"headerlink\" title=\"安装完成后\"></a>安装完成后</h5><p>打开命令行窗口或（终端）</p>\n<p><strong>设置用户名</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git config --global user.name 'username'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>设置用户邮箱</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git config --global user.email 'user@163.com'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>查看设置</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git config --list\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em>注意：<code>git config --global</code>参数设置后，表明这台机器上的所有Git仓库都会使用这个配置，当然也可以指定某个仓库设置不同的用户名邮箱</em></p>\n<h5 id=\"创建仓库（repository）\"><a href=\"#创建仓库（repository）\" class=\"headerlink\" title=\"创建仓库（repository）\"></a>创建仓库（repository）</h5><p>什么是仓库：你可以将其理解为一个简单的目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除、Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">mkdir newRep\ncd newRep\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>创建完仓库后</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git init //将这个目录变成Git可以管理的仓库\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>将需要上传的文件放到当前文件夹下</strong></p>\n<ol>\n<li><p>工作区：就是当前的文件目录，在工作去有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>\n<p>git的版本库</p>\n</li>\n<li><p>暂存区</p>\n</li>\n<li><p>仓库</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/19/git%E4%BD%BF%E7%94%A8/d3c801894031d80480e26efe7008a949.png\" alt></p>\n<p><strong>将文件添加到暂存区</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git add filename1.txt\ngit add filename2.txt filename3.txt\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>将文件提交到仓库</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git commit -m '描述信息'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em>多次使用<code>add</code>添加多个文件，<code>commit</code>可以一次提交多个文件</em></p>\n<p><strong>查看仓库当前状态</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git status    //可以查看需要上传的文件是否修改了\ngit diff filename.txt  //查看修改后的文件与之前的文件的不同之处\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><em>修改后的文件上传的话，需要重新进行<code>add</code>和<code>commit</code></em></p>\n<h5 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h5><p><strong>查看提交历史</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git log\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em>在git中，用<code>HEAD</code>表示当前版本，上一个版本就是    <code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>，当然往上100个版本不可能写100个^，可以写成<code>HEAD~100</code></em></p>\n<p><strong>回到上个版本中</strong></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git reset --hard HEAD^    //使用git reset命令可以回退版本\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em><code>HEAD</code>也可以是通过<code>git log</code>命令查看到的每次提交的id，这样就可以在不同的版本之间来回的切换了。</em></p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git reflog //用来记录你的每一次命令\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h5><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git checkout -- readme.txt\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>\n<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>\n<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>\n<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n<h5 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h5><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git rm filename.txt \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h5><p><strong>首先创建SSH Key。</strong></p>\n<p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">ssh-keygen -t rsa -C \"youremail@example.com\"\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>\n<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>\n<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>\n<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p>\n<h5 id=\"将本地仓库内容推送到GitHub仓库中\"><a href=\"#将本地仓库内容推送到GitHub仓库中\" class=\"headerlink\" title=\"将本地仓库内容推送到GitHub仓库中\"></a>将本地仓库内容推送到GitHub仓库中</h5><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git remote add origin git@github.com:yymfp/blog.git  //关联远程库  yymfp改成自己的GitHub用户名\ngit push -u origin master\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><em>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>\n<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>\n<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>\n<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>\n<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>\n<h5 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h5><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git clone git@github.com:yymfp/仓库名.git\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><em>GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</em></p>\n<p><em>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</em></p>\n<h5 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h5><p>创建新的分支：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git checkout -b dev \nSwitched to a new branch 'dev'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><code>git checkout</code>命令加上<code>-b</code>表示创建并切换，相当于以下两条命令：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">git branch dev\ngit checkout dev\nSwitched to branch 'dev'\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>然后<code>git branch</code>查看当前分支</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"git使用\"><a href=\"#git使用\" class=\"headerlink\" title=\"git使用\"></a>git使用</h3><h5 id=\"安装完成后\"><a href=\"#安装完成后\" class=\"headerlink\" title=\"安装完成后\"></a>安装完成后</h5><p>打开命令行窗口或（终端）</p>\n<p><strong>设置用户名</strong></p>\n<pre><code class=\"shell\">git config --global user.name &#39;username&#39;\n</code></pre>\n<p><strong>设置用户邮箱</strong></p>\n<pre><code class=\"shell\">git config --global user.email &#39;user@163.com&#39;\n</code></pre>\n<p><strong>查看设置</strong></p>\n<pre><code class=\"shell\">git config --list\n</code></pre>\n<p><em>注意：<code>git config --global</code>参数设置后，表明这台机器上的所有Git仓库都会使用这个配置，当然也可以指定某个仓库设置不同的用户名邮箱</em></p>\n<h5 id=\"创建仓库（repository）\"><a href=\"#创建仓库（repository）\" class=\"headerlink\" title=\"创建仓库（repository）\"></a>创建仓库（repository）</h5><p>什么是仓库：你可以将其理解为一个简单的目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除、Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原。</p>\n<pre><code class=\"shell\">mkdir newRep\ncd newRep\n</code></pre>\n<p><strong>创建完仓库后</strong></p>\n<pre><code class=\"shell\">git init //将这个目录变成Git可以管理的仓库\n</code></pre>\n<p><strong>将需要上传的文件放到当前文件夹下</strong></p>\n<ol>\n<li><p>工作区：就是当前的文件目录，在工作去有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>\n<p>git的版本库</p>\n</li>\n<li><p>暂存区</p>\n</li>\n<li><p>仓库</p>\n</li>\n</ol>\n<p><img src=\"/2018/10/19/git%E4%BD%BF%E7%94%A8/d3c801894031d80480e26efe7008a949.png\" alt></p>\n<p><strong>将文件添加到暂存区</strong></p>\n<pre><code class=\"shell\">git add filename1.txt\ngit add filename2.txt filename3.txt\n</code></pre>\n<p><strong>将文件提交到仓库</strong></p>\n<pre><code class=\"shell\">git commit -m &#39;描述信息&#39;\n</code></pre>\n<p><em>多次使用<code>add</code>添加多个文件，<code>commit</code>可以一次提交多个文件</em></p>\n<p><strong>查看仓库当前状态</strong></p>\n<pre><code class=\"shell\">git status    //可以查看需要上传的文件是否修改了\ngit diff filename.txt  //查看修改后的文件与之前的文件的不同之处\n</code></pre>\n<p><em>修改后的文件上传的话，需要重新进行<code>add</code>和<code>commit</code></em></p>\n<h5 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h5><p><strong>查看提交历史</strong></p>\n<pre><code class=\"shell\">git log\n</code></pre>\n<p><em>在git中，用<code>HEAD</code>表示当前版本，上一个版本就是    <code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>，当然往上100个版本不可能写100个^，可以写成<code>HEAD~100</code></em></p>\n<p><strong>回到上个版本中</strong></p>\n<pre><code class=\"shell\">git reset --hard HEAD^    //使用git reset命令可以回退版本\n</code></pre>\n<p><em><code>HEAD</code>也可以是通过<code>git log</code>命令查看到的每次提交的id，这样就可以在不同的版本之间来回的切换了。</em></p>\n<pre><code class=\"shell\">git reflog //用来记录你的每一次命令\n</code></pre>\n<h5 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h5><pre><code class=\"shell\">git checkout -- readme.txt\n</code></pre>\n<p>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>\n<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>\n<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>\n<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>\n<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>\n<h5 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h5><pre><code class=\"shell\">git rm filename.txt \n</code></pre>\n<h5 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h5><p><strong>首先创建SSH Key。</strong></p>\n<p>在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>\n<pre><code class=\"shell\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n</code></pre>\n<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>\n<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>\n<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>\n<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p>\n<h5 id=\"将本地仓库内容推送到GitHub仓库中\"><a href=\"#将本地仓库内容推送到GitHub仓库中\" class=\"headerlink\" title=\"将本地仓库内容推送到GitHub仓库中\"></a>将本地仓库内容推送到GitHub仓库中</h5><pre><code class=\"shell\">git remote add origin git@github.com:yymfp/blog.git  //关联远程库  yymfp改成自己的GitHub用户名\ngit push -u origin master\n</code></pre>\n<p><em>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</em></p>\n<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>\n<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>\n<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>\n<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>\n<h5 id=\"从远程库克隆\"><a href=\"#从远程库克隆\" class=\"headerlink\" title=\"从远程库克隆\"></a>从远程库克隆</h5><pre><code class=\"shell\">git clone git@github.com:yymfp/仓库名.git\n</code></pre>\n<p><em>GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</em></p>\n<p><em>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</em></p>\n<h5 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h5><p>创建新的分支：</p>\n<pre><code class=\"shell\">git checkout -b dev \nSwitched to a new branch &#39;dev&#39;\n</code></pre>\n<p><code>git checkout</code>命令加上<code>-b</code>表示创建并切换，相当于以下两条命令：</p>\n<pre><code class=\"shell\">git branch dev\ngit checkout dev\nSwitched to branch &#39;dev&#39;\n</code></pre>\n<p>然后<code>git branch</code>查看当前分支</p>\n"},{"title":"html块级元素、内联元素","date":"2018-10-11T02:39:05.000Z","_content":"\n### html块级元素、内联元素\n\n**html中的元素分为两种：块级元素和内联元素。**\n\n##### 块级元素\n\n特点：显示在一块内，可以自动换行，元素从上到下垂直排列，各占一行。\n\n1. 总是在新行上开始\n2. 高度、行高、外边距、内边距可控\n3. 宽度缺省，默认100%\n4. 可以容纳其他的内联元素或块级元素\n\n常见的标签：p、ul、form、div、address等标签。\n\n块级元素一般可嵌套块级元素或者行内元素，一般作为容器出现，用来组织结构，但并不全如此。元素都有属性`display:block;`\n\n##### 内联元素\n\n特点：元素在一行内水平排列，高度由元素的内容决定，height不起作用（可以设置line-height控制高度）。\n\n1. 在同一行上边显示\n2. 高度、行高、垂直方向外边距、垂直方向内边距不可改变\n3. 宽度是文字或者图片的宽度，不可以改变\n4. 内联元素只能容纳内联元素或文本\n\n常见的标签：span、input、a、sub、sup等。\n\n行内元素一般都是语义化的基本元素，内能容纳文本或其他的内联元素，元素设置属性`display:inline;`\n\n##### 两者间区别：\n\n1. 块级元素独占一行，行内不会\n2. 块级元素可以设置宽高，行内不可以\n3. 块级元素可以设置margin、padding，行内只能设置水平方向上的\n4. 块级元素显示display:block，行内display:inline。","source":"_posts/html块级元素、内联元素.md","raw":"---\ntitle: html块级元素、内联元素\ndate: 2018-10-11 10:39:05\ntags: HTML\ncategories: 前端\n---\n\n### html块级元素、内联元素\n\n**html中的元素分为两种：块级元素和内联元素。**\n\n##### 块级元素\n\n特点：显示在一块内，可以自动换行，元素从上到下垂直排列，各占一行。\n\n1. 总是在新行上开始\n2. 高度、行高、外边距、内边距可控\n3. 宽度缺省，默认100%\n4. 可以容纳其他的内联元素或块级元素\n\n常见的标签：p、ul、form、div、address等标签。\n\n块级元素一般可嵌套块级元素或者行内元素，一般作为容器出现，用来组织结构，但并不全如此。元素都有属性`display:block;`\n\n##### 内联元素\n\n特点：元素在一行内水平排列，高度由元素的内容决定，height不起作用（可以设置line-height控制高度）。\n\n1. 在同一行上边显示\n2. 高度、行高、垂直方向外边距、垂直方向内边距不可改变\n3. 宽度是文字或者图片的宽度，不可以改变\n4. 内联元素只能容纳内联元素或文本\n\n常见的标签：span、input、a、sub、sup等。\n\n行内元素一般都是语义化的基本元素，内能容纳文本或其他的内联元素，元素设置属性`display:inline;`\n\n##### 两者间区别：\n\n1. 块级元素独占一行，行内不会\n2. 块级元素可以设置宽高，行内不可以\n3. 块级元素可以设置margin、padding，行内只能设置水平方向上的\n4. 块级元素显示display:block，行内display:inline。","slug":"html块级元素、内联元素","published":1,"updated":"2024-02-19T07:42:51.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrae00291xop0y97f2ww","content":"<h3 id=\"html块级元素、内联元素\"><a href=\"#html块级元素、内联元素\" class=\"headerlink\" title=\"html块级元素、内联元素\"></a>html块级元素、内联元素</h3><p><strong>html中的元素分为两种：块级元素和内联元素。</strong></p>\n<h5 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h5><p>特点：显示在一块内，可以自动换行，元素从上到下垂直排列，各占一行。</p>\n<ol>\n<li>总是在新行上开始</li>\n<li>高度、行高、外边距、内边距可控</li>\n<li>宽度缺省，默认100%</li>\n<li>可以容纳其他的内联元素或块级元素</li>\n</ol>\n<p>常见的标签：p、ul、form、div、address等标签。</p>\n<p>块级元素一般可嵌套块级元素或者行内元素，一般作为容器出现，用来组织结构，但并不全如此。元素都有属性<code>display:block;</code></p>\n<h5 id=\"内联元素\"><a href=\"#内联元素\" class=\"headerlink\" title=\"内联元素\"></a>内联元素</h5><p>特点：元素在一行内水平排列，高度由元素的内容决定，height不起作用（可以设置line-height控制高度）。</p>\n<ol>\n<li>在同一行上边显示</li>\n<li>高度、行高、垂直方向外边距、垂直方向内边距不可改变</li>\n<li>宽度是文字或者图片的宽度，不可以改变</li>\n<li>内联元素只能容纳内联元素或文本</li>\n</ol>\n<p>常见的标签：span、input、a、sub、sup等。</p>\n<p>行内元素一般都是语义化的基本元素，内能容纳文本或其他的内联元素，元素设置属性<code>display:inline;</code></p>\n<h5 id=\"两者间区别：\"><a href=\"#两者间区别：\" class=\"headerlink\" title=\"两者间区别：\"></a>两者间区别：</h5><ol>\n<li>块级元素独占一行，行内不会</li>\n<li>块级元素可以设置宽高，行内不可以</li>\n<li>块级元素可以设置margin、padding，行内只能设置水平方向上的</li>\n<li>块级元素显示display:block，行内display:inline。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"html块级元素、内联元素\"><a href=\"#html块级元素、内联元素\" class=\"headerlink\" title=\"html块级元素、内联元素\"></a>html块级元素、内联元素</h3><p><strong>html中的元素分为两种：块级元素和内联元素。</strong></p>\n<h5 id=\"块级元素\"><a href=\"#块级元素\" class=\"headerlink\" title=\"块级元素\"></a>块级元素</h5><p>特点：显示在一块内，可以自动换行，元素从上到下垂直排列，各占一行。</p>\n<ol>\n<li>总是在新行上开始</li>\n<li>高度、行高、外边距、内边距可控</li>\n<li>宽度缺省，默认100%</li>\n<li>可以容纳其他的内联元素或块级元素</li>\n</ol>\n<p>常见的标签：p、ul、form、div、address等标签。</p>\n<p>块级元素一般可嵌套块级元素或者行内元素，一般作为容器出现，用来组织结构，但并不全如此。元素都有属性<code>display:block;</code></p>\n<h5 id=\"内联元素\"><a href=\"#内联元素\" class=\"headerlink\" title=\"内联元素\"></a>内联元素</h5><p>特点：元素在一行内水平排列，高度由元素的内容决定，height不起作用（可以设置line-height控制高度）。</p>\n<ol>\n<li>在同一行上边显示</li>\n<li>高度、行高、垂直方向外边距、垂直方向内边距不可改变</li>\n<li>宽度是文字或者图片的宽度，不可以改变</li>\n<li>内联元素只能容纳内联元素或文本</li>\n</ol>\n<p>常见的标签：span、input、a、sub、sup等。</p>\n<p>行内元素一般都是语义化的基本元素，内能容纳文本或其他的内联元素，元素设置属性<code>display:inline;</code></p>\n<h5 id=\"两者间区别：\"><a href=\"#两者间区别：\" class=\"headerlink\" title=\"两者间区别：\"></a>两者间区别：</h5><ol>\n<li>块级元素独占一行，行内不会</li>\n<li>块级元素可以设置宽高，行内不可以</li>\n<li>块级元素可以设置margin、padding，行内只能设置水平方向上的</li>\n<li>块级元素显示display:block，行内display:inline。</li>\n</ol>\n"},{"title":"js包装对象","date":"2018-10-08T08:34:14.000Z","_content":"\n### js包装对象\n\n在js中，对于基本的string、number、Boolean类型，在对其进行类似对象的操作时，会将这些基本类型包装成一个临时对象类型，例如：\n\n```javascript\nlet srt=\"string\";\nconsole.log(str);\t//\"string\"\nconsole.log(str.length); //6\n```\n\n***说明：***定义一个变量，赋值为字符串'string'，本身是一个基本的string类型，在调用它的length时，会将其包装成一个临时的对象，用来获取相关属性。调用length属性之后，这个临时的对象会被立即销毁。\n\n```javascript\nconsole.log(str); //string\nstr.a=10;\nconsole.log(str.a); //undefined\n```\n\n**给str添加a属性，添加完毕，包装对象立即被销毁，再去访问，得到undefined。**","source":"_posts/js包装对象.md","raw":"---\ntitle: js包装对象\ndate: 2018-10-08 16:34:14\ntags: js\ncategories: 前端\n---\n\n### js包装对象\n\n在js中，对于基本的string、number、Boolean类型，在对其进行类似对象的操作时，会将这些基本类型包装成一个临时对象类型，例如：\n\n```javascript\nlet srt=\"string\";\nconsole.log(str);\t//\"string\"\nconsole.log(str.length); //6\n```\n\n***说明：***定义一个变量，赋值为字符串'string'，本身是一个基本的string类型，在调用它的length时，会将其包装成一个临时的对象，用来获取相关属性。调用length属性之后，这个临时的对象会被立即销毁。\n\n```javascript\nconsole.log(str); //string\nstr.a=10;\nconsole.log(str.a); //undefined\n```\n\n**给str添加a属性，添加完毕，包装对象立即被销毁，再去访问，得到undefined。**","slug":"js包装对象","published":1,"updated":"2024-02-19T07:42:51.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdraf002d1xophzlk7mot","content":"<h3 id=\"js包装对象\"><a href=\"#js包装对象\" class=\"headerlink\" title=\"js包装对象\"></a>js包装对象</h3><p>在js中，对于基本的string、number、Boolean类型，在对其进行类似对象的操作时，会将这些基本类型包装成一个临时对象类型，例如：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> srt<span class=\"token operator\">=</span><span class=\"token string\">\"string\"</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//\"string\"</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//6</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong><em>说明：</em></strong>定义一个变量，赋值为字符串’string’，本身是一个基本的string类型，在调用它的length时，会将其包装成一个临时的对象，用来获取相关属性。调用length属性之后，这个临时的对象会被立即销毁。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//string</span>\nstr<span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//undefined</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>给str添加a属性，添加完毕，包装对象立即被销毁，再去访问，得到undefined。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js包装对象\"><a href=\"#js包装对象\" class=\"headerlink\" title=\"js包装对象\"></a>js包装对象</h3><p>在js中，对于基本的string、number、Boolean类型，在对其进行类似对象的操作时，会将这些基本类型包装成一个临时对象类型，例如：</p>\n<pre><code class=\"javascript\">let srt=&quot;string&quot;;\nconsole.log(str);    //&quot;string&quot;\nconsole.log(str.length); //6\n</code></pre>\n<p><strong><em>说明：</em></strong>定义一个变量，赋值为字符串’string’，本身是一个基本的string类型，在调用它的length时，会将其包装成一个临时的对象，用来获取相关属性。调用length属性之后，这个临时的对象会被立即销毁。</p>\n<pre><code class=\"javascript\">console.log(str); //string\nstr.a=10;\nconsole.log(str.a); //undefined\n</code></pre>\n<p><strong>给str添加a属性，添加完毕，包装对象立即被销毁，再去访问，得到undefined。</strong></p>\n"},{"title":"js变量提升---预处理&&执行上下文","date":"2019-05-03T04:09:04.000Z","_content":"\n### js变量提升---预处理\n\njs引擎在代码正式执行前会做一个预处理工作：\n\n1. 收集变量\n\n2. 收集函数\n\n   依据：\n\n   * var 将var后边的变量定义但不赋值 `var username = undefined`\n   * function(){} 提前定义该函数\n\n   ​\t\n\n### 执行上下文\n\n- 理解：代码执行的环境\n\n- 时机：代码正式执行之前会进入到执行环境\n\n- 创建执行上下文（**es3版本**）：\n\n  1. 创建变量对象：\n\n     - 变量\n  \n     - 函数及函数的参数\n  \n     > 函数声明会被加入到变量对象中，而函数表达式会被忽略\n       >\n     > ```js\n       > function fn(){} // 函数声明\n       > var fn = function _fn(){} //函数表达式   fn会作为变量加入到变量对象中  _fn作为函数表达式，不会被加入到变量对象中\n     > ```\n  \n   - 全局：window\n  \n   - 局部：抽象的但是确实存在\n  \n     > 函数内部的变量，只会在函数执行的过程中存在，在函数被调用时，具体的代码执行之前，js引擎会用当前函数的参数列表（`arguments`）初始化一个“变量对象”并将当前执行上下文与之关联，函数内部代码声明的**变量**和**函数**将作为属性加到这个变量对象中。\n  \n  2. 确认this的指向\n  \n     - 全局：this ---> window\n     - 局部： this ---> 调用其的对象\n  \n  3. 创建作用域链\n\n     - 构成：父级作用域链+当前的变量对象\n  \n     - 查找规则：查找变量时，会先从当前执行上下文变量对象中查找，如果没找到，就会从父级（词法层面）执行上下文的变量对象中查找，一直找到最外层（全局上下文）的变量对象。\n  \n       > 函数的作用域在函数创建时就确定了。当函数创建时，会有一个名为[[scope]]的内部属性保存所有父级变量对象到其中。当函数调用时，会创建函数执行环境，将[[scope]]属性复制初始化作用域链，变量对象（VO）激活为活动对象（AO），并添加到作用域链前端，完成创建作用域链：\n       >\n       > ```js\n       > Scope = [AO].concat([[Scope]]);\n       > ```\n  \n  4. 扩展：\n  \n     ```js\n     ECObj = {\n         //变量对象： {变量，函数，函数的形参},\n         //scopeChain：父级作用域链+当前的变量对象,\n         //this:{window || 调用其的对象}\n     }\n     ```\n  \n- 创建执行上下文（es5）\n\n  ![](js变量提升-预处理&&执行上下文/image-20200706120514737.png)[可参考](https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-5)\n\n- 创建执行上下文（es6）\n\n  ![](js变量提升-预处理&&执行上下文/image-20200706121750467.png)","source":"_posts/js变量提升-预处理&&执行上下文.md","raw":"---\ntitle: js变量提升---预处理&&执行上下文\ndate: 2019-05-03 12:09:04\ntags: js\ncategories: 前端\n---\n\n### js变量提升---预处理\n\njs引擎在代码正式执行前会做一个预处理工作：\n\n1. 收集变量\n\n2. 收集函数\n\n   依据：\n\n   * var 将var后边的变量定义但不赋值 `var username = undefined`\n   * function(){} 提前定义该函数\n\n   ​\t\n\n### 执行上下文\n\n- 理解：代码执行的环境\n\n- 时机：代码正式执行之前会进入到执行环境\n\n- 创建执行上下文（**es3版本**）：\n\n  1. 创建变量对象：\n\n     - 变量\n  \n     - 函数及函数的参数\n  \n     > 函数声明会被加入到变量对象中，而函数表达式会被忽略\n       >\n     > ```js\n       > function fn(){} // 函数声明\n       > var fn = function _fn(){} //函数表达式   fn会作为变量加入到变量对象中  _fn作为函数表达式，不会被加入到变量对象中\n     > ```\n  \n   - 全局：window\n  \n   - 局部：抽象的但是确实存在\n  \n     > 函数内部的变量，只会在函数执行的过程中存在，在函数被调用时，具体的代码执行之前，js引擎会用当前函数的参数列表（`arguments`）初始化一个“变量对象”并将当前执行上下文与之关联，函数内部代码声明的**变量**和**函数**将作为属性加到这个变量对象中。\n  \n  2. 确认this的指向\n  \n     - 全局：this ---> window\n     - 局部： this ---> 调用其的对象\n  \n  3. 创建作用域链\n\n     - 构成：父级作用域链+当前的变量对象\n  \n     - 查找规则：查找变量时，会先从当前执行上下文变量对象中查找，如果没找到，就会从父级（词法层面）执行上下文的变量对象中查找，一直找到最外层（全局上下文）的变量对象。\n  \n       > 函数的作用域在函数创建时就确定了。当函数创建时，会有一个名为[[scope]]的内部属性保存所有父级变量对象到其中。当函数调用时，会创建函数执行环境，将[[scope]]属性复制初始化作用域链，变量对象（VO）激活为活动对象（AO），并添加到作用域链前端，完成创建作用域链：\n       >\n       > ```js\n       > Scope = [AO].concat([[Scope]]);\n       > ```\n  \n  4. 扩展：\n  \n     ```js\n     ECObj = {\n         //变量对象： {变量，函数，函数的形参},\n         //scopeChain：父级作用域链+当前的变量对象,\n         //this:{window || 调用其的对象}\n     }\n     ```\n  \n- 创建执行上下文（es5）\n\n  ![](js变量提升-预处理&&执行上下文/image-20200706120514737.png)[可参考](https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-5)\n\n- 创建执行上下文（es6）\n\n  ![](js变量提升-预处理&&执行上下文/image-20200706121750467.png)","slug":"js变量提升-预处理&&执行上下文","published":1,"updated":"2024-02-19T07:42:51.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdraf002g1xopdw61geh2","content":"<h3 id=\"js变量提升—预处理\"><a href=\"#js变量提升—预处理\" class=\"headerlink\" title=\"js变量提升—预处理\"></a>js变量提升—预处理</h3><p>js引擎在代码正式执行前会做一个预处理工作：</p>\n<ol>\n<li><p>收集变量</p>\n</li>\n<li><p>收集函数</p>\n<p>依据：</p>\n<ul>\n<li>var 将var后边的变量定义但不赋值 <code>var username = undefined</code></li>\n<li>function(){} 提前定义该函数</li>\n</ul>\n<p>​    </p>\n</li>\n</ol>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><ul>\n<li><p>理解：代码执行的环境</p>\n</li>\n<li><p>时机：代码正式执行之前会进入到执行环境</p>\n</li>\n<li><p>创建执行上下文（<strong>es3版本</strong>）：</p>\n<ol>\n<li><p>创建变量对象：</p>\n<ul>\n<li><p>变量</p>\n</li>\n<li><p>函数及函数的参数</p>\n</li>\n</ul>\n<blockquote>\n<p>函数声明会被加入到变量对象中，而函数表达式会被忽略</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">// 函数声明</span>\n<span class=\"token keyword\">var</span> fn <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">_fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//函数表达式   fn会作为变量加入到变量对象中  _fn作为函数表达式，不会被加入到变量对象中</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</blockquote>\n<ul>\n<li><p>全局：window</p>\n</li>\n<li><p>局部：抽象的但是确实存在</p>\n</li>\n</ul>\n<blockquote>\n<p>函数内部的变量，只会在函数执行的过程中存在，在函数被调用时，具体的代码执行之前，js引擎会用当前函数的参数列表（<code>arguments</code>）初始化一个“变量对象”并将当前执行上下文与之关联，函数内部代码声明的<strong>变量</strong>和<strong>函数</strong>将作为属性加到这个变量对象中。</p>\n</blockquote>\n</li>\n<li><p>确认this的指向</p>\n<ul>\n<li>全局：this —&gt; window</li>\n<li>局部： this —&gt; 调用其的对象</li>\n</ul>\n</li>\n<li><p>创建作用域链</p>\n<ul>\n<li><p>构成：父级作用域链+当前的变量对象</p>\n</li>\n<li><p>查找规则：查找变量时，会先从当前执行上下文变量对象中查找，如果没找到，就会从父级（词法层面）执行上下文的变量对象中查找，一直找到最外层（全局上下文）的变量对象。</p>\n<blockquote>\n<p>函数的作用域在函数创建时就确定了。当函数创建时，会有一个名为[[scope]]的内部属性保存所有父级变量对象到其中。当函数调用时，会创建函数执行环境，将[[scope]]属性复制初始化作用域链，变量对象（VO）激活为活动对象（AO），并添加到作用域链前端，完成创建作用域链：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">Scope <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>AO<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span>Scope<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>扩展：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">ECObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//变量对象： {变量，函数，函数的形参},</span>\n    <span class=\"token comment\" spellcheck=\"true\">//scopeChain：父级作用域链+当前的变量对象,</span>\n    <span class=\"token comment\" spellcheck=\"true\">//this:{window || 调用其的对象}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n<li><p>创建执行上下文（es5）</p>\n<p><img src=\"/2019/05/03/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E9%A2%84%E5%A4%84%E7%90%86&&%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20200706120514737.png\" alt><a href=\"https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-5\" target=\"_blank\" rel=\"noopener\">可参考</a></p>\n</li>\n<li><p>创建执行上下文（es6）</p>\n<p><img src=\"/2019/05/03/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E9%A2%84%E5%A4%84%E7%90%86&&%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20200706121750467.png\" alt></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js变量提升—预处理\"><a href=\"#js变量提升—预处理\" class=\"headerlink\" title=\"js变量提升—预处理\"></a>js变量提升—预处理</h3><p>js引擎在代码正式执行前会做一个预处理工作：</p>\n<ol>\n<li><p>收集变量</p>\n</li>\n<li><p>收集函数</p>\n<p>依据：</p>\n<ul>\n<li>var 将var后边的变量定义但不赋值 <code>var username = undefined</code></li>\n<li>function(){} 提前定义该函数</li>\n</ul>\n<p>​    </p>\n</li>\n</ol>\n<h3 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h3><ul>\n<li><p>理解：代码执行的环境</p>\n</li>\n<li><p>时机：代码正式执行之前会进入到执行环境</p>\n</li>\n<li><p>创建执行上下文（<strong>es3版本</strong>）：</p>\n<ol>\n<li><p>创建变量对象：</p>\n<ul>\n<li><p>变量</p>\n</li>\n<li><p>函数及函数的参数</p>\n</li>\n</ul>\n<blockquote>\n<p>函数声明会被加入到变量对象中，而函数表达式会被忽略</p>\n<pre><code class=\"js\">function fn(){} // 函数声明\nvar fn = function _fn(){} //函数表达式   fn会作为变量加入到变量对象中  _fn作为函数表达式，不会被加入到变量对象中\n</code></pre>\n</blockquote>\n<ul>\n<li><p>全局：window</p>\n</li>\n<li><p>局部：抽象的但是确实存在</p>\n</li>\n</ul>\n<blockquote>\n<p>函数内部的变量，只会在函数执行的过程中存在，在函数被调用时，具体的代码执行之前，js引擎会用当前函数的参数列表（<code>arguments</code>）初始化一个“变量对象”并将当前执行上下文与之关联，函数内部代码声明的<strong>变量</strong>和<strong>函数</strong>将作为属性加到这个变量对象中。</p>\n</blockquote>\n</li>\n<li><p>确认this的指向</p>\n<ul>\n<li>全局：this —&gt; window</li>\n<li>局部： this —&gt; 调用其的对象</li>\n</ul>\n</li>\n<li><p>创建作用域链</p>\n<ul>\n<li><p>构成：父级作用域链+当前的变量对象</p>\n</li>\n<li><p>查找规则：查找变量时，会先从当前执行上下文变量对象中查找，如果没找到，就会从父级（词法层面）执行上下文的变量对象中查找，一直找到最外层（全局上下文）的变量对象。</p>\n<blockquote>\n<p>函数的作用域在函数创建时就确定了。当函数创建时，会有一个名为[[scope]]的内部属性保存所有父级变量对象到其中。当函数调用时，会创建函数执行环境，将[[scope]]属性复制初始化作用域链，变量对象（VO）激活为活动对象（AO），并添加到作用域链前端，完成创建作用域链：</p>\n<pre><code class=\"js\">Scope = [AO].concat([[Scope]]);\n</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>扩展：</p>\n<pre><code class=\"js\">ECObj = {\n    //变量对象： {变量，函数，函数的形参},\n    //scopeChain：父级作用域链+当前的变量对象,\n    //this:{window || 调用其的对象}\n}\n</code></pre>\n</li>\n</ol>\n</li>\n<li><p>创建执行上下文（es5）</p>\n<p><img src=\"/2019/05/03/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E9%A2%84%E5%A4%84%E7%90%86&&%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20200706120514737.png\" alt><a href=\"https://juejin.im/post/5ba32171f265da0ab719a6d7#heading-5\" target=\"_blank\" rel=\"noopener\">可参考</a></p>\n</li>\n<li><p>创建执行上下文（es6）</p>\n<p><img src=\"/2019/05/03/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E9%A2%84%E5%A4%84%E7%90%86&&%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/image-20200706121750467.png\" alt></p>\n</li>\n</ul>\n"},{"title":"js对象","date":"2018-10-23T08:20:52.000Z","_content":"\n### js对象\n\n- ##### 创建对象的方式\n\n\n1. 通过字面量方式创建\n\n   ```js\n   var Person={}; //相当于var Person=new Object()\n   var Person={\n       name:'张三',\n       age:20\n   }\n   ```\n\n2. 通过Object构造函数\n\n   ```js\n   var Person=new Object();\n   Person.name=\"张三\";\n   Person.age=20;\n   ```\n\n3. 工厂模式\n\n   ```js\n   function cretPerson(name,age){\n       var o=new Object();\n       o.name=name;\n       o.age=age;\n       o.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n       return o;\n   }\n   var person1=cretPerson('张三',20);\n   ```\n\n4. 构造函数\n\n   ```js\n   function Person(name,age){\n       this.name=name;\n       this.age=age;\n       this.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n   }\n   var person1=new Person('张三',20);\n   ```\n\n5. 原型模式\n\n   ```js\n   function Person(){};\n   Person.prototype.name='张三';\n   Person.prototype.age=20;\n   Person.prototype.say=function(){\n       console.log(this.name+': '+this.age);\n   }\n   var person1=new Person();\n   ```\n\n6. 使用ES5的Object.create()\n\n   ```js\n   const Person = {\n     \tname:'张三',\n       age:20\n   };\n   var person1 = Object.create(Person);\n   \n   function Person(){};\n   var person2 = Object.create(Person);\n   ```\n\n7. 使用Class关键字\n\n   ```js\n   class Person(name,age){\n       this.name=name;\n       this.age=age;\n       this.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n   }\n   var person1=new Person();\n   ```\n\n   ##### Object.create()和new的异同\n\n   1. new：\n\n      - 创建新对象\n      - 将相关属性和this绑定到新对象上\n      - 将新创建的对象的原型(`__proto__`)指向构造函数的原型(`prototype`)\n\n   2. Object.create()：\n\n      > 语法：`Object.create(proto, [propertiesObject])`\n\n      - 创建一个空对象\n      - 如果[propertiesObject]存在，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称\n      - 将新创建的对象的原型(`__proto__`)指向参数proto本身。（这里是参数proto，而不是proto.prototype）\n\n| 比较     | new                     | Object.create           |\n| -------- | ----------------------- | ----------------------- |\n| 构造函数 | 保留原构造函数属性      | 丢失原构造函数属性      |\n| 原型链   | 原构造函数prototype属性 | 原构造函数/（对象）本身 |\n| 作用对象 | function                | function和object        |\n\n```js\nfunction o(){};\nvar a=new o();\nvar b=Object.create(o);\nconsole.log(a.__proto__===o.prototype); //true    new创建的对象的原型指向构造函数的原型\nconsole.log(b.__proto__===o); //true Object.create创建的对象的原型指向构造函数o本身\nconsole.log(b.__proto__); //f o(){}\n```\n\n##### 使用`Object.create`的`propertyObject`参数\n\n```js\nfunction o(){};\nvar b=Object.create(o,{name:{value:'张三'}});\nconsole.log(b); //Function {name: \"张三\"}\n```\n\n- **对象枚举**\n\n  for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性---所以有必要过滤掉那些你不想要的值。通常使用的过滤器是`hasOwnProperty`方法，以及使用`typeof`来排除函数。\n\n  原型链中的任何属性通过typeof判断：\n\n  ```js\n  typeof obj.toString    // 'function'\n  typeof obj.constructor  // 'function'\n  ```\n\n  ```js\n  var name;\n  //通过typeof来排除原型中的属性\n  for(name in obj) {\n      if(typeof obj[name] !== 'function') {\n          //执行其他\n      }\n  }\n  //通过hasOwnProperty来排除原型中的属性\n  for(name in obj) {\n      if(obj.hasOwnProperty(name)) {\n          //执行其他\n      }\n  }\n  ```\n\n  在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。\n\n  ```js\n  var i;\n  var properties = [\n      'first-name',\n      'middle-name',\n      'last-name',\n      'profession'\n  ]\n  for(i = 0; i < properties.length; i += 1) {\n      obj[properties[i]];\n  }\n  ```\n\n- 删除对象中的属性\n\n  `delete`运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。\n\n**new的原理**\n\nnew：\n\n1. 创建一个新对象\n2. 对这个新对象执行原型连接\n3. 属性和方法被加入到this引用的对象中，并执行构造函数中的方法\n4. 如果函数没有返回其他对象，那么this指向这个新对象，否则this指向构造函数中返回的对象\n\n```js\nfunction new(func) {\n    let target = {};\n    target.__proto__ = func.prototype;  // 原型连接\n    let res = func.call(target);  // 将新对象作为this指向执行构造函数，并获取返回结果\n    if (res && typeof(res) == \"object\" || typeof(res) == \"function\") {  // 判断返回结果是否有其他对象，如果有则返回\n    \treturn res;\n    }\n    return target;\n}\n```\n\n","source":"_posts/js对象.md","raw":"---\ntitle: js对象\ndate: 2018-10-23 16:20:52\ntags: js\ncategories: 前端\n---\n\n### js对象\n\n- ##### 创建对象的方式\n\n\n1. 通过字面量方式创建\n\n   ```js\n   var Person={}; //相当于var Person=new Object()\n   var Person={\n       name:'张三',\n       age:20\n   }\n   ```\n\n2. 通过Object构造函数\n\n   ```js\n   var Person=new Object();\n   Person.name=\"张三\";\n   Person.age=20;\n   ```\n\n3. 工厂模式\n\n   ```js\n   function cretPerson(name,age){\n       var o=new Object();\n       o.name=name;\n       o.age=age;\n       o.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n       return o;\n   }\n   var person1=cretPerson('张三',20);\n   ```\n\n4. 构造函数\n\n   ```js\n   function Person(name,age){\n       this.name=name;\n       this.age=age;\n       this.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n   }\n   var person1=new Person('张三',20);\n   ```\n\n5. 原型模式\n\n   ```js\n   function Person(){};\n   Person.prototype.name='张三';\n   Person.prototype.age=20;\n   Person.prototype.say=function(){\n       console.log(this.name+': '+this.age);\n   }\n   var person1=new Person();\n   ```\n\n6. 使用ES5的Object.create()\n\n   ```js\n   const Person = {\n     \tname:'张三',\n       age:20\n   };\n   var person1 = Object.create(Person);\n   \n   function Person(){};\n   var person2 = Object.create(Person);\n   ```\n\n7. 使用Class关键字\n\n   ```js\n   class Person(name,age){\n       this.name=name;\n       this.age=age;\n       this.say=function(){\n           console.log(this.name+': '+this.age);\n       }\n   }\n   var person1=new Person();\n   ```\n\n   ##### Object.create()和new的异同\n\n   1. new：\n\n      - 创建新对象\n      - 将相关属性和this绑定到新对象上\n      - 将新创建的对象的原型(`__proto__`)指向构造函数的原型(`prototype`)\n\n   2. Object.create()：\n\n      > 语法：`Object.create(proto, [propertiesObject])`\n\n      - 创建一个空对象\n      - 如果[propertiesObject]存在，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称\n      - 将新创建的对象的原型(`__proto__`)指向参数proto本身。（这里是参数proto，而不是proto.prototype）\n\n| 比较     | new                     | Object.create           |\n| -------- | ----------------------- | ----------------------- |\n| 构造函数 | 保留原构造函数属性      | 丢失原构造函数属性      |\n| 原型链   | 原构造函数prototype属性 | 原构造函数/（对象）本身 |\n| 作用对象 | function                | function和object        |\n\n```js\nfunction o(){};\nvar a=new o();\nvar b=Object.create(o);\nconsole.log(a.__proto__===o.prototype); //true    new创建的对象的原型指向构造函数的原型\nconsole.log(b.__proto__===o); //true Object.create创建的对象的原型指向构造函数o本身\nconsole.log(b.__proto__); //f o(){}\n```\n\n##### 使用`Object.create`的`propertyObject`参数\n\n```js\nfunction o(){};\nvar b=Object.create(o,{name:{value:'张三'}});\nconsole.log(b); //Function {name: \"张三\"}\n```\n\n- **对象枚举**\n\n  for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性---所以有必要过滤掉那些你不想要的值。通常使用的过滤器是`hasOwnProperty`方法，以及使用`typeof`来排除函数。\n\n  原型链中的任何属性通过typeof判断：\n\n  ```js\n  typeof obj.toString    // 'function'\n  typeof obj.constructor  // 'function'\n  ```\n\n  ```js\n  var name;\n  //通过typeof来排除原型中的属性\n  for(name in obj) {\n      if(typeof obj[name] !== 'function') {\n          //执行其他\n      }\n  }\n  //通过hasOwnProperty来排除原型中的属性\n  for(name in obj) {\n      if(obj.hasOwnProperty(name)) {\n          //执行其他\n      }\n  }\n  ```\n\n  在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。\n\n  ```js\n  var i;\n  var properties = [\n      'first-name',\n      'middle-name',\n      'last-name',\n      'profession'\n  ]\n  for(i = 0; i < properties.length; i += 1) {\n      obj[properties[i]];\n  }\n  ```\n\n- 删除对象中的属性\n\n  `delete`运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。\n\n**new的原理**\n\nnew：\n\n1. 创建一个新对象\n2. 对这个新对象执行原型连接\n3. 属性和方法被加入到this引用的对象中，并执行构造函数中的方法\n4. 如果函数没有返回其他对象，那么this指向这个新对象，否则this指向构造函数中返回的对象\n\n```js\nfunction new(func) {\n    let target = {};\n    target.__proto__ = func.prototype;  // 原型连接\n    let res = func.call(target);  // 将新对象作为this指向执行构造函数，并获取返回结果\n    if (res && typeof(res) == \"object\" || typeof(res) == \"function\") {  // 判断返回结果是否有其他对象，如果有则返回\n    \treturn res;\n    }\n    return target;\n}\n```\n\n","slug":"js对象","published":1,"updated":"2024-02-19T07:42:51.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrag002k1xopc0v3dca3","content":"<h3 id=\"js对象\"><a href=\"#js对象\" class=\"headerlink\" title=\"js对象\"></a>js对象</h3><ul>\n<li><h5 id=\"创建对象的方式\"><a href=\"#创建对象的方式\" class=\"headerlink\" title=\"创建对象的方式\"></a>创建对象的方式</h5></li>\n</ul>\n<ol>\n<li><p>通过字面量方式创建</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Person<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//相当于var Person=new Object()</span>\n<span class=\"token keyword\">var</span> Person<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span><span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>通过Object构造函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Person<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>工厂模式</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">cretPerson</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span>age<span class=\"token punctuation\">;</span>\n    o<span class=\"token punctuation\">.</span>say<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">': '</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> o<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person1<span class=\"token operator\">=</span><span class=\"token function\">cretPerson</span><span class=\"token punctuation\">(</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>构造函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span>age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>say<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">': '</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>原型模式</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nPerson<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>say<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">': '</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用ES5的Object.create()</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      name<span class=\"token punctuation\">:</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span><span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person1 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> person2 <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用Class关键字</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span>age<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>say<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">': '</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> person1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"Object-create-和new的异同\"><a href=\"#Object-create-和new的异同\" class=\"headerlink\" title=\"Object.create()和new的异同\"></a>Object.create()和new的异同</h5><ol>\n<li><p>new：</p>\n<ul>\n<li>创建新对象</li>\n<li>将相关属性和this绑定到新对象上</li>\n<li>将新创建的对象的原型(<code>__proto__</code>)指向构造函数的原型(<code>prototype</code>)</li>\n</ul>\n</li>\n<li><p>Object.create()：</p>\n<blockquote>\n<p>语法：<code>Object.create(proto, [propertiesObject])</code></p>\n</blockquote>\n<ul>\n<li>创建一个空对象</li>\n<li>如果[propertiesObject]存在，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称</li>\n<li>将新创建的对象的原型(<code>__proto__</code>)指向参数proto本身。（这里是参数proto，而不是proto.prototype）</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>new</th>\n<th>Object.create</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构造函数</td>\n<td>保留原构造函数属性</td>\n<td>丢失原构造函数属性</td>\n</tr>\n<tr>\n<td>原型链</td>\n<td>原构造函数prototype属性</td>\n<td>原构造函数/（对象）本身</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>function</td>\n<td>function和object</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">o</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> a<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">o</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b<span class=\"token operator\">=</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">.</span>__proto__<span class=\"token operator\">===</span>o<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true    new创建的对象的原型指向构造函数的原型</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>__proto__<span class=\"token operator\">===</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true Object.create创建的对象的原型指向构造函数o本身</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//f o(){}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"使用Object-create的propertyObject参数\"><a href=\"#使用Object-create的propertyObject参数\" class=\"headerlink\" title=\"使用Object.create的propertyObject参数\"></a>使用<code>Object.create</code>的<code>propertyObject</code>参数</h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">o</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b<span class=\"token operator\">=</span>Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>value<span class=\"token punctuation\">:</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Function {name: \"张三\"}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p><strong>对象枚举</strong></p>\n<p>for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性—所以有必要过滤掉那些你不想要的值。通常使用的过滤器是<code>hasOwnProperty</code>方法，以及使用<code>typeof</code>来排除函数。</p>\n<p>原型链中的任何属性通过typeof判断：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">.</span>toString    <span class=\"token comment\" spellcheck=\"true\">// 'function'</span>\n<span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">.</span>constructor  <span class=\"token comment\" spellcheck=\"true\">// 'function'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//通过typeof来排除原型中的属性</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj<span class=\"token punctuation\">[</span>name<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行其他</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//通过hasOwnProperty来排除原型中的属性</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>name <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行其他</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> i<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> properties <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'first-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'middle-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'last-name'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">'profession'</span>\n<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> properties<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    obj<span class=\"token punctuation\">[</span>properties<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除对象中的属性</p>\n<p><code>delete</code>运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。</p>\n</li>\n</ul>\n<p><strong>new的原理</strong></p>\n<p>new：</p>\n<ol>\n<li>创建一个新对象</li>\n<li>对这个新对象执行原型连接</li>\n<li>属性和方法被加入到this引用的对象中，并执行构造函数中的方法</li>\n<li>如果函数没有返回其他对象，那么this指向这个新对象，否则this指向构造函数中返回的对象</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> target <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    target<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">=</span> func<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 原型连接</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> func<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 将新对象作为this指向执行构造函数，并获取返回结果</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>res <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"object\"</span> <span class=\"token operator\">||</span> <span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"function\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 判断返回结果是否有其他对象，如果有则返回</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> target<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js对象\"><a href=\"#js对象\" class=\"headerlink\" title=\"js对象\"></a>js对象</h3><ul>\n<li><h5 id=\"创建对象的方式\"><a href=\"#创建对象的方式\" class=\"headerlink\" title=\"创建对象的方式\"></a>创建对象的方式</h5></li>\n</ul>\n<ol>\n<li><p>通过字面量方式创建</p>\n<pre><code class=\"js\">var Person={}; //相当于var Person=new Object()\nvar Person={\n    name:&#39;张三&#39;,\n    age:20\n}\n</code></pre>\n</li>\n<li><p>通过Object构造函数</p>\n<pre><code class=\"js\">var Person=new Object();\nPerson.name=&quot;张三&quot;;\nPerson.age=20;\n</code></pre>\n</li>\n<li><p>工厂模式</p>\n<pre><code class=\"js\">function cretPerson(name,age){\n    var o=new Object();\n    o.name=name;\n    o.age=age;\n    o.say=function(){\n        console.log(this.name+&#39;: &#39;+this.age);\n    }\n    return o;\n}\nvar person1=cretPerson(&#39;张三&#39;,20);\n</code></pre>\n</li>\n<li><p>构造函数</p>\n<pre><code class=\"js\">function Person(name,age){\n    this.name=name;\n    this.age=age;\n    this.say=function(){\n        console.log(this.name+&#39;: &#39;+this.age);\n    }\n}\nvar person1=new Person(&#39;张三&#39;,20);\n</code></pre>\n</li>\n<li><p>原型模式</p>\n<pre><code class=\"js\">function Person(){};\nPerson.prototype.name=&#39;张三&#39;;\nPerson.prototype.age=20;\nPerson.prototype.say=function(){\n    console.log(this.name+&#39;: &#39;+this.age);\n}\nvar person1=new Person();\n</code></pre>\n</li>\n<li><p>使用ES5的Object.create()</p>\n<pre><code class=\"js\">const Person = {\n      name:&#39;张三&#39;,\n    age:20\n};\nvar person1 = Object.create(Person);\n\nfunction Person(){};\nvar person2 = Object.create(Person);\n</code></pre>\n</li>\n<li><p>使用Class关键字</p>\n<pre><code class=\"js\">class Person(name,age){\n    this.name=name;\n    this.age=age;\n    this.say=function(){\n        console.log(this.name+&#39;: &#39;+this.age);\n    }\n}\nvar person1=new Person();\n</code></pre>\n<h5 id=\"Object-create-和new的异同\"><a href=\"#Object-create-和new的异同\" class=\"headerlink\" title=\"Object.create()和new的异同\"></a>Object.create()和new的异同</h5><ol>\n<li><p>new：</p>\n<ul>\n<li>创建新对象</li>\n<li>将相关属性和this绑定到新对象上</li>\n<li>将新创建的对象的原型(<code>__proto__</code>)指向构造函数的原型(<code>prototype</code>)</li>\n</ul>\n</li>\n<li><p>Object.create()：</p>\n<blockquote>\n<p>语法：<code>Object.create(proto, [propertiesObject])</code></p>\n</blockquote>\n<ul>\n<li>创建一个空对象</li>\n<li>如果[propertiesObject]存在，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称</li>\n<li>将新创建的对象的原型(<code>__proto__</code>)指向参数proto本身。（这里是参数proto，而不是proto.prototype）</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>比较</th>\n<th>new</th>\n<th>Object.create</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>构造函数</td>\n<td>保留原构造函数属性</td>\n<td>丢失原构造函数属性</td>\n</tr>\n<tr>\n<td>原型链</td>\n<td>原构造函数prototype属性</td>\n<td>原构造函数/（对象）本身</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>function</td>\n<td>function和object</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"js\">function o(){};\nvar a=new o();\nvar b=Object.create(o);\nconsole.log(a.__proto__===o.prototype); //true    new创建的对象的原型指向构造函数的原型\nconsole.log(b.__proto__===o); //true Object.create创建的对象的原型指向构造函数o本身\nconsole.log(b.__proto__); //f o(){}\n</code></pre>\n<h5 id=\"使用Object-create的propertyObject参数\"><a href=\"#使用Object-create的propertyObject参数\" class=\"headerlink\" title=\"使用Object.create的propertyObject参数\"></a>使用<code>Object.create</code>的<code>propertyObject</code>参数</h5><pre><code class=\"js\">function o(){};\nvar b=Object.create(o,{name:{value:&#39;张三&#39;}});\nconsole.log(b); //Function {name: &quot;张三&quot;}\n</code></pre>\n<ul>\n<li><p><strong>对象枚举</strong></p>\n<p>for in 语句可以用来遍历一个对象中所有的属性名，该枚举过程将会列出所有的属性—包括函数和你可能不关心的原型中的属性—所以有必要过滤掉那些你不想要的值。通常使用的过滤器是<code>hasOwnProperty</code>方法，以及使用<code>typeof</code>来排除函数。</p>\n<p>原型链中的任何属性通过typeof判断：</p>\n<pre><code class=\"js\">typeof obj.toString    // &#39;function&#39;\ntypeof obj.constructor  // &#39;function&#39;\n</code></pre>\n<pre><code class=\"js\">var name;\n//通过typeof来排除原型中的属性\nfor(name in obj) {\n    if(typeof obj[name] !== &#39;function&#39;) {\n        //执行其他\n    }\n}\n//通过hasOwnProperty来排除原型中的属性\nfor(name in obj) {\n    if(obj.hasOwnProperty(name)) {\n        //执行其他\n    }\n}\n</code></pre>\n<p>在使用for in 遍历对象时，属性名出现的顺序是不确定的。如果想要确保属性以特定的顺序出现，最好的办法就是避免使用for in 语句，而是创建一个数组，在其中以正确的顺序包含属性名。</p>\n<pre><code class=\"js\">var i;\nvar properties = [\n    &#39;first-name&#39;,\n    &#39;middle-name&#39;,\n    &#39;last-name&#39;,\n    &#39;profession&#39;\n]\nfor(i = 0; i &lt; properties.length; i += 1) {\n    obj[properties[i]];\n}\n</code></pre>\n</li>\n<li><p>删除对象中的属性</p>\n<p><code>delete</code>运算符可以用来删除对象的属性。它将会移除对象中确定包含的属性，它不会触及原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性浮现出来。</p>\n</li>\n</ul>\n<p><strong>new的原理</strong></p>\n<p>new：</p>\n<ol>\n<li>创建一个新对象</li>\n<li>对这个新对象执行原型连接</li>\n<li>属性和方法被加入到this引用的对象中，并执行构造函数中的方法</li>\n<li>如果函数没有返回其他对象，那么this指向这个新对象，否则this指向构造函数中返回的对象</li>\n</ol>\n<pre><code class=\"js\">function new(func) {\n    let target = {};\n    target.__proto__ = func.prototype;  // 原型连接\n    let res = func.call(target);  // 将新对象作为this指向执行构造函数，并获取返回结果\n    if (res &amp;&amp; typeof(res) == &quot;object&quot; || typeof(res) == &quot;function&quot;) {  // 判断返回结果是否有其他对象，如果有则返回\n        return res;\n    }\n    return target;\n}\n</code></pre>\n"},{"title":"js作用域与作用域链","date":"2020-07-30T06:13:27.000Z","_content":"\n### js作用域与作用域链\n\n- ##### **作用域**\n\n  作用域决定了变量的生命周期和可见性。作用域分为全局作用域和局部作用域。全局作用域就是顶级（最外层）作用域。js采用词法作用域，也就是说作用域是在代码编译阶段确定的。\n\n- ##### **作用域链**\n\n  作用域链就是各个词法环境连接成的一个链。每创建一个执行上下文，就会创建对应的词法环境。词法环境由环境记录器（声明试环境记录器和对象环境记录器）和**外部环境的引用**构成。这个外部环境的引用其实就是对父（外层）作用域的一个引用。在全局执行上下文中。这个外部环境的引用为`null`。作用域链的访问是单向的，只能从内部访问外部。我们每一层的执行上下文只有对外层的引用，而没有对内层的引用。\n\n- ##### **执行过程**\n\n  执行时，首先从当前的词法环境中进行寻找，如果没找到，就找上层（词法层面）的词法环境，直到找到或到达顶层词法环境为止。\n\n","source":"_posts/js作用域与作用域链.md","raw":"---\ntitle: js作用域与作用域链\ndate: 2020-07-30 14:13:27\ntags: js\ncategories: 前端\n---\n\n### js作用域与作用域链\n\n- ##### **作用域**\n\n  作用域决定了变量的生命周期和可见性。作用域分为全局作用域和局部作用域。全局作用域就是顶级（最外层）作用域。js采用词法作用域，也就是说作用域是在代码编译阶段确定的。\n\n- ##### **作用域链**\n\n  作用域链就是各个词法环境连接成的一个链。每创建一个执行上下文，就会创建对应的词法环境。词法环境由环境记录器（声明试环境记录器和对象环境记录器）和**外部环境的引用**构成。这个外部环境的引用其实就是对父（外层）作用域的一个引用。在全局执行上下文中。这个外部环境的引用为`null`。作用域链的访问是单向的，只能从内部访问外部。我们每一层的执行上下文只有对外层的引用，而没有对内层的引用。\n\n- ##### **执行过程**\n\n  执行时，首先从当前的词法环境中进行寻找，如果没找到，就找上层（词法层面）的词法环境，直到找到或到达顶层词法环境为止。\n\n","slug":"js作用域与作用域链","published":1,"updated":"2024-02-19T07:42:51.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrag002n1xopdbkc7uin","content":"<h3 id=\"js作用域与作用域链\"><a href=\"#js作用域与作用域链\" class=\"headerlink\" title=\"js作用域与作用域链\"></a>js作用域与作用域链</h3><ul>\n<li><h5 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h5><p>作用域决定了变量的生命周期和可见性。作用域分为全局作用域和局部作用域。全局作用域就是顶级（最外层）作用域。js采用词法作用域，也就是说作用域是在代码编译阶段确定的。</p>\n</li>\n<li><h5 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a><strong>作用域链</strong></h5><p>作用域链就是各个词法环境连接成的一个链。每创建一个执行上下文，就会创建对应的词法环境。词法环境由环境记录器（声明试环境记录器和对象环境记录器）和<strong>外部环境的引用</strong>构成。这个外部环境的引用其实就是对父（外层）作用域的一个引用。在全局执行上下文中。这个外部环境的引用为<code>null</code>。作用域链的访问是单向的，只能从内部访问外部。我们每一层的执行上下文只有对外层的引用，而没有对内层的引用。</p>\n</li>\n<li><h5 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a><strong>执行过程</strong></h5><p>执行时，首先从当前的词法环境中进行寻找，如果没找到，就找上层（词法层面）的词法环境，直到找到或到达顶层词法环境为止。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js作用域与作用域链\"><a href=\"#js作用域与作用域链\" class=\"headerlink\" title=\"js作用域与作用域链\"></a>js作用域与作用域链</h3><ul>\n<li><h5 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a><strong>作用域</strong></h5><p>作用域决定了变量的生命周期和可见性。作用域分为全局作用域和局部作用域。全局作用域就是顶级（最外层）作用域。js采用词法作用域，也就是说作用域是在代码编译阶段确定的。</p>\n</li>\n<li><h5 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a><strong>作用域链</strong></h5><p>作用域链就是各个词法环境连接成的一个链。每创建一个执行上下文，就会创建对应的词法环境。词法环境由环境记录器（声明试环境记录器和对象环境记录器）和<strong>外部环境的引用</strong>构成。这个外部环境的引用其实就是对父（外层）作用域的一个引用。在全局执行上下文中。这个外部环境的引用为<code>null</code>。作用域链的访问是单向的，只能从内部访问外部。我们每一层的执行上下文只有对外层的引用，而没有对内层的引用。</p>\n</li>\n<li><h5 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a><strong>执行过程</strong></h5><p>执行时，首先从当前的词法环境中进行寻找，如果没找到，就找上层（词法层面）的词法环境，直到找到或到达顶层词法环境为止。</p>\n</li>\n</ul>\n"},{"title":"js宏任务和微任务","date":"2019-04-28T03:03:51.000Z","_content":"\n### js宏任务和微任务\n\n##### 宏任务\n\n分类：`setTimeout` `setInterval` `requrestAnimationFrame`\n\n1. 宏任务所处的队列就是宏任务队列\n2. 第一个宏任务队列中只有一个任务：执行主线程的js代码\n3. 宏任务队列可以有多个\n4. 当宏任务队列中的任务全部被执行完以后会查看是否有微任务队列如果有则先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列\n\n##### 微任务\n\n分类：`new promise.then(回调)` `process.nextTick`\n\n1. 微任务所处的队列就是微任务队列\n2. 只有一个微任务队列\n3. 在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务 \n\n```js\nconsole.log('---------- start --------------');\nsetTimeout(() => {\n    console.log('setTimeout');\n}, 0)\n\nnew Promise((resolve, reject) => {\n    for(var i = 0; i < 5; i++) {\n        console.log(i);\n    }\n    resolve(); //修改promise实例对象的状态为成功的状态\n}).then(() => {\n    console.log('promise实例成功回调执行！');\n})\nconsole.log('------------- end ----------------');\n\n\n\n//输出结果\n/*\n---------- start --------------\n0\n1\n2\n3\n4\n------------- end ----------------\npromise实例成功回调执行\nsetTimeout\n*/\n```\n\n","source":"_posts/js宏任务和微任务.md","raw":"---\ntitle: js宏任务和微任务\ndate: 2019-04-28 11:03:51\ntags: js\ncategories: 前端\n---\n\n### js宏任务和微任务\n\n##### 宏任务\n\n分类：`setTimeout` `setInterval` `requrestAnimationFrame`\n\n1. 宏任务所处的队列就是宏任务队列\n2. 第一个宏任务队列中只有一个任务：执行主线程的js代码\n3. 宏任务队列可以有多个\n4. 当宏任务队列中的任务全部被执行完以后会查看是否有微任务队列如果有则先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列\n\n##### 微任务\n\n分类：`new promise.then(回调)` `process.nextTick`\n\n1. 微任务所处的队列就是微任务队列\n2. 只有一个微任务队列\n3. 在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务 \n\n```js\nconsole.log('---------- start --------------');\nsetTimeout(() => {\n    console.log('setTimeout');\n}, 0)\n\nnew Promise((resolve, reject) => {\n    for(var i = 0; i < 5; i++) {\n        console.log(i);\n    }\n    resolve(); //修改promise实例对象的状态为成功的状态\n}).then(() => {\n    console.log('promise实例成功回调执行！');\n})\nconsole.log('------------- end ----------------');\n\n\n\n//输出结果\n/*\n---------- start --------------\n0\n1\n2\n3\n4\n------------- end ----------------\npromise实例成功回调执行\nsetTimeout\n*/\n```\n\n","slug":"js宏任务和微任务","published":1,"updated":"2024-02-19T07:42:51.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrah002r1xop178d4pnl","content":"<h3 id=\"js宏任务和微任务\"><a href=\"#js宏任务和微任务\" class=\"headerlink\" title=\"js宏任务和微任务\"></a>js宏任务和微任务</h3><h5 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h5><p>分类：<code>setTimeout</code> <code>setInterval</code> <code>requrestAnimationFrame</code></p>\n<ol>\n<li>宏任务所处的队列就是宏任务队列</li>\n<li>第一个宏任务队列中只有一个任务：执行主线程的js代码</li>\n<li>宏任务队列可以有多个</li>\n<li>当宏任务队列中的任务全部被执行完以后会查看是否有微任务队列如果有则先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列</li>\n</ol>\n<h5 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h5><p>分类：<code>new promise.then(回调)</code> <code>process.nextTick</code></p>\n<ol>\n<li>微任务所处的队列就是微任务队列</li>\n<li>只有一个微任务队列</li>\n<li>在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务 </li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'---------- start --------------'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//修改promise实例对象的状态为成功的状态</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise实例成功回调执行！'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'------------- end ----------------'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n\n<span class=\"token comment\" spellcheck=\"true\">//输出结果</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n---------- start --------------\n0\n1\n2\n3\n4\n------------- end ----------------\npromise实例成功回调执行\nsetTimeout\n*/</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js宏任务和微任务\"><a href=\"#js宏任务和微任务\" class=\"headerlink\" title=\"js宏任务和微任务\"></a>js宏任务和微任务</h3><h5 id=\"宏任务\"><a href=\"#宏任务\" class=\"headerlink\" title=\"宏任务\"></a>宏任务</h5><p>分类：<code>setTimeout</code> <code>setInterval</code> <code>requrestAnimationFrame</code></p>\n<ol>\n<li>宏任务所处的队列就是宏任务队列</li>\n<li>第一个宏任务队列中只有一个任务：执行主线程的js代码</li>\n<li>宏任务队列可以有多个</li>\n<li>当宏任务队列中的任务全部被执行完以后会查看是否有微任务队列如果有则先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列</li>\n</ol>\n<h5 id=\"微任务\"><a href=\"#微任务\" class=\"headerlink\" title=\"微任务\"></a>微任务</h5><p>分类：<code>new promise.then(回调)</code> <code>process.nextTick</code></p>\n<ol>\n<li>微任务所处的队列就是微任务队列</li>\n<li>只有一个微任务队列</li>\n<li>在上一个宏任务队列执行完毕后如果有微任务队列就会执行微任务队列中的所有任务 </li>\n</ol>\n<pre><code class=\"js\">console.log(&#39;---------- start --------------&#39;);\nsetTimeout(() =&gt; {\n    console.log(&#39;setTimeout&#39;);\n}, 0)\n\nnew Promise((resolve, reject) =&gt; {\n    for(var i = 0; i &lt; 5; i++) {\n        console.log(i);\n    }\n    resolve(); //修改promise实例对象的状态为成功的状态\n}).then(() =&gt; {\n    console.log(&#39;promise实例成功回调执行！&#39;);\n})\nconsole.log(&#39;------------- end ----------------&#39;);\n\n\n\n//输出结果\n/*\n---------- start --------------\n0\n1\n2\n3\n4\n------------- end ----------------\npromise实例成功回调执行\nsetTimeout\n*/\n</code></pre>\n"},{"title":"js的prototype总结","date":"2018-10-06T09:40:45.000Z","_content":"\n### js的prototype总结\n\n**1. 每一个函数都有一个`prototype`，即原型**。\n\n**2. 每个对象都有一个`__proto__`，可称为隐式原型，指向创建该对象的函数的`prototype`。**\n\n> **`Object.prototype`却是一个特例——它的`__proto__`指向的是`null`。**\n\n![](js的prototype总结/3ed52e91409ae13e805e9ea9c771c66c.png)\n\n**3. 自定义函数`Foo.__proto__`指向`Function.prototype`,`Object.__proto__`指向`Function.prototype`，而`Function.__proto__`指向`Function.prototype`,从而形成一个环形结构。`Function`也是一个函数，函数是一种对象，而`Function`是被自身所创建的一种函数，所以它的`__proto__`指向了自身的`prototype`。**\n\n![](js的prototype总结/672e52454044214b80a9d2f140417535.png)\n\n**4. `Function.prototype`是一个对象，它的`__proto__`也指向`Object.prototype`。**\n\n![](js的prototype总结/fc61390740d130488051d1089074ba12.png)\n\n**5. `Instanceof`运算符：**\n\n> `instanceof`运算符的左边的变量是一个对象，暂时称为A；右边的变量为一个函数，暂时称为B。\n>\n> **`instanceof`的判断规则：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能够找到同一个引用，也就是同一个对象的话，返回`true`，如果找到终点还未重合，则返回`false`。**\n\n```javascript\nfunction Foo(){};\nlet f1=new Foo();\nconsole.log(f1 instanceof Foo); //true\nconsole.log(f1 instanceof Object); //true\n```\n\n![](js的prototype总结/ad023c9f40a1e17f803967a5a402683e.png)\n\n***`instanceof`表示的就是一种继承关系，或者原型链的结构。***\n\n![](js的prototype总结/fb2ec26540658c9480e22f7217f7ff29.png)","source":"_posts/js的prototype总结.md","raw":"---\ntitle: js的prototype总结\ndate: 2018-10-06 17:40:45\ntags: js\ncategories: 前端\n---\n\n### js的prototype总结\n\n**1. 每一个函数都有一个`prototype`，即原型**。\n\n**2. 每个对象都有一个`__proto__`，可称为隐式原型，指向创建该对象的函数的`prototype`。**\n\n> **`Object.prototype`却是一个特例——它的`__proto__`指向的是`null`。**\n\n![](js的prototype总结/3ed52e91409ae13e805e9ea9c771c66c.png)\n\n**3. 自定义函数`Foo.__proto__`指向`Function.prototype`,`Object.__proto__`指向`Function.prototype`，而`Function.__proto__`指向`Function.prototype`,从而形成一个环形结构。`Function`也是一个函数，函数是一种对象，而`Function`是被自身所创建的一种函数，所以它的`__proto__`指向了自身的`prototype`。**\n\n![](js的prototype总结/672e52454044214b80a9d2f140417535.png)\n\n**4. `Function.prototype`是一个对象，它的`__proto__`也指向`Object.prototype`。**\n\n![](js的prototype总结/fc61390740d130488051d1089074ba12.png)\n\n**5. `Instanceof`运算符：**\n\n> `instanceof`运算符的左边的变量是一个对象，暂时称为A；右边的变量为一个函数，暂时称为B。\n>\n> **`instanceof`的判断规则：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能够找到同一个引用，也就是同一个对象的话，返回`true`，如果找到终点还未重合，则返回`false`。**\n\n```javascript\nfunction Foo(){};\nlet f1=new Foo();\nconsole.log(f1 instanceof Foo); //true\nconsole.log(f1 instanceof Object); //true\n```\n\n![](js的prototype总结/ad023c9f40a1e17f803967a5a402683e.png)\n\n***`instanceof`表示的就是一种继承关系，或者原型链的结构。***\n\n![](js的prototype总结/fb2ec26540658c9480e22f7217f7ff29.png)","slug":"js的prototype总结","published":1,"updated":"2024-02-19T07:42:51.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrah002u1xop0e8rcouz","content":"<h3 id=\"js的prototype总结\"><a href=\"#js的prototype总结\" class=\"headerlink\" title=\"js的prototype总结\"></a>js的prototype总结</h3><p><strong>1. 每一个函数都有一个<code>prototype</code>，即原型</strong>。</p>\n<p><strong>2. 每个对象都有一个<code>__proto__</code>，可称为隐式原型，指向创建该对象的函数的<code>prototype</code>。</strong></p>\n<blockquote>\n<p><strong><code>Object.prototype</code>却是一个特例——它的<code>__proto__</code>指向的是<code>null</code>。</strong></p>\n</blockquote>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/3ed52e91409ae13e805e9ea9c771c66c.png\" alt></p>\n<p><strong>3. 自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>,<code>Object.__proto__</code>指向<code>Function.prototype</code>，而<code>Function.__proto__</code>指向<code>Function.prototype</code>,从而形成一个环形结构。<code>Function</code>也是一个函数，函数是一种对象，而<code>Function</code>是被自身所创建的一种函数，所以它的<code>__proto__</code>指向了自身的<code>prototype</code>。</strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/672e52454044214b80a9d2f140417535.png\" alt></p>\n<p><strong>4. <code>Function.prototype</code>是一个对象，它的<code>__proto__</code>也指向<code>Object.prototype</code>。</strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/fc61390740d130488051d1089074ba12.png\" alt></p>\n<p><strong>5. <code>Instanceof</code>运算符：</strong></p>\n<blockquote>\n<p><code>instanceof</code>运算符的左边的变量是一个对象，暂时称为A；右边的变量为一个函数，暂时称为B。</p>\n<p><strong><code>instanceof</code>的判断规则：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能够找到同一个引用，也就是同一个对象的话，返回<code>true</code>，如果找到终点还未重合，则返回<code>false</code>。</strong></p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> f1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>f1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>f1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/ad023c9f40a1e17f803967a5a402683e.png\" alt></p>\n<p><strong><em><code>instanceof</code>表示的就是一种继承关系，或者原型链的结构。</em></strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/fb2ec26540658c9480e22f7217f7ff29.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js的prototype总结\"><a href=\"#js的prototype总结\" class=\"headerlink\" title=\"js的prototype总结\"></a>js的prototype总结</h3><p><strong>1. 每一个函数都有一个<code>prototype</code>，即原型</strong>。</p>\n<p><strong>2. 每个对象都有一个<code>__proto__</code>，可称为隐式原型，指向创建该对象的函数的<code>prototype</code>。</strong></p>\n<blockquote>\n<p><strong><code>Object.prototype</code>却是一个特例——它的<code>__proto__</code>指向的是<code>null</code>。</strong></p>\n</blockquote>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/3ed52e91409ae13e805e9ea9c771c66c.png\" alt></p>\n<p><strong>3. 自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>,<code>Object.__proto__</code>指向<code>Function.prototype</code>，而<code>Function.__proto__</code>指向<code>Function.prototype</code>,从而形成一个环形结构。<code>Function</code>也是一个函数，函数是一种对象，而<code>Function</code>是被自身所创建的一种函数，所以它的<code>__proto__</code>指向了自身的<code>prototype</code>。</strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/672e52454044214b80a9d2f140417535.png\" alt></p>\n<p><strong>4. <code>Function.prototype</code>是一个对象，它的<code>__proto__</code>也指向<code>Object.prototype</code>。</strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/fc61390740d130488051d1089074ba12.png\" alt></p>\n<p><strong>5. <code>Instanceof</code>运算符：</strong></p>\n<blockquote>\n<p><code>instanceof</code>运算符的左边的变量是一个对象，暂时称为A；右边的变量为一个函数，暂时称为B。</p>\n<p><strong><code>instanceof</code>的判断规则：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能够找到同一个引用，也就是同一个对象的话，返回<code>true</code>，如果找到终点还未重合，则返回<code>false</code>。</strong></p>\n</blockquote>\n<pre><code class=\"javascript\">function Foo(){};\nlet f1=new Foo();\nconsole.log(f1 instanceof Foo); //true\nconsole.log(f1 instanceof Object); //true\n</code></pre>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/ad023c9f40a1e17f803967a5a402683e.png\" alt></p>\n<p><strong><em><code>instanceof</code>表示的就是一种继承关系，或者原型链的结构。</em></strong></p>\n<p><img src=\"/2018/10/06/js%E7%9A%84prototype%E6%80%BB%E7%BB%93/fb2ec26540658c9480e22f7217f7ff29.png\" alt></p>\n"},{"title":"js深拷贝、浅拷贝","date":"2019-06-01T03:27:05.000Z","_content":"\n### js深拷贝、浅拷贝\n\n什么是深拷贝？深拷贝和浅拷贝有什么区别？\n\n浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。\n\n深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。\n\n实现一个深拷贝:\n\n```js\nfunction deepClone(obj) {\n    if(obj === null) {return null}; // null情况\n    if(obj instanceof RegExp) {return new RegExp(obj)};\n    if(obj instanceof Date) {return new Date(obj)};\n    \n    // 如果不是复杂数据类型，直接返回\n    if(typeof obj !== 'object') {\n        return obj\n    }\n    \n    // 如果obj是数组，那么obj.constructor是[Function: Array]\n    // 如果obj是对象，那么obj.constructor是[Function: Object]\n    \n    let t = new obj.constructor(); // [] or {}\n    for(let key in obj) {\n        t[key] = deepClone(obj[key]) // 复杂数据类型进行递归\n    }\n  \treturn t\n}\n```\n\n","source":"_posts/js深拷贝、浅拷贝.md","raw":"---\ntitle: js深拷贝、浅拷贝\ndate: 2019-06-01 11:27:05\ntags: js\ncategories: 前端\n---\n\n### js深拷贝、浅拷贝\n\n什么是深拷贝？深拷贝和浅拷贝有什么区别？\n\n浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。\n\n深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。\n\n实现一个深拷贝:\n\n```js\nfunction deepClone(obj) {\n    if(obj === null) {return null}; // null情况\n    if(obj instanceof RegExp) {return new RegExp(obj)};\n    if(obj instanceof Date) {return new Date(obj)};\n    \n    // 如果不是复杂数据类型，直接返回\n    if(typeof obj !== 'object') {\n        return obj\n    }\n    \n    // 如果obj是数组，那么obj.constructor是[Function: Array]\n    // 如果obj是对象，那么obj.constructor是[Function: Object]\n    \n    let t = new obj.constructor(); // [] or {}\n    for(let key in obj) {\n        t[key] = deepClone(obj[key]) // 复杂数据类型进行递归\n    }\n  \treturn t\n}\n```\n\n","slug":"js深拷贝、浅拷贝","published":1,"updated":"2024-02-19T07:42:51.604Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrai002x1xop3l0vc15u","content":"<h3 id=\"js深拷贝、浅拷贝\"><a href=\"#js深拷贝、浅拷贝\" class=\"headerlink\" title=\"js深拷贝、浅拷贝\"></a>js深拷贝、浅拷贝</h3><p>什么是深拷贝？深拷贝和浅拷贝有什么区别？</p>\n<p>浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>\n<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>\n<p>实现一个深拷贝:</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// null情况</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RegExp</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果不是复杂数据类型，直接返回</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> obj <span class=\"token operator\">!==</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> obj\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 如果obj是数组，那么obj.constructor是[Function: Array]</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果obj是对象，那么obj.constructor是[Function: Object]</span>\n\n    <span class=\"token keyword\">let</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">obj<span class=\"token punctuation\">.</span>constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [] or {}</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        t<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">deepClone</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 复杂数据类型进行递归</span>\n    <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> t\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js深拷贝、浅拷贝\"><a href=\"#js深拷贝、浅拷贝\" class=\"headerlink\" title=\"js深拷贝、浅拷贝\"></a>js深拷贝、浅拷贝</h3><p>什么是深拷贝？深拷贝和浅拷贝有什么区别？</p>\n<p>浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>\n<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>\n<p>实现一个深拷贝:</p>\n<pre><code class=\"js\">function deepClone(obj) {\n    if(obj === null) {return null}; // null情况\n    if(obj instanceof RegExp) {return new RegExp(obj)};\n    if(obj instanceof Date) {return new Date(obj)};\n\n    // 如果不是复杂数据类型，直接返回\n    if(typeof obj !== &#39;object&#39;) {\n        return obj\n    }\n\n    // 如果obj是数组，那么obj.constructor是[Function: Array]\n    // 如果obj是对象，那么obj.constructor是[Function: Object]\n\n    let t = new obj.constructor(); // [] or {}\n    for(let key in obj) {\n        t[key] = deepClone(obj[key]) // 复杂数据类型进行递归\n    }\n      return t\n}\n</code></pre>\n"},{"title":"js类型检测总结","date":"2018-10-06T10:25:53.000Z","_content":"\n### js类型检测总结\n\n**检测规则：**\n\n![](js类型检测总结/5e35a8e04062aeeb805a82c051a9560d.png)\n\n1. **`typeof`：操作符返回一个字符串，表示未经计算的操作数的类型**\n\n   语法：`typeof`运算符后跟操作数。\n\n   >```javascript\n   >typeof operand\n   >or\n   >typeof (operand)\n   >```\n   >\n   >**operand是一个表达式，表示对象或原始值，其类型将被返回。**\n   >\n   >| 类型                                        | 结果                       |\n   >| ------------------------------------------- | -------------------------- |\n   >| Undefined                                   | `\"undefined\"`              |\n   >| Null                                        | `\"object\"`                 |\n   >| Boolean                                     | `\"boolean\"`                |\n   >| Number                                      | `\"number\"`                 |\n   >| String                                      | `\"string\"`                 |\n   >| Symbol （ECMAScript 6 新增）                | `\"symbol\"`                 |\n   >| 宿主对象（由JS环境提供）                    | *Implementation-dependent* |\n   >| 函数对象（[[Call]] 在ECMA-262条款中实现了） | `\"function\"`               |\n   >| 任何其他对象                                | `\"object\"`                 |\n\n   ##### 使用`new`操作符：\n\n   ```javascript\n   let str=new String('string');\n   let num=new Number(100);\n   typeof str; //'object'\n   typeof num; //'object'\n   let func=new Function();\n   typeof func; //'function'\n   ```\n\n   ##### 语法中需要括号：\n\n   ```javascript\n   let num=99;\n   typeof num + ' str'; //it will return 'number str'\n   typeof (num+' str'); //string\n   ```\n\n   ##### 暂存死区：\n\n   > 在 ECMAScript 2015 之前，`typeof`总是保证为任何操作数返回一个字符串。但是，除了非提升，块作用域的[let](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let)和[const](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const)之外，在声明之前对块中的`let`和`const`变量使用`typeof`会抛出一个[ReferenceError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)。这与未声明的变量形成对比，`typeof`会返回“undefined”。块作用域变量在块的头部处于“[暂时死区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let)”，直到被初始化，在这期间，如果变量被访问将会引发错误。\n   >\n   > ```\n   > typeof undeclaredVariable === 'undefined';\n   > typeof newLetVariable; let newLetVariable; // ReferenceError\n   > typeof newConstVariable; const newConstVariable = 'hello'; // ReferenceError\n   > ```\n   >\n   >\n\n2. **`instanceof`：用于测试构造函数的`prototype`属性是否出现在对象的原型链中的任何位置**\n\n> **语法：`object instanceof constructor`**\n>\n> **参数：`object` 要检测的对象， `constructor` 某个构造函数**\n>\n> **举例：**\n>\n> ```javascript\n> function Dog(name,food){\n>     this.name=name;\n>     this.food=food;\n>     console.log(this.name+'吃'+this.food);\n> }\n> let dog=new Dog('小黑','骨头');\n> console.log(dog instanceof Dog); //true\n> console.log(dog instanceof Object); //true\n> ```\n\n##### 描述：`instanceof`运算符用来检测`constructor.prototype`是否存在于参数`object`的原型链上。\n\n```javascript\n//定义函数\nfunction A(){};\nfunction B(){};\n\nlet o=new A();\no instanceof A; //true，因为o.__proto__指向A.prototype\no instanceof Object; //true,因为o.__proto__指向A.prototype，A.prototype指向Object.prototype\n\n//继承\nB.prototype=new A();\nlet o1=new B();\no1 instanceof B; //true\no1 instanceof A; //true，因为A.prototype在o1的原型链上\n```\n\n> 需要注意的是，如果表达式 `obj instanceof Foo` 返回`true`，则并不意味着该表达式会永远返回`true`，因为`Foo.prototype`属性的值有可能会改变，改变之后的值很有可能不存在于`obj`的原型链上，这时原表达式的值就会成为`false`。另外一种情况下，原表达式的值也会改变，就是改变对象`obj`的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的`__proto__`伪属性，是可以实现的。比如执行`obj.__proto__ = {}`之后，`obj instanceof Foo`就会返回`false`了。\n\n##### `instanceof`和多全局对象（多个farme或多个window之间的交互）\n\n> 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 `[] instanceof window.frames[0].Array` 会返回`false`，因为 `Array.prototype !== window.frames[0].Array.prototype`，并且数组从前者继承。\n\n##### 演示`String`对象和`Date`对象都属于`Object`类型和一些特殊情况\n\n下面的代码使用了`instanceof`来证明：`String`和`Date`对象同时也属于`Object`类型（他们是由`Object`类派生出来的）。\n\n但是，使用对象文字符号创建的对象在这里是一个例外：虽然原型未定义，但`instanceof Object`返回`true`。\n\n```javascript\nvar simpleStr = \"This is a simple string\"; \nvar myString  = new String();\nvar newStr    = new String(\"String created with constructor\");\nvar myDate    = new Date();\nvar myObj     = {};\n\nsimpleStr instanceof String; // 返回 false, 检查原型链会找到 undefined\nmyString  instanceof String; // 返回 true\nnewStr    instanceof String; // 返回 true\nmyString  instanceof Object; // 返回 true\n\nmyObj instanceof Object;    // 返回 true, 尽管原型没有定义\n({})  instanceof Object;    // 返回 true, 同上\nmyNonObj instanceof Object; // 返回 false, 一种创建对象的方法，这种方法创建的对象不是Object的一个实例\n\nmyString instanceof Date; //返回 false\n\nmyDate instanceof Date;     // 返回 true\nmyDate instanceof Object;   // 返回 true\nmyDate instanceof String;   // 返回 false\n```\n\n- instanceof\n\n  instanceof可以判断复杂数据类型，不能判断基本数据类型。\n  \n  instanceof实现原理是通过原型链进行查找。\n  实现代码：\n  \n```js\n    // L instanceof R\n    function instance_of(L,R) { // L表示左表达式，R表示右表达式\n        let O = R.prototype;  // R的显式原型\n        L = L.__proto__;  // L的隐式原型\n        while(true) {\n            if(L === null) {  // Object.prototype.__proto__ --> null\n                return false;\n            }\n            if(O === L) { // 判断全等时返回true\n                return true;\n            }\n            L = L.__proto__;\n        }\n        \n    }\n```\n\n**判断复杂类型**\n\n```js\n    Object.prototype.toString.call(Array); // [object Array]\n```\n\n","source":"_posts/js类型检测总结.md","raw":"---\ntitle: js类型检测总结\ndate: 2018-10-06 18:25:53\ntags: js\ncategories: 前端\n---\n\n### js类型检测总结\n\n**检测规则：**\n\n![](js类型检测总结/5e35a8e04062aeeb805a82c051a9560d.png)\n\n1. **`typeof`：操作符返回一个字符串，表示未经计算的操作数的类型**\n\n   语法：`typeof`运算符后跟操作数。\n\n   >```javascript\n   >typeof operand\n   >or\n   >typeof (operand)\n   >```\n   >\n   >**operand是一个表达式，表示对象或原始值，其类型将被返回。**\n   >\n   >| 类型                                        | 结果                       |\n   >| ------------------------------------------- | -------------------------- |\n   >| Undefined                                   | `\"undefined\"`              |\n   >| Null                                        | `\"object\"`                 |\n   >| Boolean                                     | `\"boolean\"`                |\n   >| Number                                      | `\"number\"`                 |\n   >| String                                      | `\"string\"`                 |\n   >| Symbol （ECMAScript 6 新增）                | `\"symbol\"`                 |\n   >| 宿主对象（由JS环境提供）                    | *Implementation-dependent* |\n   >| 函数对象（[[Call]] 在ECMA-262条款中实现了） | `\"function\"`               |\n   >| 任何其他对象                                | `\"object\"`                 |\n\n   ##### 使用`new`操作符：\n\n   ```javascript\n   let str=new String('string');\n   let num=new Number(100);\n   typeof str; //'object'\n   typeof num; //'object'\n   let func=new Function();\n   typeof func; //'function'\n   ```\n\n   ##### 语法中需要括号：\n\n   ```javascript\n   let num=99;\n   typeof num + ' str'; //it will return 'number str'\n   typeof (num+' str'); //string\n   ```\n\n   ##### 暂存死区：\n\n   > 在 ECMAScript 2015 之前，`typeof`总是保证为任何操作数返回一个字符串。但是，除了非提升，块作用域的[let](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let)和[const](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const)之外，在声明之前对块中的`let`和`const`变量使用`typeof`会抛出一个[ReferenceError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)。这与未声明的变量形成对比，`typeof`会返回“undefined”。块作用域变量在块的头部处于“[暂时死区](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let)”，直到被初始化，在这期间，如果变量被访问将会引发错误。\n   >\n   > ```\n   > typeof undeclaredVariable === 'undefined';\n   > typeof newLetVariable; let newLetVariable; // ReferenceError\n   > typeof newConstVariable; const newConstVariable = 'hello'; // ReferenceError\n   > ```\n   >\n   >\n\n2. **`instanceof`：用于测试构造函数的`prototype`属性是否出现在对象的原型链中的任何位置**\n\n> **语法：`object instanceof constructor`**\n>\n> **参数：`object` 要检测的对象， `constructor` 某个构造函数**\n>\n> **举例：**\n>\n> ```javascript\n> function Dog(name,food){\n>     this.name=name;\n>     this.food=food;\n>     console.log(this.name+'吃'+this.food);\n> }\n> let dog=new Dog('小黑','骨头');\n> console.log(dog instanceof Dog); //true\n> console.log(dog instanceof Object); //true\n> ```\n\n##### 描述：`instanceof`运算符用来检测`constructor.prototype`是否存在于参数`object`的原型链上。\n\n```javascript\n//定义函数\nfunction A(){};\nfunction B(){};\n\nlet o=new A();\no instanceof A; //true，因为o.__proto__指向A.prototype\no instanceof Object; //true,因为o.__proto__指向A.prototype，A.prototype指向Object.prototype\n\n//继承\nB.prototype=new A();\nlet o1=new B();\no1 instanceof B; //true\no1 instanceof A; //true，因为A.prototype在o1的原型链上\n```\n\n> 需要注意的是，如果表达式 `obj instanceof Foo` 返回`true`，则并不意味着该表达式会永远返回`true`，因为`Foo.prototype`属性的值有可能会改变，改变之后的值很有可能不存在于`obj`的原型链上，这时原表达式的值就会成为`false`。另外一种情况下，原表达式的值也会改变，就是改变对象`obj`的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的`__proto__`伪属性，是可以实现的。比如执行`obj.__proto__ = {}`之后，`obj instanceof Foo`就会返回`false`了。\n\n##### `instanceof`和多全局对象（多个farme或多个window之间的交互）\n\n> 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 `[] instanceof window.frames[0].Array` 会返回`false`，因为 `Array.prototype !== window.frames[0].Array.prototype`，并且数组从前者继承。\n\n##### 演示`String`对象和`Date`对象都属于`Object`类型和一些特殊情况\n\n下面的代码使用了`instanceof`来证明：`String`和`Date`对象同时也属于`Object`类型（他们是由`Object`类派生出来的）。\n\n但是，使用对象文字符号创建的对象在这里是一个例外：虽然原型未定义，但`instanceof Object`返回`true`。\n\n```javascript\nvar simpleStr = \"This is a simple string\"; \nvar myString  = new String();\nvar newStr    = new String(\"String created with constructor\");\nvar myDate    = new Date();\nvar myObj     = {};\n\nsimpleStr instanceof String; // 返回 false, 检查原型链会找到 undefined\nmyString  instanceof String; // 返回 true\nnewStr    instanceof String; // 返回 true\nmyString  instanceof Object; // 返回 true\n\nmyObj instanceof Object;    // 返回 true, 尽管原型没有定义\n({})  instanceof Object;    // 返回 true, 同上\nmyNonObj instanceof Object; // 返回 false, 一种创建对象的方法，这种方法创建的对象不是Object的一个实例\n\nmyString instanceof Date; //返回 false\n\nmyDate instanceof Date;     // 返回 true\nmyDate instanceof Object;   // 返回 true\nmyDate instanceof String;   // 返回 false\n```\n\n- instanceof\n\n  instanceof可以判断复杂数据类型，不能判断基本数据类型。\n  \n  instanceof实现原理是通过原型链进行查找。\n  实现代码：\n  \n```js\n    // L instanceof R\n    function instance_of(L,R) { // L表示左表达式，R表示右表达式\n        let O = R.prototype;  // R的显式原型\n        L = L.__proto__;  // L的隐式原型\n        while(true) {\n            if(L === null) {  // Object.prototype.__proto__ --> null\n                return false;\n            }\n            if(O === L) { // 判断全等时返回true\n                return true;\n            }\n            L = L.__proto__;\n        }\n        \n    }\n```\n\n**判断复杂类型**\n\n```js\n    Object.prototype.toString.call(Array); // [object Array]\n```\n\n","slug":"js类型检测总结","published":1,"updated":"2024-02-19T07:42:51.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdraj00311xopfg739e8b","content":"<h3 id=\"js类型检测总结\"><a href=\"#js类型检测总结\" class=\"headerlink\" title=\"js类型检测总结\"></a>js类型检测总结</h3><p><strong>检测规则：</strong></p>\n<p><img src=\"/2018/10/06/js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93/5e35a8e04062aeeb805a82c051a9560d.png\" alt></p>\n<ol>\n<li><p><strong><code>typeof</code>：操作符返回一个字符串，表示未经计算的操作数的类型</strong></p>\n<p>语法：<code>typeof</code>运算符后跟操作数。</p>\n<blockquote>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">typeof</span> operand\nor\n<span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span>operand<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>operand是一个表达式，表示对象或原始值，其类型将被返回。</strong></p>\n<p>| 类型                                        | 结果                       |<br>| ——————————————- | ————————– |<br>| Undefined                                   | <code>&quot;undefined&quot;</code>              |<br>| Null                                        | <code>&quot;object&quot;</code>                 |<br>| Boolean                                     | <code>&quot;boolean&quot;</code>                |<br>| Number                                      | <code>&quot;number&quot;</code>                 |<br>| String                                      | <code>&quot;string&quot;</code>                 |<br>| Symbol （ECMAScript 6 新增）                | <code>&quot;symbol&quot;</code>                 |<br>| 宿主对象（由JS环境提供）                    | <em>Implementation-dependent</em> |<br>| 函数对象（[[Call]] 在ECMA-262条款中实现了） | <code>&quot;function&quot;</code>               |<br>| 任何其他对象                                | <code>&quot;object&quot;</code>                 |</p>\n</blockquote>\n<h5 id=\"使用new操作符：\"><a href=\"#使用new操作符：\" class=\"headerlink\" title=\"使用new操作符：\"></a>使用<code>new</code>操作符：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> str<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> num<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typeof</span> str<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'object'</span>\n<span class=\"token keyword\">typeof</span> num<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'object'</span>\n<span class=\"token keyword\">let</span> func<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typeof</span> func<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//'function'</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"语法中需要括号：\"><a href=\"#语法中需要括号：\" class=\"headerlink\" title=\"语法中需要括号：\"></a>语法中需要括号：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> num<span class=\"token operator\">=</span><span class=\"token number\">99</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">typeof</span> num <span class=\"token operator\">+</span> <span class=\"token string\">' str'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//it will return 'number str'</span>\n<span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span>num<span class=\"token operator\">+</span><span class=\"token string\">' str'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//string</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"暂存死区：\"><a href=\"#暂存死区：\" class=\"headerlink\" title=\"暂存死区：\"></a>暂存死区：</h5><blockquote>\n<p>在 ECMAScript 2015 之前，<code>typeof</code>总是保证为任何操作数返回一个字符串。但是，除了非提升，块作用域的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"noopener\">let</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"noopener\">const</a>之外，在声明之前对块中的<code>let</code>和<code>const</code>变量使用<code>typeof</code>会抛出一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\" target=\"_blank\" rel=\"noopener\">ReferenceError</a>。这与未声明的变量形成对比，<code>typeof</code>会返回“undefined”。块作用域变量在块的头部处于“<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">暂时死区</a>”，直到被初始化，在这期间，如果变量被访问将会引发错误。</p>\n<pre><code>typeof undeclaredVariable === &#39;undefined&#39;;\ntypeof newLetVariable; let newLetVariable; // ReferenceError\ntypeof newConstVariable; const newConstVariable = &#39;hello&#39;; // ReferenceError\n</code></pre></blockquote>\n</li>\n<li><p><strong><code>instanceof</code>：用于测试构造函数的<code>prototype</code>属性是否出现在对象的原型链中的任何位置</strong></p>\n</li>\n</ol>\n<blockquote>\n<p><strong>语法：<code>object instanceof constructor</code></strong></p>\n<p><strong>参数：<code>object</code> 要检测的对象， <code>constructor</code> 某个构造函数</strong></p>\n<p><strong>举例：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Dog</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>food<span class=\"token operator\">=</span>food<span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">'吃'</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> dog<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小黑'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'骨头'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n<h5 id=\"描述：instanceof运算符用来检测constructor-prototype是否存在于参数object的原型链上。\"><a href=\"#描述：instanceof运算符用来检测constructor-prototype是否存在于参数object的原型链上。\" class=\"headerlink\" title=\"描述：instanceof运算符用来检测constructor.prototype是否存在于参数object的原型链上。\"></a>描述：<code>instanceof</code>运算符用来检测<code>constructor.prototype</code>是否存在于参数<code>object</code>的原型链上。</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//定义函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> o<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\no <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true，因为o.__proto__指向A.prototype</span>\no <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true,因为o.__proto__指向A.prototype，A.prototype指向Object.prototype</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//继承</span>\nB<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> o1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\no1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">B</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\no1 <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true，因为A.prototype在o1的原型链上</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>需要注意的是，如果表达式 <code>obj instanceof Foo</code> 返回<code>true</code>，则并不意味着该表达式会永远返回<code>true</code>，因为<code>Foo.prototype</code>属性的值有可能会改变，改变之后的值很有可能不存在于<code>obj</code>的原型链上，这时原表达式的值就会成为<code>false</code>。另外一种情况下，原表达式的值也会改变，就是改变对象<code>obj</code>的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<code>__proto__</code>伪属性，是可以实现的。比如执行<code>obj.__proto__ = {}</code>之后，<code>obj instanceof Foo</code>就会返回<code>false</code>了。</p>\n</blockquote>\n<h5 id=\"instanceof和多全局对象（多个farme或多个window之间的交互）\"><a href=\"#instanceof和多全局对象（多个farme或多个window之间的交互）\" class=\"headerlink\" title=\"instanceof和多全局对象（多个farme或多个window之间的交互）\"></a><code>instanceof</code>和多全局对象（多个farme或多个window之间的交互）</h5><blockquote>\n<p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 <code>[] instanceof window.frames[0].Array</code> 会返回<code>false</code>，因为 <code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p>\n</blockquote>\n<h5 id=\"演示String对象和Date对象都属于Object类型和一些特殊情况\"><a href=\"#演示String对象和Date对象都属于Object类型和一些特殊情况\" class=\"headerlink\" title=\"演示String对象和Date对象都属于Object类型和一些特殊情况\"></a>演示<code>String</code>对象和<code>Date</code>对象都属于<code>Object</code>类型和一些特殊情况</h5><p>下面的代码使用了<code>instanceof</code>来证明：<code>String</code>和<code>Date</code>对象同时也属于<code>Object</code>类型（他们是由<code>Object</code>类派生出来的）。</p>\n<p>但是，使用对象文字符号创建的对象在这里是一个例外：虽然原型未定义，但<code>instanceof Object</code>返回<code>true</code>。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> simpleStr <span class=\"token operator\">=</span> <span class=\"token string\">\"This is a simple string\"</span><span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">var</span> myString  <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> newStr    <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"String created with constructor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> myDate    <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> myObj     <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nsimpleStr <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 false, 检查原型链会找到 undefined</span>\nmyString  <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\nnewStr    <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\nmyString  <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\n\nmyObj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 返回 true, 尽管原型没有定义</span>\n<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>  <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 返回 true, 同上</span>\nmyNonObj <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 返回 false, 一种创建对象的方法，这种方法创建的对象不是Object的一个实例</span>\n\nmyString <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//返回 false</span>\n\nmyDate <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\nmyDate <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 返回 true</span>\nmyDate <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 返回 false</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>instanceof</p>\n<p>instanceof可以判断复杂数据类型，不能判断基本数据类型。</p>\n<p>instanceof实现原理是通过原型链进行查找。<br>实现代码：</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    <span class=\"token comment\" spellcheck=\"true\">// L instanceof R</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">instance_of</span><span class=\"token punctuation\">(</span>L<span class=\"token punctuation\">,</span>R<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// L表示左表达式，R表示右表达式</span>\n        <span class=\"token keyword\">let</span> O <span class=\"token operator\">=</span> R<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// R的显式原型</span>\n        L <span class=\"token operator\">=</span> L<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// L的隐式原型</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>L <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// Object.prototype.__proto__ --> null</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>O <span class=\"token operator\">===</span> L<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 判断全等时返回true</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            L <span class=\"token operator\">=</span> L<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>判断复杂类型</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">    Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// [object Array]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js类型检测总结\"><a href=\"#js类型检测总结\" class=\"headerlink\" title=\"js类型检测总结\"></a>js类型检测总结</h3><p><strong>检测规则：</strong></p>\n<p><img src=\"/2018/10/06/js%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%80%BB%E7%BB%93/5e35a8e04062aeeb805a82c051a9560d.png\" alt></p>\n<ol>\n<li><p><strong><code>typeof</code>：操作符返回一个字符串，表示未经计算的操作数的类型</strong></p>\n<p>语法：<code>typeof</code>运算符后跟操作数。</p>\n<blockquote>\n<pre><code class=\"javascript\">typeof operand\nor\ntypeof (operand)\n</code></pre>\n<p><strong>operand是一个表达式，表示对象或原始值，其类型将被返回。</strong></p>\n<p>| 类型                                        | 结果                       |<br>| ——————————————- | ————————– |<br>| Undefined                                   | <code>&quot;undefined&quot;</code>              |<br>| Null                                        | <code>&quot;object&quot;</code>                 |<br>| Boolean                                     | <code>&quot;boolean&quot;</code>                |<br>| Number                                      | <code>&quot;number&quot;</code>                 |<br>| String                                      | <code>&quot;string&quot;</code>                 |<br>| Symbol （ECMAScript 6 新增）                | <code>&quot;symbol&quot;</code>                 |<br>| 宿主对象（由JS环境提供）                    | <em>Implementation-dependent</em> |<br>| 函数对象（[[Call]] 在ECMA-262条款中实现了） | <code>&quot;function&quot;</code>               |<br>| 任何其他对象                                | <code>&quot;object&quot;</code>                 |</p>\n</blockquote>\n<h5 id=\"使用new操作符：\"><a href=\"#使用new操作符：\" class=\"headerlink\" title=\"使用new操作符：\"></a>使用<code>new</code>操作符：</h5><pre><code class=\"javascript\">let str=new String(&#39;string&#39;);\nlet num=new Number(100);\ntypeof str; //&#39;object&#39;\ntypeof num; //&#39;object&#39;\nlet func=new Function();\ntypeof func; //&#39;function&#39;\n</code></pre>\n<h5 id=\"语法中需要括号：\"><a href=\"#语法中需要括号：\" class=\"headerlink\" title=\"语法中需要括号：\"></a>语法中需要括号：</h5><pre><code class=\"javascript\">let num=99;\ntypeof num + &#39; str&#39;; //it will return &#39;number str&#39;\ntypeof (num+&#39; str&#39;); //string\n</code></pre>\n<h5 id=\"暂存死区：\"><a href=\"#暂存死区：\" class=\"headerlink\" title=\"暂存死区：\"></a>暂存死区：</h5><blockquote>\n<p>在 ECMAScript 2015 之前，<code>typeof</code>总是保证为任何操作数返回一个字符串。但是，除了非提升，块作用域的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"noopener\">let</a>和<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"noopener\">const</a>之外，在声明之前对块中的<code>let</code>和<code>const</code>变量使用<code>typeof</code>会抛出一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\" target=\"_blank\" rel=\"noopener\">ReferenceError</a>。这与未声明的变量形成对比，<code>typeof</code>会返回“undefined”。块作用域变量在块的头部处于“<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let\" target=\"_blank\" rel=\"noopener\">暂时死区</a>”，直到被初始化，在这期间，如果变量被访问将会引发错误。</p>\n<pre><code>typeof undeclaredVariable === &#39;undefined&#39;;\ntypeof newLetVariable; let newLetVariable; // ReferenceError\ntypeof newConstVariable; const newConstVariable = &#39;hello&#39;; // ReferenceError\n</code></pre></blockquote>\n</li>\n<li><p><strong><code>instanceof</code>：用于测试构造函数的<code>prototype</code>属性是否出现在对象的原型链中的任何位置</strong></p>\n</li>\n</ol>\n<blockquote>\n<p><strong>语法：<code>object instanceof constructor</code></strong></p>\n<p><strong>参数：<code>object</code> 要检测的对象， <code>constructor</code> 某个构造函数</strong></p>\n<p><strong>举例：</strong></p>\n<pre><code class=\"javascript\">function Dog(name,food){\n    this.name=name;\n    this.food=food;\n    console.log(this.name+&#39;吃&#39;+this.food);\n}\nlet dog=new Dog(&#39;小黑&#39;,&#39;骨头&#39;);\nconsole.log(dog instanceof Dog); //true\nconsole.log(dog instanceof Object); //true\n</code></pre>\n</blockquote>\n<h5 id=\"描述：instanceof运算符用来检测constructor-prototype是否存在于参数object的原型链上。\"><a href=\"#描述：instanceof运算符用来检测constructor-prototype是否存在于参数object的原型链上。\" class=\"headerlink\" title=\"描述：instanceof运算符用来检测constructor.prototype是否存在于参数object的原型链上。\"></a>描述：<code>instanceof</code>运算符用来检测<code>constructor.prototype</code>是否存在于参数<code>object</code>的原型链上。</h5><pre><code class=\"javascript\">//定义函数\nfunction A(){};\nfunction B(){};\n\nlet o=new A();\no instanceof A; //true，因为o.__proto__指向A.prototype\no instanceof Object; //true,因为o.__proto__指向A.prototype，A.prototype指向Object.prototype\n\n//继承\nB.prototype=new A();\nlet o1=new B();\no1 instanceof B; //true\no1 instanceof A; //true，因为A.prototype在o1的原型链上\n</code></pre>\n<blockquote>\n<p>需要注意的是，如果表达式 <code>obj instanceof Foo</code> 返回<code>true</code>，则并不意味着该表达式会永远返回<code>true</code>，因为<code>Foo.prototype</code>属性的值有可能会改变，改变之后的值很有可能不存在于<code>obj</code>的原型链上，这时原表达式的值就会成为<code>false</code>。另外一种情况下，原表达式的值也会改变，就是改变对象<code>obj</code>的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<code>__proto__</code>伪属性，是可以实现的。比如执行<code>obj.__proto__ = {}</code>之后，<code>obj instanceof Foo</code>就会返回<code>false</code>了。</p>\n</blockquote>\n<h5 id=\"instanceof和多全局对象（多个farme或多个window之间的交互）\"><a href=\"#instanceof和多全局对象（多个farme或多个window之间的交互）\" class=\"headerlink\" title=\"instanceof和多全局对象（多个farme或多个window之间的交互）\"></a><code>instanceof</code>和多全局对象（多个farme或多个window之间的交互）</h5><blockquote>\n<p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 <code>[] instanceof window.frames[0].Array</code> 会返回<code>false</code>，因为 <code>Array.prototype !== window.frames[0].Array.prototype</code>，并且数组从前者继承。</p>\n</blockquote>\n<h5 id=\"演示String对象和Date对象都属于Object类型和一些特殊情况\"><a href=\"#演示String对象和Date对象都属于Object类型和一些特殊情况\" class=\"headerlink\" title=\"演示String对象和Date对象都属于Object类型和一些特殊情况\"></a>演示<code>String</code>对象和<code>Date</code>对象都属于<code>Object</code>类型和一些特殊情况</h5><p>下面的代码使用了<code>instanceof</code>来证明：<code>String</code>和<code>Date</code>对象同时也属于<code>Object</code>类型（他们是由<code>Object</code>类派生出来的）。</p>\n<p>但是，使用对象文字符号创建的对象在这里是一个例外：虽然原型未定义，但<code>instanceof Object</code>返回<code>true</code>。</p>\n<pre><code class=\"javascript\">var simpleStr = &quot;This is a simple string&quot;; \nvar myString  = new String();\nvar newStr    = new String(&quot;String created with constructor&quot;);\nvar myDate    = new Date();\nvar myObj     = {};\n\nsimpleStr instanceof String; // 返回 false, 检查原型链会找到 undefined\nmyString  instanceof String; // 返回 true\nnewStr    instanceof String; // 返回 true\nmyString  instanceof Object; // 返回 true\n\nmyObj instanceof Object;    // 返回 true, 尽管原型没有定义\n({})  instanceof Object;    // 返回 true, 同上\nmyNonObj instanceof Object; // 返回 false, 一种创建对象的方法，这种方法创建的对象不是Object的一个实例\n\nmyString instanceof Date; //返回 false\n\nmyDate instanceof Date;     // 返回 true\nmyDate instanceof Object;   // 返回 true\nmyDate instanceof String;   // 返回 false\n</code></pre>\n<ul>\n<li><p>instanceof</p>\n<p>instanceof可以判断复杂数据类型，不能判断基本数据类型。</p>\n<p>instanceof实现原理是通过原型链进行查找。<br>实现代码：</p>\n</li>\n</ul>\n<pre><code class=\"js\">    // L instanceof R\n    function instance_of(L,R) { // L表示左表达式，R表示右表达式\n        let O = R.prototype;  // R的显式原型\n        L = L.__proto__;  // L的隐式原型\n        while(true) {\n            if(L === null) {  // Object.prototype.__proto__ --&gt; null\n                return false;\n            }\n            if(O === L) { // 判断全等时返回true\n                return true;\n            }\n            L = L.__proto__;\n        }\n\n    }\n</code></pre>\n<p><strong>判断复杂类型</strong></p>\n<pre><code class=\"js\">    Object.prototype.toString.call(Array); // [object Array]\n</code></pre>\n"},{"title":"js的this指向问题","date":"2018-10-22T11:22:01.000Z","_content":"\n### this总结\n\n**一句话：谁调用的，this就指向谁。**\n\n##### this分为以下的几种情况：\n\n1. 全局的this（浏览器）\n\n   ```js\n   console.log(this.document===document); //true\n   console.log(this===window); //true\n   this.a=20;\n   console.log(window.a); //20\n   ```\n\n2. 一般函数的this（浏览器）\n\n   ```js\n   this.b=10;\n   function f(){\n       console.log(this===window); //true\n       console.log(this.b===window.b); //true\n       console.log(this.b); //10\n       console.log(window.b); //10\n   }\n   f();\n   ```\n\n3. 作为对象方法的函数的this\n\n   ```js\n   //例一\n   var o={\n       prop:10,\n       f:function(){\n           return this.prop;\n       }\n   }\n   console.log(o.f()); //10\n   \n   //例二\n   var o={prop:20};\n   function p(){\n       return this.prop;\n   }\n   o.f=p;\n   console.log(o.f()); //20\n   \n   //例三\n   var o={\n       prop:30,\n       f:function(){\n           return this.prop;\n       }\n   }\n   var f1=o.f;\n   console.log(f1()); //undefined\n   //如果f函数被赋值到另一个变量中，并没有作为对象o的属性被调用，那么this的指向就是window，this.prop就为undefined。\n   ```\n\n4. 对象原型链上的this\n\n   ```js\n   function f(){\n       this.name=\"张三\";\n       this.age=20;\n   }\n   f.prototype.get=function(){\n       console.log(this.name+': '+this.age);\n   }\n   var f1=new f();\n   f1.get(); //张三：20\n   ```\n\n   **不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也是当前对象的值。**\n\n5. get/set方法与this\n\n6. 构造器中的this\n\n   ```js\n   function myClass(){\n       this.a=20;\n   }\n   var o=new myClass();\n   console.log(o.a); //20\n   \n   function myClass1(){\n       this.a=20;\n       return {a:10};\n   }\n   o=new myClass1();\n   console.log(o.a); //10\n   ```\n\n7. call/apply方法与this\n\n   ```js\n   function add(c,d){\n       return this.a+this.b+c+d;\n   }\n   var o={a:1,b:2};\n   add.call(o,3,4); //1+2+3+4=10\n   add.apply(o,[3,4]) //1+2+3+4=10\n   function bar(){\n       console.log(Object.prototype.toString.call(this));\n   }\n   bar.call(1); //\"[object Number]\"\n   ```\n\n8. bind方法与this\n\n   与call/apply类似。\n\n   **需要注意的一种情况：**\n\n   ```js\n   var o={\n       prop:10,\n       f:function(){\n           function f1(){\n               console.log(this);//Window {postMessage:ƒ, blur:ƒ, focus:ƒ, close:ƒ, frames:Window,...}\n               console.log(this.prop); //undefined\n           }\n           f1();\n       }\n   }\n   o.f();\n   //函数f1虽然是对象o.f内部定义的，但是它仍然是一个普通的函数，this仍然指向window。\n   ```\n\n```js\n// this\n\t\tconsole.log('------------------------this问题---------------');\n\t\tvar number = 5;\n\t\tvar obj1 = {\n\t\t    number: 3,\n\t\t    fn1: (function () {\n\t\t        var number;\n\t\t        this.number *= 2;\n\t\t        number = number * 2;\n\t\t        number = 3;\n\t\t        return function () {\n\t\t            var num = this.number;\n\t\t            this.number *= 2;\n\t\t            console.log(num);\n\t\t            number *= 3;\n\t\t            console.log(number);\n\t\t        }\n\t\t    })()\n\t\t}\n\t\tvar fn1 = obj1.fn1;\n\t\tfn1.call(null);\n\t\tobj1.fn1();\n\t\tconsole.log(window.number);\n\t\t/*\n\t\t\t10\n\t\t\t9\n\t\t\t3\n\t\t\t27\n\t\t\t20\n\t\t*/\n```\n\n","source":"_posts/js的this指向问题.md","raw":"---\ntitle: js的this指向问题\ndate: 2018-10-22 19:22:01\ntags: js\ncategories: 前端\n---\n\n### this总结\n\n**一句话：谁调用的，this就指向谁。**\n\n##### this分为以下的几种情况：\n\n1. 全局的this（浏览器）\n\n   ```js\n   console.log(this.document===document); //true\n   console.log(this===window); //true\n   this.a=20;\n   console.log(window.a); //20\n   ```\n\n2. 一般函数的this（浏览器）\n\n   ```js\n   this.b=10;\n   function f(){\n       console.log(this===window); //true\n       console.log(this.b===window.b); //true\n       console.log(this.b); //10\n       console.log(window.b); //10\n   }\n   f();\n   ```\n\n3. 作为对象方法的函数的this\n\n   ```js\n   //例一\n   var o={\n       prop:10,\n       f:function(){\n           return this.prop;\n       }\n   }\n   console.log(o.f()); //10\n   \n   //例二\n   var o={prop:20};\n   function p(){\n       return this.prop;\n   }\n   o.f=p;\n   console.log(o.f()); //20\n   \n   //例三\n   var o={\n       prop:30,\n       f:function(){\n           return this.prop;\n       }\n   }\n   var f1=o.f;\n   console.log(f1()); //undefined\n   //如果f函数被赋值到另一个变量中，并没有作为对象o的属性被调用，那么this的指向就是window，this.prop就为undefined。\n   ```\n\n4. 对象原型链上的this\n\n   ```js\n   function f(){\n       this.name=\"张三\";\n       this.age=20;\n   }\n   f.prototype.get=function(){\n       console.log(this.name+': '+this.age);\n   }\n   var f1=new f();\n   f1.get(); //张三：20\n   ```\n\n   **不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也是当前对象的值。**\n\n5. get/set方法与this\n\n6. 构造器中的this\n\n   ```js\n   function myClass(){\n       this.a=20;\n   }\n   var o=new myClass();\n   console.log(o.a); //20\n   \n   function myClass1(){\n       this.a=20;\n       return {a:10};\n   }\n   o=new myClass1();\n   console.log(o.a); //10\n   ```\n\n7. call/apply方法与this\n\n   ```js\n   function add(c,d){\n       return this.a+this.b+c+d;\n   }\n   var o={a:1,b:2};\n   add.call(o,3,4); //1+2+3+4=10\n   add.apply(o,[3,4]) //1+2+3+4=10\n   function bar(){\n       console.log(Object.prototype.toString.call(this));\n   }\n   bar.call(1); //\"[object Number]\"\n   ```\n\n8. bind方法与this\n\n   与call/apply类似。\n\n   **需要注意的一种情况：**\n\n   ```js\n   var o={\n       prop:10,\n       f:function(){\n           function f1(){\n               console.log(this);//Window {postMessage:ƒ, blur:ƒ, focus:ƒ, close:ƒ, frames:Window,...}\n               console.log(this.prop); //undefined\n           }\n           f1();\n       }\n   }\n   o.f();\n   //函数f1虽然是对象o.f内部定义的，但是它仍然是一个普通的函数，this仍然指向window。\n   ```\n\n```js\n// this\n\t\tconsole.log('------------------------this问题---------------');\n\t\tvar number = 5;\n\t\tvar obj1 = {\n\t\t    number: 3,\n\t\t    fn1: (function () {\n\t\t        var number;\n\t\t        this.number *= 2;\n\t\t        number = number * 2;\n\t\t        number = 3;\n\t\t        return function () {\n\t\t            var num = this.number;\n\t\t            this.number *= 2;\n\t\t            console.log(num);\n\t\t            number *= 3;\n\t\t            console.log(number);\n\t\t        }\n\t\t    })()\n\t\t}\n\t\tvar fn1 = obj1.fn1;\n\t\tfn1.call(null);\n\t\tobj1.fn1();\n\t\tconsole.log(window.number);\n\t\t/*\n\t\t\t10\n\t\t\t9\n\t\t\t3\n\t\t\t27\n\t\t\t20\n\t\t*/\n```\n\n","slug":"js的this指向问题","published":1,"updated":"2024-02-19T07:42:51.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdraj00341xophazv48b2","content":"<h3 id=\"this总结\"><a href=\"#this总结\" class=\"headerlink\" title=\"this总结\"></a>this总结</h3><p><strong>一句话：谁调用的，this就指向谁。</strong></p>\n<h5 id=\"this分为以下的几种情况：\"><a href=\"#this分为以下的几种情况：\" class=\"headerlink\" title=\"this分为以下的几种情况：\"></a>this分为以下的几种情况：</h5><ol>\n<li><p>全局的this（浏览器）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>document<span class=\"token operator\">===</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">===</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//20</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>一般函数的this（浏览器）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token operator\">===</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token operator\">===</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>作为对象方法的函数的this</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//例一</span>\n<span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    prop<span class=\"token punctuation\">:</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    f<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//例二</span>\n<span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>prop<span class=\"token punctuation\">:</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\no<span class=\"token punctuation\">.</span>f<span class=\"token operator\">=</span>p<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//20</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//例三</span>\n<span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    prop<span class=\"token punctuation\">:</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n    f<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> f1<span class=\"token operator\">=</span>o<span class=\"token punctuation\">.</span>f<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//undefined</span>\n<span class=\"token comment\" spellcheck=\"true\">//如果f函数被赋值到另一个变量中，并没有作为对象o的属性被调用，那么this的指向就是window，this.prop就为undefined。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>对象原型链上的this</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"张三\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nf<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span><span class=\"token string\">': '</span><span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> f1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nf1<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//张三：20</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也是当前对象的值。</strong></p>\n</li>\n<li><p>get/set方法与this</p>\n</li>\n<li><p>构造器中的this</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">myClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">myClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//20</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myClass1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token operator\">=</span><span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">:</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\no<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">myClass1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//10</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>call/apply方法与this</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>a<span class=\"token operator\">+</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>b<span class=\"token operator\">+</span>c<span class=\"token operator\">+</span>d<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nadd<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1+2+3+4=10</span>\nadd<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//1+2+3+4=10</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>toString<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//\"[object Number]\"</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>bind方法与this</p>\n<p>与call/apply类似。</p>\n<p><strong>需要注意的一种情况：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> o<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    prop<span class=\"token punctuation\">:</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    f<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//Window {postMessage:ƒ, blur:ƒ, focus:ƒ, close:ƒ, frames:Window,...}</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>prop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//undefined</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\no<span class=\"token punctuation\">.</span><span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//函数f1虽然是对象o.f内部定义的，但是它仍然是一个普通的函数，this仍然指向window。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// this</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'------------------------this问题---------------'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> number <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> obj1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            number<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n            fn1<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">var</span> number<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>number <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                number <span class=\"token operator\">=</span> number <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">var</span> num <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>number <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    number <span class=\"token operator\">*</span><span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n                    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">var</span> fn1 <span class=\"token operator\">=</span> obj1<span class=\"token punctuation\">.</span>fn1<span class=\"token punctuation\">;</span>\n        fn1<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        obj1<span class=\"token punctuation\">.</span><span class=\"token function\">fn1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">/*\n            10\n            9\n            3\n            27\n            20\n        */</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"this总结\"><a href=\"#this总结\" class=\"headerlink\" title=\"this总结\"></a>this总结</h3><p><strong>一句话：谁调用的，this就指向谁。</strong></p>\n<h5 id=\"this分为以下的几种情况：\"><a href=\"#this分为以下的几种情况：\" class=\"headerlink\" title=\"this分为以下的几种情况：\"></a>this分为以下的几种情况：</h5><ol>\n<li><p>全局的this（浏览器）</p>\n<pre><code class=\"js\">console.log(this.document===document); //true\nconsole.log(this===window); //true\nthis.a=20;\nconsole.log(window.a); //20\n</code></pre>\n</li>\n<li><p>一般函数的this（浏览器）</p>\n<pre><code class=\"js\">this.b=10;\nfunction f(){\n    console.log(this===window); //true\n    console.log(this.b===window.b); //true\n    console.log(this.b); //10\n    console.log(window.b); //10\n}\nf();\n</code></pre>\n</li>\n<li><p>作为对象方法的函数的this</p>\n<pre><code class=\"js\">//例一\nvar o={\n    prop:10,\n    f:function(){\n        return this.prop;\n    }\n}\nconsole.log(o.f()); //10\n\n//例二\nvar o={prop:20};\nfunction p(){\n    return this.prop;\n}\no.f=p;\nconsole.log(o.f()); //20\n\n//例三\nvar o={\n    prop:30,\n    f:function(){\n        return this.prop;\n    }\n}\nvar f1=o.f;\nconsole.log(f1()); //undefined\n//如果f函数被赋值到另一个变量中，并没有作为对象o的属性被调用，那么this的指向就是window，this.prop就为undefined。\n</code></pre>\n</li>\n<li><p>对象原型链上的this</p>\n<pre><code class=\"js\">function f(){\n    this.name=&quot;张三&quot;;\n    this.age=20;\n}\nf.prototype.get=function(){\n    console.log(this.name+&#39;: &#39;+this.age);\n}\nvar f1=new f();\nf1.get(); //张三：20\n</code></pre>\n<p><strong>不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也是当前对象的值。</strong></p>\n</li>\n<li><p>get/set方法与this</p>\n</li>\n<li><p>构造器中的this</p>\n<pre><code class=\"js\">function myClass(){\n    this.a=20;\n}\nvar o=new myClass();\nconsole.log(o.a); //20\n\nfunction myClass1(){\n    this.a=20;\n    return {a:10};\n}\no=new myClass1();\nconsole.log(o.a); //10\n</code></pre>\n</li>\n<li><p>call/apply方法与this</p>\n<pre><code class=\"js\">function add(c,d){\n    return this.a+this.b+c+d;\n}\nvar o={a:1,b:2};\nadd.call(o,3,4); //1+2+3+4=10\nadd.apply(o,[3,4]) //1+2+3+4=10\nfunction bar(){\n    console.log(Object.prototype.toString.call(this));\n}\nbar.call(1); //&quot;[object Number]&quot;\n</code></pre>\n</li>\n<li><p>bind方法与this</p>\n<p>与call/apply类似。</p>\n<p><strong>需要注意的一种情况：</strong></p>\n<pre><code class=\"js\">var o={\n    prop:10,\n    f:function(){\n        function f1(){\n            console.log(this);//Window {postMessage:ƒ, blur:ƒ, focus:ƒ, close:ƒ, frames:Window,...}\n            console.log(this.prop); //undefined\n        }\n        f1();\n    }\n}\no.f();\n//函数f1虽然是对象o.f内部定义的，但是它仍然是一个普通的函数，this仍然指向window。\n</code></pre>\n</li>\n</ol>\n<pre><code class=\"js\">// this\n        console.log(&#39;------------------------this问题---------------&#39;);\n        var number = 5;\n        var obj1 = {\n            number: 3,\n            fn1: (function () {\n                var number;\n                this.number *= 2;\n                number = number * 2;\n                number = 3;\n                return function () {\n                    var num = this.number;\n                    this.number *= 2;\n                    console.log(num);\n                    number *= 3;\n                    console.log(number);\n                }\n            })()\n        }\n        var fn1 = obj1.fn1;\n        fn1.call(null);\n        obj1.fn1();\n        console.log(window.number);\n        /*\n            10\n            9\n            3\n            27\n            20\n        */\n</code></pre>\n"},{"title":"less","date":"2019-06-08T05:59:34.000Z","_content":"\n### less\n\nless是一种动态样式语言，属于css预处理器的范畴，它扩展了css语言，增加了变量、Mixin、函数等特性，使css更易于维护和扩展。\n\n**Less即可以在客户端上运行，也可以借助Node.js在服务端运行**\n\n##### Less中的注释\n\n- 以//开头的注释，不会被编译到css文件中。\n- 以/**/包裹的注释会被编译到css文件中。\n\n##### less中的变量\n\n使用@来申明一个变量:@pink:pink\n\n1. 作为普通属性值来使用：直接使用@pink\n\n2. 作为选择器和属性：#@{selector的值}的形式\n\n3. 作为URL：@{url}\n\n4. 变量的延迟加载\n\n   ```less\n   // less也拥有块级作用域{}\n   @var: 0;\n   .class {\n       @var: 1;\n       .brass {\n           @var: 2;\n           three: @var;  // 3\n           @var: 3;\n       }\n       one: @var;\n   }\n   ```\n\n   \n\n##### less中的嵌套规则\n\n1. 基本嵌套规则\n\n2. &的使用\n\n   ```less\n   // &代表平级\n   /*\n   \t<div class=\"wrap\">\n   \t\t<div class=\"inner\"></div>\n   \t</div>\n   */\n   @color:deepink;   // 定义变量\t\n   #wrap{\n       position: relative;\n       width: 300px;\n       height: 400px;\n       border: 1px solid;\n       margin: 0 auto;\n       .inner{\n           position: absolute;\n           left: 0;\n           right: 0;\n           top: 0;\n           bottom: 0;\n           margin: auto;\n           background: @color;\n           height: 100px;\n           width: 100px;\n           &:hover{  // 最终解析出来的是 #wrap .inner:hover 如果不加&符号，#wrap .inner :hover\n               background: pink;\n           }\n       }\n   }\n   ```\n\n   \n\n##### less中的混合\n\n混合就是将一系列属性从一个规则集引入到另一个规则集的方式\n\n1. 普通混合\n2. 不带输出的混合\n3. 带参数的混合\n4. 带参数并且有默认值的混合\n5. 带多个参数的混合\n6. 命名参数\n7. 匹配模式\n8. arguments变量\n\n```less\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n    .inner2{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n}\n// 普通混合 ---> 编译后，不会被删除\n.juzhong{\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 不带输出混合 ---> 编译后，不会显示\n.juzhong(){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 带参数混合 ---> 使用.juzhong(100px,100px,deeppink)\n.juzhong(@w,@h,@c){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: @c;\n    width: @w;\n    height: @h;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n       .juzhong;\n    }\n    .inner2{\n        .juzhong;\n    }\n}\n```\n\n##### less运算\n\n在less中可以进行加减乘除的运算\n\n```less\n#wrap .sjx{\n    width:(100 + 100px);  // 只需一方带单位即可\n}\n```\n\n##### less避免编译\n\n```less\n.div{\n    margin: 100px;\n    padding: ~\"cacl(100px + 100px)\"; // ~\"\"将被识别为字符串，不会被编译\n}\n```\n\n\n\n##### less继承\n\n1. 性能比混合高\n2. 灵活度比混合低\n\n```less\n.juzhong{ // 继承不能使用参数\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner:extend(.juzhong){  // 继承\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n}\n```\n\n","source":"_posts/less.md","raw":"---\ntitle: less\ndate: 2019-06-08 13:59:34\ntags: css\ncategories: 前端\n---\n\n### less\n\nless是一种动态样式语言，属于css预处理器的范畴，它扩展了css语言，增加了变量、Mixin、函数等特性，使css更易于维护和扩展。\n\n**Less即可以在客户端上运行，也可以借助Node.js在服务端运行**\n\n##### Less中的注释\n\n- 以//开头的注释，不会被编译到css文件中。\n- 以/**/包裹的注释会被编译到css文件中。\n\n##### less中的变量\n\n使用@来申明一个变量:@pink:pink\n\n1. 作为普通属性值来使用：直接使用@pink\n\n2. 作为选择器和属性：#@{selector的值}的形式\n\n3. 作为URL：@{url}\n\n4. 变量的延迟加载\n\n   ```less\n   // less也拥有块级作用域{}\n   @var: 0;\n   .class {\n       @var: 1;\n       .brass {\n           @var: 2;\n           three: @var;  // 3\n           @var: 3;\n       }\n       one: @var;\n   }\n   ```\n\n   \n\n##### less中的嵌套规则\n\n1. 基本嵌套规则\n\n2. &的使用\n\n   ```less\n   // &代表平级\n   /*\n   \t<div class=\"wrap\">\n   \t\t<div class=\"inner\"></div>\n   \t</div>\n   */\n   @color:deepink;   // 定义变量\t\n   #wrap{\n       position: relative;\n       width: 300px;\n       height: 400px;\n       border: 1px solid;\n       margin: 0 auto;\n       .inner{\n           position: absolute;\n           left: 0;\n           right: 0;\n           top: 0;\n           bottom: 0;\n           margin: auto;\n           background: @color;\n           height: 100px;\n           width: 100px;\n           &:hover{  // 最终解析出来的是 #wrap .inner:hover 如果不加&符号，#wrap .inner :hover\n               background: pink;\n           }\n       }\n   }\n   ```\n\n   \n\n##### less中的混合\n\n混合就是将一系列属性从一个规则集引入到另一个规则集的方式\n\n1. 普通混合\n2. 不带输出的混合\n3. 带参数的混合\n4. 带参数并且有默认值的混合\n5. 带多个参数的混合\n6. 命名参数\n7. 匹配模式\n8. arguments变量\n\n```less\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n    .inner2{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n}\n// 普通混合 ---> 编译后，不会被删除\n.juzhong{\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 不带输出混合 ---> 编译后，不会显示\n.juzhong(){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 带参数混合 ---> 使用.juzhong(100px,100px,deeppink)\n.juzhong(@w,@h,@c){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: @c;\n    width: @w;\n    height: @h;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n       .juzhong;\n    }\n    .inner2{\n        .juzhong;\n    }\n}\n```\n\n##### less运算\n\n在less中可以进行加减乘除的运算\n\n```less\n#wrap .sjx{\n    width:(100 + 100px);  // 只需一方带单位即可\n}\n```\n\n##### less避免编译\n\n```less\n.div{\n    margin: 100px;\n    padding: ~\"cacl(100px + 100px)\"; // ~\"\"将被识别为字符串，不会被编译\n}\n```\n\n\n\n##### less继承\n\n1. 性能比混合高\n2. 灵活度比混合低\n\n```less\n.juzhong{ // 继承不能使用参数\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner:extend(.juzhong){  // 继承\n        background: deeppink;\n    \twidth: 100px;\n    \theight: 100px;\n    }\n}\n```\n\n","slug":"less","published":1,"updated":"2024-02-19T07:42:51.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrak00381xop0on4eahu","content":"<h3 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h3><p>less是一种动态样式语言，属于css预处理器的范畴，它扩展了css语言，增加了变量、Mixin、函数等特性，使css更易于维护和扩展。</p>\n<p><strong>Less即可以在客户端上运行，也可以借助Node.js在服务端运行</strong></p>\n<h5 id=\"Less中的注释\"><a href=\"#Less中的注释\" class=\"headerlink\" title=\"Less中的注释\"></a>Less中的注释</h5><ul>\n<li>以//开头的注释，不会被编译到css文件中。</li>\n<li>以/**/包裹的注释会被编译到css文件中。</li>\n</ul>\n<h5 id=\"less中的变量\"><a href=\"#less中的变量\" class=\"headerlink\" title=\"less中的变量\"></a>less中的变量</h5><p>使用@来申明一个变量:@pink:pink</p>\n<ol>\n<li><p>作为普通属性值来使用：直接使用@pink</p>\n</li>\n<li><p>作为选择器和属性：#@{selector的值}的形式</p>\n</li>\n<li><p>作为URL：@{url}</p>\n</li>\n<li><p>变量的延迟加载</p>\n<pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token comment\" spellcheck=\"true\">// less也拥有块级作用域{}</span>\n<span class=\"token variable\">@var<span class=\"token punctuation\">:</span></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token selector\">.class</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token variable\">@var<span class=\"token punctuation\">:</span></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token selector\">.brass</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token variable\">@var<span class=\"token punctuation\">:</span></span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">three</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@var</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 3</span>\n        <span class=\"token variable\">@var<span class=\"token punctuation\">:</span></span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token property\">one</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@var</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h5 id=\"less中的嵌套规则\"><a href=\"#less中的嵌套规则\" class=\"headerlink\" title=\"less中的嵌套规则\"></a>less中的嵌套规则</h5><ol>\n<li><p>基本嵌套规则</p>\n</li>\n<li><p>&amp;的使用</p>\n<pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token comment\" spellcheck=\"true\">// &amp;代表平级</span>\n<span class=\"token comment\" spellcheck=\"true\">/*\n    &lt;div class=\"wrap\">\n        &lt;div class=\"inner\">&lt;/div>\n    &lt;/div>\n*/</span>\n<span class=\"token variable\">@color<span class=\"token punctuation\">:</span></span>deepink<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">// 定义变量    </span>\n<span class=\"token selector\">#wrap</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">400</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px solid<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token selector\">.inner</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@color</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token selector\">&amp;:hover</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 最终解析出来的是 #wrap .inner:hover 如果不加&amp;符号，#wrap .inner :hover</span>\n            <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> pink<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h5 id=\"less中的混合\"><a href=\"#less中的混合\" class=\"headerlink\" title=\"less中的混合\"></a>less中的混合</h5><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式</p>\n<ol>\n<li>普通混合</li>\n<li>不带输出的混合</li>\n<li>带参数的混合</li>\n<li>带参数并且有默认值的混合</li>\n<li>带多个参数的混合</li>\n<li>命名参数</li>\n<li>匹配模式</li>\n<li>arguments变量</li>\n</ol>\n<pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token selector\">#wrap</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">400</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px solid<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token selector\">.inner</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> deeppink<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\">.inner2</span><span class=\"token punctuation\">{</span>\n        <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> deeppink<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 普通混合 ---> 编译后，不会被删除</span>\n<span class=\"token selector\">.juzhong</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> deeppink<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 不带输出混合 ---> 编译后，不会显示</span>\n<span class=\"token selector\">.juzhong()</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> deeppink<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 带参数混合 ---> 使用.juzhong(100px,100px,deeppink)</span>\n<span class=\"token selector\">.juzhong(<span class=\"token variable\">@w</span>,<span class=\"token variable\">@h</span>,<span class=\"token variable\">@c</span>)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@c</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@w</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token variable\">@h</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">#wrap</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">400</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px solid<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token selector\">.inner</span><span class=\"token punctuation\">{</span>\n       <span class=\"token mixin-usage function\">.juzhong</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token selector\">.inner2</span><span class=\"token punctuation\">{</span>\n        <span class=\"token mixin-usage function\">.juzhong</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"less运算\"><a href=\"#less运算\" class=\"headerlink\" title=\"less运算\"></a>less运算</h5><p>在less中可以进行加减乘除的运算</p>\n<pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token selector\">#wrap .sjx</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span> <span class=\"token operator\">+</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 只需一方带单位即可</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"less避免编译\"><a href=\"#less避免编译\" class=\"headerlink\" title=\"less避免编译\"></a>less避免编译</h5><pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token selector\">.div</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">padding</span><span class=\"token punctuation\">:</span> ~<span class=\"token string\">\"cacl(100px + 100px)\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// ~\"\"将被识别为字符串，不会被编译</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"less继承\"><a href=\"#less继承\" class=\"headerlink\" title=\"less继承\"></a>less继承</h5><ol>\n<li>性能比混合高</li>\n<li>灵活度比混合低</li>\n</ol>\n<pre class=\"line-numbers language-less\"><code class=\"language-less\"><span class=\"token selector\">.juzhong</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// 继承不能使用参数</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> absolute<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">left</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">right</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">top</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">bottom</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> auto<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\">#wrap</span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">position</span><span class=\"token punctuation\">:</span> relative<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">400</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>px solid<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">margin</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> auto<span class=\"token punctuation\">;</span>\n    <span class=\"token selector\">.inner:extend(.juzhong)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">// 继承</span>\n        <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> deeppink<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">width</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n        <span class=\"token property\">height</span><span class=\"token punctuation\">:</span> <span class=\"token number\">100</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h3><p>less是一种动态样式语言，属于css预处理器的范畴，它扩展了css语言，增加了变量、Mixin、函数等特性，使css更易于维护和扩展。</p>\n<p><strong>Less即可以在客户端上运行，也可以借助Node.js在服务端运行</strong></p>\n<h5 id=\"Less中的注释\"><a href=\"#Less中的注释\" class=\"headerlink\" title=\"Less中的注释\"></a>Less中的注释</h5><ul>\n<li>以//开头的注释，不会被编译到css文件中。</li>\n<li>以/**/包裹的注释会被编译到css文件中。</li>\n</ul>\n<h5 id=\"less中的变量\"><a href=\"#less中的变量\" class=\"headerlink\" title=\"less中的变量\"></a>less中的变量</h5><p>使用@来申明一个变量:@pink:pink</p>\n<ol>\n<li><p>作为普通属性值来使用：直接使用@pink</p>\n</li>\n<li><p>作为选择器和属性：#@{selector的值}的形式</p>\n</li>\n<li><p>作为URL：@{url}</p>\n</li>\n<li><p>变量的延迟加载</p>\n<pre><code class=\"less\">// less也拥有块级作用域{}\n@var: 0;\n.class {\n    @var: 1;\n    .brass {\n        @var: 2;\n        three: @var;  // 3\n        @var: 3;\n    }\n    one: @var;\n}\n</code></pre>\n</li>\n</ol>\n<h5 id=\"less中的嵌套规则\"><a href=\"#less中的嵌套规则\" class=\"headerlink\" title=\"less中的嵌套规则\"></a>less中的嵌套规则</h5><ol>\n<li><p>基本嵌套规则</p>\n</li>\n<li><p>&amp;的使用</p>\n<pre><code class=\"less\">// &amp;代表平级\n/*\n    &lt;div class=&quot;wrap&quot;&gt;\n        &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n*/\n@color:deepink;   // 定义变量    \n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: @color;\n        height: 100px;\n        width: 100px;\n        &amp;:hover{  // 最终解析出来的是 #wrap .inner:hover 如果不加&amp;符号，#wrap .inner :hover\n            background: pink;\n        }\n    }\n}\n</code></pre>\n</li>\n</ol>\n<h5 id=\"less中的混合\"><a href=\"#less中的混合\" class=\"headerlink\" title=\"less中的混合\"></a>less中的混合</h5><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式</p>\n<ol>\n<li>普通混合</li>\n<li>不带输出的混合</li>\n<li>带参数的混合</li>\n<li>带参数并且有默认值的混合</li>\n<li>带多个参数的混合</li>\n<li>命名参数</li>\n<li>匹配模式</li>\n<li>arguments变量</li>\n</ol>\n<pre><code class=\"less\">#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n        width: 100px;\n        height: 100px;\n    }\n    .inner2{\n        position: absolute;\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 0;\n        margin: auto;\n        background: deeppink;\n        width: 100px;\n        height: 100px;\n    }\n}\n// 普通混合 ---&gt; 编译后，不会被删除\n.juzhong{\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 不带输出混合 ---&gt; 编译后，不会显示\n.juzhong(){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: deeppink;\n    width: 100px;\n    height: 100px;\n}\n// 带参数混合 ---&gt; 使用.juzhong(100px,100px,deeppink)\n.juzhong(@w,@h,@c){\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n    background: @c;\n    width: @w;\n    height: @h;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner{\n       .juzhong;\n    }\n    .inner2{\n        .juzhong;\n    }\n}\n</code></pre>\n<h5 id=\"less运算\"><a href=\"#less运算\" class=\"headerlink\" title=\"less运算\"></a>less运算</h5><p>在less中可以进行加减乘除的运算</p>\n<pre><code class=\"less\">#wrap .sjx{\n    width:(100 + 100px);  // 只需一方带单位即可\n}\n</code></pre>\n<h5 id=\"less避免编译\"><a href=\"#less避免编译\" class=\"headerlink\" title=\"less避免编译\"></a>less避免编译</h5><pre><code class=\"less\">.div{\n    margin: 100px;\n    padding: ~&quot;cacl(100px + 100px)&quot;; // ~&quot;&quot;将被识别为字符串，不会被编译\n}\n</code></pre>\n<h5 id=\"less继承\"><a href=\"#less继承\" class=\"headerlink\" title=\"less继承\"></a>less继承</h5><ol>\n<li>性能比混合高</li>\n<li>灵活度比混合低</li>\n</ol>\n<pre><code class=\"less\">.juzhong{ // 继承不能使用参数\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    margin: auto;\n}\n#wrap{\n    position: relative;\n    width: 300px;\n    height: 400px;\n    border: 1px solid;\n    margin: 0 auto;\n    .inner:extend(.juzhong){  // 继承\n        background: deeppink;\n        width: 100px;\n        height: 100px;\n    }\n}\n</code></pre>\n"},{"title":"position属性","date":"2018-10-18T05:19:20.000Z","_content":"\n### position属性\n\n**该属性规定元素的定位类型**\n\n> 语法：`position:absolute | relative | fixed | static | interit;`\n>\n> - absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。（left、top、right、bottom）\n> - fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。（left、top、right、bottom）\n> - relative：生成相对定位的元素，相对于其正常位置进行定位。\n> - static：默认值。没有定位，元素出现在正常的流中。（忽略 top, bottom, left, right 或者 z-index 声明）\n> - inherit：规定应该从元素继承position属性的值。\n\n对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。\n\n**注释：**根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。","source":"_posts/position属性.md","raw":"---\ntitle: position属性\ndate: 2018-10-18 13:19:20\ntags: css\ncategories: 前端\n---\n\n### position属性\n\n**该属性规定元素的定位类型**\n\n> 语法：`position:absolute | relative | fixed | static | interit;`\n>\n> - absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。（left、top、right、bottom）\n> - fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。（left、top、right、bottom）\n> - relative：生成相对定位的元素，相对于其正常位置进行定位。\n> - static：默认值。没有定位，元素出现在正常的流中。（忽略 top, bottom, left, right 或者 z-index 声明）\n> - inherit：规定应该从元素继承position属性的值。\n\n对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。\n\n**注释：**根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。","slug":"position属性","published":1,"updated":"2024-02-19T07:42:51.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdran003b1xop896hdf8z","content":"<h3 id=\"position属性\"><a href=\"#position属性\" class=\"headerlink\" title=\"position属性\"></a>position属性</h3><p><strong>该属性规定元素的定位类型</strong></p>\n<blockquote>\n<p>语法：<code>position:absolute | relative | fixed | static | interit;</code></p>\n<ul>\n<li>absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。（left、top、right、bottom）</li>\n<li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。（left、top、right、bottom）</li>\n<li>relative：生成相对定位的元素，相对于其正常位置进行定位。</li>\n<li>static：默认值。没有定位，元素出现在正常的流中。（忽略 top, bottom, left, right 或者 z-index 声明）</li>\n<li>inherit：规定应该从元素继承position属性的值。</li>\n</ul>\n</blockquote>\n<p>对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>\n<p><strong>注释：</strong>根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"position属性\"><a href=\"#position属性\" class=\"headerlink\" title=\"position属性\"></a>position属性</h3><p><strong>该属性规定元素的定位类型</strong></p>\n<blockquote>\n<p>语法：<code>position:absolute | relative | fixed | static | interit;</code></p>\n<ul>\n<li>absolute：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。（left、top、right、bottom）</li>\n<li>fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。（left、top、right、bottom）</li>\n<li>relative：生成相对定位的元素，相对于其正常位置进行定位。</li>\n<li>static：默认值。没有定位，元素出现在正常的流中。（忽略 top, bottom, left, right 或者 z-index 声明）</li>\n<li>inherit：规定应该从元素继承position属性的值。</li>\n</ul>\n</blockquote>\n<p>对于定位的主要问题是要记住每种定位的意义。所以，现在让我们复习一下学过的知识吧：相对定位是“相对于”元素在文档中的初始位置，而绝对定位是“相对于”最近的已定位祖先元素，如果不存在已定位的祖先元素，那么“相对于”最初的包含块。</p>\n<p><strong>注释：</strong>根据用户代理的不同，最初的包含块可能是画布或 HTML 元素。</p>\n"},{"title":"js继承","date":"2018-10-05T07:46:12.000Z","_content":"\n### js继承\n\n```javascript\nfuntion Animal(){\n    this.type='animal';\n}\nfunction Dog(name,food){\n    this.name=name;\n    this.food=food;\n}\n```\n\n如何让Dog继承Animal呢？\n\n1. **对构造函数进行绑定（通过使用function的`call、apply方法，将父对象的构造函数绑定在子对象上）**\n\n   ```javascript\n   function Dog(name,food){\n       Animal.call(this,arguments); //this的指向属于dog\n       this.name=name;\n       this.food=food;\n   }\n   let dog=new Dog('小黄','骨头');\n   console.log(dog.type); //animal\n   ```\n\n   以上代码相当于：\n\n   ```javascript\n   function Dog(name,food){\n       this.type='animal';\t//this的指向属于dog\n       this.name=name;\n       this.food=food;\n   }\n   let dog=new Dog('小黄','骨头');\n   console.log(dog.type); //animal\n   ```\n\n\n​     2.**利用prototype**\n\n实现方式：\n\n```javascript\nDog.prototype=new Animal();  //通过修改Dog的prototype对象，让其指向Animal的实例。\nDog.prototype.constructor=Dog; \nlet dog=new Dog('小黄','骨头'); //对象dog的__proto__指向Dog的prototype(也就是Animal)\nconsole.log(dog.type); //animal\n```\n\n> 上述代码中,第一行将Dog原来的`prototype`整体替换成了Animal,由于任何一个`prototype`对象都有一个`constructor`属性,而这个属性指向它的构造函数.也就是说:\n>\n> ```javascript\n> console.log(Dog.prototype.constructor==Dog); //true\n> ```\n>\n> 而第一行代码将原本指向Dog的`constructor`属性改成了指向Animal:\n>\n> ```javascript\n> Dog.prototype=new Animal();\n> console.log(Dog.prototype.constructor==Animal); //true\n> ```\n>\n> 这样就会造成一种现象:dog明明是被构造函数Dog生成的,而`constructor`却指向了构造函数Animal,这显然不是我们想要的,所以需要对`constructor`的指向重新赋值:\n>\n> ```javascript\n> Dog.prototype.constructor=Dog;\n> ```\n>\n>\n\n##### 3.利用空对象作为中介\n\n方法二中继承时，需要创建Animal的实例，比较浪费内存。\n\n```js\nlet O = function(){};\nO.prototype=Animal.prototype;\nDog.prototype=new O();\nDog.prototype.constructor=Dog;\n```\n\n*O是一个空对象，几乎不占用内存。而且修改Dog.prototype也不会影响到Animal的prototype对象。*\n\n将其封装成一个函数：\n\n```js\nfunction extend(Child,Parent){\n    let O=function(){};\n    O.prototype=Parent.prototype;\n    Child.prototype=new O();\n    Child.prototype.constructor=Child;\n    Child.uber=Parent.prototype;   //预留的访问父对象的接口\n}\n```\n\n","source":"_posts/js继承.md","raw":"---\ntitle: js继承\ndate: 2018-10-05 15:46:12\ntags: js\ncategories: 前端\n---\n\n### js继承\n\n```javascript\nfuntion Animal(){\n    this.type='animal';\n}\nfunction Dog(name,food){\n    this.name=name;\n    this.food=food;\n}\n```\n\n如何让Dog继承Animal呢？\n\n1. **对构造函数进行绑定（通过使用function的`call、apply方法，将父对象的构造函数绑定在子对象上）**\n\n   ```javascript\n   function Dog(name,food){\n       Animal.call(this,arguments); //this的指向属于dog\n       this.name=name;\n       this.food=food;\n   }\n   let dog=new Dog('小黄','骨头');\n   console.log(dog.type); //animal\n   ```\n\n   以上代码相当于：\n\n   ```javascript\n   function Dog(name,food){\n       this.type='animal';\t//this的指向属于dog\n       this.name=name;\n       this.food=food;\n   }\n   let dog=new Dog('小黄','骨头');\n   console.log(dog.type); //animal\n   ```\n\n\n​     2.**利用prototype**\n\n实现方式：\n\n```javascript\nDog.prototype=new Animal();  //通过修改Dog的prototype对象，让其指向Animal的实例。\nDog.prototype.constructor=Dog; \nlet dog=new Dog('小黄','骨头'); //对象dog的__proto__指向Dog的prototype(也就是Animal)\nconsole.log(dog.type); //animal\n```\n\n> 上述代码中,第一行将Dog原来的`prototype`整体替换成了Animal,由于任何一个`prototype`对象都有一个`constructor`属性,而这个属性指向它的构造函数.也就是说:\n>\n> ```javascript\n> console.log(Dog.prototype.constructor==Dog); //true\n> ```\n>\n> 而第一行代码将原本指向Dog的`constructor`属性改成了指向Animal:\n>\n> ```javascript\n> Dog.prototype=new Animal();\n> console.log(Dog.prototype.constructor==Animal); //true\n> ```\n>\n> 这样就会造成一种现象:dog明明是被构造函数Dog生成的,而`constructor`却指向了构造函数Animal,这显然不是我们想要的,所以需要对`constructor`的指向重新赋值:\n>\n> ```javascript\n> Dog.prototype.constructor=Dog;\n> ```\n>\n>\n\n##### 3.利用空对象作为中介\n\n方法二中继承时，需要创建Animal的实例，比较浪费内存。\n\n```js\nlet O = function(){};\nO.prototype=Animal.prototype;\nDog.prototype=new O();\nDog.prototype.constructor=Dog;\n```\n\n*O是一个空对象，几乎不占用内存。而且修改Dog.prototype也不会影响到Animal的prototype对象。*\n\n将其封装成一个函数：\n\n```js\nfunction extend(Child,Parent){\n    let O=function(){};\n    O.prototype=Parent.prototype;\n    Child.prototype=new O();\n    Child.prototype.constructor=Child;\n    Child.uber=Parent.prototype;   //预留的访问父对象的接口\n}\n```\n\n","slug":"js继承","published":1,"updated":"2024-02-19T07:42:51.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrao003f1xop08t6drh6","content":"<h3 id=\"js继承\"><a href=\"#js继承\" class=\"headerlink\" title=\"js继承\"></a>js继承</h3><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">funtion <span class=\"token function\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>type<span class=\"token operator\">=</span><span class=\"token string\">'animal'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Dog</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>food<span class=\"token operator\">=</span>food<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如何让Dog继承Animal呢？</p>\n<ol>\n<li><p><strong>对构造函数进行绑定（通过使用function的`call、apply方法，将父对象的构造函数绑定在子对象上）</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Dog</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Animal<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//this的指向属于dog</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>food<span class=\"token operator\">=</span>food<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> dog<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小黄'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'骨头'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//animal</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>以上代码相当于：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Dog</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>type<span class=\"token operator\">=</span><span class=\"token string\">'animal'</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//this的指向属于dog</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span>name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>food<span class=\"token operator\">=</span>food<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> dog<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小黄'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'骨头'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//animal</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p>​     2.<strong>利用prototype</strong></p>\n<p>实现方式：</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">Dog<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//通过修改Dog的prototype对象，让其指向Animal的实例。</span>\nDog<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">=</span>Dog<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">let</span> dog<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Dog</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小黄'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'骨头'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//对象dog的__proto__指向Dog的prototype(也就是Animal)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>dog<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//animal</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>上述代码中,第一行将Dog原来的<code>prototype</code>整体替换成了Animal,由于任何一个<code>prototype</code>对象都有一个<code>constructor</code>属性,而这个属性指向它的构造函数.也就是说:</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Dog<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">==</span>Dog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>而第一行代码将原本指向Dog的<code>constructor</code>属性改成了指向Animal:</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">Dog<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Animal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Dog<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">==</span>Animal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这样就会造成一种现象:dog明明是被构造函数Dog生成的,而<code>constructor</code>却指向了构造函数Animal,这显然不是我们想要的,所以需要对<code>constructor</code>的指向重新赋值:</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">Dog<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">=</span>Dog<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</blockquote>\n<h5 id=\"3-利用空对象作为中介\"><a href=\"#3-利用空对象作为中介\" class=\"headerlink\" title=\"3.利用空对象作为中介\"></a>3.利用空对象作为中介</h5><p>方法二中继承时，需要创建Animal的实例，比较浪费内存。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> O <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nO<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span>Animal<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\nDog<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">O</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nDog<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">=</span>Dog<span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em>O是一个空对象，几乎不占用内存。而且修改Dog.prototype也不会影响到Animal的prototype对象。</em></p>\n<p>将其封装成一个函数：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">extend</span><span class=\"token punctuation\">(</span>Child<span class=\"token punctuation\">,</span>Parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> O<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    O<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span>Parent<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n    Child<span class=\"token punctuation\">.</span>prototype<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">O</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Child<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>constructor<span class=\"token operator\">=</span>Child<span class=\"token punctuation\">;</span>\n    Child<span class=\"token punctuation\">.</span>uber<span class=\"token operator\">=</span>Parent<span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//预留的访问父对象的接口</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js继承\"><a href=\"#js继承\" class=\"headerlink\" title=\"js继承\"></a>js继承</h3><pre><code class=\"javascript\">funtion Animal(){\n    this.type=&#39;animal&#39;;\n}\nfunction Dog(name,food){\n    this.name=name;\n    this.food=food;\n}\n</code></pre>\n<p>如何让Dog继承Animal呢？</p>\n<ol>\n<li><p><strong>对构造函数进行绑定（通过使用function的`call、apply方法，将父对象的构造函数绑定在子对象上）</strong></p>\n<pre><code class=\"javascript\">function Dog(name,food){\n    Animal.call(this,arguments); //this的指向属于dog\n    this.name=name;\n    this.food=food;\n}\nlet dog=new Dog(&#39;小黄&#39;,&#39;骨头&#39;);\nconsole.log(dog.type); //animal\n</code></pre>\n<p>以上代码相当于：</p>\n<pre><code class=\"javascript\">function Dog(name,food){\n    this.type=&#39;animal&#39;;    //this的指向属于dog\n    this.name=name;\n    this.food=food;\n}\nlet dog=new Dog(&#39;小黄&#39;,&#39;骨头&#39;);\nconsole.log(dog.type); //animal\n</code></pre>\n</li>\n</ol>\n<p>​     2.<strong>利用prototype</strong></p>\n<p>实现方式：</p>\n<pre><code class=\"javascript\">Dog.prototype=new Animal();  //通过修改Dog的prototype对象，让其指向Animal的实例。\nDog.prototype.constructor=Dog; \nlet dog=new Dog(&#39;小黄&#39;,&#39;骨头&#39;); //对象dog的__proto__指向Dog的prototype(也就是Animal)\nconsole.log(dog.type); //animal\n</code></pre>\n<blockquote>\n<p>上述代码中,第一行将Dog原来的<code>prototype</code>整体替换成了Animal,由于任何一个<code>prototype</code>对象都有一个<code>constructor</code>属性,而这个属性指向它的构造函数.也就是说:</p>\n<pre><code class=\"javascript\">console.log(Dog.prototype.constructor==Dog); //true\n</code></pre>\n<p>而第一行代码将原本指向Dog的<code>constructor</code>属性改成了指向Animal:</p>\n<pre><code class=\"javascript\">Dog.prototype=new Animal();\nconsole.log(Dog.prototype.constructor==Animal); //true\n</code></pre>\n<p>这样就会造成一种现象:dog明明是被构造函数Dog生成的,而<code>constructor</code>却指向了构造函数Animal,这显然不是我们想要的,所以需要对<code>constructor</code>的指向重新赋值:</p>\n<pre><code class=\"javascript\">Dog.prototype.constructor=Dog;\n</code></pre>\n</blockquote>\n<h5 id=\"3-利用空对象作为中介\"><a href=\"#3-利用空对象作为中介\" class=\"headerlink\" title=\"3.利用空对象作为中介\"></a>3.利用空对象作为中介</h5><p>方法二中继承时，需要创建Animal的实例，比较浪费内存。</p>\n<pre><code class=\"js\">let O = function(){};\nO.prototype=Animal.prototype;\nDog.prototype=new O();\nDog.prototype.constructor=Dog;\n</code></pre>\n<p><em>O是一个空对象，几乎不占用内存。而且修改Dog.prototype也不会影响到Animal的prototype对象。</em></p>\n<p>将其封装成一个函数：</p>\n<pre><code class=\"js\">function extend(Child,Parent){\n    let O=function(){};\n    O.prototype=Parent.prototype;\n    Child.prototype=new O();\n    Child.prototype.constructor=Child;\n    Child.uber=Parent.prototype;   //预留的访问父对象的接口\n}\n</code></pre>\n"},{"title":"px、em、rem区别","date":"2018-09-27T09:19:59.000Z","_content":"# px、em、rem之间的区别\n### PX\npx：像素。是相对长度单位，相对于当前显示器屏幕分辨率而言的。\n\n##### px特点   \n1. 大部分浏览器无法做到调整使用px作为单位的字体大小。\n2. 国外大部分网站使用em或者rem作为字体单位。\n\n### EM\nem：是相对长度单位。相对于当前对象内文本的字体尺寸，如当前对行内文本的尺寸未被人为设置，则相对于浏览器的默认字体尺寸。\n\n##### em特点\n1. em的值并不是固定的。\n2. em会继承父元素的字体大小。\n\n>*注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px\\*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。*\n所以我们在写CSS的时候，需要注意两点：   \n1. body选择器中声明Font-size=62.5%;\n2. 将你的原来的px数值除以10，然后换上em作为单位;\n3. 重新计算那些被放大的字体的em数值，避免字体大小的重复声明。\n*也就是避免1.2\\*1.2=1.44的现象。（因为em汇集成父元素的字体大小）举个例子来说：比如说你在父元素中声明了字体大小为1.2em，那么在声明父元素内部的字体大小时，只能使用1em，而不是1.2em，以为当前的1em就代表的父元素声明的1.2em，也就是1em=1.2px。*\n\n### REM\nrem：css3新增的一个相对单位(root em)，这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓是集相对大小与绝对大小的优点与一身，可以通过只是修改根元素就成比例的调整页面的所有字体大小，又可以避免字体大小逐层符合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。\n例如：`p{font-size:14px;font-size:0.875rem;}`\n```css\nhtml {font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/}\nbody {font-size: 1.4rem;/*1.4 × 10px = 14px */}\nh1 { font-size: 2.4rem;/*2.4 × 10px = 24px*/}\n```\n#### 如何选择字体单位   \n1. 对于一般的只需要适配少部分设备的网页来说，使用px就可以解决。\n2. 对于需要适配多种设备的网页，使用rem，特别是分辨率差别比较大的。\n","source":"_posts/px、em、rem区别.md","raw":"---\ntitle: px、em、rem区别\ndate: 2018-09-27 17:19:59\ntags: css\ncategories: 前端\n---\n# px、em、rem之间的区别\n### PX\npx：像素。是相对长度单位，相对于当前显示器屏幕分辨率而言的。\n\n##### px特点   \n1. 大部分浏览器无法做到调整使用px作为单位的字体大小。\n2. 国外大部分网站使用em或者rem作为字体单位。\n\n### EM\nem：是相对长度单位。相对于当前对象内文本的字体尺寸，如当前对行内文本的尺寸未被人为设置，则相对于浏览器的默认字体尺寸。\n\n##### em特点\n1. em的值并不是固定的。\n2. em会继承父元素的字体大小。\n\n>*注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px\\*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。*\n所以我们在写CSS的时候，需要注意两点：   \n1. body选择器中声明Font-size=62.5%;\n2. 将你的原来的px数值除以10，然后换上em作为单位;\n3. 重新计算那些被放大的字体的em数值，避免字体大小的重复声明。\n*也就是避免1.2\\*1.2=1.44的现象。（因为em汇集成父元素的字体大小）举个例子来说：比如说你在父元素中声明了字体大小为1.2em，那么在声明父元素内部的字体大小时，只能使用1em，而不是1.2em，以为当前的1em就代表的父元素声明的1.2em，也就是1em=1.2px。*\n\n### REM\nrem：css3新增的一个相对单位(root em)，这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓是集相对大小与绝对大小的优点与一身，可以通过只是修改根元素就成比例的调整页面的所有字体大小，又可以避免字体大小逐层符合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。\n例如：`p{font-size:14px;font-size:0.875rem;}`\n```css\nhtml {font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/}\nbody {font-size: 1.4rem;/*1.4 × 10px = 14px */}\nh1 { font-size: 2.4rem;/*2.4 × 10px = 24px*/}\n```\n#### 如何选择字体单位   \n1. 对于一般的只需要适配少部分设备的网页来说，使用px就可以解决。\n2. 对于需要适配多种设备的网页，使用rem，特别是分辨率差别比较大的。\n","slug":"px、em、rem区别","published":1,"updated":"2024-02-19T07:42:51.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrap003i1xopc278a7tu","content":"<h1 id=\"px、em、rem之间的区别\"><a href=\"#px、em、rem之间的区别\" class=\"headerlink\" title=\"px、em、rem之间的区别\"></a>px、em、rem之间的区别</h1><h3 id=\"PX\"><a href=\"#PX\" class=\"headerlink\" title=\"PX\"></a>PX</h3><p>px：像素。是相对长度单位，相对于当前显示器屏幕分辨率而言的。</p>\n<h5 id=\"px特点\"><a href=\"#px特点\" class=\"headerlink\" title=\"px特点\"></a>px特点</h5><ol>\n<li>大部分浏览器无法做到调整使用px作为单位的字体大小。</li>\n<li>国外大部分网站使用em或者rem作为字体单位。</li>\n</ol>\n<h3 id=\"EM\"><a href=\"#EM\" class=\"headerlink\" title=\"EM\"></a>EM</h3><p>em：是相对长度单位。相对于当前对象内文本的字体尺寸，如当前对行内文本的尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>\n<h5 id=\"em特点\"><a href=\"#em特点\" class=\"headerlink\" title=\"em特点\"></a>em特点</h5><ol>\n<li>em的值并不是固定的。</li>\n<li>em会继承父元素的字体大小。</li>\n</ol>\n<blockquote>\n<p><em>注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px\\</em>62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。*<br>所以我们在写CSS的时候，需要注意两点：   </p>\n<ol>\n<li>body选择器中声明Font-size=62.5%;</li>\n<li>将你的原来的px数值除以10，然后换上em作为单位;</li>\n<li>重新计算那些被放大的字体的em数值，避免字体大小的重复声明。<br><em>也就是避免1.2\\</em>1.2=1.44的现象。（因为em汇集成父元素的字体大小）举个例子来说：比如说你在父元素中声明了字体大小为1.2em，那么在声明父元素内部的字体大小时，只能使用1em，而不是1.2em，以为当前的1em就代表的父元素声明的1.2em，也就是1em=1.2px。*</li>\n</ol>\n</blockquote>\n<h3 id=\"REM\"><a href=\"#REM\" class=\"headerlink\" title=\"REM\"></a>REM</h3><p>rem：css3新增的一个相对单位(root em)，这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓是集相对大小与绝对大小的优点与一身，可以通过只是修改根元素就成比例的调整页面的所有字体大小，又可以避免字体大小逐层符合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。<br>例如：<code>p{font-size:14px;font-size:0.875rem;}</code></p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\">html </span><span class=\"token punctuation\">{</span><span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">62.5%</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">/*10 ÷ 16 × 100% = 62.5%*/</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">body </span><span class=\"token punctuation\">{</span><span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1.4</span>rem<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">/*1.4 × 10px = 14px */</span><span class=\"token punctuation\">}</span>\n<span class=\"token selector\">h1 </span><span class=\"token punctuation\">{</span> <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2.4</span>rem<span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">/*2.4 × 10px = 24px*/</span><span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"如何选择字体单位\"><a href=\"#如何选择字体单位\" class=\"headerlink\" title=\"如何选择字体单位\"></a>如何选择字体单位</h4><ol>\n<li>对于一般的只需要适配少部分设备的网页来说，使用px就可以解决。</li>\n<li>对于需要适配多种设备的网页，使用rem，特别是分辨率差别比较大的。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"px、em、rem之间的区别\"><a href=\"#px、em、rem之间的区别\" class=\"headerlink\" title=\"px、em、rem之间的区别\"></a>px、em、rem之间的区别</h1><h3 id=\"PX\"><a href=\"#PX\" class=\"headerlink\" title=\"PX\"></a>PX</h3><p>px：像素。是相对长度单位，相对于当前显示器屏幕分辨率而言的。</p>\n<h5 id=\"px特点\"><a href=\"#px特点\" class=\"headerlink\" title=\"px特点\"></a>px特点</h5><ol>\n<li>大部分浏览器无法做到调整使用px作为单位的字体大小。</li>\n<li>国外大部分网站使用em或者rem作为字体单位。</li>\n</ol>\n<h3 id=\"EM\"><a href=\"#EM\" class=\"headerlink\" title=\"EM\"></a>EM</h3><p>em：是相对长度单位。相对于当前对象内文本的字体尺寸，如当前对行内文本的尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p>\n<h5 id=\"em特点\"><a href=\"#em特点\" class=\"headerlink\" title=\"em特点\"></a>em特点</h5><ol>\n<li>em的值并不是固定的。</li>\n<li>em会继承父元素的字体大小。</li>\n</ol>\n<blockquote>\n<p><em>注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px\\</em>62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。*<br>所以我们在写CSS的时候，需要注意两点：   </p>\n<ol>\n<li>body选择器中声明Font-size=62.5%;</li>\n<li>将你的原来的px数值除以10，然后换上em作为单位;</li>\n<li>重新计算那些被放大的字体的em数值，避免字体大小的重复声明。<br><em>也就是避免1.2\\</em>1.2=1.44的现象。（因为em汇集成父元素的字体大小）举个例子来说：比如说你在父元素中声明了字体大小为1.2em，那么在声明父元素内部的字体大小时，只能使用1em，而不是1.2em，以为当前的1em就代表的父元素声明的1.2em，也就是1em=1.2px。*</li>\n</ol>\n</blockquote>\n<h3 id=\"REM\"><a href=\"#REM\" class=\"headerlink\" title=\"REM\"></a>REM</h3><p>rem：css3新增的一个相对单位(root em)，这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓是集相对大小与绝对大小的优点与一身，可以通过只是修改根元素就成比例的调整页面的所有字体大小，又可以避免字体大小逐层符合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。<br>例如：<code>p{font-size:14px;font-size:0.875rem;}</code></p>\n<pre><code class=\"css\">html {font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/}\nbody {font-size: 1.4rem;/*1.4 × 10px = 14px */}\nh1 { font-size: 2.4rem;/*2.4 × 10px = 24px*/}\n</code></pre>\n<h4 id=\"如何选择字体单位\"><a href=\"#如何选择字体单位\" class=\"headerlink\" title=\"如何选择字体单位\"></a>如何选择字体单位</h4><ol>\n<li>对于一般的只需要适配少部分设备的网页来说，使用px就可以解决。</li>\n<li>对于需要适配多种设备的网页，使用rem，特别是分辨率差别比较大的。</li>\n</ol>\n"},{"title":"js闭包","date":"2018-10-08T09:19:00.000Z","_content":"\n### js闭包\n\n**概念：**\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起，这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n>\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t———维基百科\n\n**闭包特点：**\n\n1. 优点：灵活方便、封装。\n2. 空间浪费、内存泄漏、性能消耗。\n\n##### 闭包形成的两个必要条件：\n\n1. 函数嵌套\n2. 内部函数引用外部函数的局部变量\n\n**闭包常见的表现形式：**\n\n1. 函数作为返回值\n2. 函数作为参数传递\n\n**举例：**\n\n```javascript\n//函数作为返回值\nfunction fn(){\n    let max=10;\n    return function bar(x){\n        if(x<max){\n            console.log(max);\n        }else{\n            console.log(x);\n        }\n    }\n}\nlet f1=fn();\nf1(13); //13\n```\n\n说明：我们都知道，一般函数调用之后，其内存会得到释放，函数内部定义的变量都会随着函数调用执行结束后释放。fn函数的返回值是函数bar,而函数bar中调用了fn函数中定义的max变量，导致max变量无法的到释放，从而形成了闭包。所以f1(13)可以输出13。\n\n```javascript\n//函数作为参数被传递\nlet max=10,\n    fn=function (x){\n        if(x>max){\n            console.log(x);\n        }\n    };\n(function (f){\n    let max=100;\n    f(15); //15\n})(fn);\n```\n\n说明：如上代码中，fn函数作为一个参数传递到立即执行函数中，在执行f(15)时，max的变量取值仍然是10而不是100。（在调用函数时，函数会先去查找内部的作用域，如果存在，则调用，如果不存在，就会去创建这个函数的作用域去取值，而不是在调用的那个‘父作用域’）。\n\n**注意：**\n\n1. 函数内部可以读取函数外部的全局变量，而在函数内部无法读取函数内的局部变量。\n2. 在函数内部定义变量必须用let/var，否则引用的还是全局的变量。\n3. 滥用闭包，会导致内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n4. 会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n**附加：**\n\n![](js闭包/d2a9dab04077415480e81d7d8e8fd13e.png)\n\n![](js闭包/a33c05334094f1ce80d00166ab7ed5aa.png)\n\n","source":"_posts/js闭包.md","raw":"---\ntitle: js闭包\ndate: 2018-10-08 17:19:00\ntags: js\ncategories: 前端\n---\n\n### js闭包\n\n**概念：**\n\n> 在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起，这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。\n>\n> 闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t———维基百科\n\n**闭包特点：**\n\n1. 优点：灵活方便、封装。\n2. 空间浪费、内存泄漏、性能消耗。\n\n##### 闭包形成的两个必要条件：\n\n1. 函数嵌套\n2. 内部函数引用外部函数的局部变量\n\n**闭包常见的表现形式：**\n\n1. 函数作为返回值\n2. 函数作为参数传递\n\n**举例：**\n\n```javascript\n//函数作为返回值\nfunction fn(){\n    let max=10;\n    return function bar(x){\n        if(x<max){\n            console.log(max);\n        }else{\n            console.log(x);\n        }\n    }\n}\nlet f1=fn();\nf1(13); //13\n```\n\n说明：我们都知道，一般函数调用之后，其内存会得到释放，函数内部定义的变量都会随着函数调用执行结束后释放。fn函数的返回值是函数bar,而函数bar中调用了fn函数中定义的max变量，导致max变量无法的到释放，从而形成了闭包。所以f1(13)可以输出13。\n\n```javascript\n//函数作为参数被传递\nlet max=10,\n    fn=function (x){\n        if(x>max){\n            console.log(x);\n        }\n    };\n(function (f){\n    let max=100;\n    f(15); //15\n})(fn);\n```\n\n说明：如上代码中，fn函数作为一个参数传递到立即执行函数中，在执行f(15)时，max的变量取值仍然是10而不是100。（在调用函数时，函数会先去查找内部的作用域，如果存在，则调用，如果不存在，就会去创建这个函数的作用域去取值，而不是在调用的那个‘父作用域’）。\n\n**注意：**\n\n1. 函数内部可以读取函数外部的全局变量，而在函数内部无法读取函数内的局部变量。\n2. 在函数内部定义变量必须用let/var，否则引用的还是全局的变量。\n3. 滥用闭包，会导致内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n4. 会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n**附加：**\n\n![](js闭包/d2a9dab04077415480e81d7d8e8fd13e.png)\n\n![](js闭包/a33c05334094f1ce80d00166ab7ed5aa.png)\n\n","slug":"js闭包","published":1,"updated":"2024-02-19T07:42:51.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdras003m1xop2p5vc7eu","content":"<h3 id=\"js闭包\"><a href=\"#js闭包\" class=\"headerlink\" title=\"js闭包\"></a>js闭包</h3><p><strong>概念：</strong></p>\n<blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起，这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。</p>\n<p>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n<p>​                                                                                            ———维基百科</p>\n</blockquote>\n<p><strong>闭包特点：</strong></p>\n<ol>\n<li>优点：灵活方便、封装。</li>\n<li>空间浪费、内存泄漏、性能消耗。</li>\n</ol>\n<h5 id=\"闭包形成的两个必要条件：\"><a href=\"#闭包形成的两个必要条件：\" class=\"headerlink\" title=\"闭包形成的两个必要条件：\"></a>闭包形成的两个必要条件：</h5><ol>\n<li>函数嵌套</li>\n<li>内部函数引用外部函数的局部变量</li>\n</ol>\n<p><strong>闭包常见的表现形式：</strong></p>\n<ol>\n<li>函数作为返回值</li>\n<li>函数作为参数传递</li>\n</ol>\n<p><strong>举例：</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//函数作为返回值</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> max<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">&lt;</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> f1<span class=\"token operator\">=</span><span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//13</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>说明：我们都知道，一般函数调用之后，其内存会得到释放，函数内部定义的变量都会随着函数调用执行结束后释放。fn函数的返回值是函数bar,而函数bar中调用了fn函数中定义的max变量，导致max变量无法的到释放，从而形成了闭包。所以f1(13)可以输出13。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//函数作为参数被传递</span>\n<span class=\"token keyword\">let</span> max<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    fn<span class=\"token operator\">=</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> max<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//15</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>说明：如上代码中，fn函数作为一个参数传递到立即执行函数中，在执行f(15)时，max的变量取值仍然是10而不是100。（在调用函数时，函数会先去查找内部的作用域，如果存在，则调用，如果不存在，就会去创建这个函数的作用域去取值，而不是在调用的那个‘父作用域’）。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>函数内部可以读取函数外部的全局变量，而在函数内部无法读取函数内的局部变量。</li>\n<li>在函数内部定义变量必须用let/var，否则引用的还是全局的变量。</li>\n<li>滥用闭包，会导致内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>\n<li>会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ol>\n<p><strong>附加：</strong></p>\n<p><img src=\"/2018/10/08/js%E9%97%AD%E5%8C%85/d2a9dab04077415480e81d7d8e8fd13e.png\" alt></p>\n<p><img src=\"/2018/10/08/js%E9%97%AD%E5%8C%85/a33c05334094f1ce80d00166ab7ed5aa.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js闭包\"><a href=\"#js闭包\" class=\"headerlink\" title=\"js闭包\"></a>js闭包</h3><p><strong>概念：</strong></p>\n<blockquote>\n<p>在计算机科学中，闭包（也称词法闭包或函数闭包）是指一个函数或函数的引用，与一个引用环境绑定在一起，这个引用环境是一个存储该函数每个非局部变量（也叫自由变量）的表。</p>\n<p>闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量。</p>\n<p>​                                                                                            ———维基百科</p>\n</blockquote>\n<p><strong>闭包特点：</strong></p>\n<ol>\n<li>优点：灵活方便、封装。</li>\n<li>空间浪费、内存泄漏、性能消耗。</li>\n</ol>\n<h5 id=\"闭包形成的两个必要条件：\"><a href=\"#闭包形成的两个必要条件：\" class=\"headerlink\" title=\"闭包形成的两个必要条件：\"></a>闭包形成的两个必要条件：</h5><ol>\n<li>函数嵌套</li>\n<li>内部函数引用外部函数的局部变量</li>\n</ol>\n<p><strong>闭包常见的表现形式：</strong></p>\n<ol>\n<li>函数作为返回值</li>\n<li>函数作为参数传递</li>\n</ol>\n<p><strong>举例：</strong></p>\n<pre><code class=\"javascript\">//函数作为返回值\nfunction fn(){\n    let max=10;\n    return function bar(x){\n        if(x&lt;max){\n            console.log(max);\n        }else{\n            console.log(x);\n        }\n    }\n}\nlet f1=fn();\nf1(13); //13\n</code></pre>\n<p>说明：我们都知道，一般函数调用之后，其内存会得到释放，函数内部定义的变量都会随着函数调用执行结束后释放。fn函数的返回值是函数bar,而函数bar中调用了fn函数中定义的max变量，导致max变量无法的到释放，从而形成了闭包。所以f1(13)可以输出13。</p>\n<pre><code class=\"javascript\">//函数作为参数被传递\nlet max=10,\n    fn=function (x){\n        if(x&gt;max){\n            console.log(x);\n        }\n    };\n(function (f){\n    let max=100;\n    f(15); //15\n})(fn);\n</code></pre>\n<p>说明：如上代码中，fn函数作为一个参数传递到立即执行函数中，在执行f(15)时，max的变量取值仍然是10而不是100。（在调用函数时，函数会先去查找内部的作用域，如果存在，则调用，如果不存在，就会去创建这个函数的作用域去取值，而不是在调用的那个‘父作用域’）。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>函数内部可以读取函数外部的全局变量，而在函数内部无法读取函数内的局部变量。</li>\n<li>在函数内部定义变量必须用let/var，否则引用的还是全局的变量。</li>\n<li>滥用闭包，会导致内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>\n<li>会改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>\n</ol>\n<p><strong>附加：</strong></p>\n<p><img src=\"/2018/10/08/js%E9%97%AD%E5%8C%85/d2a9dab04077415480e81d7d8e8fd13e.png\" alt></p>\n<p><img src=\"/2018/10/08/js%E9%97%AD%E5%8C%85/a33c05334094f1ce80d00166ab7ed5aa.png\" alt></p>\n"},{"title":"package中的devdependencies和dependencies","date":"2019-04-24T04:45:50.000Z","_content":"\n### package中的devdependencies和dependencies\n\n##### devdependencies和dependencies\n\n这两个配置代表的是项目中所需要的相关依赖模块插件，通过键值的方式来定义：\n\n\n```json\n\"name\": \"webpack-react-express\",\n  \"version\": \"0.2.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"antd\": \"^2.13.11\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"base-64\": \"^0.1.0\",\n    \"bluebird\": \"^3.5.1\",\n    \"css-loader\": \"^0.28.7\",\n    \"echarts\": \"^3.7.2\",\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-loader\": \"^6.4.1\",\n    \"babel-plugin-transform-class-properties\": \"^6.24.1\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"webpack\": \"^1.12.13\",\n    \"webpack-hot-middleware\": \"^2.21.0\"\n  },\n```\n##### devDependencies\n1. 内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围\n\n2. 作用：该模块中所列举的插件属于开发环境的依赖（比如：测试或者文档框架等）\n\n3. 部署来源：通过你npm install进行依赖安装时加上-save-dev，devDependencies对象中便会增加你所需要的插件的安装配置\n\n    `npm install name -save-dev`\n##### dependencies\n1. 内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围\n\n2. 作用：该模块中所列举的插件属于生产环境的依赖（程序正常运行需要加载的依赖）\n\n3. 部署来源：通过你npm install进行依赖安装时加上-save，dependencies对象中便会增加你所需要的插件的安装配置\n    `npm install name -save`\n\n##### 安装依赖\n\n1. 如果拿到别人的项目，需要安装之前package.json中devdependencies 和 dependencies两个模块下所列举的依赖，可以通过执行以下命令实现\n\n    `npm install`\n\n2. 如果拿到别人的项目，只需要安装之前package.json中dependencies 模块下所列举的依赖，可以通过执行以下命令实现\n\n    `npm install packagename`\n\n3. 如果拿到别人的项目，只需要安装之前package.json中devdependencies 模块下所列举的依赖，可以通过执行以下命令实现\n    `npm install packagename -dev`\n##### 删除依赖\n1. npm uninstall \"依赖名称\"：删除依赖，但不会删除package.json的配置（即通过npm install依然可以安装该依赖），删除echarts依赖实例代码如下\n\n    `npm uninstall echarts`\n\n2. npm uninstall \"依赖名称\" --save-dev：删除依赖，同时删除package.json中devdependencies的配置,删除echarts依赖实例代码如下\n\n    `npm uninstall echarts  --save-dev`\n\n3. npm uninstall \"依赖名称\" --save：删除依赖，同时删除package.json中dependencies的配置,删除echarts依赖实例代码如下\n\n    `npm uninstall echarts --save`","source":"_posts/package中的devdependencies和dependencies.md","raw":"---\ntitle: package中的devdependencies和dependencies\ndate: 2019-04-24 12:45:50\ntags: Vue\ncategories: 前端\n---\n\n### package中的devdependencies和dependencies\n\n##### devdependencies和dependencies\n\n这两个配置代表的是项目中所需要的相关依赖模块插件，通过键值的方式来定义：\n\n\n```json\n\"name\": \"webpack-react-express\",\n  \"version\": \"0.2.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"antd\": \"^2.13.11\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"base-64\": \"^0.1.0\",\n    \"bluebird\": \"^3.5.1\",\n    \"css-loader\": \"^0.28.7\",\n    \"echarts\": \"^3.7.2\",\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"^6.26.0\",\n    \"babel-loader\": \"^6.4.1\",\n    \"babel-plugin-transform-class-properties\": \"^6.24.1\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"babel-preset-es2015\": \"^6.24.1\",\n    \"webpack\": \"^1.12.13\",\n    \"webpack-hot-middleware\": \"^2.21.0\"\n  },\n```\n##### devDependencies\n1. 内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围\n\n2. 作用：该模块中所列举的插件属于开发环境的依赖（比如：测试或者文档框架等）\n\n3. 部署来源：通过你npm install进行依赖安装时加上-save-dev，devDependencies对象中便会增加你所需要的插件的安装配置\n\n    `npm install name -save-dev`\n##### dependencies\n1. 内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围\n\n2. 作用：该模块中所列举的插件属于生产环境的依赖（程序正常运行需要加载的依赖）\n\n3. 部署来源：通过你npm install进行依赖安装时加上-save，dependencies对象中便会增加你所需要的插件的安装配置\n    `npm install name -save`\n\n##### 安装依赖\n\n1. 如果拿到别人的项目，需要安装之前package.json中devdependencies 和 dependencies两个模块下所列举的依赖，可以通过执行以下命令实现\n\n    `npm install`\n\n2. 如果拿到别人的项目，只需要安装之前package.json中dependencies 模块下所列举的依赖，可以通过执行以下命令实现\n\n    `npm install packagename`\n\n3. 如果拿到别人的项目，只需要安装之前package.json中devdependencies 模块下所列举的依赖，可以通过执行以下命令实现\n    `npm install packagename -dev`\n##### 删除依赖\n1. npm uninstall \"依赖名称\"：删除依赖，但不会删除package.json的配置（即通过npm install依然可以安装该依赖），删除echarts依赖实例代码如下\n\n    `npm uninstall echarts`\n\n2. npm uninstall \"依赖名称\" --save-dev：删除依赖，同时删除package.json中devdependencies的配置,删除echarts依赖实例代码如下\n\n    `npm uninstall echarts  --save-dev`\n\n3. npm uninstall \"依赖名称\" --save：删除依赖，同时删除package.json中dependencies的配置,删除echarts依赖实例代码如下\n\n    `npm uninstall echarts --save`","slug":"package中的devdependencies和dependencies","published":1,"updated":"2024-02-19T07:42:51.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrau003p1xop1vh45469","content":"<h3 id=\"package中的devdependencies和dependencies\"><a href=\"#package中的devdependencies和dependencies\" class=\"headerlink\" title=\"package中的devdependencies和dependencies\"></a>package中的devdependencies和dependencies</h3><h5 id=\"devdependencies和dependencies\"><a href=\"#devdependencies和dependencies\" class=\"headerlink\" title=\"devdependencies和dependencies\"></a>devdependencies和dependencies</h5><p>这两个配置代表的是项目中所需要的相关依赖模块插件，通过键值的方式来定义：</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"webpack-react-express\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"0.2.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"private\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"dependencies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"antd\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^2.13.11\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-polyfill\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.26.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"base-64\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^0.1.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"bluebird\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^3.5.1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"css-loader\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^0.28.7\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"echarts\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^3.7.2\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"devDependencies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"babel-core\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.26.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-loader\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.4.1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-plugin-transform-class-properties\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.24.1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-plugin-transform-runtime\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.23.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-polyfill\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.26.0\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"babel-preset-es2015\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^6.24.1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^1.12.13\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack-hot-middleware\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^2.21.0\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"devDependencies\"><a href=\"#devDependencies\" class=\"headerlink\" title=\"devDependencies\"></a>devDependencies</h5><ol>\n<li><p>内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围</p>\n</li>\n<li><p>作用：该模块中所列举的插件属于开发环境的依赖（比如：测试或者文档框架等）</p>\n</li>\n<li><p>部署来源：通过你npm install进行依赖安装时加上-save-dev，devDependencies对象中便会增加你所需要的插件的安装配置</p>\n<p> <code>npm install name -save-dev</code></p>\n<h5 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h5></li>\n<li><p>内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围</p>\n</li>\n<li><p>作用：该模块中所列举的插件属于生产环境的依赖（程序正常运行需要加载的依赖）</p>\n</li>\n<li><p>部署来源：通过你npm install进行依赖安装时加上-save，dependencies对象中便会增加你所需要的插件的安装配置<br> <code>npm install name -save</code></p>\n</li>\n</ol>\n<h5 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><ol>\n<li><p>如果拿到别人的项目，需要安装之前package.json中devdependencies 和 dependencies两个模块下所列举的依赖，可以通过执行以下命令实现</p>\n<p> <code>npm install</code></p>\n</li>\n<li><p>如果拿到别人的项目，只需要安装之前package.json中dependencies 模块下所列举的依赖，可以通过执行以下命令实现</p>\n<p> <code>npm install packagename</code></p>\n</li>\n<li><p>如果拿到别人的项目，只需要安装之前package.json中devdependencies 模块下所列举的依赖，可以通过执行以下命令实现<br> <code>npm install packagename -dev</code></p>\n<h5 id=\"删除依赖\"><a href=\"#删除依赖\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5></li>\n<li><p>npm uninstall “依赖名称”：删除依赖，但不会删除package.json的配置（即通过npm install依然可以安装该依赖），删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts</code></p>\n</li>\n<li><p>npm uninstall “依赖名称” –save-dev：删除依赖，同时删除package.json中devdependencies的配置,删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts  --save-dev</code></p>\n</li>\n<li><p>npm uninstall “依赖名称” –save：删除依赖，同时删除package.json中dependencies的配置,删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts --save</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"package中的devdependencies和dependencies\"><a href=\"#package中的devdependencies和dependencies\" class=\"headerlink\" title=\"package中的devdependencies和dependencies\"></a>package中的devdependencies和dependencies</h3><h5 id=\"devdependencies和dependencies\"><a href=\"#devdependencies和dependencies\" class=\"headerlink\" title=\"devdependencies和dependencies\"></a>devdependencies和dependencies</h5><p>这两个配置代表的是项目中所需要的相关依赖模块插件，通过键值的方式来定义：</p>\n<pre><code class=\"json\">&quot;name&quot;: &quot;webpack-react-express&quot;,\n  &quot;version&quot;: &quot;0.2.0&quot;,\n  &quot;private&quot;: true,\n  &quot;dependencies&quot;: {\n    &quot;antd&quot;: &quot;^2.13.11&quot;,\n    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,\n    &quot;base-64&quot;: &quot;^0.1.0&quot;,\n    &quot;bluebird&quot;: &quot;^3.5.1&quot;,\n    &quot;css-loader&quot;: &quot;^0.28.7&quot;,\n    &quot;echarts&quot;: &quot;^3.7.2&quot;,\n  },\n  &quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.26.0&quot;,\n    &quot;babel-loader&quot;: &quot;^6.4.1&quot;,\n    &quot;babel-plugin-transform-class-properties&quot;: &quot;^6.24.1&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,\n    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,\n    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,\n    &quot;webpack&quot;: &quot;^1.12.13&quot;,\n    &quot;webpack-hot-middleware&quot;: &quot;^2.21.0&quot;\n  },\n</code></pre>\n<h5 id=\"devDependencies\"><a href=\"#devDependencies\" class=\"headerlink\" title=\"devDependencies\"></a>devDependencies</h5><ol>\n<li><p>内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围</p>\n</li>\n<li><p>作用：该模块中所列举的插件属于开发环境的依赖（比如：测试或者文档框架等）</p>\n</li>\n<li><p>部署来源：通过你npm install进行依赖安装时加上-save-dev，devDependencies对象中便会增加你所需要的插件的安装配置</p>\n<p> <code>npm install name -save-dev</code></p>\n<h5 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h5></li>\n<li><p>内容：是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围</p>\n</li>\n<li><p>作用：该模块中所列举的插件属于生产环境的依赖（程序正常运行需要加载的依赖）</p>\n</li>\n<li><p>部署来源：通过你npm install进行依赖安装时加上-save，dependencies对象中便会增加你所需要的插件的安装配置<br> <code>npm install name -save</code></p>\n</li>\n</ol>\n<h5 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><ol>\n<li><p>如果拿到别人的项目，需要安装之前package.json中devdependencies 和 dependencies两个模块下所列举的依赖，可以通过执行以下命令实现</p>\n<p> <code>npm install</code></p>\n</li>\n<li><p>如果拿到别人的项目，只需要安装之前package.json中dependencies 模块下所列举的依赖，可以通过执行以下命令实现</p>\n<p> <code>npm install packagename</code></p>\n</li>\n<li><p>如果拿到别人的项目，只需要安装之前package.json中devdependencies 模块下所列举的依赖，可以通过执行以下命令实现<br> <code>npm install packagename -dev</code></p>\n<h5 id=\"删除依赖\"><a href=\"#删除依赖\" class=\"headerlink\" title=\"删除依赖\"></a>删除依赖</h5></li>\n<li><p>npm uninstall “依赖名称”：删除依赖，但不会删除package.json的配置（即通过npm install依然可以安装该依赖），删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts</code></p>\n</li>\n<li><p>npm uninstall “依赖名称” –save-dev：删除依赖，同时删除package.json中devdependencies的配置,删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts  --save-dev</code></p>\n</li>\n<li><p>npm uninstall “依赖名称” –save：删除依赖，同时删除package.json中dependencies的配置,删除echarts依赖实例代码如下</p>\n<p> <code>npm uninstall echarts --save</code></p>\n</li>\n</ol>\n"},{"title":"vue-router","date":"2018-10-20T06:41:41.000Z","_content":"\n### Vue-router\n\n##### 路由的定义使用：\n\n**HTML**\n\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n```js\n//非模块化定义\n//1.定义路由组件\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n//2.定义路由\nconst routes=[\n    {\n        path:'/foo',\n        component:Foo\n    },\n    {\n        path:'/bar',\n        component:Bar\n    }\n]\n//3.创建路由实例，将routes配置传入\nconst router=new VueRouter({\n    routes  //相当于routes:routes\n})\n//4.创建和挂载根实例\nconst app =new Vue({\n    router  //相当于router:router\n}).$mount(\"#app\")\n```\n\n```js\n//模块化开发定义方式\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport routes from './routes'\nVue.use(VueRouter)\n//1.创建路由实例，将routes传入\nconst router=new VueRouter({\n    mode:'history',\n    routes\n})\n//文件./routes内容\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\nconst routes=[\n    {\n        path:'/foo',\n        component:Foo\n    },\n    {\n        path:'/bar',\n        component:Bar\n    }\n]\n```\n\n**定义完成后，可以再组件内通过 `this.$router` 访问路由器，也可以通过 `this.$route` 访问当前路由：**\n\n```js\n//Foo.vue\nexport default{\n    methods:{\n        myRouter(){\n            this.$router.push({\n            \tpath:'/', //要跳转的路由位置\n            })\n        }\n    }\n}\n```\n\n##### 动态路由匹配\n\n**路由传参：**\n\n```js\nconst User={\n\ttemplate:'<div>User{{ $route.params.id }}</div>'\n}\nconst router=new VueRouter({\n    routes:[\n        {\n            path:'/user/:id',\n            component:User\n        }\n    ]\n})\n```\n\n*一个路径参数使用“:”标记。当匹配到一个路由时，参数值会被设置到`this.$rote.params`。*\n\n你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 `$route.params` 中。例如：\n\n| 模式                          | 匹配路径            | $route.params                        |\n| ----------------------------- | ------------------- | ------------------------------------ |\n| /user/:username               | /user/evan          | `{ username: 'evan' }`               |\n| /user/:username/post/:post_id | /user/evan/post/123 | `{ username: 'evan', post_id: 123 }` |\n\n除了 `$route.params` 外，`$route` 对象还提供了其它有用的信息，例如，`$route.query` (如果 URL 中有查询参数)、`$route.hash` 等等。你可以查看 [API 文档](https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1) 的详细说明。\n\n**注意：路由跳转时，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则更加高效。这也就意味着，组件的生命周期钩子不会再被调用。**\n\n复用组件时，可以`watch`（监测变化）`$route`对象：\n\n```js\nconst User={\n    template:'...',\n    watch:{\n        '$route' (to,from){\n            //对路由变化做出响应\n        }\n    }\n}\n```\n\n使用`beforeRouteUpdate`导航守卫：\n\n```js\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n\n**匹配优先级**\n\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n\n##### 嵌套路由\n\napp：\n\n```html\n<div id=\"app\">\n    <router-view></router-view>\n</div>\n```\n\n*app这里的`<router-view>`是最顶层的出口。一个被渲染的组件同样可以包含自己嵌套的`<router-view>`。例如在`User`模板中添加`<router-view>`：*\n\n```js\nconst User={\n    template: `\n\t\t<div class=\"user\">\n\t\t\t<h2>User {{$route.params.id}}</h2>\n\t\t\t<router-link to=\"/user/:id/posts\">UserPosts</router-link>\n\t\t\t<router-link to=\"/user/:id/profile\">UserProfile</router-link>\n\t\t\t<router-view></router-view>\n\t\t</div>\n\t`\n};\n//实现嵌套路由的话，需要在配置项中添加children属性。\nconst route=new VueRouter({\n    routes:[\n        {\n            path:'/user/:id',\n            component:User,\n            children:[\n                // 当 /user/:id/profile匹配成功\n                //UserProfile会被渲染在User的<router-view>中\n                {\n                    path:'profile',\n                    component:UserProfile\n                },\n                // 当 /user/:id/posts匹配成功\n                //UserPosts会被渲染在User的<router-view>中\n                {\n                    path:'posts',\n                    component:UserPosts\n                }\n            ]\n        },\n    ]\n});\n\n```\n\n*注意：以`/`开头的匹配，会被当作根路径。`children`的配置类似于routes的配置，可以进行多层嵌套。*\n\n```js\nconst UserProfile={\n    template:`\n\t\t<div class=\"userprofile\">\n\t\t\tuserprofile\n\t\t</div>\n\t`\n};\nconst UserPosts={\n    template:`\n\t\t<div class=\"UserPosts\">\n\t\t\tUserPosts\n\t\t</div>\n\t`\n}\n```\n\n","source":"_posts/vue-router.md","raw":"---\ntitle: vue-router\ndate: 2018-10-20 14:41:41\ntags: Vue\ncategories: 前端\n---\n\n### Vue-router\n\n##### 路由的定义使用：\n\n**HTML**\n\n```html\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n\n```js\n//非模块化定义\n//1.定义路由组件\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n//2.定义路由\nconst routes=[\n    {\n        path:'/foo',\n        component:Foo\n    },\n    {\n        path:'/bar',\n        component:Bar\n    }\n]\n//3.创建路由实例，将routes配置传入\nconst router=new VueRouter({\n    routes  //相当于routes:routes\n})\n//4.创建和挂载根实例\nconst app =new Vue({\n    router  //相当于router:router\n}).$mount(\"#app\")\n```\n\n```js\n//模块化开发定义方式\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport routes from './routes'\nVue.use(VueRouter)\n//1.创建路由实例，将routes传入\nconst router=new VueRouter({\n    mode:'history',\n    routes\n})\n//文件./routes内容\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\nconst routes=[\n    {\n        path:'/foo',\n        component:Foo\n    },\n    {\n        path:'/bar',\n        component:Bar\n    }\n]\n```\n\n**定义完成后，可以再组件内通过 `this.$router` 访问路由器，也可以通过 `this.$route` 访问当前路由：**\n\n```js\n//Foo.vue\nexport default{\n    methods:{\n        myRouter(){\n            this.$router.push({\n            \tpath:'/', //要跳转的路由位置\n            })\n        }\n    }\n}\n```\n\n##### 动态路由匹配\n\n**路由传参：**\n\n```js\nconst User={\n\ttemplate:'<div>User{{ $route.params.id }}</div>'\n}\nconst router=new VueRouter({\n    routes:[\n        {\n            path:'/user/:id',\n            component:User\n        }\n    ]\n})\n```\n\n*一个路径参数使用“:”标记。当匹配到一个路由时，参数值会被设置到`this.$rote.params`。*\n\n你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 `$route.params` 中。例如：\n\n| 模式                          | 匹配路径            | $route.params                        |\n| ----------------------------- | ------------------- | ------------------------------------ |\n| /user/:username               | /user/evan          | `{ username: 'evan' }`               |\n| /user/:username/post/:post_id | /user/evan/post/123 | `{ username: 'evan', post_id: 123 }` |\n\n除了 `$route.params` 外，`$route` 对象还提供了其它有用的信息，例如，`$route.query` (如果 URL 中有查询参数)、`$route.hash` 等等。你可以查看 [API 文档](https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1) 的详细说明。\n\n**注意：路由跳转时，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则更加高效。这也就意味着，组件的生命周期钩子不会再被调用。**\n\n复用组件时，可以`watch`（监测变化）`$route`对象：\n\n```js\nconst User={\n    template:'...',\n    watch:{\n        '$route' (to,from){\n            //对路由变化做出响应\n        }\n    }\n}\n```\n\n使用`beforeRouteUpdate`导航守卫：\n\n```js\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n\n**匹配优先级**\n\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n\n##### 嵌套路由\n\napp：\n\n```html\n<div id=\"app\">\n    <router-view></router-view>\n</div>\n```\n\n*app这里的`<router-view>`是最顶层的出口。一个被渲染的组件同样可以包含自己嵌套的`<router-view>`。例如在`User`模板中添加`<router-view>`：*\n\n```js\nconst User={\n    template: `\n\t\t<div class=\"user\">\n\t\t\t<h2>User {{$route.params.id}}</h2>\n\t\t\t<router-link to=\"/user/:id/posts\">UserPosts</router-link>\n\t\t\t<router-link to=\"/user/:id/profile\">UserProfile</router-link>\n\t\t\t<router-view></router-view>\n\t\t</div>\n\t`\n};\n//实现嵌套路由的话，需要在配置项中添加children属性。\nconst route=new VueRouter({\n    routes:[\n        {\n            path:'/user/:id',\n            component:User,\n            children:[\n                // 当 /user/:id/profile匹配成功\n                //UserProfile会被渲染在User的<router-view>中\n                {\n                    path:'profile',\n                    component:UserProfile\n                },\n                // 当 /user/:id/posts匹配成功\n                //UserPosts会被渲染在User的<router-view>中\n                {\n                    path:'posts',\n                    component:UserPosts\n                }\n            ]\n        },\n    ]\n});\n\n```\n\n*注意：以`/`开头的匹配，会被当作根路径。`children`的配置类似于routes的配置，可以进行多层嵌套。*\n\n```js\nconst UserProfile={\n    template:`\n\t\t<div class=\"userprofile\">\n\t\t\tuserprofile\n\t\t</div>\n\t`\n};\nconst UserPosts={\n    template:`\n\t\t<div class=\"UserPosts\">\n\t\t\tUserPosts\n\t\t</div>\n\t`\n}\n```\n\n","slug":"vue-router","published":1,"updated":"2024-02-19T07:42:51.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrax003t1xoph6y72g2i","content":"<h3 id=\"Vue-router\"><a href=\"#Vue-router\" class=\"headerlink\" title=\"Vue-router\"></a>Vue-router</h3><h5 id=\"路由的定义使用：\"><a href=\"#路由的定义使用：\" class=\"headerlink\" title=\"路由的定义使用：\"></a>路由的定义使用：</h5><p><strong>HTML</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue/dist/vue.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>https://unpkg.com/vue-router/dist/vue-router.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Hello App!<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 使用 router-link 组件来导航. --></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 通过传入 `to` 属性指定链接. --></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/foo<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Go to Foo<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-link</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/bar<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Go to Bar<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-link</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 路由出口 --></span>\n  <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 路由匹配到的组件将渲染在这里 --></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-view</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-view</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//非模块化定义</span>\n<span class=\"token comment\" spellcheck=\"true\">//1.定义路由组件</span>\n<span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>foo&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> Bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>bar&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//2.定义路由</span>\n<span class=\"token keyword\">const</span> routes<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        path<span class=\"token punctuation\">:</span><span class=\"token string\">'/foo'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token punctuation\">:</span>Foo\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n        path<span class=\"token punctuation\">:</span><span class=\"token string\">'/bar'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token punctuation\">:</span>Bar\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n<span class=\"token comment\" spellcheck=\"true\">//3.创建路由实例，将routes配置传入</span>\n<span class=\"token keyword\">const</span> router<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    routes  <span class=\"token comment\" spellcheck=\"true\">//相当于routes:routes</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//4.创建和挂载根实例</span>\n<span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    router  <span class=\"token comment\" spellcheck=\"true\">//相当于router:router</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">$mount</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#app\"</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//模块化开发定义方式</span>\n<span class=\"token comment\" spellcheck=\"true\">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span>\n<span class=\"token keyword\">import</span> Vue <span class=\"token keyword\">from</span> <span class=\"token string\">'vue'</span>\n<span class=\"token keyword\">import</span> VueRouter <span class=\"token keyword\">from</span> <span class=\"token string\">'vue-router'</span>\n<span class=\"token keyword\">import</span> routes <span class=\"token keyword\">from</span> <span class=\"token string\">'./routes'</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>VueRouter<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//1.创建路由实例，将routes传入</span>\n<span class=\"token keyword\">const</span> router<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    mode<span class=\"token punctuation\">:</span><span class=\"token string\">'history'</span><span class=\"token punctuation\">,</span>\n    routes\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//文件./routes内容</span>\n<span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>foo&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> Bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> template<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;div>bar&lt;/div>'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> routes<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n        path<span class=\"token punctuation\">:</span><span class=\"token string\">'/foo'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token punctuation\">:</span>Foo\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span>\n        path<span class=\"token punctuation\">:</span><span class=\"token string\">'/bar'</span><span class=\"token punctuation\">,</span>\n        component<span class=\"token punctuation\">:</span>Bar\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>定义完成后，可以再组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//Foo.vue</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">{</span>\n    methods<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">myRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$router<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n                path<span class=\"token punctuation\">:</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//要跳转的路由位置</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h5><p><strong>路由传参：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> User<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span><span class=\"token string\">'&lt;div>User{{ $route.params.id }}&lt;/div>'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> router<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    routes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n            path<span class=\"token punctuation\">:</span><span class=\"token string\">'/user/:id'</span><span class=\"token punctuation\">,</span>\n            component<span class=\"token punctuation\">:</span>User\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em>一个路径参数使用“:”标记。当匹配到一个路由时，参数值会被设置到<code>this.$rote.params</code>。</em></p>\n<p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td><code>{ username: &#39;evan&#39; }</code></td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td><code>{ username: &#39;evan&#39;, post_id: 123 }</code></td>\n</tr>\n</tbody>\n</table>\n<p>除了 <code>$route.params</code> 外，<code>$route</code> 对象还提供了其它有用的信息，例如，<code>$route.query</code> (如果 URL 中有查询参数)、<code>$route.hash</code> 等等。你可以查看 <a href=\"https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1\" target=\"_blank\" rel=\"noopener\">API 文档</a> 的详细说明。</p>\n<p><strong>注意：路由跳转时，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则更加高效。这也就意味着，组件的生命周期钩子不会再被调用。</strong></p>\n<p>复用组件时，可以<code>watch</code>（监测变化）<code>$route</code>对象：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> User<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span><span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span>\n    watch<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'$route'</span> <span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//对路由变化做出响应</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用<code>beforeRouteUpdate</code>导航守卫：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> User <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">,</span>\n  beforeRouteUpdate <span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">,</span> <span class=\"token keyword\">from</span><span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// react to route changes...</span>\n    <span class=\"token comment\" spellcheck=\"true\">// don't forget to call next()</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>匹配优先级</strong></p>\n<p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h5 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h5><p>app：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>router-view</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>router-view</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><em>app这里的<code>&lt;router-view&gt;</code>是最顶层的出口。一个被渲染的组件同样可以包含自己嵌套的<code>&lt;router-view&gt;</code>。例如在<code>User</code>模板中添加<code>&lt;router-view&gt;</code>：</em></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> User<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token string\">`\n        &lt;div class=\"user\">\n            &lt;h2>User {{$route.params.id}}&lt;/h2>\n            &lt;router-link to=\"/user/:id/posts\">UserPosts&lt;/router-link>\n            &lt;router-link to=\"/user/:id/profile\">UserProfile&lt;/router-link>\n            &lt;router-view>&lt;/router-view>\n        &lt;/div>\n    `</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//实现嵌套路由的话，需要在配置项中添加children属性。</span>\n<span class=\"token keyword\">const</span> route<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">VueRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    routes<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span>\n            path<span class=\"token punctuation\">:</span><span class=\"token string\">'/user/:id'</span><span class=\"token punctuation\">,</span>\n            component<span class=\"token punctuation\">:</span>User<span class=\"token punctuation\">,</span>\n            children<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 当 /user/:id/profile匹配成功</span>\n                <span class=\"token comment\" spellcheck=\"true\">//UserProfile会被渲染在User的&lt;router-view>中</span>\n                <span class=\"token punctuation\">{</span>\n                    path<span class=\"token punctuation\">:</span><span class=\"token string\">'profile'</span><span class=\"token punctuation\">,</span>\n                    component<span class=\"token punctuation\">:</span>UserProfile\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 当 /user/:id/posts匹配成功</span>\n                <span class=\"token comment\" spellcheck=\"true\">//UserPosts会被渲染在User的&lt;router-view>中</span>\n                <span class=\"token punctuation\">{</span>\n                    path<span class=\"token punctuation\">:</span><span class=\"token string\">'posts'</span><span class=\"token punctuation\">,</span>\n                    component<span class=\"token punctuation\">:</span>UserPosts\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em>注意：以<code>/</code>开头的匹配，会被当作根路径。<code>children</code>的配置类似于routes的配置，可以进行多层嵌套。</em></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> UserProfile<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span><span class=\"token template-string\"><span class=\"token string\">`\n        &lt;div class=\"userprofile\">\n            userprofile\n        &lt;/div>\n    `</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> UserPosts<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span><span class=\"token template-string\"><span class=\"token string\">`\n        &lt;div class=\"UserPosts\">\n            UserPosts\n        &lt;/div>\n    `</span></span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Vue-router\"><a href=\"#Vue-router\" class=\"headerlink\" title=\"Vue-router\"></a>Vue-router</h3><h5 id=\"路由的定义使用：\"><a href=\"#路由的定义使用：\" class=\"headerlink\" title=\"路由的定义使用：\"></a>路由的定义使用：</h5><p><strong>HTML</strong></p>\n<pre><code class=\"html\">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;\n\n&lt;div id=&quot;app&quot;&gt;\n  &lt;h1&gt;Hello App!&lt;/h1&gt;\n  &lt;p&gt;\n    &lt;!-- 使用 router-link 组件来导航. --&gt;\n    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;\n    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;\n    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;\n    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;\n  &lt;/p&gt;\n  &lt;!-- 路由出口 --&gt;\n  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">//非模块化定义\n//1.定义路由组件\nconst Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }\nconst Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }\n//2.定义路由\nconst routes=[\n    {\n        path:&#39;/foo&#39;,\n        component:Foo\n    },\n    {\n        path:&#39;/bar&#39;,\n        component:Bar\n    }\n]\n//3.创建路由实例，将routes配置传入\nconst router=new VueRouter({\n    routes  //相当于routes:routes\n})\n//4.创建和挂载根实例\nconst app =new Vue({\n    router  //相当于router:router\n}).$mount(&quot;#app&quot;)\n</code></pre>\n<pre><code class=\"js\">//模块化开发定义方式\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\nimport Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\nimport routes from &#39;./routes&#39;\nVue.use(VueRouter)\n//1.创建路由实例，将routes传入\nconst router=new VueRouter({\n    mode:&#39;history&#39;,\n    routes\n})\n//文件./routes内容\nconst Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }\nconst Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }\nconst routes=[\n    {\n        path:&#39;/foo&#39;,\n        component:Foo\n    },\n    {\n        path:&#39;/bar&#39;,\n        component:Bar\n    }\n]\n</code></pre>\n<p><strong>定义完成后，可以再组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由：</strong></p>\n<pre><code class=\"js\">//Foo.vue\nexport default{\n    methods:{\n        myRouter(){\n            this.$router.push({\n                path:&#39;/&#39;, //要跳转的路由位置\n            })\n        }\n    }\n}\n</code></pre>\n<h5 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h5><p><strong>路由传参：</strong></p>\n<pre><code class=\"js\">const User={\n    template:&#39;&lt;div&gt;User{{ $route.params.id }}&lt;/div&gt;&#39;\n}\nconst router=new VueRouter({\n    routes:[\n        {\n            path:&#39;/user/:id&#39;,\n            component:User\n        }\n    ]\n})\n</code></pre>\n<p><em>一个路径参数使用“:”标记。当匹配到一个路由时，参数值会被设置到<code>this.$rote.params</code>。</em></p>\n<p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td><code>{ username: &#39;evan&#39; }</code></td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td><code>{ username: &#39;evan&#39;, post_id: 123 }</code></td>\n</tr>\n</tbody>\n</table>\n<p>除了 <code>$route.params</code> 外，<code>$route</code> 对象还提供了其它有用的信息，例如，<code>$route.query</code> (如果 URL 中有查询参数)、<code>$route.hash</code> 等等。你可以查看 <a href=\"https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1\" target=\"_blank\" rel=\"noopener\">API 文档</a> 的详细说明。</p>\n<p><strong>注意：路由跳转时，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则更加高效。这也就意味着，组件的生命周期钩子不会再被调用。</strong></p>\n<p>复用组件时，可以<code>watch</code>（监测变化）<code>$route</code>对象：</p>\n<pre><code class=\"js\">const User={\n    template:&#39;...&#39;,\n    watch:{\n        &#39;$route&#39; (to,from){\n            //对路由变化做出响应\n        }\n    }\n}\n</code></pre>\n<p>使用<code>beforeRouteUpdate</code>导航守卫：</p>\n<pre><code class=\"js\">const User = {\n  template: &#39;...&#39;,\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don&#39;t forget to call next()\n  }\n}\n</code></pre>\n<p><strong>匹配优先级</strong></p>\n<p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h5 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h5><p>app：</p>\n<pre><code class=\"html\">&lt;div id=&quot;app&quot;&gt;\n    &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n</code></pre>\n<p><em>app这里的<code>&lt;router-view&gt;</code>是最顶层的出口。一个被渲染的组件同样可以包含自己嵌套的<code>&lt;router-view&gt;</code>。例如在<code>User</code>模板中添加<code>&lt;router-view&gt;</code>：</em></p>\n<pre><code class=\"js\">const User={\n    template: `\n        &lt;div class=&quot;user&quot;&gt;\n            &lt;h2&gt;User {{$route.params.id}}&lt;/h2&gt;\n            &lt;router-link to=&quot;/user/:id/posts&quot;&gt;UserPosts&lt;/router-link&gt;\n            &lt;router-link to=&quot;/user/:id/profile&quot;&gt;UserProfile&lt;/router-link&gt;\n            &lt;router-view&gt;&lt;/router-view&gt;\n        &lt;/div&gt;\n    `\n};\n//实现嵌套路由的话，需要在配置项中添加children属性。\nconst route=new VueRouter({\n    routes:[\n        {\n            path:&#39;/user/:id&#39;,\n            component:User,\n            children:[\n                // 当 /user/:id/profile匹配成功\n                //UserProfile会被渲染在User的&lt;router-view&gt;中\n                {\n                    path:&#39;profile&#39;,\n                    component:UserProfile\n                },\n                // 当 /user/:id/posts匹配成功\n                //UserPosts会被渲染在User的&lt;router-view&gt;中\n                {\n                    path:&#39;posts&#39;,\n                    component:UserPosts\n                }\n            ]\n        },\n    ]\n});\n\n</code></pre>\n<p><em>注意：以<code>/</code>开头的匹配，会被当作根路径。<code>children</code>的配置类似于routes的配置，可以进行多层嵌套。</em></p>\n<pre><code class=\"js\">const UserProfile={\n    template:`\n        &lt;div class=&quot;userprofile&quot;&gt;\n            userprofile\n        &lt;/div&gt;\n    `\n};\nconst UserPosts={\n    template:`\n        &lt;div class=&quot;UserPosts&quot;&gt;\n            UserPosts\n        &lt;/div&gt;\n    `\n}\n</code></pre>\n"},{"title":"snabbdom源码笔记","date":"2020-07-30T02:40:35.000Z","_content":"\n### Snabbdom源码笔记\n\n- ##### **创建项目**\n\n  ```bash\n  # 创建项目目录\n  mkdir snabbdom-demo\n  # 进入项目\n  cd snabbdom-demo\n  # 创建 package.json\n  npm init -y\n  # 本地安装 parcel\n  npm add parcel-bundler\n  # 安装snabbdom\n  npm i snabbdom\n  ```\n\n- ##### **配置package.json**\n\n  ```js\n  \"script\": {\n    \"dev\": \"parcel index.html --open\",\n    \"build\": \"parcel build index.html\"\n  }\n  ```\n\n- ##### **创建目录结构**\n\n  ```\n  | index.html\n  | package.json\n  |-src\n  \t\t\t\tdemo.js\n  ```\n\n- ##### **demo.js**\n\n  ```js\n  import { h, init } from 'snabbdom'\n  // 导入模块\n  import style from 'snabbdom/modules/style'\n  import eventlisteners from 'snabbdom/modules/eventlisteners'\n  \n  let patch = init([style, eventlisteners])\n  let vNode = h('div#container', {\n      style: {\n          backgroundColor: 'red',\n      },\n      on: {\n          click: () => {\n              console.log('hello word')\n          }\n      },\n      hook: {\n          init(vNode) {\n              console.log(vNode)\n          },\n          create(emptyVnode, vNode) {\n              console.log(emptyVnode)\n          }\n      }\n  }, [\n      h('h1', 'Hello World'),\n      h('p', 'p 标签')\n  ])\n  let app = document.querySelector('#app')\n  patch(app, vNode)\n  ```\n\n- ##### **init函数源码分析**\n\n  - init函数接收一个modules的数组参数和用户自定义的domApi（可选）\n\n    ```ts\n    export function init (modules: Array<Partial<Module>>, domApi?: DOMAPI) {\n      // ***\n    }\n    ```\n\n  - 初始化cbs（存储回调钩子函数）\n\n    ```ts\n    const hooks: Array<keyof Module> = ['create', 'update', 'remove', 'destroy', 'pre', 'post']\n    \n    const cbs: ModuleHooks = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    }\n    \n    // 初始化所有的钩子函数结构\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = []\n      // 将传入模块的钩子函数添加到cbs对应的钩子函数结构中\n        for (j = 0; j < modules.length; ++j) {\n          const hook = modules[j][hooks[i]]\n          if (hook !== undefined) {\n            (cbs[hooks[i]] as any[]).push(hook)\n          }\n        }\n     }\n    ```\n\n  - 判断domapi\n\n    ```ts\n    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi\n    ```\n\n  - 返回patch函数\n\n    ```js\n    return function patch (oldVnode: VNode | Element, vnode: VNode): VNode {\n      // ****\n    }\n    ```\n\n    ","source":"_posts/snabbdom源码笔记.md","raw":"---\ntitle: snabbdom源码笔记\ndate: 2020-07-30 10:40:35\ntags: Vue\ncategories: 前端\n---\n\n### Snabbdom源码笔记\n\n- ##### **创建项目**\n\n  ```bash\n  # 创建项目目录\n  mkdir snabbdom-demo\n  # 进入项目\n  cd snabbdom-demo\n  # 创建 package.json\n  npm init -y\n  # 本地安装 parcel\n  npm add parcel-bundler\n  # 安装snabbdom\n  npm i snabbdom\n  ```\n\n- ##### **配置package.json**\n\n  ```js\n  \"script\": {\n    \"dev\": \"parcel index.html --open\",\n    \"build\": \"parcel build index.html\"\n  }\n  ```\n\n- ##### **创建目录结构**\n\n  ```\n  | index.html\n  | package.json\n  |-src\n  \t\t\t\tdemo.js\n  ```\n\n- ##### **demo.js**\n\n  ```js\n  import { h, init } from 'snabbdom'\n  // 导入模块\n  import style from 'snabbdom/modules/style'\n  import eventlisteners from 'snabbdom/modules/eventlisteners'\n  \n  let patch = init([style, eventlisteners])\n  let vNode = h('div#container', {\n      style: {\n          backgroundColor: 'red',\n      },\n      on: {\n          click: () => {\n              console.log('hello word')\n          }\n      },\n      hook: {\n          init(vNode) {\n              console.log(vNode)\n          },\n          create(emptyVnode, vNode) {\n              console.log(emptyVnode)\n          }\n      }\n  }, [\n      h('h1', 'Hello World'),\n      h('p', 'p 标签')\n  ])\n  let app = document.querySelector('#app')\n  patch(app, vNode)\n  ```\n\n- ##### **init函数源码分析**\n\n  - init函数接收一个modules的数组参数和用户自定义的domApi（可选）\n\n    ```ts\n    export function init (modules: Array<Partial<Module>>, domApi?: DOMAPI) {\n      // ***\n    }\n    ```\n\n  - 初始化cbs（存储回调钩子函数）\n\n    ```ts\n    const hooks: Array<keyof Module> = ['create', 'update', 'remove', 'destroy', 'pre', 'post']\n    \n    const cbs: ModuleHooks = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    }\n    \n    // 初始化所有的钩子函数结构\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = []\n      // 将传入模块的钩子函数添加到cbs对应的钩子函数结构中\n        for (j = 0; j < modules.length; ++j) {\n          const hook = modules[j][hooks[i]]\n          if (hook !== undefined) {\n            (cbs[hooks[i]] as any[]).push(hook)\n          }\n        }\n     }\n    ```\n\n  - 判断domapi\n\n    ```ts\n    const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi\n    ```\n\n  - 返回patch函数\n\n    ```js\n    return function patch (oldVnode: VNode | Element, vnode: VNode): VNode {\n      // ****\n    }\n    ```\n\n    ","slug":"snabbdom源码笔记","published":1,"updated":"2024-02-19T07:42:51.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb0003w1xop9e400u15","content":"<h3 id=\"Snabbdom源码笔记\"><a href=\"#Snabbdom源码笔记\" class=\"headerlink\" title=\"Snabbdom源码笔记\"></a>Snabbdom源码笔记</h3><ul>\n<li><h5 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a><strong>创建项目</strong></h5><pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\"># 创建项目目录</span>\n<span class=\"token function\">mkdir</span> snabbdom-demo\n<span class=\"token comment\" spellcheck=\"true\"># 进入项目</span>\n<span class=\"token function\">cd</span> snabbdom-demo\n<span class=\"token comment\" spellcheck=\"true\"># 创建 package.json</span>\n<span class=\"token function\">npm</span> init -y\n<span class=\"token comment\" spellcheck=\"true\"># 本地安装 parcel</span>\n<span class=\"token function\">npm</span> add parcel-bundler\n<span class=\"token comment\" spellcheck=\"true\"># 安装snabbdom</span>\n<span class=\"token function\">npm</span> i snabbdom\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><h5 id=\"配置package-json\"><a href=\"#配置package-json\" class=\"headerlink\" title=\"配置package.json\"></a><strong>配置package.json</strong></h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">\"dev\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"parcel index.html --open\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string\">\"build\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"parcel build index.html\"</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><h5 id=\"创建目录结构\"><a href=\"#创建目录结构\" class=\"headerlink\" title=\"创建目录结构\"></a><strong>创建目录结构</strong></h5><pre><code>| index.html\n| package.json\n|-src\n                demo.js\n</code></pre></li>\n<li><h5 id=\"demo-js\"><a href=\"#demo-js\" class=\"headerlink\" title=\"demo.js\"></a><strong>demo.js</strong></h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> h<span class=\"token punctuation\">,</span> init <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'snabbdom'</span>\n<span class=\"token comment\" spellcheck=\"true\">// 导入模块</span>\n<span class=\"token keyword\">import</span> style <span class=\"token keyword\">from</span> <span class=\"token string\">'snabbdom/modules/style'</span>\n<span class=\"token keyword\">import</span> eventlisteners <span class=\"token keyword\">from</span> <span class=\"token string\">'snabbdom/modules/eventlisteners'</span>\n\n<span class=\"token keyword\">let</span> patch <span class=\"token operator\">=</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>style<span class=\"token punctuation\">,</span> eventlisteners<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> vNode <span class=\"token operator\">=</span> <span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token string\">'div#container'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    style<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        backgroundColor<span class=\"token punctuation\">:</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    on<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        click<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello word'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    hook<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>vNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>vNode<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>emptyVnode<span class=\"token punctuation\">,</span> vNode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>emptyVnode<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'p 标签'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> app <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#app'</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">patch</span><span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">,</span> vNode<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><h5 id=\"init函数源码分析\"><a href=\"#init函数源码分析\" class=\"headerlink\" title=\"init函数源码分析\"></a><strong>init函数源码分析</strong></h5><ul>\n<li><p>init函数接收一个modules的数组参数和用户自定义的domApi（可选）</p>\n<pre class=\"line-numbers language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> init <span class=\"token punctuation\">(</span>modules<span class=\"token punctuation\">:</span> <span class=\"token keyword\">Array</span><span class=\"token operator\">&lt;</span>Partial<span class=\"token operator\">&lt;</span>Module<span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> domApi<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> DOMAPI<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ***</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>初始化cbs（存储回调钩子函数）</p>\n<pre class=\"line-numbers language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> hooks<span class=\"token punctuation\">:</span> <span class=\"token keyword\">Array</span><span class=\"token operator\">&lt;</span>keyof Module<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'create'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'update'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'remove'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'destroy'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pre'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'post'</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">const</span> cbs<span class=\"token punctuation\">:</span> ModuleHooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    create<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    update<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    remove<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    destroy<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    pre<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    post<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 初始化所有的钩子函数结构</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> hooks<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cbs<span class=\"token punctuation\">[</span>hooks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 将传入模块的钩子函数添加到cbs对应的钩子函数结构中</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> modules<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> modules<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>hooks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hook <span class=\"token operator\">!==</span> undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span>cbs<span class=\"token punctuation\">[</span>hooks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> as <span class=\"token keyword\">any</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>判断domapi</p>\n<pre class=\"line-numbers language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> api<span class=\"token punctuation\">:</span> DOMAPI <span class=\"token operator\">=</span> domApi <span class=\"token operator\">!==</span> undefined <span class=\"token operator\">?</span> domApi <span class=\"token punctuation\">:</span> htmlDomApi\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>返回patch函数</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> patch <span class=\"token punctuation\">(</span>oldVnode<span class=\"token punctuation\">:</span> VNode <span class=\"token operator\">|</span> Element<span class=\"token punctuation\">,</span> vnode<span class=\"token punctuation\">:</span> VNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> VNode <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// ****</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Snabbdom源码笔记\"><a href=\"#Snabbdom源码笔记\" class=\"headerlink\" title=\"Snabbdom源码笔记\"></a>Snabbdom源码笔记</h3><ul>\n<li><h5 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a><strong>创建项目</strong></h5><pre><code class=\"bash\"># 创建项目目录\nmkdir snabbdom-demo\n# 进入项目\ncd snabbdom-demo\n# 创建 package.json\nnpm init -y\n# 本地安装 parcel\nnpm add parcel-bundler\n# 安装snabbdom\nnpm i snabbdom\n</code></pre>\n</li>\n<li><h5 id=\"配置package-json\"><a href=\"#配置package-json\" class=\"headerlink\" title=\"配置package.json\"></a><strong>配置package.json</strong></h5><pre><code class=\"js\">&quot;script&quot;: {\n  &quot;dev&quot;: &quot;parcel index.html --open&quot;,\n  &quot;build&quot;: &quot;parcel build index.html&quot;\n}\n</code></pre>\n</li>\n<li><h5 id=\"创建目录结构\"><a href=\"#创建目录结构\" class=\"headerlink\" title=\"创建目录结构\"></a><strong>创建目录结构</strong></h5><pre><code>| index.html\n| package.json\n|-src\n                demo.js\n</code></pre></li>\n<li><h5 id=\"demo-js\"><a href=\"#demo-js\" class=\"headerlink\" title=\"demo.js\"></a><strong>demo.js</strong></h5><pre><code class=\"js\">import { h, init } from &#39;snabbdom&#39;\n// 导入模块\nimport style from &#39;snabbdom/modules/style&#39;\nimport eventlisteners from &#39;snabbdom/modules/eventlisteners&#39;\n\nlet patch = init([style, eventlisteners])\nlet vNode = h(&#39;div#container&#39;, {\n    style: {\n        backgroundColor: &#39;red&#39;,\n    },\n    on: {\n        click: () =&gt; {\n            console.log(&#39;hello word&#39;)\n        }\n    },\n    hook: {\n        init(vNode) {\n            console.log(vNode)\n        },\n        create(emptyVnode, vNode) {\n            console.log(emptyVnode)\n        }\n    }\n}, [\n    h(&#39;h1&#39;, &#39;Hello World&#39;),\n    h(&#39;p&#39;, &#39;p 标签&#39;)\n])\nlet app = document.querySelector(&#39;#app&#39;)\npatch(app, vNode)\n</code></pre>\n</li>\n<li><h5 id=\"init函数源码分析\"><a href=\"#init函数源码分析\" class=\"headerlink\" title=\"init函数源码分析\"></a><strong>init函数源码分析</strong></h5><ul>\n<li><p>init函数接收一个modules的数组参数和用户自定义的domApi（可选）</p>\n<pre><code class=\"ts\">export function init (modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) {\n  // ***\n}\n</code></pre>\n</li>\n<li><p>初始化cbs（存储回调钩子函数）</p>\n<pre><code class=\"ts\">const hooks: Array&lt;keyof Module&gt; = [&#39;create&#39;, &#39;update&#39;, &#39;remove&#39;, &#39;destroy&#39;, &#39;pre&#39;, &#39;post&#39;]\n\nconst cbs: ModuleHooks = {\n    create: [],\n    update: [],\n    remove: [],\n    destroy: [],\n    pre: [],\n    post: []\n}\n\n// 初始化所有的钩子函数结构\nfor (i = 0; i &lt; hooks.length; ++i) {\n    cbs[hooks[i]] = []\n  // 将传入模块的钩子函数添加到cbs对应的钩子函数结构中\n    for (j = 0; j &lt; modules.length; ++j) {\n      const hook = modules[j][hooks[i]]\n      if (hook !== undefined) {\n        (cbs[hooks[i]] as any[]).push(hook)\n      }\n    }\n }\n</code></pre>\n</li>\n<li><p>判断domapi</p>\n<pre><code class=\"ts\">const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi\n</code></pre>\n</li>\n<li><p>返回patch函数</p>\n<pre><code class=\"js\">return function patch (oldVnode: VNode | Element, vnode: VNode): VNode {\n  // ****\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"redux","date":"2018-11-22T09:14:55.000Z","_content":"\n### redux\n\n##### 使用方式：\n\n安装：`npm install redux react-redux --save`\n\n1. 首先需要引入\n\n   ```jsx\n   import {createStore} from 'redux';\n   import {Provider} from 'react-redux';\n   ```\n\n2. 创建`action`\n\n   ```jsx\n   const changeColor=(state,action)=>{\n       if(!state) return{\n           themeColor:'red'\n       }\n       switch(action.type){\n           case 'CHANGE_COLOR':\n               return {...state,themeColor:action.themeColor}\n           default:\n               return state\n       }\n   }\n   ```\n\n3. 创建生成`store`\n\n   ```jsx\n   const store=createStore(changeColor);\n   ```\n\n4. 使用`Provider`组件作为根组件将`store`作为`props`传入\n\n   ```jsx\n   <Provider store={store}>\n   \t<Index/>\n       <Header/>\n       <Content/>\n       <Footer/>\n   </Provider>\n   ```\n\n5. 子组件使用\n\n   ```jsx\n   import PropTypes from 'prop-types';\n   import {connect} from 'react-redux';\n   class Header extends React.Component{\n       state contentType={  //必须添加类型验证才能拿到state数据\n           store:PropTypes.object\n       }\n       ...\n       //子组件使用数据，this.props.themeColor\n   }\n   const mapStateTopProps=(state)=>{ //通过connect高阶组件将themeColor属性添加进去<Header themeColor={state.themeColor}></Header>\n       return {\n           themeColor:state.themeColor\n       }\n   }\n   const mapDispatchToProps=(dispatch)=>{ //通过connect高阶组件将onSwitchColor属性方法添加进去<Header onSwitchColor={(color)=>{dispatch({type:'CHANGE_COLOR',themeColor:color})}}\n       return {\n           onSwitchColor:(color)=>{\n               dispatch({type:'CHANGE_COLOR',themeColor:color})\n           }\n       }\n   }\n   Header=connect(mapStateTopProps,mapDispatchToProps)(Header);\n   export default Header\n   ```\n\n\n**`createStore`的原理类似这样：**\n\n```jsx\nfunction createStore (reducer) {\n  let state = null\n  const listeners = []\n  const subscribe = (listener) => listeners.push(listener)\n  const getState = () => state\n  const dispatch = (action) => {\n    state = reducer(state, action)\n    listeners.forEach((listener) => listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\n```\n\n1. `dispatch`：分发`action`\n2. `subscribe`：注册`listener`，监听`state`变化\n3. `getState`：读取`store tree`中所有`state`\n4. `replaceReucer`：替换`reducer`，改变`state`更新逻辑\n5. `reducer`就是类似上边`action`步骤的`changeColor`\n\n##### Redux基本原理图：\n\n![](redux/417252aa40fd5841805aee7017fc73cd.png)","source":"_posts/redux.md","raw":"---\ntitle: redux\ndate: 2018-11-22 17:14:55\ntags: react\ncategories: 前端\n---\n\n### redux\n\n##### 使用方式：\n\n安装：`npm install redux react-redux --save`\n\n1. 首先需要引入\n\n   ```jsx\n   import {createStore} from 'redux';\n   import {Provider} from 'react-redux';\n   ```\n\n2. 创建`action`\n\n   ```jsx\n   const changeColor=(state,action)=>{\n       if(!state) return{\n           themeColor:'red'\n       }\n       switch(action.type){\n           case 'CHANGE_COLOR':\n               return {...state,themeColor:action.themeColor}\n           default:\n               return state\n       }\n   }\n   ```\n\n3. 创建生成`store`\n\n   ```jsx\n   const store=createStore(changeColor);\n   ```\n\n4. 使用`Provider`组件作为根组件将`store`作为`props`传入\n\n   ```jsx\n   <Provider store={store}>\n   \t<Index/>\n       <Header/>\n       <Content/>\n       <Footer/>\n   </Provider>\n   ```\n\n5. 子组件使用\n\n   ```jsx\n   import PropTypes from 'prop-types';\n   import {connect} from 'react-redux';\n   class Header extends React.Component{\n       state contentType={  //必须添加类型验证才能拿到state数据\n           store:PropTypes.object\n       }\n       ...\n       //子组件使用数据，this.props.themeColor\n   }\n   const mapStateTopProps=(state)=>{ //通过connect高阶组件将themeColor属性添加进去<Header themeColor={state.themeColor}></Header>\n       return {\n           themeColor:state.themeColor\n       }\n   }\n   const mapDispatchToProps=(dispatch)=>{ //通过connect高阶组件将onSwitchColor属性方法添加进去<Header onSwitchColor={(color)=>{dispatch({type:'CHANGE_COLOR',themeColor:color})}}\n       return {\n           onSwitchColor:(color)=>{\n               dispatch({type:'CHANGE_COLOR',themeColor:color})\n           }\n       }\n   }\n   Header=connect(mapStateTopProps,mapDispatchToProps)(Header);\n   export default Header\n   ```\n\n\n**`createStore`的原理类似这样：**\n\n```jsx\nfunction createStore (reducer) {\n  let state = null\n  const listeners = []\n  const subscribe = (listener) => listeners.push(listener)\n  const getState = () => state\n  const dispatch = (action) => {\n    state = reducer(state, action)\n    listeners.forEach((listener) => listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\n```\n\n1. `dispatch`：分发`action`\n2. `subscribe`：注册`listener`，监听`state`变化\n3. `getState`：读取`store tree`中所有`state`\n4. `replaceReucer`：替换`reducer`，改变`state`更新逻辑\n5. `reducer`就是类似上边`action`步骤的`changeColor`\n\n##### Redux基本原理图：\n\n![](redux/417252aa40fd5841805aee7017fc73cd.png)","slug":"redux","published":1,"updated":"2024-02-19T07:42:51.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb000401xop885zdjyr","content":"<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><h5 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h5><p>安装：<code>npm install redux react-redux --save</code></p>\n<ol>\n<li><p>首先需要引入</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>createStore<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'redux'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>Provider<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-redux'</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建<code>action</code></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> changeColor<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span>action<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>state<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">{</span>\n        themeColor<span class=\"token punctuation\">:</span><span class=\"token string\">'red'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">'CHANGE_COLOR'</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>state<span class=\"token punctuation\">,</span>themeColor<span class=\"token punctuation\">:</span>action<span class=\"token punctuation\">.</span>themeColor<span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> state\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>创建生成<code>store</code></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> store<span class=\"token operator\">=</span><span class=\"token function\">createStore</span><span class=\"token punctuation\">(</span>changeColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>使用<code>Provider</code>组件作为根组件将<code>store</code>作为<code>props</code>传入</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Provider</span> <span class=\"token attr-name\">store</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>store<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Index</span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Header</span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Content</span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Footer</span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Provider</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>子组件使用</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> PropTypes <span class=\"token keyword\">from</span> <span class=\"token string\">'prop-types'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>connect<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-redux'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Header</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>\n    state contentType<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//必须添加类型验证才能拿到state数据</span>\n        store<span class=\"token punctuation\">:</span>PropTypes<span class=\"token punctuation\">.</span>object\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token comment\" spellcheck=\"true\">//子组件使用数据，this.props.themeColor</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> mapStateTopProps<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//通过connect高阶组件将themeColor属性添加进去&lt;Header themeColor={state.themeColor}>&lt;/Header></span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        themeColor<span class=\"token punctuation\">:</span>state<span class=\"token punctuation\">.</span>themeColor\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> mapDispatchToProps<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>dispatch<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//通过connect高阶组件将onSwitchColor属性方法添加进去&lt;Header onSwitchColor={(color)=>{dispatch({type:'CHANGE_COLOR',themeColor:color})}}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        onSwitchColor<span class=\"token punctuation\">:</span><span class=\"token punctuation\">(</span>color<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n            <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>type<span class=\"token punctuation\">:</span><span class=\"token string\">'CHANGE_COLOR'</span><span class=\"token punctuation\">,</span>themeColor<span class=\"token punctuation\">:</span>color<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nHeader<span class=\"token operator\">=</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span>mapStateTopProps<span class=\"token punctuation\">,</span>mapDispatchToProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>Header<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Header\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p><strong><code>createStore</code>的原理类似这样：</strong></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> createStore <span class=\"token punctuation\">(</span>reducer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> state <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">const</span> listeners <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">const</span> subscribe <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> listeners<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">const</span> getState <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> state\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    state <span class=\"token operator\">=</span> <span class=\"token function\">reducer</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> action<span class=\"token punctuation\">)</span>\n    listeners<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">listener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">dispatch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化 state</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> getState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">,</span> subscribe <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol>\n<li><code>dispatch</code>：分发<code>action</code></li>\n<li><code>subscribe</code>：注册<code>listener</code>，监听<code>state</code>变化</li>\n<li><code>getState</code>：读取<code>store tree</code>中所有<code>state</code></li>\n<li><code>replaceReucer</code>：替换<code>reducer</code>，改变<code>state</code>更新逻辑</li>\n<li><code>reducer</code>就是类似上边<code>action</code>步骤的<code>changeColor</code></li>\n</ol>\n<h5 id=\"Redux基本原理图：\"><a href=\"#Redux基本原理图：\" class=\"headerlink\" title=\"Redux基本原理图：\"></a>Redux基本原理图：</h5><p><img src=\"/2018/11/22/redux/417252aa40fd5841805aee7017fc73cd.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><h5 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h5><p>安装：<code>npm install redux react-redux --save</code></p>\n<ol>\n<li><p>首先需要引入</p>\n<pre><code class=\"jsx\">import {createStore} from &#39;redux&#39;;\nimport {Provider} from &#39;react-redux&#39;;\n</code></pre>\n</li>\n<li><p>创建<code>action</code></p>\n<pre><code class=\"jsx\">const changeColor=(state,action)=&gt;{\n    if(!state) return{\n        themeColor:&#39;red&#39;\n    }\n    switch(action.type){\n        case &#39;CHANGE_COLOR&#39;:\n            return {...state,themeColor:action.themeColor}\n        default:\n            return state\n    }\n}\n</code></pre>\n</li>\n<li><p>创建生成<code>store</code></p>\n<pre><code class=\"jsx\">const store=createStore(changeColor);\n</code></pre>\n</li>\n<li><p>使用<code>Provider</code>组件作为根组件将<code>store</code>作为<code>props</code>传入</p>\n<pre><code class=\"jsx\">&lt;Provider store={store}&gt;\n    &lt;Index/&gt;\n    &lt;Header/&gt;\n    &lt;Content/&gt;\n    &lt;Footer/&gt;\n&lt;/Provider&gt;\n</code></pre>\n</li>\n<li><p>子组件使用</p>\n<pre><code class=\"jsx\">import PropTypes from &#39;prop-types&#39;;\nimport {connect} from &#39;react-redux&#39;;\nclass Header extends React.Component{\n    state contentType={  //必须添加类型验证才能拿到state数据\n        store:PropTypes.object\n    }\n    ...\n    //子组件使用数据，this.props.themeColor\n}\nconst mapStateTopProps=(state)=&gt;{ //通过connect高阶组件将themeColor属性添加进去&lt;Header themeColor={state.themeColor}&gt;&lt;/Header&gt;\n    return {\n        themeColor:state.themeColor\n    }\n}\nconst mapDispatchToProps=(dispatch)=&gt;{ //通过connect高阶组件将onSwitchColor属性方法添加进去&lt;Header onSwitchColor={(color)=&gt;{dispatch({type:&#39;CHANGE_COLOR&#39;,themeColor:color})}}\n    return {\n        onSwitchColor:(color)=&gt;{\n            dispatch({type:&#39;CHANGE_COLOR&#39;,themeColor:color})\n        }\n    }\n}\nHeader=connect(mapStateTopProps,mapDispatchToProps)(Header);\nexport default Header\n</code></pre>\n</li>\n</ol>\n<p><strong><code>createStore</code>的原理类似这样：</strong></p>\n<pre><code class=\"jsx\">function createStore (reducer) {\n  let state = null\n  const listeners = []\n  const subscribe = (listener) =&gt; listeners.push(listener)\n  const getState = () =&gt; state\n  const dispatch = (action) =&gt; {\n    state = reducer(state, action)\n    listeners.forEach((listener) =&gt; listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\n</code></pre>\n<ol>\n<li><code>dispatch</code>：分发<code>action</code></li>\n<li><code>subscribe</code>：注册<code>listener</code>，监听<code>state</code>变化</li>\n<li><code>getState</code>：读取<code>store tree</code>中所有<code>state</code></li>\n<li><code>replaceReucer</code>：替换<code>reducer</code>，改变<code>state</code>更新逻辑</li>\n<li><code>reducer</code>就是类似上边<code>action</code>步骤的<code>changeColor</code></li>\n</ol>\n<h5 id=\"Redux基本原理图：\"><a href=\"#Redux基本原理图：\" class=\"headerlink\" title=\"Redux基本原理图：\"></a>Redux基本原理图：</h5><p><img src=\"/2018/11/22/redux/417252aa40fd5841805aee7017fc73cd.png\" alt></p>\n"},{"title":"react","date":"2018-10-24T09:19:44.000Z","_content":"\n### React\n\n##### React中的几个核心概念\n\n1. **虚拟DOM**\n\n   - **DOM本质是什么**：是浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API。\n\n   - **什么是React中的虚拟DOM**：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套。\n\n   - **使用虚拟DOM的目的**：为了实现页面中，DOM元素的高效更新。\n\n   - **DOM和虚拟DOM之间的区别**：\n\n     - **DOM**：浏览器中提供的概念，用JS对象表示页面上的元素，并提供操作元素地API。\n\n     - **虚拟DOM**：是框架中的概念，开发框架的程序员手动用JS对象来模拟DOM元素和嵌套关系。\n\n       ```html\n       <div class=\"Odiv\" data-index=\"0\">\n           div文本\n           <p>\n               p文本\n           </p>\n       </div>\n       <script>\n           //使用js对象模拟DOM树\n           var div={\n               tagName:'div',\n               attr:{\n                   class:'Odiv',\n                   'data-index':'0'\n               },\n               childrens:[\n                   'div文本',\n                   {\n                       tagName:'p',\n                       attr:{},\n                       childrens:[\n                           'p文本'\n                       ]\n                   }\n               ]\n           }\n       </script>\n       ```\n\n2. **Diff算法**\n\n   - **tree diff**：新旧两颗DOM树逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。\n\n   - **component diff**：在进行Tree diff的时候，每一层中，组件级别的对比，叫做Component diff。\n\n     1. 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。\n     2. 如果对比前后，组件类型不同，则需要移除旧的组件，创建新组件，并追加到页面上。\n\n   - **element diff**：进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这就叫做Element diff。\n\n     ![](react/6873d82c40e03c3080a5f4098f6df602.png)\n\n##### 在项目中使用react\n\n1. 运行`npm i react react-dom -S`安装包\n   - react：专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中\n   - react-dom：专门进行DOM操作的，最主要的应用场景，就是`ReactDOM.render()`\n\n2. 在`index.html`页面中，创建容器：\n\n   ```html\n   <!-- 容器，在使用react创建的虚拟DOM元素，都会被渲染到这个指定的容器中 -->\n   <div id=\"app\">\n       \n   </div>\n   ```\n\n3. 在`index.js`中导入包：\n\n4. ```js\n   //1. 这两个包导入的时候，必需这么写\n   import React from 'react'  //创建组件、虚拟DOM元素、生命周期\n   import ReactDOM from 'react-dom'  //把创建好的组件和虚拟DOM放到页面上展示\n   \n   //2. 创建虚拟DOM元素\n   //参数1：创建的元素的类型，字符串，表示元素的名称\n   //参数2：是一个对象或null，表示当前这个DOM元素的属性\n   //参数3：子节点（包括其他虚拟DOM获取文本子节点）\n   //参数n：其他子节点\n   //<h1>这是一个h1标签</h1>\n   const myH1=React.createElement('h1',null,'这是一个h1标签')\n   \n   //3. 使用ReactDOM把虚拟DOM渲染到页面上\n   //参数1：要渲染的那个虚拟DOM元素\n   //参数2：指定页面上一个容器\n   ReactDOM.render(myH1,document.getElementById(\"app\"))\n   ```\n\n   使用`babel`转换JS中的标签：\n\n   > 什么是JSX语法：就是符合xml规范的JS语法。（语法格式相对HTML严谨很多）\n\n   **注意：在JS中，混合写入类似于HTML的语法，叫做JSX语法。（默认无法识别，会报错，需要第三方转换插件）**\n\n   **注意：JSX语法的本质，还是在运行的时候，被转换成了React.createElement形式来执行。**\n\n   1. 如何启用jsx语法：\n\n      - 安装`babel`插件\n\n        - 运行`npm i babel-core babel-loader babel-plugin-transform-runtime -D`\n\n        - 运行`npm i babel-preset-env babel-preset-stage-0 -D`\n\n      - 安装能够识别转换JSX语法的包`babel-preset-react`\n\n        - 运行`npm i babel-preset-react -D`\n\n          ```js\n          //配置webpack.config.js文件\n          const path = require('path')\n          const HtmlWebPackPlugin = require('html-webpack-plugin') //导入 在内存中自动生成index页面的插件\n          \n          //创建一个插件实例对象\n          const htmlPlugin = new HtmlWebPackPlugin({\n              template: path.join(__dirname, './src/index.html'), //源文件\n              filename: 'index.html' //生成的内存中首页名称\n          })\n          \n          //向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\n          module.exports={\n              mode:'production', //development production\n              //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n              plugins:[\n                  htmlPlugin\n              ],\n              module:{ //所有第三放模块的配置规则\n                  rules:[ //第三方匹配规则\n                      { test: /\\.js|jsx$/,use: 'babel-loader',exclude: /node_modules/ }, //test匹配规则 use 使用插件 exclude 排除项\n                      //可以在 css-loader之后，通过? 追加参数\n                      //其中由两个固定的参数，叫做modules，表示为普通的css样式表，启用模块化\n                      //注意:css模块化只针对类选择器和ID选择器生效 不会将标签选择器模块化\n                      { test: /\\.css$/, use: ['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]']}, //打包处理css样式表的第三方loader\n                      {test: /\\.ttf|woff|woff2|eot|svg$/, use: 'url-loader'}, //打包处理 字体文件的loader\n                  ]\n              },\n              resolve:{\n                  extensions:['.js','jsx','.json'], //表示，这几个文件的后缀名可以省略不写\n                  alias:{\n                      '@': path.join(__dirname, './src') //这样，@表示项目根目录中src的这一层路径\n                  }\n              }\n          }\n          ```\n\n\n##### 配置`babel`配置文件\n\n在项目的根目录中创建文件后缀为`.babelrc`的文件\n\n```json\n{\n \t\"presets\":[\"env\",\"stage-0\",\"react\"],\n    \"plugins\":[\"transform-runtime\"]\n}\n```\n\n在`index.js`文件中使用JSX语法：\n\n```js\n// 这两个包导入的时候，必需这么写\nimport React from 'react'  //创建组件、虚拟DOM元素、生命周期\nimport ReactDOM from 'react-dom'  //把创建好的组件和虚拟DOM放到页面上展示\n\nlet a=10;\nlet str=\"你好！\";\nlet boo=true;\nlet title=\"titleName\";\nconst h1=<h1>这是一个H1</h1>;\nconst arr=[\n    <h2>这是h2</h2>\n    <h3>这是h3</h3>\n];\nconst arrstr=['张三','李四','王五'];\n\n// 使用ReactDOM把虚拟DOM渲染到页面上\n//参数1：要渲染的那个虚拟DOM元素\n//参数2：指定页面上一个容器\nReactDOM.render(<div>\n                {a+2} //12\n                {str} //你好\n                {boo ? '条件为真' : '条件为假'} //条件为真\n                <p title={title}>P标签</p>\n                {h1}\n                {arr}\n                {arrstr.map(item => <h5>{item}</h5>)}\n                </div>,document.getElementById(\"app\"))\n```\n\n##### 创建组件的方式\n\n1. 第一种：\n\n   ```js\n   //导入包\n   import React from 'react'\n   import ReactDOM from 'react-dom'\n   \n   //第一种创建组件的方式 (是一个构造函数，首字母大写)\n   function Hello(props){\n       return <div>这是Hello组件 --{props.name}--{props.gender}</div>\n   }\n   //定义参数变量\n   const dog={\n       name:'阿旺',\n       gender:'雄'\n   }\n   //调用render函数渲染 jsx xml 比HTML严格的多\n   ReactDOM.render(<div>\n                   <Hello name={dog.name} gender={dog.gender}></Hello>\n                   </div>,document.getElementById('app'))\n   ```\n\n2. 第二种：\n\n   ```js\n   //如果要使用class定义组件，必需让自己的组件，继承自React.Component\n   class '组件名称' extends React.Component{\n       //构造器\n       constructor(){\n           //子类的自定义构造器中必需先调用super()\n           super();\n           //只有调用了super才能使用this关键字\n           this.state={ //相当于vue中的data(){ return{} }\n               msg:'hello',\n           }\n       }\n       //在组件内部，必须有render函数 作用：渲染当前组件对应的虚拟DOM结构\n       render(){ //render函数中必需返回合法的jsx虚拟dom结构\n           //在class关键字中创建的组件，如果要访问外界传递的参数，不需接收，直接this.props.***就可以访问\n           return <div>\n               这是一个div \n           <h3>{this.state.msg}</h3>\n           </div>;\n       }\n   }\n   ```\n\n   **两种创建组件方式的区别：**\n\n   > 注意：使用`class`创建的组件，有自己的私有数据和生命周期函数；\n   >\n   > 使用`function`创建的组件，只有props，没有自己的私有数据和生命周期；\n   >\n   > 1. 用**构造函数**创建出来的组件：叫做“无状态组件”\n   > 2. 用**class关键字**创建出来的组件：叫做“有状态组件”\n   > 3. 有状态组件和无状态组件的本指区别就是：有无state属性\n\n   组件中的`props`和`state/data`之间的区别：\n\n   - `porps`中的数据都是外界传递过来的；\n   - `state/data`中的数据，都是组件的私有数据（通过Ajax传递过来的）；\n   - `props`中的数据都是只读的，不能被重新赋值；\n   - `state/data`中的数据，都是可读可写的；\n   - `state`是让组件控制自己的状态的，`props`是让外部对组件进行自我配置的。\n\n##### 组件的props\n\n​\t在使用一个组件的时候，可以把参数放在标签的属性当中，所用属性都会作为`props`对象的键值。甚至可以传入一个函数作为属性的参数。\n\n```jsx\nclass Index extends Component {\n  render () {\n    return (\n      <div>\n        <LikeButton\n          wordings={{likedText: '已赞', unlikedText: '赞'}}\n          onClick={() => console.log('Click on like button!')}/>\n      </div>\n    )\n  }\n}\n```\n\n可以通过`this.props.onClick`获取到这个传进去的函数。\n\n1. 默认配置defaultProps\n\n   ```jsx\n   class Link extends Component{\n       static defaultProps={\n           liked:'喜欢',\n           unlike:'不喜欢'\n       }\n       constructor(){\n           super();\n           this.state={\n               \n           }\n       }\n       render(){\n           return <div></div>\n       }\n   }\n   ```\n\n2. props不可变\n\n   > `props`一旦传入进来就不能改变。如果想要去改变，只能是从父组件重新传入新的内容进行重新渲染的方式去改变。\n\n##### 组件抽离为JSX文件\n\n**注意：所谓jsx其实就是js对象**\n\n```jsx\n// components/Hello.jsx\n//需要导入React\nimport React from 'react'\nexport default function Hello(props){\t//定义组件并导出\n    return <div>这是一个Hello组件 --{props.name}--{props.gender}</div>\n}\n```\n\n```js\n//导入包\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n//导入组件\n//默认，如果不做单独的配置的话，不能省略.jsx后缀名\nimport Hello from './components/Hello.jsx'\n\n//定义参数变量\nconst dog={\n    name:'阿旺',\n    gender:'雄'\n}\n//调用render函数渲染 jsx xml 比HTML严格的多\nReactDOM.render(<div>\n                <Hello name={dog.name} gender={dog.gender}></Hello>\n                </div>,document.getElementById('app'))\n```\n\n**jsx到页面到底经过了怎样的过程呢？**\n\n![](react/35cc29484072961d801e4de7f94c3b65.png)\n\n为什么不直接从jsx直接渲染构造DOM结构呢？\n\n1. 第一个原因是：当我们拿到一个表示ui的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能会将它们渲染到canvas或者是手机app上。而js对象可以很方便让我们去进行其他地方的渲染。（ReactNative就是帮我们把它转换成原生的app的）\n2. 第二个原因是：有了这一个对象，当数据变化，需要更新组件的时候，就可以用比较块的算法操作这个js对象，而不用直接去操作页面中的dom元素，这样可以尽可能的减少浏览器的重排，优化性能。\n3. 总结：\n   - jsx是js语言的一种语法扩展，长得像html，但并不是html。\n   - React.js可以用jsx来描述你的组件长什么样。\n   - jsx在编译的时候会变成相应的js对象描述。\n   - react-dom负责把这个用来描述UI信息的js对象转变成dom元素并且渲染到页面中去。\n\n**渲染列表**\n\n对于用表达式套数组罗列到页面上的元素，都要为每个元素加上key属性，这个key必需是每个元素唯一的标识，一般来说，`key`的取值为后台传过来的`id`值。\n\n##### 在组件中使用style\n\n```js\nclass '组件名称' extends React.Component{\n    constructor(){\n        super();\n        this.state={ \n            msg:'hello',\n        }\n    }\n    //注意 在jsx语法中不能识别行内样式，不能为style设置字符串的值。\n    //正确的写法： style={ {color:'red'} }\n    render(){ \n        return <div style={ {color:'red' fontSize:'20px'} }>\n            这是一个div \n        <h3>{this.state.msg}</h3>\n        </div>;\n    }\n}\n```\n\n使用`localIdentName`自定义生成的类名格式，可选的参数有：\n\n- `[path]`表示样式表相对于**项目根目录**所在的路径\n\n- `[name]`表示样式表文件名称\n\n- `[local]`表示样式的类名定义名称\n\n- `[hash:length]`表示32位的hash值\n\n  例子：`{ test: /\\.css$/, use: ['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]']}`\n\n使用`:local()`和`:global()`\n\n- `:local()`包裹的类名，是被模块化选中的。（默认）`className={cssObj.类名}`\n- `:global()`包裹的类名，是全局生效的，不会被模块化（`css-modules`）控制，定义的类名是什么，就使用定义的类名`className=\"类名\"`\n\n##### 在项目中使用模块化并同时使用bootstrap\n\n1. 把自己的样式表，定义为`.scss`文件\n\n2. 第三方的样式表还是以`.css`结尾\n\n3. 只为自己定义的`.scss`文件启用模块化即可\n\n4. 运行`npm i sass-loader node-sass -D` 安装能够解析`scss`文件的loader\n\n   例子：`{test: /\\.scss$/, use: ['style-loader','css-loader','sass-loader']}` 打包处理`.scss`文件的`loader`\n\n##### React中绑定事件的注意点\n\n1. 事件的名称都是React提供的，首字母大写`onClick`、`onMouseOver`，需要注意的是，这些事件监听只能用在普通的HTML标签上，而不能用在组件的标签上。\n\n   ```jsx\n   <Header onClick={...} />\n   ```\n\n   这样的写法是不对的，不会有什么效果。\n\n2. 为事件提供的处理函数，必须是如下格式\n\n3. ```js\n   onClick={function}\n   ```\n\n   用的最多的事件绑定形式为：\n\n   ```jsx\n   <button onClick={ () => this.show('参数') }>按钮</button>\n   \n   //事件的处理函数，需要定义为一个箭头函数，然后赋值给函数名称\n   show = (arg1) => {\n       console.log('show方法'+arg1);\n   }\n   ```\n\n4. 再React中，如果想要修改state中的数据，推荐使用`this.setState({ })`，此方法是**异步的**。\n\n用法:\n\n```js\nthis.setState({\n\tmsg:''\n},function(){\t//回调函数，若想得到最新的state值，需要再回调函数内部获取\n    \n})\n```\n\n5. 实现文本框数据双向更新\n\n   ```jsx\n   <input value={this.state.msg} onChange={(e)=>this.changeTxt(e)} ref=\"txt\"></input>\n   \n   textChange= (e) =>{\n       const newText=this.refs.txt.value; //或者等于e.target.value\n       this.setState({\n           msg: newText\n       })\n   }\n   ```\n\n6. event对象\n\n   和普通的浏览器一样，事件监听函数会被自动传入一个`event`对象，这个对象和普通的浏览器`event`对象所包含的方法和属性都基本一致。不过，`react.js`中的`event`是经过封装的，对外提供了统一的api，这样就不用考虑浏览器的兼容性问题。这个`event`对象符合`w3c`标准。它具有类似`event.stopPropagation`、`event.preventDefault`这种常用的方法。\n\n7. this问题\n\n   在`react`调用你所传入给它的方法的时候，并不是通过对象方法的方式去调用的，而是直接通过函数调用的，所以事件监听函数内并不能通过this获取到实例。\n\n   如果你想获取到当前的实例，需要手动将this bind进去。\n\n   ```jsx\n   class Title extends Component {\n     handleClickOnTitle (e) {\n       console.log(this)\n     }\n   \n     render () {\n       return (\n         <h1 onClick={this.handleClickOnTitle.bind(this)}>React 小书</h1>\n       )\n     }\n   }\n   ```\n\n\n##### React组件的生命周期分为三部分：\n\n> 这里只是列举了常用的生命周期，不包括所有的，如需了解其他的，请参考官方文档。\n\n*在了解生命周期之前，先介绍什么是挂载：*\n\n**组件的挂载：React.js将组件渲染，并且构造DOM元素然后塞入页面的过程称为组件的挂载。**\n\n**React.js会在组件的`render`之前调用`componentWillMount`，在DOM元素塞入页面以后调用`componentDidMount`**\n\n**一般来说，所有关于组件自身的状态的初始化工作都会放在`constructor`里面（比如React.js组件中的状态state就是在这个阶段初始化）**\n\n****\n\n- **组件的创建阶段**：特点，只会执行一次\n\n  > componentWillMount:（**常用来做一些组件启动的动作，包括像Ajax数据的拉取操作、一些定时器的启动等，就可以放在这个阶段去进行**）\n  >\n  > ```js\n  > //写一个Ajax\n  > componentWillMount(){\n  >     ajax.get('http://json-api.com/user',(userData)=>{\n  >         this.setState({userData})\n  >     })\n  > }\n  > ```\n  >\n  > render:（**react.js最重要的步骤，用来创建虚拟dom，进行Diff算法，更新dom树都在此进行，此时不能更改state**）\n  >\n  > **render之后会将虚拟dom渲染并插入到页面的根节点中**\n  >\n  > componentDidMount:（**此阶段组件已经渲染完毕，可以获取dom结点**）\n\n- **组件的运行阶段**：按需，根据props属性或state状态的改变，有选择性的执行0到多次\n\n  > componentWillReceiveProps:（**组件在接收新的props时调用，组件初始化时不调用**）\n  >\n  > shouldComponentUpdateL:（**react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在次对比前后两个props以及state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就可以避免创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，特别是在dom结构相对复杂的时候**）\n  >\n  > componentWillUpdate:（**组件初始化时不调用，组建更新调用**）\n  >\n  > render:（**组件再次渲染**）\n  >\n  > componentDidUpdate:（**此阶段类似`componentDidMount`，此时可以获取dom结点**）\n\n- **组件的销毁阶段**：只执行一次\n\n  > componentWillUnmount:（**它的作用主要是用来销毁一些数据事件监听以及定时器的**）\n\n##### React路由\n\n1. React-router\n\n   React-router提供了`Router`,`Route`,`Switch`等`router`的核心api，但是它没有提供dom操作进行相关跳转的api。\n\n2. React-router-dom\n\n   React-router-dom提供了`BrowserRouter`,`Route`,`Link`等api，可以通过它们来操作dom的事件从而控制路由。\n\n   用法：(以下两个是路由的基本，就像盖房子一样，要有地基，需要将它们包裹在最外层，作为路由的根节点，我们只需要选择它们其一就可以了)\n\n   1. HashRouter\n\n      > **特点：**它是通过hash值来对路由进行控制，如果你选择使用它，就会在url上看到#。\n      >\n      > **用法：**\n      >\n      > ![](react/231d414640b509d980203a5ab45a3c4e.png)\n      >\n      > ```html\n      > <Router>\n      >        <Layout className=\"layout\">\n      >             <Header>\n      >                 <Menu \n      >                   theme=\"dark\"\n      >                   mode=\"horizontal\"\n      >                   style={{lineHeight:'64px'}} >\n      >                     <Menu.Item key=\"1\" ><Link to=\"/home\"><Icon type=\"home\"/>首页</Link>\t\t\t\t\t\t   </Menu.Item>\n      >                     <Menu.Item key=\"2\"><Link to=\"/content\"><Icon type=\"file-text\"/>文档</Link>\t\t\t\t   </Menu.Item>\n      >                 </Menu>\n      >             </Header>\n      >             <Content>\n      >                 <Switch>\n      >                     <Route exact path=\"/\" component={home}></Route>\n      >                     <Route path=\"/home\" component={home}></Route>\n      >                     <Route path=\"/content\" component={content}></Route>\n      >                 </Switch>\n      >             </Content>\n      >        </Layout>\n      > </Router>\n      > ```\n      >\n      >\n\n   2. BrowserRouter\n\n      >**特点：**它的url看起来与正常的一样，不存在类似于`HashRouter`中出现的#\n      >\n      >**用法：**\n\n      > ```jsx\n      > import {BrowserRouter as Router, Link, Route, Switch} from 'react-router-dom'\n      > <Router>\n      >     <div>\n      >     \t<Route path=\"/\" component={home}></Route>\n      >     \t<Link to=\"/\">Home</Link>\n      > \t</div>\n      > </Router>\n      > ```\n      >\n      > **它的原理是使用HTML5 history API(pushState,replaceState,propState)来使你的内容随url的动态改变**\n      >\n      > 有一个常用的api，`basename`如果你的文件放在服务器的二级目录下则可以使用它。（你的主页前面有一级目录calendar可以这样使用）\n      >\n      > ```jsx\n      > <BrowserRouter basename=\"/calendar\">\n      >     <Route path=\"/\" component={home}></Route>\n      > </BrowserRouter>\n      > ```\n\n   3. Route\n\n      >**特点：**它是路由的原材料，用来控制路由对应显示的组件。我们常用它的`exact`、`path`以及`component`属性\n      >\n      >```jsx\n      ><Route exact path=\"/\" component={Home}></Route>\n      ><Route path=\"/second\" component={Second}></Route>\n      ><Route path=\"/third\" component={Third}></Route>\n      >```\n      >\n      >`exact`：用来控制匹配到/路径时，不会再继续往下匹配，用来进行精确定位。\n      >\n      >`path`：标识路由的路径。\n      >\n      >`component`：表示路径对应显示的组件。\n\n   4. Link\n\n      > **作用：**用来进行跳转的页面链接。\n      >\n      > ```jsx\n      > <Link to=\"/home\"></Link>\n      > <Link to={{\n      >         pathname:'/home',\n      >         search:'?sort=name',\n      >         hash:'#the-hash',\n      >         state:{fromDashboard:true}\n      >     }}></Link>\n      > ```\n      >\n      > 主要的API时to，可以接受string或者一个object，用来控制url。\n\n   5. NavLink\n\n      > **特点：**可以为当前选中的路由设置类名、样式以及回调函数等。\n      >\n      > ```jsx\n      > <NavLink exact activeClassName=\"selected\" to=\"/\">home</NavLink>\n      > <NavLink activeClassName=\"selected\" to=\"/second/1234\">second</NavLink>\n      > <Route path=\"/second/:id\" component={Second}></Route>\n      > ```\n      >\n      > `exact`：用于严格匹配，与route中的作用类似。\n      >\n      > `to`：用来控制url跳转。\n      >\n      > `activeClassName`：选中状态的类名，可以为其添加样式。\n      >\n      > 在second后添加/1234结合Route中/second/:id\n\n   6. match\n\n      > `match`时使用router之后会被放到props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。`match`中包含的信息如下：\n      >\n      > ```js\n      > {\n      >     path:\"/second/:id\",\n      >     url:\"/second/1234\",\n      >     isExact:true,\n      >     parms:{\n      >     \tid:\"1234\"        \n      >    \t}\n      > }\n      > ```\n      >\n      > **常用来获取id**\n\n   7. Switch\n\n      > 常用来包裹Route，里面不能放其他的元素。\n\n**路由嵌套**(子组件<Route>可以作为父<Route>的component属性值)\n\n```jsx\n<Route path=\"parent\" component={Parent}></Route>\nconst Parent=()=>(\n\t<div>\n    \t<Route path=\"child\" component={Child}></Route>\n        <Route path=\"other\" component={Other}></Route>\n    </div>\n)\n```\n\n**最后需要注意的是：`HashRouter`以及`BrowserRouter`使用时，其孩子节点只能有一个，例如：**\n\n```jsx\n<HashRouter>\n\t<div>\n    \t<Route path=\"/\" component={home}></Route>\n        <Link to=\"/\">home</Link>\n    </div>\n</HashRouter>\n<BrowserRouter>\n\t<div>\n    \t<Route path=\"/\" component={home}></Route>\n        <Link to=\"/\">home</Link>\n    </div>\n</BrowserRouter>\n```\n\n##### 组件的Render方法\n\n在`react.js`中，一切皆组件。我们在编写`react.js`组件的时候，一般需要继承`react.js`的`component`。一个组件的类必须要实现`render`方法，这个`render`方法必需返回一个JSX元素。需要注意的是，必需要有一个外层的jsx元素把所有内容包裹起来，返回并列多个JSX元素是不合法的。\n\n```jsx\n//错误的做法\nrender(){\n    return (\n    \t<div>第一个元素</div>\n    \t<div>第二个元素</div>\n    )\n}\n//正确的写法\nrender(){\n    return (\n        <div>\n        \t<div>第一个元素</div>\n    \t\t<div>第二个元素</div>\n        </div>\n    )\n}\n```\n\n**自定义组件都必须要大写字母开头，普通的HTML标题都用小写字母开头**\n\n##### 状态提升\n\n**状态提升：**当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用`props`传递数据或函数来管理这种依赖或者影响的关系。\n\n**组件的内容编写顺序如下：**\n\n1. `static`开头的类属性，如`defaultProps`、`propTypes`。\n2. 构造函数，`constructor`。\n3. `getter/setter`。\n4. 组件的生命周期。\n5. `_`开头的私有方法。\n6. 事件监听方法，`handle`。\n7. `render`开头的方法，有时候`render()`方法里面的内容会被分开到不同的函数里边进行，这些函数都以`render`开头。\n8. `render()`方法。\n\n##### **高阶组件：**\n\n什么是高阶组件：*高阶组件就是一个函数，传给它一个组件，返回一个新的组件。*\n\n重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件\n\n```jsx\nimport React, { Component } from 'react'\n\nexport default (WrappedComponent, name) => {\n  class NewComponent extends Component {\n    constructor () {\n      super()\n      this.state = { data: null }\n    }\n\n    componentWillMount () {\n      let data = localStorage.getItem(name)\n      this.setState({ data })\n    }\n\n    render () {\n      return <WrappedComponent data={this.state.data} />\n    }\n  }\n  return NewComponent\n}\n```\n\n**高阶组件的主要作用就是用来封装一些组件，提取出多个组件中代码逻辑相同的部分，编写一个高阶组件函数，可以提高代码的复用性。**\n\n\n\n##### propTypes组件参数验证\n\n使用：`npm install prop-types --save`\n\n它可以帮助我们验证`props`的参数类型，例如：\n\n```jsx\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass Comment extends Component {\n  static propTypes = {\n    comment: PropTypes.object\n  }\n\n  render () {\n    const { comment } = this.props\n    return (\n      <div className='comment'>\n        <div className='comment-user'>\n          <span>{comment.username} </span>：\n        </div>\n        <p>{comment.content}</p>\n      </div>\n    )\n  }\n}\n```\n\n注意我们在文件头部引入了 `PropTypes`，并且给 `Comment` 组件类添加了类属性 `propTypes`，里面的内容的意思就是你传入的 `comment` 类型必须为 `object`（对象）。*它可以帮助我们更好地去定位出现的错误，将控制台的错误信息展示的更加友好。*","source":"_posts/react.md","raw":"---\ntitle: react\ndate: 2018-10-24 17:19:44\ntags: react\ncategories: 前端\n---\n\n### React\n\n##### React中的几个核心概念\n\n1. **虚拟DOM**\n\n   - **DOM本质是什么**：是浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API。\n\n   - **什么是React中的虚拟DOM**：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套。\n\n   - **使用虚拟DOM的目的**：为了实现页面中，DOM元素的高效更新。\n\n   - **DOM和虚拟DOM之间的区别**：\n\n     - **DOM**：浏览器中提供的概念，用JS对象表示页面上的元素，并提供操作元素地API。\n\n     - **虚拟DOM**：是框架中的概念，开发框架的程序员手动用JS对象来模拟DOM元素和嵌套关系。\n\n       ```html\n       <div class=\"Odiv\" data-index=\"0\">\n           div文本\n           <p>\n               p文本\n           </p>\n       </div>\n       <script>\n           //使用js对象模拟DOM树\n           var div={\n               tagName:'div',\n               attr:{\n                   class:'Odiv',\n                   'data-index':'0'\n               },\n               childrens:[\n                   'div文本',\n                   {\n                       tagName:'p',\n                       attr:{},\n                       childrens:[\n                           'p文本'\n                       ]\n                   }\n               ]\n           }\n       </script>\n       ```\n\n2. **Diff算法**\n\n   - **tree diff**：新旧两颗DOM树逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。\n\n   - **component diff**：在进行Tree diff的时候，每一层中，组件级别的对比，叫做Component diff。\n\n     1. 如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。\n     2. 如果对比前后，组件类型不同，则需要移除旧的组件，创建新组件，并追加到页面上。\n\n   - **element diff**：进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这就叫做Element diff。\n\n     ![](react/6873d82c40e03c3080a5f4098f6df602.png)\n\n##### 在项目中使用react\n\n1. 运行`npm i react react-dom -S`安装包\n   - react：专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中\n   - react-dom：专门进行DOM操作的，最主要的应用场景，就是`ReactDOM.render()`\n\n2. 在`index.html`页面中，创建容器：\n\n   ```html\n   <!-- 容器，在使用react创建的虚拟DOM元素，都会被渲染到这个指定的容器中 -->\n   <div id=\"app\">\n       \n   </div>\n   ```\n\n3. 在`index.js`中导入包：\n\n4. ```js\n   //1. 这两个包导入的时候，必需这么写\n   import React from 'react'  //创建组件、虚拟DOM元素、生命周期\n   import ReactDOM from 'react-dom'  //把创建好的组件和虚拟DOM放到页面上展示\n   \n   //2. 创建虚拟DOM元素\n   //参数1：创建的元素的类型，字符串，表示元素的名称\n   //参数2：是一个对象或null，表示当前这个DOM元素的属性\n   //参数3：子节点（包括其他虚拟DOM获取文本子节点）\n   //参数n：其他子节点\n   //<h1>这是一个h1标签</h1>\n   const myH1=React.createElement('h1',null,'这是一个h1标签')\n   \n   //3. 使用ReactDOM把虚拟DOM渲染到页面上\n   //参数1：要渲染的那个虚拟DOM元素\n   //参数2：指定页面上一个容器\n   ReactDOM.render(myH1,document.getElementById(\"app\"))\n   ```\n\n   使用`babel`转换JS中的标签：\n\n   > 什么是JSX语法：就是符合xml规范的JS语法。（语法格式相对HTML严谨很多）\n\n   **注意：在JS中，混合写入类似于HTML的语法，叫做JSX语法。（默认无法识别，会报错，需要第三方转换插件）**\n\n   **注意：JSX语法的本质，还是在运行的时候，被转换成了React.createElement形式来执行。**\n\n   1. 如何启用jsx语法：\n\n      - 安装`babel`插件\n\n        - 运行`npm i babel-core babel-loader babel-plugin-transform-runtime -D`\n\n        - 运行`npm i babel-preset-env babel-preset-stage-0 -D`\n\n      - 安装能够识别转换JSX语法的包`babel-preset-react`\n\n        - 运行`npm i babel-preset-react -D`\n\n          ```js\n          //配置webpack.config.js文件\n          const path = require('path')\n          const HtmlWebPackPlugin = require('html-webpack-plugin') //导入 在内存中自动生成index页面的插件\n          \n          //创建一个插件实例对象\n          const htmlPlugin = new HtmlWebPackPlugin({\n              template: path.join(__dirname, './src/index.html'), //源文件\n              filename: 'index.html' //生成的内存中首页名称\n          })\n          \n          //向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\n          module.exports={\n              mode:'production', //development production\n              //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n              plugins:[\n                  htmlPlugin\n              ],\n              module:{ //所有第三放模块的配置规则\n                  rules:[ //第三方匹配规则\n                      { test: /\\.js|jsx$/,use: 'babel-loader',exclude: /node_modules/ }, //test匹配规则 use 使用插件 exclude 排除项\n                      //可以在 css-loader之后，通过? 追加参数\n                      //其中由两个固定的参数，叫做modules，表示为普通的css样式表，启用模块化\n                      //注意:css模块化只针对类选择器和ID选择器生效 不会将标签选择器模块化\n                      { test: /\\.css$/, use: ['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]']}, //打包处理css样式表的第三方loader\n                      {test: /\\.ttf|woff|woff2|eot|svg$/, use: 'url-loader'}, //打包处理 字体文件的loader\n                  ]\n              },\n              resolve:{\n                  extensions:['.js','jsx','.json'], //表示，这几个文件的后缀名可以省略不写\n                  alias:{\n                      '@': path.join(__dirname, './src') //这样，@表示项目根目录中src的这一层路径\n                  }\n              }\n          }\n          ```\n\n\n##### 配置`babel`配置文件\n\n在项目的根目录中创建文件后缀为`.babelrc`的文件\n\n```json\n{\n \t\"presets\":[\"env\",\"stage-0\",\"react\"],\n    \"plugins\":[\"transform-runtime\"]\n}\n```\n\n在`index.js`文件中使用JSX语法：\n\n```js\n// 这两个包导入的时候，必需这么写\nimport React from 'react'  //创建组件、虚拟DOM元素、生命周期\nimport ReactDOM from 'react-dom'  //把创建好的组件和虚拟DOM放到页面上展示\n\nlet a=10;\nlet str=\"你好！\";\nlet boo=true;\nlet title=\"titleName\";\nconst h1=<h1>这是一个H1</h1>;\nconst arr=[\n    <h2>这是h2</h2>\n    <h3>这是h3</h3>\n];\nconst arrstr=['张三','李四','王五'];\n\n// 使用ReactDOM把虚拟DOM渲染到页面上\n//参数1：要渲染的那个虚拟DOM元素\n//参数2：指定页面上一个容器\nReactDOM.render(<div>\n                {a+2} //12\n                {str} //你好\n                {boo ? '条件为真' : '条件为假'} //条件为真\n                <p title={title}>P标签</p>\n                {h1}\n                {arr}\n                {arrstr.map(item => <h5>{item}</h5>)}\n                </div>,document.getElementById(\"app\"))\n```\n\n##### 创建组件的方式\n\n1. 第一种：\n\n   ```js\n   //导入包\n   import React from 'react'\n   import ReactDOM from 'react-dom'\n   \n   //第一种创建组件的方式 (是一个构造函数，首字母大写)\n   function Hello(props){\n       return <div>这是Hello组件 --{props.name}--{props.gender}</div>\n   }\n   //定义参数变量\n   const dog={\n       name:'阿旺',\n       gender:'雄'\n   }\n   //调用render函数渲染 jsx xml 比HTML严格的多\n   ReactDOM.render(<div>\n                   <Hello name={dog.name} gender={dog.gender}></Hello>\n                   </div>,document.getElementById('app'))\n   ```\n\n2. 第二种：\n\n   ```js\n   //如果要使用class定义组件，必需让自己的组件，继承自React.Component\n   class '组件名称' extends React.Component{\n       //构造器\n       constructor(){\n           //子类的自定义构造器中必需先调用super()\n           super();\n           //只有调用了super才能使用this关键字\n           this.state={ //相当于vue中的data(){ return{} }\n               msg:'hello',\n           }\n       }\n       //在组件内部，必须有render函数 作用：渲染当前组件对应的虚拟DOM结构\n       render(){ //render函数中必需返回合法的jsx虚拟dom结构\n           //在class关键字中创建的组件，如果要访问外界传递的参数，不需接收，直接this.props.***就可以访问\n           return <div>\n               这是一个div \n           <h3>{this.state.msg}</h3>\n           </div>;\n       }\n   }\n   ```\n\n   **两种创建组件方式的区别：**\n\n   > 注意：使用`class`创建的组件，有自己的私有数据和生命周期函数；\n   >\n   > 使用`function`创建的组件，只有props，没有自己的私有数据和生命周期；\n   >\n   > 1. 用**构造函数**创建出来的组件：叫做“无状态组件”\n   > 2. 用**class关键字**创建出来的组件：叫做“有状态组件”\n   > 3. 有状态组件和无状态组件的本指区别就是：有无state属性\n\n   组件中的`props`和`state/data`之间的区别：\n\n   - `porps`中的数据都是外界传递过来的；\n   - `state/data`中的数据，都是组件的私有数据（通过Ajax传递过来的）；\n   - `props`中的数据都是只读的，不能被重新赋值；\n   - `state/data`中的数据，都是可读可写的；\n   - `state`是让组件控制自己的状态的，`props`是让外部对组件进行自我配置的。\n\n##### 组件的props\n\n​\t在使用一个组件的时候，可以把参数放在标签的属性当中，所用属性都会作为`props`对象的键值。甚至可以传入一个函数作为属性的参数。\n\n```jsx\nclass Index extends Component {\n  render () {\n    return (\n      <div>\n        <LikeButton\n          wordings={{likedText: '已赞', unlikedText: '赞'}}\n          onClick={() => console.log('Click on like button!')}/>\n      </div>\n    )\n  }\n}\n```\n\n可以通过`this.props.onClick`获取到这个传进去的函数。\n\n1. 默认配置defaultProps\n\n   ```jsx\n   class Link extends Component{\n       static defaultProps={\n           liked:'喜欢',\n           unlike:'不喜欢'\n       }\n       constructor(){\n           super();\n           this.state={\n               \n           }\n       }\n       render(){\n           return <div></div>\n       }\n   }\n   ```\n\n2. props不可变\n\n   > `props`一旦传入进来就不能改变。如果想要去改变，只能是从父组件重新传入新的内容进行重新渲染的方式去改变。\n\n##### 组件抽离为JSX文件\n\n**注意：所谓jsx其实就是js对象**\n\n```jsx\n// components/Hello.jsx\n//需要导入React\nimport React from 'react'\nexport default function Hello(props){\t//定义组件并导出\n    return <div>这是一个Hello组件 --{props.name}--{props.gender}</div>\n}\n```\n\n```js\n//导入包\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n//导入组件\n//默认，如果不做单独的配置的话，不能省略.jsx后缀名\nimport Hello from './components/Hello.jsx'\n\n//定义参数变量\nconst dog={\n    name:'阿旺',\n    gender:'雄'\n}\n//调用render函数渲染 jsx xml 比HTML严格的多\nReactDOM.render(<div>\n                <Hello name={dog.name} gender={dog.gender}></Hello>\n                </div>,document.getElementById('app'))\n```\n\n**jsx到页面到底经过了怎样的过程呢？**\n\n![](react/35cc29484072961d801e4de7f94c3b65.png)\n\n为什么不直接从jsx直接渲染构造DOM结构呢？\n\n1. 第一个原因是：当我们拿到一个表示ui的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能会将它们渲染到canvas或者是手机app上。而js对象可以很方便让我们去进行其他地方的渲染。（ReactNative就是帮我们把它转换成原生的app的）\n2. 第二个原因是：有了这一个对象，当数据变化，需要更新组件的时候，就可以用比较块的算法操作这个js对象，而不用直接去操作页面中的dom元素，这样可以尽可能的减少浏览器的重排，优化性能。\n3. 总结：\n   - jsx是js语言的一种语法扩展，长得像html，但并不是html。\n   - React.js可以用jsx来描述你的组件长什么样。\n   - jsx在编译的时候会变成相应的js对象描述。\n   - react-dom负责把这个用来描述UI信息的js对象转变成dom元素并且渲染到页面中去。\n\n**渲染列表**\n\n对于用表达式套数组罗列到页面上的元素，都要为每个元素加上key属性，这个key必需是每个元素唯一的标识，一般来说，`key`的取值为后台传过来的`id`值。\n\n##### 在组件中使用style\n\n```js\nclass '组件名称' extends React.Component{\n    constructor(){\n        super();\n        this.state={ \n            msg:'hello',\n        }\n    }\n    //注意 在jsx语法中不能识别行内样式，不能为style设置字符串的值。\n    //正确的写法： style={ {color:'red'} }\n    render(){ \n        return <div style={ {color:'red' fontSize:'20px'} }>\n            这是一个div \n        <h3>{this.state.msg}</h3>\n        </div>;\n    }\n}\n```\n\n使用`localIdentName`自定义生成的类名格式，可选的参数有：\n\n- `[path]`表示样式表相对于**项目根目录**所在的路径\n\n- `[name]`表示样式表文件名称\n\n- `[local]`表示样式的类名定义名称\n\n- `[hash:length]`表示32位的hash值\n\n  例子：`{ test: /\\.css$/, use: ['style-loader','css-loader?modules&localIdentName=[path][name]-[local]-[hash:5]']}`\n\n使用`:local()`和`:global()`\n\n- `:local()`包裹的类名，是被模块化选中的。（默认）`className={cssObj.类名}`\n- `:global()`包裹的类名，是全局生效的，不会被模块化（`css-modules`）控制，定义的类名是什么，就使用定义的类名`className=\"类名\"`\n\n##### 在项目中使用模块化并同时使用bootstrap\n\n1. 把自己的样式表，定义为`.scss`文件\n\n2. 第三方的样式表还是以`.css`结尾\n\n3. 只为自己定义的`.scss`文件启用模块化即可\n\n4. 运行`npm i sass-loader node-sass -D` 安装能够解析`scss`文件的loader\n\n   例子：`{test: /\\.scss$/, use: ['style-loader','css-loader','sass-loader']}` 打包处理`.scss`文件的`loader`\n\n##### React中绑定事件的注意点\n\n1. 事件的名称都是React提供的，首字母大写`onClick`、`onMouseOver`，需要注意的是，这些事件监听只能用在普通的HTML标签上，而不能用在组件的标签上。\n\n   ```jsx\n   <Header onClick={...} />\n   ```\n\n   这样的写法是不对的，不会有什么效果。\n\n2. 为事件提供的处理函数，必须是如下格式\n\n3. ```js\n   onClick={function}\n   ```\n\n   用的最多的事件绑定形式为：\n\n   ```jsx\n   <button onClick={ () => this.show('参数') }>按钮</button>\n   \n   //事件的处理函数，需要定义为一个箭头函数，然后赋值给函数名称\n   show = (arg1) => {\n       console.log('show方法'+arg1);\n   }\n   ```\n\n4. 再React中，如果想要修改state中的数据，推荐使用`this.setState({ })`，此方法是**异步的**。\n\n用法:\n\n```js\nthis.setState({\n\tmsg:''\n},function(){\t//回调函数，若想得到最新的state值，需要再回调函数内部获取\n    \n})\n```\n\n5. 实现文本框数据双向更新\n\n   ```jsx\n   <input value={this.state.msg} onChange={(e)=>this.changeTxt(e)} ref=\"txt\"></input>\n   \n   textChange= (e) =>{\n       const newText=this.refs.txt.value; //或者等于e.target.value\n       this.setState({\n           msg: newText\n       })\n   }\n   ```\n\n6. event对象\n\n   和普通的浏览器一样，事件监听函数会被自动传入一个`event`对象，这个对象和普通的浏览器`event`对象所包含的方法和属性都基本一致。不过，`react.js`中的`event`是经过封装的，对外提供了统一的api，这样就不用考虑浏览器的兼容性问题。这个`event`对象符合`w3c`标准。它具有类似`event.stopPropagation`、`event.preventDefault`这种常用的方法。\n\n7. this问题\n\n   在`react`调用你所传入给它的方法的时候，并不是通过对象方法的方式去调用的，而是直接通过函数调用的，所以事件监听函数内并不能通过this获取到实例。\n\n   如果你想获取到当前的实例，需要手动将this bind进去。\n\n   ```jsx\n   class Title extends Component {\n     handleClickOnTitle (e) {\n       console.log(this)\n     }\n   \n     render () {\n       return (\n         <h1 onClick={this.handleClickOnTitle.bind(this)}>React 小书</h1>\n       )\n     }\n   }\n   ```\n\n\n##### React组件的生命周期分为三部分：\n\n> 这里只是列举了常用的生命周期，不包括所有的，如需了解其他的，请参考官方文档。\n\n*在了解生命周期之前，先介绍什么是挂载：*\n\n**组件的挂载：React.js将组件渲染，并且构造DOM元素然后塞入页面的过程称为组件的挂载。**\n\n**React.js会在组件的`render`之前调用`componentWillMount`，在DOM元素塞入页面以后调用`componentDidMount`**\n\n**一般来说，所有关于组件自身的状态的初始化工作都会放在`constructor`里面（比如React.js组件中的状态state就是在这个阶段初始化）**\n\n****\n\n- **组件的创建阶段**：特点，只会执行一次\n\n  > componentWillMount:（**常用来做一些组件启动的动作，包括像Ajax数据的拉取操作、一些定时器的启动等，就可以放在这个阶段去进行**）\n  >\n  > ```js\n  > //写一个Ajax\n  > componentWillMount(){\n  >     ajax.get('http://json-api.com/user',(userData)=>{\n  >         this.setState({userData})\n  >     })\n  > }\n  > ```\n  >\n  > render:（**react.js最重要的步骤，用来创建虚拟dom，进行Diff算法，更新dom树都在此进行，此时不能更改state**）\n  >\n  > **render之后会将虚拟dom渲染并插入到页面的根节点中**\n  >\n  > componentDidMount:（**此阶段组件已经渲染完毕，可以获取dom结点**）\n\n- **组件的运行阶段**：按需，根据props属性或state状态的改变，有选择性的执行0到多次\n\n  > componentWillReceiveProps:（**组件在接收新的props时调用，组件初始化时不调用**）\n  >\n  > shouldComponentUpdateL:（**react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在次对比前后两个props以及state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就可以避免创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，特别是在dom结构相对复杂的时候**）\n  >\n  > componentWillUpdate:（**组件初始化时不调用，组建更新调用**）\n  >\n  > render:（**组件再次渲染**）\n  >\n  > componentDidUpdate:（**此阶段类似`componentDidMount`，此时可以获取dom结点**）\n\n- **组件的销毁阶段**：只执行一次\n\n  > componentWillUnmount:（**它的作用主要是用来销毁一些数据事件监听以及定时器的**）\n\n##### React路由\n\n1. React-router\n\n   React-router提供了`Router`,`Route`,`Switch`等`router`的核心api，但是它没有提供dom操作进行相关跳转的api。\n\n2. React-router-dom\n\n   React-router-dom提供了`BrowserRouter`,`Route`,`Link`等api，可以通过它们来操作dom的事件从而控制路由。\n\n   用法：(以下两个是路由的基本，就像盖房子一样，要有地基，需要将它们包裹在最外层，作为路由的根节点，我们只需要选择它们其一就可以了)\n\n   1. HashRouter\n\n      > **特点：**它是通过hash值来对路由进行控制，如果你选择使用它，就会在url上看到#。\n      >\n      > **用法：**\n      >\n      > ![](react/231d414640b509d980203a5ab45a3c4e.png)\n      >\n      > ```html\n      > <Router>\n      >        <Layout className=\"layout\">\n      >             <Header>\n      >                 <Menu \n      >                   theme=\"dark\"\n      >                   mode=\"horizontal\"\n      >                   style={{lineHeight:'64px'}} >\n      >                     <Menu.Item key=\"1\" ><Link to=\"/home\"><Icon type=\"home\"/>首页</Link>\t\t\t\t\t\t   </Menu.Item>\n      >                     <Menu.Item key=\"2\"><Link to=\"/content\"><Icon type=\"file-text\"/>文档</Link>\t\t\t\t   </Menu.Item>\n      >                 </Menu>\n      >             </Header>\n      >             <Content>\n      >                 <Switch>\n      >                     <Route exact path=\"/\" component={home}></Route>\n      >                     <Route path=\"/home\" component={home}></Route>\n      >                     <Route path=\"/content\" component={content}></Route>\n      >                 </Switch>\n      >             </Content>\n      >        </Layout>\n      > </Router>\n      > ```\n      >\n      >\n\n   2. BrowserRouter\n\n      >**特点：**它的url看起来与正常的一样，不存在类似于`HashRouter`中出现的#\n      >\n      >**用法：**\n\n      > ```jsx\n      > import {BrowserRouter as Router, Link, Route, Switch} from 'react-router-dom'\n      > <Router>\n      >     <div>\n      >     \t<Route path=\"/\" component={home}></Route>\n      >     \t<Link to=\"/\">Home</Link>\n      > \t</div>\n      > </Router>\n      > ```\n      >\n      > **它的原理是使用HTML5 history API(pushState,replaceState,propState)来使你的内容随url的动态改变**\n      >\n      > 有一个常用的api，`basename`如果你的文件放在服务器的二级目录下则可以使用它。（你的主页前面有一级目录calendar可以这样使用）\n      >\n      > ```jsx\n      > <BrowserRouter basename=\"/calendar\">\n      >     <Route path=\"/\" component={home}></Route>\n      > </BrowserRouter>\n      > ```\n\n   3. Route\n\n      >**特点：**它是路由的原材料，用来控制路由对应显示的组件。我们常用它的`exact`、`path`以及`component`属性\n      >\n      >```jsx\n      ><Route exact path=\"/\" component={Home}></Route>\n      ><Route path=\"/second\" component={Second}></Route>\n      ><Route path=\"/third\" component={Third}></Route>\n      >```\n      >\n      >`exact`：用来控制匹配到/路径时，不会再继续往下匹配，用来进行精确定位。\n      >\n      >`path`：标识路由的路径。\n      >\n      >`component`：表示路径对应显示的组件。\n\n   4. Link\n\n      > **作用：**用来进行跳转的页面链接。\n      >\n      > ```jsx\n      > <Link to=\"/home\"></Link>\n      > <Link to={{\n      >         pathname:'/home',\n      >         search:'?sort=name',\n      >         hash:'#the-hash',\n      >         state:{fromDashboard:true}\n      >     }}></Link>\n      > ```\n      >\n      > 主要的API时to，可以接受string或者一个object，用来控制url。\n\n   5. NavLink\n\n      > **特点：**可以为当前选中的路由设置类名、样式以及回调函数等。\n      >\n      > ```jsx\n      > <NavLink exact activeClassName=\"selected\" to=\"/\">home</NavLink>\n      > <NavLink activeClassName=\"selected\" to=\"/second/1234\">second</NavLink>\n      > <Route path=\"/second/:id\" component={Second}></Route>\n      > ```\n      >\n      > `exact`：用于严格匹配，与route中的作用类似。\n      >\n      > `to`：用来控制url跳转。\n      >\n      > `activeClassName`：选中状态的类名，可以为其添加样式。\n      >\n      > 在second后添加/1234结合Route中/second/:id\n\n   6. match\n\n      > `match`时使用router之后会被放到props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。`match`中包含的信息如下：\n      >\n      > ```js\n      > {\n      >     path:\"/second/:id\",\n      >     url:\"/second/1234\",\n      >     isExact:true,\n      >     parms:{\n      >     \tid:\"1234\"        \n      >    \t}\n      > }\n      > ```\n      >\n      > **常用来获取id**\n\n   7. Switch\n\n      > 常用来包裹Route，里面不能放其他的元素。\n\n**路由嵌套**(子组件<Route>可以作为父<Route>的component属性值)\n\n```jsx\n<Route path=\"parent\" component={Parent}></Route>\nconst Parent=()=>(\n\t<div>\n    \t<Route path=\"child\" component={Child}></Route>\n        <Route path=\"other\" component={Other}></Route>\n    </div>\n)\n```\n\n**最后需要注意的是：`HashRouter`以及`BrowserRouter`使用时，其孩子节点只能有一个，例如：**\n\n```jsx\n<HashRouter>\n\t<div>\n    \t<Route path=\"/\" component={home}></Route>\n        <Link to=\"/\">home</Link>\n    </div>\n</HashRouter>\n<BrowserRouter>\n\t<div>\n    \t<Route path=\"/\" component={home}></Route>\n        <Link to=\"/\">home</Link>\n    </div>\n</BrowserRouter>\n```\n\n##### 组件的Render方法\n\n在`react.js`中，一切皆组件。我们在编写`react.js`组件的时候，一般需要继承`react.js`的`component`。一个组件的类必须要实现`render`方法，这个`render`方法必需返回一个JSX元素。需要注意的是，必需要有一个外层的jsx元素把所有内容包裹起来，返回并列多个JSX元素是不合法的。\n\n```jsx\n//错误的做法\nrender(){\n    return (\n    \t<div>第一个元素</div>\n    \t<div>第二个元素</div>\n    )\n}\n//正确的写法\nrender(){\n    return (\n        <div>\n        \t<div>第一个元素</div>\n    \t\t<div>第二个元素</div>\n        </div>\n    )\n}\n```\n\n**自定义组件都必须要大写字母开头，普通的HTML标题都用小写字母开头**\n\n##### 状态提升\n\n**状态提升：**当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用`props`传递数据或函数来管理这种依赖或者影响的关系。\n\n**组件的内容编写顺序如下：**\n\n1. `static`开头的类属性，如`defaultProps`、`propTypes`。\n2. 构造函数，`constructor`。\n3. `getter/setter`。\n4. 组件的生命周期。\n5. `_`开头的私有方法。\n6. 事件监听方法，`handle`。\n7. `render`开头的方法，有时候`render()`方法里面的内容会被分开到不同的函数里边进行，这些函数都以`render`开头。\n8. `render()`方法。\n\n##### **高阶组件：**\n\n什么是高阶组件：*高阶组件就是一个函数，传给它一个组件，返回一个新的组件。*\n\n重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件\n\n```jsx\nimport React, { Component } from 'react'\n\nexport default (WrappedComponent, name) => {\n  class NewComponent extends Component {\n    constructor () {\n      super()\n      this.state = { data: null }\n    }\n\n    componentWillMount () {\n      let data = localStorage.getItem(name)\n      this.setState({ data })\n    }\n\n    render () {\n      return <WrappedComponent data={this.state.data} />\n    }\n  }\n  return NewComponent\n}\n```\n\n**高阶组件的主要作用就是用来封装一些组件，提取出多个组件中代码逻辑相同的部分，编写一个高阶组件函数，可以提高代码的复用性。**\n\n\n\n##### propTypes组件参数验证\n\n使用：`npm install prop-types --save`\n\n它可以帮助我们验证`props`的参数类型，例如：\n\n```jsx\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nclass Comment extends Component {\n  static propTypes = {\n    comment: PropTypes.object\n  }\n\n  render () {\n    const { comment } = this.props\n    return (\n      <div className='comment'>\n        <div className='comment-user'>\n          <span>{comment.username} </span>：\n        </div>\n        <p>{comment.content}</p>\n      </div>\n    )\n  }\n}\n```\n\n注意我们在文件头部引入了 `PropTypes`，并且给 `Comment` 组件类添加了类属性 `propTypes`，里面的内容的意思就是你传入的 `comment` 类型必须为 `object`（对象）。*它可以帮助我们更好地去定位出现的错误，将控制台的错误信息展示的更加友好。*","slug":"react","published":1,"updated":"2024-02-19T07:42:51.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb100431xopciuk7jof","content":"<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><h5 id=\"React中的几个核心概念\"><a href=\"#React中的几个核心概念\" class=\"headerlink\" title=\"React中的几个核心概念\"></a>React中的几个核心概念</h5><ol>\n<li><p><strong>虚拟DOM</strong></p>\n<ul>\n<li><p><strong>DOM本质是什么</strong>：是浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API。</p>\n</li>\n<li><p><strong>什么是React中的虚拟DOM</strong>：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套。</p>\n</li>\n<li><p><strong>使用虚拟DOM的目的</strong>：为了实现页面中，DOM元素的高效更新。</p>\n</li>\n<li><p><strong>DOM和虚拟DOM之间的区别</strong>：</p>\n<ul>\n<li><p><strong>DOM</strong>：浏览器中提供的概念，用JS对象表示页面上的元素，并提供操作元素地API。</p>\n</li>\n<li><p><strong>虚拟DOM</strong>：是框架中的概念，开发框架的程序员手动用JS对象来模拟DOM元素和嵌套关系。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Odiv<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-index</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    div文本\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n        p文本\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">//使用js对象模拟DOM树</span>\n    <span class=\"token keyword\">var</span> div<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n        tagName<span class=\"token punctuation\">:</span><span class=\"token string\">'div'</span><span class=\"token punctuation\">,</span>\n        attr<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">class</span><span class=\"token punctuation\">:</span><span class=\"token string\">'Odiv'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">'data-index'</span><span class=\"token punctuation\">:</span><span class=\"token string\">'0'</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        childrens<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n            <span class=\"token string\">'div文本'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">{</span>\n                tagName<span class=\"token punctuation\">:</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span>\n                attr<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n                childrens<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n                    <span class=\"token string\">'p文本'</span>\n                <span class=\"token punctuation\">]</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Diff算法</strong></p>\n<ul>\n<li><p><strong>tree diff</strong>：新旧两颗DOM树逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。</p>\n</li>\n<li><p><strong>component diff</strong>：在进行Tree diff的时候，每一层中，组件级别的对比，叫做Component diff。</p>\n<ol>\n<li>如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。</li>\n<li>如果对比前后，组件类型不同，则需要移除旧的组件，创建新组件，并追加到页面上。</li>\n</ol>\n</li>\n<li><p><strong>element diff</strong>：进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这就叫做Element diff。</p>\n<p><img src=\"/2018/10/24/react/6873d82c40e03c3080a5f4098f6df602.png\" alt></p>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"在项目中使用react\"><a href=\"#在项目中使用react\" class=\"headerlink\" title=\"在项目中使用react\"></a>在项目中使用react</h5><ol>\n<li><p>运行<code>npm i react react-dom -S</code>安装包</p>\n<ul>\n<li>react：专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中</li>\n<li>react-dom：专门进行DOM操作的，最主要的应用场景，就是<code>ReactDOM.render()</code></li>\n</ul>\n</li>\n<li><p>在<code>index.html</code>页面中，创建容器：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 容器，在使用react创建的虚拟DOM元素，都会被渲染到这个指定的容器中 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>app<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在<code>index.js</code>中导入包：</p>\n</li>\n<li><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//1. 这两个包导入的时候，必需这么写</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>  <span class=\"token comment\" spellcheck=\"true\">//创建组件、虚拟DOM元素、生命周期</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span>  <span class=\"token comment\" spellcheck=\"true\">//把创建好的组件和虚拟DOM放到页面上展示</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//2. 创建虚拟DOM元素</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数1：创建的元素的类型，字符串，表示元素的名称</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数2：是一个对象或null，表示当前这个DOM元素的属性</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数3：子节点（包括其他虚拟DOM获取文本子节点）</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数n：其他子节点</span>\n<span class=\"token comment\" spellcheck=\"true\">//&lt;h1>这是一个h1标签&lt;/h1></span>\n<span class=\"token keyword\">const</span> myH1<span class=\"token operator\">=</span>React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h1'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token string\">'这是一个h1标签'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//3. 使用ReactDOM把虚拟DOM渲染到页面上</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数1：要渲染的那个虚拟DOM元素</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数2：指定页面上一个容器</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>myH1<span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用<code>babel</code>转换JS中的标签：</p>\n<blockquote>\n<p>什么是JSX语法：就是符合xml规范的JS语法。（语法格式相对HTML严谨很多）</p>\n</blockquote>\n<p><strong>注意：在JS中，混合写入类似于HTML的语法，叫做JSX语法。（默认无法识别，会报错，需要第三方转换插件）</strong></p>\n<p><strong>注意：JSX语法的本质，还是在运行的时候，被转换成了React.createElement形式来执行。</strong></p>\n<ol>\n<li><p>如何启用jsx语法：</p>\n<ul>\n<li><p>安装<code>babel</code>插件</p>\n<ul>\n<li><p>运行<code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code></p>\n</li>\n<li><p>运行<code>npm i babel-preset-env babel-preset-stage-0 -D</code></p>\n</li>\n</ul>\n</li>\n<li><p>安装能够识别转换JSX语法的包<code>babel-preset-react</code></p>\n<ul>\n<li><p>运行<code>npm i babel-preset-react -D</code></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//配置webpack.config.js文件</span>\n<span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> HtmlWebPackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'html-webpack-plugin'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//导入 在内存中自动生成index页面的插件</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//创建一个插件实例对象</span>\n<span class=\"token keyword\">const</span> htmlPlugin <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebPackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'./src/index.html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//源文件</span>\n    filename<span class=\"token punctuation\">:</span> <span class=\"token string\">'index.html'</span> <span class=\"token comment\" spellcheck=\"true\">//生成的内存中首页名称</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法</span>\nmodule<span class=\"token punctuation\">.</span>exports<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    mode<span class=\"token punctuation\">:</span><span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//development production</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js</span>\n    plugins<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n        htmlPlugin\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    module<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//所有第三放模块的配置规则</span>\n        rules<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span> <span class=\"token comment\" spellcheck=\"true\">//第三方匹配规则</span>\n            <span class=\"token punctuation\">{</span> test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.js|jsx$/</span><span class=\"token punctuation\">,</span>use<span class=\"token punctuation\">:</span> <span class=\"token string\">'babel-loader'</span><span class=\"token punctuation\">,</span>exclude<span class=\"token punctuation\">:</span> <span class=\"token regex\">/node_modules/</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//test匹配规则 use 使用插件 exclude 排除项</span>\n            <span class=\"token comment\" spellcheck=\"true\">//可以在 css-loader之后，通过? 追加参数</span>\n            <span class=\"token comment\" spellcheck=\"true\">//其中由两个固定的参数，叫做modules，表示为普通的css样式表，启用模块化</span>\n            <span class=\"token comment\" spellcheck=\"true\">//注意:css模块化只针对类选择器和ID选择器生效 不会将标签选择器模块化</span>\n            <span class=\"token punctuation\">{</span> test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.css$/</span><span class=\"token punctuation\">,</span> use<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'style-loader'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//打包处理css样式表的第三方loader</span>\n            <span class=\"token punctuation\">{</span>test<span class=\"token punctuation\">:</span> <span class=\"token regex\">/\\.ttf|woff|woff2|eot|svg$/</span><span class=\"token punctuation\">,</span> use<span class=\"token punctuation\">:</span> <span class=\"token string\">'url-loader'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//打包处理 字体文件的loader</span>\n        <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    resolve<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n        extensions<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">'.js'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'jsx'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'.json'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//表示，这几个文件的后缀名可以省略不写</span>\n        alias<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n            <span class=\"token string\">'@'</span><span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'./src'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//这样，@表示项目根目录中src的这一层路径</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"配置babel配置文件\"><a href=\"#配置babel配置文件\" class=\"headerlink\" title=\"配置babel配置文件\"></a>配置<code>babel</code>配置文件</h5><p>在项目的根目录中创建文件后缀为<code>.babelrc</code>的文件</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n     <span class=\"token property\">\"presets\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"env\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"stage-0\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"react\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"plugins\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"transform-runtime\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在<code>index.js</code>文件中使用JSX语法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 这两个包导入的时候，必需这么写</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>  <span class=\"token comment\" spellcheck=\"true\">//创建组件、虚拟DOM元素、生命周期</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span>  <span class=\"token comment\" spellcheck=\"true\">//把创建好的组件和虚拟DOM放到页面上展示</span>\n\n<span class=\"token keyword\">let</span> a<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> str<span class=\"token operator\">=</span><span class=\"token string\">\"你好！\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> boo<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> title<span class=\"token operator\">=</span><span class=\"token string\">\"titleName\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> h1<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>这是一个H1<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> arr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span>\n    <span class=\"token operator\">&lt;</span>h2<span class=\"token operator\">></span>这是h2<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h2<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>h3<span class=\"token operator\">></span>这是h3<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h3<span class=\"token operator\">></span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> arrstr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'张三'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'李四'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'王五'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 使用ReactDOM把虚拟DOM渲染到页面上</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数1：要渲染的那个虚拟DOM元素</span>\n<span class=\"token comment\" spellcheck=\"true\">//参数2：指定页面上一个容器</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n                <span class=\"token punctuation\">{</span>a<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//12</span>\n                <span class=\"token punctuation\">{</span>str<span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//你好</span>\n                <span class=\"token punctuation\">{</span>boo <span class=\"token operator\">?</span> <span class=\"token string\">'条件为真'</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">'条件为假'</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\">//条件为真</span>\n                <span class=\"token operator\">&lt;</span>p title<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>title<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>P标签<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n                <span class=\"token punctuation\">{</span>h1<span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">{</span>arr<span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">{</span>arrstr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>h5<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h5<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n                <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"创建组件的方式\"><a href=\"#创建组件的方式\" class=\"headerlink\" title=\"创建组件的方式\"></a>创建组件的方式</h5><ol>\n<li><p>第一种：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//导入包</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//第一种创建组件的方式 (是一个构造函数，首字母大写)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Hello</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>这是Hello组件 <span class=\"token operator\">--</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">--</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>gender<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//定义参数变量</span>\n<span class=\"token keyword\">const</span> dog<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span><span class=\"token string\">'阿旺'</span><span class=\"token punctuation\">,</span>\n    gender<span class=\"token punctuation\">:</span><span class=\"token string\">'雄'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//调用render函数渲染 jsx xml 比HTML严格的多</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>Hello name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>dog<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span> gender<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>dog<span class=\"token punctuation\">.</span>gender<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Hello<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'app'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>第二种：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//如果要使用class定义组件，必需让自己的组件，继承自React.Component</span>\n<span class=\"token keyword\">class</span> <span class=\"token string\">'组件名称'</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//构造器</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//子类的自定义构造器中必需先调用super()</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//只有调用了super才能使用this关键字</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//相当于vue中的data(){ return{} }</span>\n            msg<span class=\"token punctuation\">:</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在组件内部，必须有render函数 作用：渲染当前组件对应的虚拟DOM结构</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//render函数中必需返回合法的jsx虚拟dom结构</span>\n        <span class=\"token comment\" spellcheck=\"true\">//在class关键字中创建的组件，如果要访问外界传递的参数，不需接收，直接this.props.***就可以访问</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n            这是一个div \n        <span class=\"token operator\">&lt;</span>h3<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>msg<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h3<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>两种创建组件方式的区别：</strong></p>\n<blockquote>\n<p>注意：使用<code>class</code>创建的组件，有自己的私有数据和生命周期函数；</p>\n<p>使用<code>function</code>创建的组件，只有props，没有自己的私有数据和生命周期；</p>\n<ol>\n<li>用<strong>构造函数</strong>创建出来的组件：叫做“无状态组件”</li>\n<li>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”</li>\n<li>有状态组件和无状态组件的本指区别就是：有无state属性</li>\n</ol>\n</blockquote>\n<p>组件中的<code>props</code>和<code>state/data</code>之间的区别：</p>\n<ul>\n<li><code>porps</code>中的数据都是外界传递过来的；</li>\n<li><code>state/data</code>中的数据，都是组件的私有数据（通过Ajax传递过来的）；</li>\n<li><code>props</code>中的数据都是只读的，不能被重新赋值；</li>\n<li><code>state/data</code>中的数据，都是可读可写的；</li>\n<li><code>state</code>是让组件控制自己的状态的，<code>props</code>是让外部对组件进行自我配置的。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"组件的props\"><a href=\"#组件的props\" class=\"headerlink\" title=\"组件的props\"></a>组件的props</h5><p>​    在使用一个组件的时候，可以把参数放在标签的属性当中，所用属性都会作为<code>props</code>对象的键值。甚至可以传入一个函数作为属性的参数。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Index</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  render <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>LikeButton</span>\n          <span class=\"token attr-name\">wordings</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>likedText<span class=\"token punctuation\">:</span> <span class=\"token string\">'已赞'</span><span class=\"token punctuation\">,</span> unlikedText<span class=\"token punctuation\">:</span> <span class=\"token string\">'赞'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span>\n          <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Click on like button!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">/></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以通过<code>this.props.onClick</code>获取到这个传进去的函数。</p>\n<ol>\n<li><p>默认配置defaultProps</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Link</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> defaultProps<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n        liked<span class=\"token punctuation\">:</span><span class=\"token string\">'喜欢'</span><span class=\"token punctuation\">,</span>\n        unlike<span class=\"token punctuation\">:</span><span class=\"token string\">'不喜欢'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>props不可变</p>\n<blockquote>\n<p><code>props</code>一旦传入进来就不能改变。如果想要去改变，只能是从父组件重新传入新的内容进行重新渲染的方式去改变。</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"组件抽离为JSX文件\"><a href=\"#组件抽离为JSX文件\" class=\"headerlink\" title=\"组件抽离为JSX文件\"></a>组件抽离为JSX文件</h5><p><strong>注意：所谓jsx其实就是js对象</strong></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\" spellcheck=\"true\">// components/Hello.jsx</span>\n<span class=\"token comment\" spellcheck=\"true\">//需要导入React</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Hello</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//定义组件并导出</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>这是一个Hello组件 <span class=\"token operator\">--</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">--</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>gender<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//导入包</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//导入组件</span>\n<span class=\"token comment\" spellcheck=\"true\">//默认，如果不做单独的配置的话，不能省略.jsx后缀名</span>\n<span class=\"token keyword\">import</span> Hello <span class=\"token keyword\">from</span> <span class=\"token string\">'./components/Hello.jsx'</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//定义参数变量</span>\n<span class=\"token keyword\">const</span> dog<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    name<span class=\"token punctuation\">:</span><span class=\"token string\">'阿旺'</span><span class=\"token punctuation\">,</span>\n    gender<span class=\"token punctuation\">:</span><span class=\"token string\">'雄'</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//调用render函数渲染 jsx xml 比HTML严格的多</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span>Hello name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>dog<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span> gender<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>dog<span class=\"token punctuation\">.</span>gender<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Hello<span class=\"token operator\">></span>\n                <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'app'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>jsx到页面到底经过了怎样的过程呢？</strong></p>\n<p><img src=\"/2018/10/24/react/35cc29484072961d801e4de7f94c3b65.png\" alt></p>\n<p>为什么不直接从jsx直接渲染构造DOM结构呢？</p>\n<ol>\n<li>第一个原因是：当我们拿到一个表示ui的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能会将它们渲染到canvas或者是手机app上。而js对象可以很方便让我们去进行其他地方的渲染。（ReactNative就是帮我们把它转换成原生的app的）</li>\n<li>第二个原因是：有了这一个对象，当数据变化，需要更新组件的时候，就可以用比较块的算法操作这个js对象，而不用直接去操作页面中的dom元素，这样可以尽可能的减少浏览器的重排，优化性能。</li>\n<li>总结：<ul>\n<li>jsx是js语言的一种语法扩展，长得像html，但并不是html。</li>\n<li>React.js可以用jsx来描述你的组件长什么样。</li>\n<li>jsx在编译的时候会变成相应的js对象描述。</li>\n<li>react-dom负责把这个用来描述UI信息的js对象转变成dom元素并且渲染到页面中去。</li>\n</ul>\n</li>\n</ol>\n<p><strong>渲染列表</strong></p>\n<p>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上key属性，这个key必需是每个元素唯一的标识，一般来说，<code>key</code>的取值为后台传过来的<code>id</code>值。</p>\n<h5 id=\"在组件中使用style\"><a href=\"#在组件中使用style\" class=\"headerlink\" title=\"在组件中使用style\"></a>在组件中使用style</h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token string\">'组件名称'</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> \n            msg<span class=\"token punctuation\">:</span><span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//注意 在jsx语法中不能识别行内样式，不能为style设置字符串的值。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//正确的写法： style={ {color:'red'} }</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n        <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">{</span>color<span class=\"token punctuation\">:</span><span class=\"token string\">'red'</span> fontSize<span class=\"token punctuation\">:</span><span class=\"token string\">'20px'</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            这是一个div \n        <span class=\"token operator\">&lt;</span>h3<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>msg<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h3<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用<code>localIdentName</code>自定义生成的类名格式，可选的参数有：</p>\n<ul>\n<li><p><code>[path]</code>表示样式表相对于<strong>项目根目录</strong>所在的路径</p>\n</li>\n<li><p><code>[name]</code>表示样式表文件名称</p>\n</li>\n<li><p><code>[local]</code>表示样式的类名定义名称</p>\n</li>\n<li><p><code>[hash:length]</code>表示32位的hash值</p>\n<p>例子：<code>{ test: /\\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]&#39;]}</code></p>\n</li>\n</ul>\n<p>使用<code>:local()</code>和<code>:global()</code></p>\n<ul>\n<li><code>:local()</code>包裹的类名，是被模块化选中的。（默认）<code>className={cssObj.类名}</code></li>\n<li><code>:global()</code>包裹的类名，是全局生效的，不会被模块化（<code>css-modules</code>）控制，定义的类名是什么，就使用定义的类名<code>className=&quot;类名&quot;</code></li>\n</ul>\n<h5 id=\"在项目中使用模块化并同时使用bootstrap\"><a href=\"#在项目中使用模块化并同时使用bootstrap\" class=\"headerlink\" title=\"在项目中使用模块化并同时使用bootstrap\"></a>在项目中使用模块化并同时使用bootstrap</h5><ol>\n<li><p>把自己的样式表，定义为<code>.scss</code>文件</p>\n</li>\n<li><p>第三方的样式表还是以<code>.css</code>结尾</p>\n</li>\n<li><p>只为自己定义的<code>.scss</code>文件启用模块化即可</p>\n</li>\n<li><p>运行<code>npm i sass-loader node-sass -D</code> 安装能够解析<code>scss</code>文件的loader</p>\n<p>例子：<code>{test: /\\.scss$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]}</code> 打包处理<code>.scss</code>文件的<code>loader</code></p>\n</li>\n</ol>\n<h5 id=\"React中绑定事件的注意点\"><a href=\"#React中绑定事件的注意点\" class=\"headerlink\" title=\"React中绑定事件的注意点\"></a>React中绑定事件的注意点</h5><ol>\n<li><p>事件的名称都是React提供的，首字母大写<code>onClick</code>、<code>onMouseOver</code>，需要注意的是，这些事件监听只能用在普通的HTML标签上，而不能用在组件的标签上。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Header</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这样的写法是不对的，不会有什么效果。</p>\n</li>\n<li><p>为事件提供的处理函数，必须是如下格式</p>\n</li>\n<li><pre class=\"line-numbers language-js\"><code class=\"language-js\">onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>用的最多的事件绑定形式为：</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">show</span><span class=\"token punctuation\">(</span><span class=\"token string\">'参数'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span>按钮<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">//事件的处理函数，需要定义为一个箭头函数，然后赋值给函数名称</span>\nshow <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arg1<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'show方法'</span><span class=\"token operator\">+</span>arg1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>再React中，如果想要修改state中的数据，推荐使用<code>this.setState({ })</code>，此方法是<strong>异步的</strong>。</p>\n</li>\n</ol>\n<p>用法:</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    msg<span class=\"token punctuation\">:</span><span class=\"token string\">''</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//回调函数，若想得到最新的state值，需要再回调函数内部获取</span>\n\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"5\">\n<li><p>实现文本框数据双向更新</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>msg<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">changeTxt</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>txt<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>input</span><span class=\"token punctuation\">></span></span>\n\ntextChange<span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> newText<span class=\"token operator\">=</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>refs<span class=\"token punctuation\">.</span>txt<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//或者等于e.target.value</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        msg<span class=\"token punctuation\">:</span> newText\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>event对象</p>\n<p>和普通的浏览器一样，事件监听函数会被自动传入一个<code>event</code>对象，这个对象和普通的浏览器<code>event</code>对象所包含的方法和属性都基本一致。不过，<code>react.js</code>中的<code>event</code>是经过封装的，对外提供了统一的api，这样就不用考虑浏览器的兼容性问题。这个<code>event</code>对象符合<code>w3c</code>标准。它具有类似<code>event.stopPropagation</code>、<code>event.preventDefault</code>这种常用的方法。</p>\n</li>\n<li><p>this问题</p>\n<p>在<code>react</code>调用你所传入给它的方法的时候，并不是通过对象方法的方式去调用的，而是直接通过函数调用的，所以事件监听函数内并不能通过this获取到实例。</p>\n<p>如果你想获取到当前的实例，需要手动将this bind进去。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Title</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  handleClickOnTitle <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  render <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleClickOnTitle<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span>React 小书<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<h5 id=\"React组件的生命周期分为三部分：\"><a href=\"#React组件的生命周期分为三部分：\" class=\"headerlink\" title=\"React组件的生命周期分为三部分：\"></a>React组件的生命周期分为三部分：</h5><blockquote>\n<p>这里只是列举了常用的生命周期，不包括所有的，如需了解其他的，请参考官方文档。</p>\n</blockquote>\n<p><em>在了解生命周期之前，先介绍什么是挂载：</em></p>\n<p><strong>组件的挂载：React.js将组件渲染，并且构造DOM元素然后塞入页面的过程称为组件的挂载。</strong></p>\n<p><strong>React.js会在组件的<code>render</code>之前调用<code>componentWillMount</code>，在DOM元素塞入页面以后调用<code>componentDidMount</code></strong></p>\n<p><strong>一般来说，所有关于组件自身的状态的初始化工作都会放在<code>constructor</code>里面（比如React.js组件中的状态state就是在这个阶段初始化）</strong></p>\n<hr>\n<ul>\n<li><p><strong>组件的创建阶段</strong>：特点，只会执行一次</p>\n<blockquote>\n<p>componentWillMount:（<strong>常用来做一些组件启动的动作，包括像Ajax数据的拉取操作、一些定时器的启动等，就可以放在这个阶段去进行</strong>）</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//写一个Ajax</span>\n<span class=\"token function\">componentWillMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    ajax<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://json-api.com/user'</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>userData<span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>userData<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>render:（<strong>react.js最重要的步骤，用来创建虚拟dom，进行Diff算法，更新dom树都在此进行，此时不能更改state</strong>）</p>\n<p><strong>render之后会将虚拟dom渲染并插入到页面的根节点中</strong></p>\n<p>componentDidMount:（<strong>此阶段组件已经渲染完毕，可以获取dom结点</strong>）</p>\n</blockquote>\n</li>\n<li><p><strong>组件的运行阶段</strong>：按需，根据props属性或state状态的改变，有选择性的执行0到多次</p>\n<blockquote>\n<p>componentWillReceiveProps:（<strong>组件在接收新的props时调用，组件初始化时不调用</strong>）</p>\n<p>shouldComponentUpdateL:（<strong>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在次对比前后两个props以及state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就可以避免创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，特别是在dom结构相对复杂的时候</strong>）</p>\n<p>componentWillUpdate:（<strong>组件初始化时不调用，组建更新调用</strong>）</p>\n<p>render:（<strong>组件再次渲染</strong>）</p>\n<p>componentDidUpdate:（<strong>此阶段类似<code>componentDidMount</code>，此时可以获取dom结点</strong>）</p>\n</blockquote>\n</li>\n<li><p><strong>组件的销毁阶段</strong>：只执行一次</p>\n<blockquote>\n<p>componentWillUnmount:（<strong>它的作用主要是用来销毁一些数据事件监听以及定时器的</strong>）</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"React路由\"><a href=\"#React路由\" class=\"headerlink\" title=\"React路由\"></a>React路由</h5><ol>\n<li><p>React-router</p>\n<p>React-router提供了<code>Router</code>,<code>Route</code>,<code>Switch</code>等<code>router</code>的核心api，但是它没有提供dom操作进行相关跳转的api。</p>\n</li>\n<li><p>React-router-dom</p>\n<p>React-router-dom提供了<code>BrowserRouter</code>,<code>Route</code>,<code>Link</code>等api，可以通过它们来操作dom的事件从而控制路由。</p>\n<p>用法：(以下两个是路由的基本，就像盖房子一样，要有地基，需要将它们包裹在最外层，作为路由的根节点，我们只需要选择它们其一就可以了)</p>\n<ol>\n<li><p>HashRouter</p>\n<blockquote>\n<p><strong>特点：</strong>它是通过hash值来对路由进行控制，如果你选择使用它，就会在url上看到#。</p>\n<p><strong>用法：</strong></p>\n<p><img src=\"/2018/10/24/react/231d414640b509d980203a5ab45a3c4e.png\" alt></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Router</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Layout</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>layout<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Header</span><span class=\"token punctuation\">></span></span>\n                &lt;Menu \n                  theme=\"dark\"\n                  mode=\"horizontal\"\n                  style={{lineHeight:'64px'}} >\n                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Menu.Item</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/home<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Icon</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>home<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>首页<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>                           <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Menu.Item</span><span class=\"token punctuation\">></span></span>\n                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Menu.Item</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/content<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Icon</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>file-text<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>文档<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>                   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Menu.Item</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Menu</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Header</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Content</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Switch</span><span class=\"token punctuation\">></span></span>\n                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">exact</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{home}</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/home<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{home}</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n                    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/content<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{content}</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n                <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Switch</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Content</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Layout</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Router</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>BrowserRouter</p>\n<blockquote>\n<p><strong>特点：</strong>它的url看起来与正常的一样，不存在类似于<code>HashRouter</code>中出现的#</p>\n<p><strong>用法：</strong></p>\n</blockquote>\n<blockquote>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>BrowserRouter <span class=\"token keyword\">as</span> Router<span class=\"token punctuation\">,</span> Link<span class=\"token punctuation\">,</span> Route<span class=\"token punctuation\">,</span> Switch<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-router-dom'</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Router</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>home<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Home<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Router</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>它的原理是使用HTML5 history API(pushState,replaceState,propState)来使你的内容随url的动态改变</strong></p>\n<p>有一个常用的api，<code>basename</code>如果你的文件放在服务器的二级目录下则可以使用它。（你的主页前面有一级目录calendar可以这样使用）</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>BrowserRouter</span> <span class=\"token attr-name\">basename</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/calendar<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>home<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>BrowserRouter</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</blockquote>\n</li>\n<li><p>Route</p>\n<blockquote>\n<p><strong>特点：</strong>它是路由的原材料，用来控制路由对应显示的组件。我们常用它的<code>exact</code>、<code>path</code>以及<code>component</code>属性</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">exact</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Home<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/second<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Second<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/third<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Third<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><code>exact</code>：用来控制匹配到/路径时，不会再继续往下匹配，用来进行精确定位。</p>\n<p><code>path</code>：标识路由的路径。</p>\n<p><code>component</code>：表示路径对应显示的组件。</p>\n</blockquote>\n</li>\n<li><p>Link</p>\n<blockquote>\n<p><strong>作用：</strong>用来进行跳转的页面链接。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/home<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to={{</span>\n      <span class=\"token punctuation\">></span></span>         pathname<span class=\"token punctuation\">:</span><span class=\"token string\">'/home'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token operator\">></span>         search<span class=\"token punctuation\">:</span><span class=\"token string\">'?sort=name'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token operator\">></span>         hash<span class=\"token punctuation\">:</span><span class=\"token string\">'#the-hash'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token operator\">></span>         state<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>fromDashboard<span class=\"token punctuation\">:</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">></span>     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>主要的API时to，可以接受string或者一个object，用来控制url。</p>\n</blockquote>\n</li>\n<li><p>NavLink</p>\n<blockquote>\n<p><strong>特点：</strong>可以为当前选中的路由设置类名、样式以及回调函数等。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>NavLink</span> <span class=\"token attr-name\">exact</span> <span class=\"token attr-name\">activeClassName</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>selected<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>home<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>NavLink</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>NavLink</span> <span class=\"token attr-name\">activeClassName</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>selected<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/second/1234<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>second<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>NavLink</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/second/:id<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Second<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><code>exact</code>：用于严格匹配，与route中的作用类似。</p>\n<p><code>to</code>：用来控制url跳转。</p>\n<p><code>activeClassName</code>：选中状态的类名，可以为其添加样式。</p>\n<p>在second后添加/1234结合Route中/second/:id</p>\n</blockquote>\n</li>\n<li><p>match</p>\n<blockquote>\n<p><code>match</code>时使用router之后会被放到props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。<code>match</code>中包含的信息如下：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    path<span class=\"token punctuation\">:</span><span class=\"token string\">\"/second/:id\"</span><span class=\"token punctuation\">,</span>\n    url<span class=\"token punctuation\">:</span><span class=\"token string\">\"/second/1234\"</span><span class=\"token punctuation\">,</span>\n    isExact<span class=\"token punctuation\">:</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    parms<span class=\"token punctuation\">:</span><span class=\"token punctuation\">{</span>\n        id<span class=\"token punctuation\">:</span><span class=\"token string\">\"1234\"</span>        \n       <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>常用来获取id</strong></p>\n</blockquote>\n</li>\n<li><p>Switch</p>\n<blockquote>\n<p>常用来包裹Route，里面不能放其他的元素。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>路由嵌套</strong>(子组件<Route>可以作为父<Route>的component属性值)</Route></Route></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Parent<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n<span class=\"token keyword\">const</span> Parent<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>child<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Child<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>other<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>Other<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>最后需要注意的是：<code>HashRouter</code>以及<code>BrowserRouter</code>使用时，其孩子节点只能有一个，例如：</strong></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>HashRouter</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>home<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>home<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>HashRouter</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>BrowserRouter</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Route</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">component</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span>home<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Route</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Link</span> <span class=\"token attr-name\">to</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>home<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Link</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>BrowserRouter</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"组件的Render方法\"><a href=\"#组件的Render方法\" class=\"headerlink\" title=\"组件的Render方法\"></a>组件的Render方法</h5><p>在<code>react.js</code>中，一切皆组件。我们在编写<code>react.js</code>组件的时候，一般需要继承<code>react.js</code>的<code>component</code>。一个组件的类必须要实现<code>render</code>方法，这个<code>render</code>方法必需返回一个JSX元素。需要注意的是，必需要有一个外层的jsx元素把所有内容包裹起来，返回并列多个JSX元素是不合法的。</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\" spellcheck=\"true\">//错误的做法</span>\n<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>第一个元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>第二个元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//正确的写法</span>\n<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>第一个元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>第二个元素<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>自定义组件都必须要大写字母开头，普通的HTML标题都用小写字母开头</strong></p>\n<h5 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h5><p><strong>状态提升：</strong>当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用<code>props</code>传递数据或函数来管理这种依赖或者影响的关系。</p>\n<p><strong>组件的内容编写顺序如下：</strong></p>\n<ol>\n<li><code>static</code>开头的类属性，如<code>defaultProps</code>、<code>propTypes</code>。</li>\n<li>构造函数，<code>constructor</code>。</li>\n<li><code>getter/setter</code>。</li>\n<li>组件的生命周期。</li>\n<li><code>_</code>开头的私有方法。</li>\n<li>事件监听方法，<code>handle</code>。</li>\n<li><code>render</code>开头的方法，有时候<code>render()</code>方法里面的内容会被分开到不同的函数里边进行，这些函数都以<code>render</code>开头。</li>\n<li><code>render()</code>方法。</li>\n</ol>\n<h5 id=\"高阶组件：\"><a href=\"#高阶组件：\" class=\"headerlink\" title=\"高阶组件：\"></a><strong>高阶组件：</strong></h5><p>什么是高阶组件：<em>高阶组件就是一个函数，传给它一个组件，返回一个新的组件。</em></p>\n<p>重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">(</span>WrappedComponent<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">NewComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n    constructor <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    componentWillMount <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> data <span class=\"token operator\">=</span> localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> data <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    render <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>WrappedComponent</span> <span class=\"token attr-name\">data</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> NewComponent\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>高阶组件的主要作用就是用来封装一些组件，提取出多个组件中代码逻辑相同的部分，编写一个高阶组件函数，可以提高代码的复用性。</strong></p>\n<h5 id=\"propTypes组件参数验证\"><a href=\"#propTypes组件参数验证\" class=\"headerlink\" title=\"propTypes组件参数验证\"></a>propTypes组件参数验证</h5><p>使用：<code>npm install prop-types --save</code></p>\n<p>它可以帮助我们验证<code>props</code>的参数类型，例如：</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span>\n<span class=\"token keyword\">import</span> PropTypes <span class=\"token keyword\">from</span> <span class=\"token string\">'prop-types'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Comment</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">static</span> propTypes <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    comment<span class=\"token punctuation\">:</span> PropTypes<span class=\"token punctuation\">.</span>object\n  <span class=\"token punctuation\">}</span>\n\n  render <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> comment <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">'</span>comment<span class=\"token punctuation\">'</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">'</span>comment-user<span class=\"token punctuation\">'</span></span><span class=\"token punctuation\">></span></span>\n          <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>comment<span class=\"token punctuation\">.</span>username<span class=\"token punctuation\">}</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>：\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>comment<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意我们在文件头部引入了 <code>PropTypes</code>，并且给 <code>Comment</code> 组件类添加了类属性 <code>propTypes</code>，里面的内容的意思就是你传入的 <code>comment</code> 类型必须为 <code>object</code>（对象）。<em>它可以帮助我们更好地去定位出现的错误，将控制台的错误信息展示的更加友好。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><h5 id=\"React中的几个核心概念\"><a href=\"#React中的几个核心概念\" class=\"headerlink\" title=\"React中的几个核心概念\"></a>React中的几个核心概念</h5><ol>\n<li><p><strong>虚拟DOM</strong></p>\n<ul>\n<li><p><strong>DOM本质是什么</strong>：是浏览器中的概念，用JS对象来表示页面上的元素，并提供了操作DOM对象的API。</p>\n</li>\n<li><p><strong>什么是React中的虚拟DOM</strong>：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套。</p>\n</li>\n<li><p><strong>使用虚拟DOM的目的</strong>：为了实现页面中，DOM元素的高效更新。</p>\n</li>\n<li><p><strong>DOM和虚拟DOM之间的区别</strong>：</p>\n<ul>\n<li><p><strong>DOM</strong>：浏览器中提供的概念，用JS对象表示页面上的元素，并提供操作元素地API。</p>\n</li>\n<li><p><strong>虚拟DOM</strong>：是框架中的概念，开发框架的程序员手动用JS对象来模拟DOM元素和嵌套关系。</p>\n<pre><code class=\"html\">&lt;div class=&quot;Odiv&quot; data-index=&quot;0&quot;&gt;\n    div文本\n    &lt;p&gt;\n        p文本\n    &lt;/p&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    //使用js对象模拟DOM树\n    var div={\n        tagName:&#39;div&#39;,\n        attr:{\n            class:&#39;Odiv&#39;,\n            &#39;data-index&#39;:&#39;0&#39;\n        },\n        childrens:[\n            &#39;div文本&#39;,\n            {\n                tagName:&#39;p&#39;,\n                attr:{},\n                childrens:[\n                    &#39;p文本&#39;\n                ]\n            }\n        ]\n    }\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Diff算法</strong></p>\n<ul>\n<li><p><strong>tree diff</strong>：新旧两颗DOM树逐层对比的过程，就是Tree Diff，当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。</p>\n</li>\n<li><p><strong>component diff</strong>：在进行Tree diff的时候，每一层中，组件级别的对比，叫做Component diff。</p>\n<ol>\n<li>如果对比前后，组件的类型相同，则暂时认为此组件不需要被更新。</li>\n<li>如果对比前后，组件类型不同，则需要移除旧的组件，创建新组件，并追加到页面上。</li>\n</ol>\n</li>\n<li><p><strong>element diff</strong>：进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这就叫做Element diff。</p>\n<p><img src=\"/2018/10/24/react/6873d82c40e03c3080a5f4098f6df602.png\" alt></p>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"在项目中使用react\"><a href=\"#在项目中使用react\" class=\"headerlink\" title=\"在项目中使用react\"></a>在项目中使用react</h5><ol>\n<li><p>运行<code>npm i react react-dom -S</code>安装包</p>\n<ul>\n<li>react：专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中</li>\n<li>react-dom：专门进行DOM操作的，最主要的应用场景，就是<code>ReactDOM.render()</code></li>\n</ul>\n</li>\n<li><p>在<code>index.html</code>页面中，创建容器：</p>\n<pre><code class=\"html\">&lt;!-- 容器，在使用react创建的虚拟DOM元素，都会被渲染到这个指定的容器中 --&gt;\n&lt;div id=&quot;app&quot;&gt;\n\n&lt;/div&gt;\n</code></pre>\n</li>\n<li><p>在<code>index.js</code>中导入包：</p>\n</li>\n<li><pre><code class=\"js\">//1. 这两个包导入的时候，必需这么写\nimport React from &#39;react&#39;  //创建组件、虚拟DOM元素、生命周期\nimport ReactDOM from &#39;react-dom&#39;  //把创建好的组件和虚拟DOM放到页面上展示\n\n//2. 创建虚拟DOM元素\n//参数1：创建的元素的类型，字符串，表示元素的名称\n//参数2：是一个对象或null，表示当前这个DOM元素的属性\n//参数3：子节点（包括其他虚拟DOM获取文本子节点）\n//参数n：其他子节点\n//&lt;h1&gt;这是一个h1标签&lt;/h1&gt;\nconst myH1=React.createElement(&#39;h1&#39;,null,&#39;这是一个h1标签&#39;)\n\n//3. 使用ReactDOM把虚拟DOM渲染到页面上\n//参数1：要渲染的那个虚拟DOM元素\n//参数2：指定页面上一个容器\nReactDOM.render(myH1,document.getElementById(&quot;app&quot;))\n</code></pre>\n<p>使用<code>babel</code>转换JS中的标签：</p>\n<blockquote>\n<p>什么是JSX语法：就是符合xml规范的JS语法。（语法格式相对HTML严谨很多）</p>\n</blockquote>\n<p><strong>注意：在JS中，混合写入类似于HTML的语法，叫做JSX语法。（默认无法识别，会报错，需要第三方转换插件）</strong></p>\n<p><strong>注意：JSX语法的本质，还是在运行的时候，被转换成了React.createElement形式来执行。</strong></p>\n<ol>\n<li><p>如何启用jsx语法：</p>\n<ul>\n<li><p>安装<code>babel</code>插件</p>\n<ul>\n<li><p>运行<code>npm i babel-core babel-loader babel-plugin-transform-runtime -D</code></p>\n</li>\n<li><p>运行<code>npm i babel-preset-env babel-preset-stage-0 -D</code></p>\n</li>\n</ul>\n</li>\n<li><p>安装能够识别转换JSX语法的包<code>babel-preset-react</code></p>\n<ul>\n<li><p>运行<code>npm i babel-preset-react -D</code></p>\n<pre><code class=\"js\">//配置webpack.config.js文件\nconst path = require(&#39;path&#39;)\nconst HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;) //导入 在内存中自动生成index页面的插件\n\n//创建一个插件实例对象\nconst htmlPlugin = new HtmlWebPackPlugin({\n    template: path.join(__dirname, &#39;./src/index.html&#39;), //源文件\n    filename: &#39;index.html&#39; //生成的内存中首页名称\n})\n\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:&#39;production&#39;, //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -&gt; index.js\n    plugins:[\n        htmlPlugin\n    ],\n    module:{ //所有第三放模块的配置规则\n        rules:[ //第三方匹配规则\n            { test: /\\.js|jsx$/,use: &#39;babel-loader&#39;,exclude: /node_modules/ }, //test匹配规则 use 使用插件 exclude 排除项\n            //可以在 css-loader之后，通过? 追加参数\n            //其中由两个固定的参数，叫做modules，表示为普通的css样式表，启用模块化\n            //注意:css模块化只针对类选择器和ID选择器生效 不会将标签选择器模块化\n            { test: /\\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]&#39;]}, //打包处理css样式表的第三方loader\n            {test: /\\.ttf|woff|woff2|eot|svg$/, use: &#39;url-loader&#39;}, //打包处理 字体文件的loader\n        ]\n    },\n    resolve:{\n        extensions:[&#39;.js&#39;,&#39;jsx&#39;,&#39;.json&#39;], //表示，这几个文件的后缀名可以省略不写\n        alias:{\n            &#39;@&#39;: path.join(__dirname, &#39;./src&#39;) //这样，@表示项目根目录中src的这一层路径\n        }\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"配置babel配置文件\"><a href=\"#配置babel配置文件\" class=\"headerlink\" title=\"配置babel配置文件\"></a>配置<code>babel</code>配置文件</h5><p>在项目的根目录中创建文件后缀为<code>.babelrc</code>的文件</p>\n<pre><code class=\"json\">{\n     &quot;presets&quot;:[&quot;env&quot;,&quot;stage-0&quot;,&quot;react&quot;],\n    &quot;plugins&quot;:[&quot;transform-runtime&quot;]\n}\n</code></pre>\n<p>在<code>index.js</code>文件中使用JSX语法：</p>\n<pre><code class=\"js\">// 这两个包导入的时候，必需这么写\nimport React from &#39;react&#39;  //创建组件、虚拟DOM元素、生命周期\nimport ReactDOM from &#39;react-dom&#39;  //把创建好的组件和虚拟DOM放到页面上展示\n\nlet a=10;\nlet str=&quot;你好！&quot;;\nlet boo=true;\nlet title=&quot;titleName&quot;;\nconst h1=&lt;h1&gt;这是一个H1&lt;/h1&gt;;\nconst arr=[\n    &lt;h2&gt;这是h2&lt;/h2&gt;\n    &lt;h3&gt;这是h3&lt;/h3&gt;\n];\nconst arrstr=[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;];\n\n// 使用ReactDOM把虚拟DOM渲染到页面上\n//参数1：要渲染的那个虚拟DOM元素\n//参数2：指定页面上一个容器\nReactDOM.render(&lt;div&gt;\n                {a+2} //12\n                {str} //你好\n                {boo ? &#39;条件为真&#39; : &#39;条件为假&#39;} //条件为真\n                &lt;p title={title}&gt;P标签&lt;/p&gt;\n                {h1}\n                {arr}\n                {arrstr.map(item =&gt; &lt;h5&gt;{item}&lt;/h5&gt;)}\n                &lt;/div&gt;,document.getElementById(&quot;app&quot;))\n</code></pre>\n<h5 id=\"创建组件的方式\"><a href=\"#创建组件的方式\" class=\"headerlink\" title=\"创建组件的方式\"></a>创建组件的方式</h5><ol>\n<li><p>第一种：</p>\n<pre><code class=\"js\">//导入包\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\n//第一种创建组件的方式 (是一个构造函数，首字母大写)\nfunction Hello(props){\n    return &lt;div&gt;这是Hello组件 --{props.name}--{props.gender}&lt;/div&gt;\n}\n//定义参数变量\nconst dog={\n    name:&#39;阿旺&#39;,\n    gender:&#39;雄&#39;\n}\n//调用render函数渲染 jsx xml 比HTML严格的多\nReactDOM.render(&lt;div&gt;\n                &lt;Hello name={dog.name} gender={dog.gender}&gt;&lt;/Hello&gt;\n                &lt;/div&gt;,document.getElementById(&#39;app&#39;))\n</code></pre>\n</li>\n<li><p>第二种：</p>\n<pre><code class=\"js\">//如果要使用class定义组件，必需让自己的组件，继承自React.Component\nclass &#39;组件名称&#39; extends React.Component{\n    //构造器\n    constructor(){\n        //子类的自定义构造器中必需先调用super()\n        super();\n        //只有调用了super才能使用this关键字\n        this.state={ //相当于vue中的data(){ return{} }\n            msg:&#39;hello&#39;,\n        }\n    }\n    //在组件内部，必须有render函数 作用：渲染当前组件对应的虚拟DOM结构\n    render(){ //render函数中必需返回合法的jsx虚拟dom结构\n        //在class关键字中创建的组件，如果要访问外界传递的参数，不需接收，直接this.props.***就可以访问\n        return &lt;div&gt;\n            这是一个div \n        &lt;h3&gt;{this.state.msg}&lt;/h3&gt;\n        &lt;/div&gt;;\n    }\n}\n</code></pre>\n<p><strong>两种创建组件方式的区别：</strong></p>\n<blockquote>\n<p>注意：使用<code>class</code>创建的组件，有自己的私有数据和生命周期函数；</p>\n<p>使用<code>function</code>创建的组件，只有props，没有自己的私有数据和生命周期；</p>\n<ol>\n<li>用<strong>构造函数</strong>创建出来的组件：叫做“无状态组件”</li>\n<li>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”</li>\n<li>有状态组件和无状态组件的本指区别就是：有无state属性</li>\n</ol>\n</blockquote>\n<p>组件中的<code>props</code>和<code>state/data</code>之间的区别：</p>\n<ul>\n<li><code>porps</code>中的数据都是外界传递过来的；</li>\n<li><code>state/data</code>中的数据，都是组件的私有数据（通过Ajax传递过来的）；</li>\n<li><code>props</code>中的数据都是只读的，不能被重新赋值；</li>\n<li><code>state/data</code>中的数据，都是可读可写的；</li>\n<li><code>state</code>是让组件控制自己的状态的，<code>props</code>是让外部对组件进行自我配置的。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"组件的props\"><a href=\"#组件的props\" class=\"headerlink\" title=\"组件的props\"></a>组件的props</h5><p>​    在使用一个组件的时候，可以把参数放在标签的属性当中，所用属性都会作为<code>props</code>对象的键值。甚至可以传入一个函数作为属性的参数。</p>\n<pre><code class=\"jsx\">class Index extends Component {\n  render () {\n    return (\n      &lt;div&gt;\n        &lt;LikeButton\n          wordings={{likedText: '已赞', unlikedText: '赞'}}\n          onClick={() =&gt; console.log(&#39;Click on like button!&#39;)}/&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>可以通过<code>this.props.onClick</code>获取到这个传进去的函数。</p>\n<ol>\n<li><p>默认配置defaultProps</p>\n<pre><code class=\"jsx\">class Link extends Component{\n    static defaultProps={\n        liked:&#39;喜欢&#39;,\n        unlike:&#39;不喜欢&#39;\n    }\n    constructor(){\n        super();\n        this.state={\n\n        }\n    }\n    render(){\n        return &lt;div&gt;&lt;/div&gt;\n    }\n}\n</code></pre>\n</li>\n<li><p>props不可变</p>\n<blockquote>\n<p><code>props</code>一旦传入进来就不能改变。如果想要去改变，只能是从父组件重新传入新的内容进行重新渲染的方式去改变。</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"组件抽离为JSX文件\"><a href=\"#组件抽离为JSX文件\" class=\"headerlink\" title=\"组件抽离为JSX文件\"></a>组件抽离为JSX文件</h5><p><strong>注意：所谓jsx其实就是js对象</strong></p>\n<pre><code class=\"jsx\">// components/Hello.jsx\n//需要导入React\nimport React from &#39;react&#39;\nexport default function Hello(props){    //定义组件并导出\n    return &lt;div&gt;这是一个Hello组件 --{props.name}--{props.gender}&lt;/div&gt;\n}\n</code></pre>\n<pre><code class=\"js\">//导入包\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\n//导入组件\n//默认，如果不做单独的配置的话，不能省略.jsx后缀名\nimport Hello from &#39;./components/Hello.jsx&#39;\n\n//定义参数变量\nconst dog={\n    name:&#39;阿旺&#39;,\n    gender:&#39;雄&#39;\n}\n//调用render函数渲染 jsx xml 比HTML严格的多\nReactDOM.render(&lt;div&gt;\n                &lt;Hello name={dog.name} gender={dog.gender}&gt;&lt;/Hello&gt;\n                &lt;/div&gt;,document.getElementById(&#39;app&#39;))\n</code></pre>\n<p><strong>jsx到页面到底经过了怎样的过程呢？</strong></p>\n<p><img src=\"/2018/10/24/react/35cc29484072961d801e4de7f94c3b65.png\" alt></p>\n<p>为什么不直接从jsx直接渲染构造DOM结构呢？</p>\n<ol>\n<li>第一个原因是：当我们拿到一个表示ui的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能会将它们渲染到canvas或者是手机app上。而js对象可以很方便让我们去进行其他地方的渲染。（ReactNative就是帮我们把它转换成原生的app的）</li>\n<li>第二个原因是：有了这一个对象，当数据变化，需要更新组件的时候，就可以用比较块的算法操作这个js对象，而不用直接去操作页面中的dom元素，这样可以尽可能的减少浏览器的重排，优化性能。</li>\n<li>总结：<ul>\n<li>jsx是js语言的一种语法扩展，长得像html，但并不是html。</li>\n<li>React.js可以用jsx来描述你的组件长什么样。</li>\n<li>jsx在编译的时候会变成相应的js对象描述。</li>\n<li>react-dom负责把这个用来描述UI信息的js对象转变成dom元素并且渲染到页面中去。</li>\n</ul>\n</li>\n</ol>\n<p><strong>渲染列表</strong></p>\n<p>对于用表达式套数组罗列到页面上的元素，都要为每个元素加上key属性，这个key必需是每个元素唯一的标识，一般来说，<code>key</code>的取值为后台传过来的<code>id</code>值。</p>\n<h5 id=\"在组件中使用style\"><a href=\"#在组件中使用style\" class=\"headerlink\" title=\"在组件中使用style\"></a>在组件中使用style</h5><pre><code class=\"js\">class &#39;组件名称&#39; extends React.Component{\n    constructor(){\n        super();\n        this.state={ \n            msg:&#39;hello&#39;,\n        }\n    }\n    //注意 在jsx语法中不能识别行内样式，不能为style设置字符串的值。\n    //正确的写法： style={ {color:&#39;red&#39;} }\n    render(){ \n        return &lt;div style={ {color:&#39;red&#39; fontSize:&#39;20px&#39;} }&gt;\n            这是一个div \n        &lt;h3&gt;{this.state.msg}&lt;/h3&gt;\n        &lt;/div&gt;;\n    }\n}\n</code></pre>\n<p>使用<code>localIdentName</code>自定义生成的类名格式，可选的参数有：</p>\n<ul>\n<li><p><code>[path]</code>表示样式表相对于<strong>项目根目录</strong>所在的路径</p>\n</li>\n<li><p><code>[name]</code>表示样式表文件名称</p>\n</li>\n<li><p><code>[local]</code>表示样式的类名定义名称</p>\n</li>\n<li><p><code>[hash:length]</code>表示32位的hash值</p>\n<p>例子：<code>{ test: /\\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]&#39;]}</code></p>\n</li>\n</ul>\n<p>使用<code>:local()</code>和<code>:global()</code></p>\n<ul>\n<li><code>:local()</code>包裹的类名，是被模块化选中的。（默认）<code>className={cssObj.类名}</code></li>\n<li><code>:global()</code>包裹的类名，是全局生效的，不会被模块化（<code>css-modules</code>）控制，定义的类名是什么，就使用定义的类名<code>className=&quot;类名&quot;</code></li>\n</ul>\n<h5 id=\"在项目中使用模块化并同时使用bootstrap\"><a href=\"#在项目中使用模块化并同时使用bootstrap\" class=\"headerlink\" title=\"在项目中使用模块化并同时使用bootstrap\"></a>在项目中使用模块化并同时使用bootstrap</h5><ol>\n<li><p>把自己的样式表，定义为<code>.scss</code>文件</p>\n</li>\n<li><p>第三方的样式表还是以<code>.css</code>结尾</p>\n</li>\n<li><p>只为自己定义的<code>.scss</code>文件启用模块化即可</p>\n</li>\n<li><p>运行<code>npm i sass-loader node-sass -D</code> 安装能够解析<code>scss</code>文件的loader</p>\n<p>例子：<code>{test: /\\.scss$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;]}</code> 打包处理<code>.scss</code>文件的<code>loader</code></p>\n</li>\n</ol>\n<h5 id=\"React中绑定事件的注意点\"><a href=\"#React中绑定事件的注意点\" class=\"headerlink\" title=\"React中绑定事件的注意点\"></a>React中绑定事件的注意点</h5><ol>\n<li><p>事件的名称都是React提供的，首字母大写<code>onClick</code>、<code>onMouseOver</code>，需要注意的是，这些事件监听只能用在普通的HTML标签上，而不能用在组件的标签上。</p>\n<pre><code class=\"jsx\">&lt;Header onClick={...} /&gt;\n</code></pre>\n<p>这样的写法是不对的，不会有什么效果。</p>\n</li>\n<li><p>为事件提供的处理函数，必须是如下格式</p>\n</li>\n<li><pre><code class=\"js\">onClick={function}\n</code></pre>\n<p>用的最多的事件绑定形式为：</p>\n<pre><code class=\"jsx\">&lt;button onClick={ () =&gt; this.show(&#39;参数&#39;) }&gt;按钮&lt;/button&gt;\n\n//事件的处理函数，需要定义为一个箭头函数，然后赋值给函数名称\nshow = (arg1) =&gt; {\n    console.log(&#39;show方法&#39;+arg1);\n}\n</code></pre>\n</li>\n<li><p>再React中，如果想要修改state中的数据，推荐使用<code>this.setState({ })</code>，此方法是<strong>异步的</strong>。</p>\n</li>\n</ol>\n<p>用法:</p>\n<pre><code class=\"js\">this.setState({\n    msg:&#39;&#39;\n},function(){    //回调函数，若想得到最新的state值，需要再回调函数内部获取\n\n})\n</code></pre>\n<ol start=\"5\">\n<li><p>实现文本框数据双向更新</p>\n<pre><code class=\"jsx\">&lt;input value={this.state.msg} onChange={(e)=&gt;this.changeTxt(e)} ref=&quot;txt&quot;&gt;&lt;/input&gt;\n\ntextChange= (e) =&gt;{\n    const newText=this.refs.txt.value; //或者等于e.target.value\n    this.setState({\n        msg: newText\n    })\n}\n</code></pre>\n</li>\n<li><p>event对象</p>\n<p>和普通的浏览器一样，事件监听函数会被自动传入一个<code>event</code>对象，这个对象和普通的浏览器<code>event</code>对象所包含的方法和属性都基本一致。不过，<code>react.js</code>中的<code>event</code>是经过封装的，对外提供了统一的api，这样就不用考虑浏览器的兼容性问题。这个<code>event</code>对象符合<code>w3c</code>标准。它具有类似<code>event.stopPropagation</code>、<code>event.preventDefault</code>这种常用的方法。</p>\n</li>\n<li><p>this问题</p>\n<p>在<code>react</code>调用你所传入给它的方法的时候，并不是通过对象方法的方式去调用的，而是直接通过函数调用的，所以事件监听函数内并不能通过this获取到实例。</p>\n<p>如果你想获取到当前的实例，需要手动将this bind进去。</p>\n<pre><code class=\"jsx\">class Title extends Component {\n  handleClickOnTitle (e) {\n    console.log(this)\n  }\n\n  render () {\n    return (\n      &lt;h1 onClick={this.handleClickOnTitle.bind(this)}&gt;React 小书&lt;/h1&gt;\n    )\n  }\n}\n</code></pre>\n</li>\n</ol>\n<h5 id=\"React组件的生命周期分为三部分：\"><a href=\"#React组件的生命周期分为三部分：\" class=\"headerlink\" title=\"React组件的生命周期分为三部分：\"></a>React组件的生命周期分为三部分：</h5><blockquote>\n<p>这里只是列举了常用的生命周期，不包括所有的，如需了解其他的，请参考官方文档。</p>\n</blockquote>\n<p><em>在了解生命周期之前，先介绍什么是挂载：</em></p>\n<p><strong>组件的挂载：React.js将组件渲染，并且构造DOM元素然后塞入页面的过程称为组件的挂载。</strong></p>\n<p><strong>React.js会在组件的<code>render</code>之前调用<code>componentWillMount</code>，在DOM元素塞入页面以后调用<code>componentDidMount</code></strong></p>\n<p><strong>一般来说，所有关于组件自身的状态的初始化工作都会放在<code>constructor</code>里面（比如React.js组件中的状态state就是在这个阶段初始化）</strong></p>\n<hr>\n<ul>\n<li><p><strong>组件的创建阶段</strong>：特点，只会执行一次</p>\n<blockquote>\n<p>componentWillMount:（<strong>常用来做一些组件启动的动作，包括像Ajax数据的拉取操作、一些定时器的启动等，就可以放在这个阶段去进行</strong>）</p>\n<pre><code class=\"js\">//写一个Ajax\ncomponentWillMount(){\n    ajax.get(&#39;http://json-api.com/user&#39;,(userData)=&gt;{\n        this.setState({userData})\n    })\n}\n</code></pre>\n<p>render:（<strong>react.js最重要的步骤，用来创建虚拟dom，进行Diff算法，更新dom树都在此进行，此时不能更改state</strong>）</p>\n<p><strong>render之后会将虚拟dom渲染并插入到页面的根节点中</strong></p>\n<p>componentDidMount:（<strong>此阶段组件已经渲染完毕，可以获取dom结点</strong>）</p>\n</blockquote>\n</li>\n<li><p><strong>组件的运行阶段</strong>：按需，根据props属性或state状态的改变，有选择性的执行0到多次</p>\n<blockquote>\n<p>componentWillReceiveProps:（<strong>组件在接收新的props时调用，组件初始化时不调用</strong>）</p>\n<p>shouldComponentUpdateL:（<strong>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在次对比前后两个props以及state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就可以避免创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，特别是在dom结构相对复杂的时候</strong>）</p>\n<p>componentWillUpdate:（<strong>组件初始化时不调用，组建更新调用</strong>）</p>\n<p>render:（<strong>组件再次渲染</strong>）</p>\n<p>componentDidUpdate:（<strong>此阶段类似<code>componentDidMount</code>，此时可以获取dom结点</strong>）</p>\n</blockquote>\n</li>\n<li><p><strong>组件的销毁阶段</strong>：只执行一次</p>\n<blockquote>\n<p>componentWillUnmount:（<strong>它的作用主要是用来销毁一些数据事件监听以及定时器的</strong>）</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"React路由\"><a href=\"#React路由\" class=\"headerlink\" title=\"React路由\"></a>React路由</h5><ol>\n<li><p>React-router</p>\n<p>React-router提供了<code>Router</code>,<code>Route</code>,<code>Switch</code>等<code>router</code>的核心api，但是它没有提供dom操作进行相关跳转的api。</p>\n</li>\n<li><p>React-router-dom</p>\n<p>React-router-dom提供了<code>BrowserRouter</code>,<code>Route</code>,<code>Link</code>等api，可以通过它们来操作dom的事件从而控制路由。</p>\n<p>用法：(以下两个是路由的基本，就像盖房子一样，要有地基，需要将它们包裹在最外层，作为路由的根节点，我们只需要选择它们其一就可以了)</p>\n<ol>\n<li><p>HashRouter</p>\n<blockquote>\n<p><strong>特点：</strong>它是通过hash值来对路由进行控制，如果你选择使用它，就会在url上看到#。</p>\n<p><strong>用法：</strong></p>\n<p><img src=\"/2018/10/24/react/231d414640b509d980203a5ab45a3c4e.png\" alt></p>\n<pre><code class=\"html\">&lt;Router&gt;\n       &lt;Layout className=&quot;layout&quot;&gt;\n            &lt;Header&gt;\n                &lt;Menu \n                  theme=&quot;dark&quot;\n                  mode=&quot;horizontal&quot;\n                  style={{lineHeight:'64px'}} &gt;\n                    &lt;Menu.Item key=&quot;1&quot; &gt;&lt;Link to=&quot;/home&quot;&gt;&lt;Icon type=&quot;home&quot;/&gt;首页&lt;/Link&gt;                           &lt;/Menu.Item&gt;\n                    &lt;Menu.Item key=&quot;2&quot;&gt;&lt;Link to=&quot;/content&quot;&gt;&lt;Icon type=&quot;file-text&quot;/&gt;文档&lt;/Link&gt;                   &lt;/Menu.Item&gt;\n                &lt;/Menu&gt;\n            &lt;/Header&gt;\n            &lt;Content&gt;\n                &lt;Switch&gt;\n                    &lt;Route exact path=&quot;/&quot; component={home}&gt;&lt;/Route&gt;\n                    &lt;Route path=&quot;/home&quot; component={home}&gt;&lt;/Route&gt;\n                    &lt;Route path=&quot;/content&quot; component={content}&gt;&lt;/Route&gt;\n                &lt;/Switch&gt;\n            &lt;/Content&gt;\n       &lt;/Layout&gt;\n&lt;/Router&gt;\n</code></pre>\n</blockquote>\n</li>\n<li><p>BrowserRouter</p>\n<blockquote>\n<p><strong>特点：</strong>它的url看起来与正常的一样，不存在类似于<code>HashRouter</code>中出现的#</p>\n<p><strong>用法：</strong></p>\n</blockquote>\n<blockquote>\n<pre><code class=\"jsx\">import {BrowserRouter as Router, Link, Route, Switch} from &#39;react-router-dom&#39;\n&lt;Router&gt;\n    &lt;div&gt;\n        &lt;Route path=&quot;/&quot; component={home}&gt;&lt;/Route&gt;\n        &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;\n    &lt;/div&gt;\n&lt;/Router&gt;\n</code></pre>\n<p><strong>它的原理是使用HTML5 history API(pushState,replaceState,propState)来使你的内容随url的动态改变</strong></p>\n<p>有一个常用的api，<code>basename</code>如果你的文件放在服务器的二级目录下则可以使用它。（你的主页前面有一级目录calendar可以这样使用）</p>\n<pre><code class=\"jsx\">&lt;BrowserRouter basename=&quot;/calendar&quot;&gt;\n    &lt;Route path=&quot;/&quot; component={home}&gt;&lt;/Route&gt;\n&lt;/BrowserRouter&gt;\n</code></pre>\n</blockquote>\n</li>\n<li><p>Route</p>\n<blockquote>\n<p><strong>特点：</strong>它是路由的原材料，用来控制路由对应显示的组件。我们常用它的<code>exact</code>、<code>path</code>以及<code>component</code>属性</p>\n<pre><code class=\"jsx\">&lt;Route exact path=&quot;/&quot; component={Home}&gt;&lt;/Route&gt;\n&lt;Route path=&quot;/second&quot; component={Second}&gt;&lt;/Route&gt;\n&lt;Route path=&quot;/third&quot; component={Third}&gt;&lt;/Route&gt;\n</code></pre>\n<p><code>exact</code>：用来控制匹配到/路径时，不会再继续往下匹配，用来进行精确定位。</p>\n<p><code>path</code>：标识路由的路径。</p>\n<p><code>component</code>：表示路径对应显示的组件。</p>\n</blockquote>\n</li>\n<li><p>Link</p>\n<blockquote>\n<p><strong>作用：</strong>用来进行跳转的页面链接。</p>\n<pre><code class=\"jsx\">&lt;Link to=&quot;/home&quot;&gt;&lt;/Link&gt;\n&lt;Link to={{\n      >         pathname:'/home',\n      >         search:'?sort=name',\n      >         hash:'#the-hash',\n      >         state:{fromDashboard:true}\n      >     }}&gt;&lt;/Link&gt;\n</code></pre>\n<p>主要的API时to，可以接受string或者一个object，用来控制url。</p>\n</blockquote>\n</li>\n<li><p>NavLink</p>\n<blockquote>\n<p><strong>特点：</strong>可以为当前选中的路由设置类名、样式以及回调函数等。</p>\n<pre><code class=\"jsx\">&lt;NavLink exact activeClassName=&quot;selected&quot; to=&quot;/&quot;&gt;home&lt;/NavLink&gt;\n&lt;NavLink activeClassName=&quot;selected&quot; to=&quot;/second/1234&quot;&gt;second&lt;/NavLink&gt;\n&lt;Route path=&quot;/second/:id&quot; component={Second}&gt;&lt;/Route&gt;\n</code></pre>\n<p><code>exact</code>：用于严格匹配，与route中的作用类似。</p>\n<p><code>to</code>：用来控制url跳转。</p>\n<p><code>activeClassName</code>：选中状态的类名，可以为其添加样式。</p>\n<p>在second后添加/1234结合Route中/second/:id</p>\n</blockquote>\n</li>\n<li><p>match</p>\n<blockquote>\n<p><code>match</code>时使用router之后会被放到props中的一个属性，在class创建的组件中我们需要通过this.props.match来获取match之中的信息。<code>match</code>中包含的信息如下：</p>\n<pre><code class=\"js\">{\n    path:&quot;/second/:id&quot;,\n    url:&quot;/second/1234&quot;,\n    isExact:true,\n    parms:{\n        id:&quot;1234&quot;        \n       }\n}\n</code></pre>\n<p><strong>常用来获取id</strong></p>\n</blockquote>\n</li>\n<li><p>Switch</p>\n<blockquote>\n<p>常用来包裹Route，里面不能放其他的元素。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>路由嵌套</strong>(子组件<Route>可以作为父<Route>的component属性值)</Route></Route></p>\n<pre><code class=\"jsx\">&lt;Route path=&quot;parent&quot; component={Parent}&gt;&lt;/Route&gt;\nconst Parent=()=&gt;(\n    &lt;div&gt;\n        &lt;Route path=&quot;child&quot; component={Child}&gt;&lt;/Route&gt;\n        &lt;Route path=&quot;other&quot; component={Other}&gt;&lt;/Route&gt;\n    &lt;/div&gt;\n)\n</code></pre>\n<p><strong>最后需要注意的是：<code>HashRouter</code>以及<code>BrowserRouter</code>使用时，其孩子节点只能有一个，例如：</strong></p>\n<pre><code class=\"jsx\">&lt;HashRouter&gt;\n    &lt;div&gt;\n        &lt;Route path=&quot;/&quot; component={home}&gt;&lt;/Route&gt;\n        &lt;Link to=&quot;/&quot;&gt;home&lt;/Link&gt;\n    &lt;/div&gt;\n&lt;/HashRouter&gt;\n&lt;BrowserRouter&gt;\n    &lt;div&gt;\n        &lt;Route path=&quot;/&quot; component={home}&gt;&lt;/Route&gt;\n        &lt;Link to=&quot;/&quot;&gt;home&lt;/Link&gt;\n    &lt;/div&gt;\n&lt;/BrowserRouter&gt;\n</code></pre>\n<h5 id=\"组件的Render方法\"><a href=\"#组件的Render方法\" class=\"headerlink\" title=\"组件的Render方法\"></a>组件的Render方法</h5><p>在<code>react.js</code>中，一切皆组件。我们在编写<code>react.js</code>组件的时候，一般需要继承<code>react.js</code>的<code>component</code>。一个组件的类必须要实现<code>render</code>方法，这个<code>render</code>方法必需返回一个JSX元素。需要注意的是，必需要有一个外层的jsx元素把所有内容包裹起来，返回并列多个JSX元素是不合法的。</p>\n<pre><code class=\"jsx\">//错误的做法\nrender(){\n    return (\n        &lt;div&gt;第一个元素&lt;/div&gt;\n        &lt;div&gt;第二个元素&lt;/div&gt;\n    )\n}\n//正确的写法\nrender(){\n    return (\n        &lt;div&gt;\n            &lt;div&gt;第一个元素&lt;/div&gt;\n            &lt;div&gt;第二个元素&lt;/div&gt;\n        &lt;/div&gt;\n    )\n}\n</code></pre>\n<p><strong>自定义组件都必须要大写字母开头，普通的HTML标题都用小写字母开头</strong></p>\n<h5 id=\"状态提升\"><a href=\"#状态提升\" class=\"headerlink\" title=\"状态提升\"></a>状态提升</h5><p><strong>状态提升：</strong>当某个状态被多个组件依赖或者影响的时候，就把该状态提升到这些组件的最近公共父组件中去管理，用<code>props</code>传递数据或函数来管理这种依赖或者影响的关系。</p>\n<p><strong>组件的内容编写顺序如下：</strong></p>\n<ol>\n<li><code>static</code>开头的类属性，如<code>defaultProps</code>、<code>propTypes</code>。</li>\n<li>构造函数，<code>constructor</code>。</li>\n<li><code>getter/setter</code>。</li>\n<li>组件的生命周期。</li>\n<li><code>_</code>开头的私有方法。</li>\n<li>事件监听方法，<code>handle</code>。</li>\n<li><code>render</code>开头的方法，有时候<code>render()</code>方法里面的内容会被分开到不同的函数里边进行，这些函数都以<code>render</code>开头。</li>\n<li><code>render()</code>方法。</li>\n</ol>\n<h5 id=\"高阶组件：\"><a href=\"#高阶组件：\" class=\"headerlink\" title=\"高阶组件：\"></a><strong>高阶组件：</strong></h5><p>什么是高阶组件：<em>高阶组件就是一个函数，传给它一个组件，返回一个新的组件。</em></p>\n<p>重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件</p>\n<pre><code class=\"jsx\">import React, { Component } from &#39;react&#39;\n\nexport default (WrappedComponent, name) =&gt; {\n  class NewComponent extends Component {\n    constructor () {\n      super()\n      this.state = { data: null }\n    }\n\n    componentWillMount () {\n      let data = localStorage.getItem(name)\n      this.setState({ data })\n    }\n\n    render () {\n      return &lt;WrappedComponent data={this.state.data} /&gt;\n    }\n  }\n  return NewComponent\n}\n</code></pre>\n<p><strong>高阶组件的主要作用就是用来封装一些组件，提取出多个组件中代码逻辑相同的部分，编写一个高阶组件函数，可以提高代码的复用性。</strong></p>\n<h5 id=\"propTypes组件参数验证\"><a href=\"#propTypes组件参数验证\" class=\"headerlink\" title=\"propTypes组件参数验证\"></a>propTypes组件参数验证</h5><p>使用：<code>npm install prop-types --save</code></p>\n<p>它可以帮助我们验证<code>props</code>的参数类型，例如：</p>\n<pre><code class=\"jsx\">import React, { Component } from &#39;react&#39;\nimport PropTypes from &#39;prop-types&#39;\n\nclass Comment extends Component {\n  static propTypes = {\n    comment: PropTypes.object\n  }\n\n  render () {\n    const { comment } = this.props\n    return (\n      &lt;div className=&#39;comment&#39;&gt;\n        &lt;div className=&#39;comment-user&#39;&gt;\n          &lt;span&gt;{comment.username} &lt;/span&gt;：\n        &lt;/div&gt;\n        &lt;p&gt;{comment.content}&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n</code></pre>\n<p>注意我们在文件头部引入了 <code>PropTypes</code>，并且给 <code>Comment</code> 组件类添加了类属性 <code>propTypes</code>，里面的内容的意思就是你传入的 <code>comment</code> 类型必须为 <code>object</code>（对象）。<em>它可以帮助我们更好地去定位出现的错误，将控制台的错误信息展示的更加友好。</em></p>\n"},{"title":"vue插槽","date":"2020-08-07T06:08:33.000Z","_content":"\n### **vue插槽**\n\n> [具体文档参考官方]: https://cn.vuejs.org/v2/guide/components-slots.html\n\n\n\n```html\n<!-- 父组件 -->\n<SlotDemo :slotList=\"listData\">\n  <template  v-slot:default=\"{myData: list}\">\n<!-- <template  v-slot:list=\"{myData: list}\"> -->\n<!-- 属于解构赋值{myData: list} v-slot:list=\"这里代表的是子组件对应的:myData=\"scope\"等数据\" -->\n  \t<ul>\n      <li>\n        {{list.name}}\n        <span v-show=\"list.age > 21\">:{{ list.age }}</span>\n      </li>\n    </ul>\n  </template>\n</SlotDemo>\n<script lang=\"ts\">\n  // ***\n  export default class Index extends Vue{\n    listData: Array<object> = [\n            {\n                name: 'jack',\n                age: 20,\n                desc: 'haha',\n            },\n            {\n                name: 'lisa',\n                age: 22,\n                desc: 'xixi',\n            },\n            {\n                name: 'tom',\n                age: 23,\n                desc: 'heihei',\n            },\n            {\n                name: 'peter',\n                age: 24,\n                desc: 'hello',\n            }\n     ]\n  }\n</script>\n<!-- 子组件 -->\n<template v-for=\"scope in slotList\">\n\t<!-- 默认name=\"default\" -->\n\t<!-- 与父组件的v-slot:name对应 -->\n\t<slot :myData=\"scope\">\n  </slot>\n</template>\n<script lang=\"ts\">\n  // ***\n   export default class slotDemo extends Vue{\n    \t@Prop({default: ''}) slotList!: any \n   }\n</script>\n```\n\n","source":"_posts/vue插槽.md","raw":"---\ntitle: vue插槽\ndate: 2020-08-07 14:08:33\ntags: vue\ncategories: 前端\n---\n\n### **vue插槽**\n\n> [具体文档参考官方]: https://cn.vuejs.org/v2/guide/components-slots.html\n\n\n\n```html\n<!-- 父组件 -->\n<SlotDemo :slotList=\"listData\">\n  <template  v-slot:default=\"{myData: list}\">\n<!-- <template  v-slot:list=\"{myData: list}\"> -->\n<!-- 属于解构赋值{myData: list} v-slot:list=\"这里代表的是子组件对应的:myData=\"scope\"等数据\" -->\n  \t<ul>\n      <li>\n        {{list.name}}\n        <span v-show=\"list.age > 21\">:{{ list.age }}</span>\n      </li>\n    </ul>\n  </template>\n</SlotDemo>\n<script lang=\"ts\">\n  // ***\n  export default class Index extends Vue{\n    listData: Array<object> = [\n            {\n                name: 'jack',\n                age: 20,\n                desc: 'haha',\n            },\n            {\n                name: 'lisa',\n                age: 22,\n                desc: 'xixi',\n            },\n            {\n                name: 'tom',\n                age: 23,\n                desc: 'heihei',\n            },\n            {\n                name: 'peter',\n                age: 24,\n                desc: 'hello',\n            }\n     ]\n  }\n</script>\n<!-- 子组件 -->\n<template v-for=\"scope in slotList\">\n\t<!-- 默认name=\"default\" -->\n\t<!-- 与父组件的v-slot:name对应 -->\n\t<slot :myData=\"scope\">\n  </slot>\n</template>\n<script lang=\"ts\">\n  // ***\n   export default class slotDemo extends Vue{\n    \t@Prop({default: ''}) slotList!: any \n   }\n</script>\n```\n\n","slug":"vue插槽","published":1,"updated":"2024-02-19T07:42:51.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb500471xop66wn4xz9","content":"<h3 id=\"vue插槽\"><a href=\"#vue插槽\" class=\"headerlink\" title=\"vue插槽\"></a><strong>vue插槽</strong></h3><blockquote>\n</blockquote>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 父组件 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>SlotDemo</span> <span class=\"token attr-name\">:slotList</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>listData<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span>  <span class=\"token attr-name\"><span class=\"token namespace\">v-slot:</span>default</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>{myData: list}<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- &lt;template  v-slot:list=\"{myData: list}\"> --></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 属于解构赋值{myData: list} v-slot:list=\"这里代表的是子组件对应的:myData=\"scope\"等数据\" --></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>\n        {{list.name}}\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">v-show</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>list.age <span class=\"token punctuation\">></span> 21<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>:{{ list.age }}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>SlotDemo</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ts<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token comment\" spellcheck=\"true\">// ***</span>\n  <span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Index</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">{</span>\n    listData<span class=\"token punctuation\">:</span> Array<span class=\"token operator\">&lt;</span>object<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n            <span class=\"token punctuation\">{</span>\n                name<span class=\"token punctuation\">:</span> <span class=\"token string\">'jack'</span><span class=\"token punctuation\">,</span>\n                age<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span>\n                desc<span class=\"token punctuation\">:</span> <span class=\"token string\">'haha'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">{</span>\n                name<span class=\"token punctuation\">:</span> <span class=\"token string\">'lisa'</span><span class=\"token punctuation\">,</span>\n                age<span class=\"token punctuation\">:</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span>\n                desc<span class=\"token punctuation\">:</span> <span class=\"token string\">'xixi'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">{</span>\n                name<span class=\"token punctuation\">:</span> <span class=\"token string\">'tom'</span><span class=\"token punctuation\">,</span>\n                age<span class=\"token punctuation\">:</span> <span class=\"token number\">23</span><span class=\"token punctuation\">,</span>\n                desc<span class=\"token punctuation\">:</span> <span class=\"token string\">'heihei'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">{</span>\n                name<span class=\"token punctuation\">:</span> <span class=\"token string\">'peter'</span><span class=\"token punctuation\">,</span>\n                age<span class=\"token punctuation\">:</span> <span class=\"token number\">24</span><span class=\"token punctuation\">,</span>\n                desc<span class=\"token punctuation\">:</span> <span class=\"token string\">'hello'</span><span class=\"token punctuation\">,</span>\n            <span class=\"token punctuation\">}</span>\n     <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 子组件 --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span> <span class=\"token attr-name\">v-for</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>scope in slotList<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 默认name=\"default\" --></span>\n    <span class=\"token comment\" spellcheck=\"true\">&lt;!-- 与父组件的v-slot:name对应 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>slot</span> <span class=\"token attr-name\">:myData</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>scope<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>slot</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>ts<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  <span class=\"token comment\" spellcheck=\"true\">// ***</span>\n   <span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">slotDemo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">{</span>\n        @<span class=\"token function\">Prop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span> <span class=\"token string\">''</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> slotList<span class=\"token operator\">!</span><span class=\"token punctuation\">:</span> any \n   <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue插槽\"><a href=\"#vue插槽\" class=\"headerlink\" title=\"vue插槽\"></a><strong>vue插槽</strong></h3><blockquote>\n</blockquote>\n<pre><code class=\"html\">&lt;!-- 父组件 --&gt;\n&lt;SlotDemo :slotList=&quot;listData&quot;&gt;\n  &lt;template  v-slot:default=&quot;{myData: list}&quot;&gt;\n&lt;!-- &lt;template  v-slot:list=&quot;{myData: list}&quot;&gt; --&gt;\n&lt;!-- 属于解构赋值{myData: list} v-slot:list=&quot;这里代表的是子组件对应的:myData=&quot;scope&quot;等数据&quot; --&gt;\n      &lt;ul&gt;\n      &lt;li&gt;\n        {{list.name}}\n        &lt;span v-show=&quot;list.age &gt; 21&quot;&gt;:{{ list.age }}&lt;/span&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/template&gt;\n&lt;/SlotDemo&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n  // ***\n  export default class Index extends Vue{\n    listData: Array&lt;object&gt; = [\n            {\n                name: &#39;jack&#39;,\n                age: 20,\n                desc: &#39;haha&#39;,\n            },\n            {\n                name: &#39;lisa&#39;,\n                age: 22,\n                desc: &#39;xixi&#39;,\n            },\n            {\n                name: &#39;tom&#39;,\n                age: 23,\n                desc: &#39;heihei&#39;,\n            },\n            {\n                name: &#39;peter&#39;,\n                age: 24,\n                desc: &#39;hello&#39;,\n            }\n     ]\n  }\n&lt;/script&gt;\n&lt;!-- 子组件 --&gt;\n&lt;template v-for=&quot;scope in slotList&quot;&gt;\n    &lt;!-- 默认name=&quot;default&quot; --&gt;\n    &lt;!-- 与父组件的v-slot:name对应 --&gt;\n    &lt;slot :myData=&quot;scope&quot;&gt;\n  &lt;/slot&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\n  // ***\n   export default class slotDemo extends Vue{\n        @Prop({default: &#39;&#39;}) slotList!: any \n   }\n&lt;/script&gt;\n</code></pre>\n"},{"title":"vue深度监听","date":"2019-06-29T01:35:46.000Z","_content":"\n### vue深度监听\n\n### 检测追踪变化的注意事项\n> 当把一个普通js对象传入到vue实例作为data选项时，vue将会对此对象的所有属性进行遍历，并使用`Object.defineProperty`把这些属性全部转为`getter/setter`方法。\n\n> 每个组件的实例都对应一个`watcher`实例，它会在组件渲染的过程中把“接触”过得数据属性记录为依赖。之后当依赖项的`setter`触发时，会通知`watcher`，从而使它相关联的组件进行更新渲染。\n\n> 对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用`Vue.set(object,propertyName,value)`方法向嵌套对象添加响应式属性（响应式属性指的是vue会在初始化实例时对属性执行`getter/setter`转化）。\n\n> 如果需要为已有对象赋值多个新属性，比如使用`Object.assign()`或`_.extend()`。但是这样添加到对象上的新属性不会去触发更新。在这种情况下，需要用原对象与要混入进去的对象的属性一起创建一个新的对象。\n\n```js\n// 代替 Object.assign(this.someObject,{a: 1, b: 2})\nthis.someObject = Object.assign({},this.someObject,{a:1,b:2})\n```\n### 数据检测监听注意事项\n\n> 由于js的限制，Vue不能检测以下数组的变动：\n\n1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`\n2. 当你修改数组的长度时，例如：`vm.items.length = newLength`\n```js\nvar vm = new Vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n```\n解决方式：\n\n```js\n// 以下两种方式都可以实现直接赋值相同的效果，同时也将在响应式系统内触发更新状态\n\n// 方式1 Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// 或者全局使用`vm.$set`实例方法\nvm.$set(vm.items, indexOfItem, newValue)\n\n// 方式2  Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n```\n为了解决第二类问题，你可以使用 splice：\n\n```vm.items.splice(newLength)```\n\n> 由于js的限制，Vue不能检测对象属性的添加或删除：需要使用`Vue.set(object, propertyName, value)`。如果想要为已有对象赋值多个属性，可以使用`Object.assign()` 或 `_.extend()`。\n\n### 异步更新队列\n\n> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n\n> 例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用\n\n> 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：\n\n```js\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```","source":"_posts/vue深度监听.md","raw":"---\ntitle: vue深度监听\ndate: 2019-06-29 09:35:46\ntags: Vue\ncategories: 前端\n---\n\n### vue深度监听\n\n### 检测追踪变化的注意事项\n> 当把一个普通js对象传入到vue实例作为data选项时，vue将会对此对象的所有属性进行遍历，并使用`Object.defineProperty`把这些属性全部转为`getter/setter`方法。\n\n> 每个组件的实例都对应一个`watcher`实例，它会在组件渲染的过程中把“接触”过得数据属性记录为依赖。之后当依赖项的`setter`触发时，会通知`watcher`，从而使它相关联的组件进行更新渲染。\n\n> 对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用`Vue.set(object,propertyName,value)`方法向嵌套对象添加响应式属性（响应式属性指的是vue会在初始化实例时对属性执行`getter/setter`转化）。\n\n> 如果需要为已有对象赋值多个新属性，比如使用`Object.assign()`或`_.extend()`。但是这样添加到对象上的新属性不会去触发更新。在这种情况下，需要用原对象与要混入进去的对象的属性一起创建一个新的对象。\n\n```js\n// 代替 Object.assign(this.someObject,{a: 1, b: 2})\nthis.someObject = Object.assign({},this.someObject,{a:1,b:2})\n```\n### 数据检测监听注意事项\n\n> 由于js的限制，Vue不能检测以下数组的变动：\n\n1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`\n2. 当你修改数组的长度时，例如：`vm.items.length = newLength`\n```js\nvar vm = new Vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n```\n解决方式：\n\n```js\n// 以下两种方式都可以实现直接赋值相同的效果，同时也将在响应式系统内触发更新状态\n\n// 方式1 Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// 或者全局使用`vm.$set`实例方法\nvm.$set(vm.items, indexOfItem, newValue)\n\n// 方式2  Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n```\n为了解决第二类问题，你可以使用 splice：\n\n```vm.items.splice(newLength)```\n\n> 由于js的限制，Vue不能检测对象属性的添加或删除：需要使用`Vue.set(object, propertyName, value)`。如果想要为已有对象赋值多个属性，可以使用`Object.assign()` 或 `_.extend()`。\n\n### 异步更新队列\n\n> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n\n> 例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用\n\n> 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：\n\n```js\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```","slug":"vue深度监听","published":1,"updated":"2024-02-19T07:42:51.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb6004a1xopgkci6ali","content":"<h3 id=\"vue深度监听\"><a href=\"#vue深度监听\" class=\"headerlink\" title=\"vue深度监听\"></a>vue深度监听</h3><h3 id=\"检测追踪变化的注意事项\"><a href=\"#检测追踪变化的注意事项\" class=\"headerlink\" title=\"检测追踪变化的注意事项\"></a>检测追踪变化的注意事项</h3><blockquote>\n<p>当把一个普通js对象传入到vue实例作为data选项时，vue将会对此对象的所有属性进行遍历，并使用<code>Object.defineProperty</code>把这些属性全部转为<code>getter/setter</code>方法。</p>\n</blockquote>\n<blockquote>\n<p>每个组件的实例都对应一个<code>watcher</code>实例，它会在组件渲染的过程中把“接触”过得数据属性记录为依赖。之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使它相关联的组件进行更新渲染。</p>\n</blockquote>\n<blockquote>\n<p>对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用<code>Vue.set(object,propertyName,value)</code>方法向嵌套对象添加响应式属性（响应式属性指的是vue会在初始化实例时对属性执行<code>getter/setter</code>转化）。</p>\n</blockquote>\n<blockquote>\n<p>如果需要为已有对象赋值多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。但是这样添加到对象上的新属性不会去触发更新。在这种情况下，需要用原对象与要混入进去的对象的属性一起创建一个新的对象。</p>\n</blockquote>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 代替 Object.assign(this.someObject,{a: 1, b: 2})</span>\n<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>someObject <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>someObject<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>a<span class=\"token punctuation\">:</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"数据检测监听注意事项\"><a href=\"#数据检测监听注意事项\" class=\"headerlink\" title=\"数据检测监听注意事项\"></a>数据检测监听注意事项</h3><blockquote>\n<p>由于js的限制，Vue不能检测以下数组的变动：</p>\n</blockquote>\n<ol>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> vm <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\ndata<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n items<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nvm<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'x'</span> <span class=\"token comment\" spellcheck=\"true\">// 不是响应性的</span>\nvm<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span>length <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">// 不是响应性的</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n解决方式：</li>\n</ol>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 以下两种方式都可以实现直接赋值相同的效果，同时也将在响应式系统内触发更新状态</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方式1 Vue.set</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">,</span> indexOfItem<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">// 或者全局使用`vm.$set`实例方法</span>\nvm<span class=\"token punctuation\">.</span>$<span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>vm<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">,</span> indexOfItem<span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 方式2  Array.prototype.splice</span>\nvm<span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>indexOfItem<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> newValue<span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为了解决第二类问题，你可以使用 splice：</p>\n<pre class=\"line-numbers language-vm.items.splice(newLength)```\"><code class=\"language-vm.items.splice(newLength)```\">\n> 由于js的限制，Vue不能检测对象属性的添加或删除：需要使用`Vue.set(object, propertyName, value)`。如果想要为已有对象赋值多个属性，可以使用`Object.assign()` 或 `_.extend()`。\n\n### 异步更新队列\n\n> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n\n> 例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用\n\n> 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：\n\n```js\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue深度监听\"><a href=\"#vue深度监听\" class=\"headerlink\" title=\"vue深度监听\"></a>vue深度监听</h3><h3 id=\"检测追踪变化的注意事项\"><a href=\"#检测追踪变化的注意事项\" class=\"headerlink\" title=\"检测追踪变化的注意事项\"></a>检测追踪变化的注意事项</h3><blockquote>\n<p>当把一个普通js对象传入到vue实例作为data选项时，vue将会对此对象的所有属性进行遍历，并使用<code>Object.defineProperty</code>把这些属性全部转为<code>getter/setter</code>方法。</p>\n</blockquote>\n<blockquote>\n<p>每个组件的实例都对应一个<code>watcher</code>实例，它会在组件渲染的过程中把“接触”过得数据属性记录为依赖。之后当依赖项的<code>setter</code>触发时，会通知<code>watcher</code>，从而使它相关联的组件进行更新渲染。</p>\n</blockquote>\n<blockquote>\n<p>对于已经创建的实例，vue不允许动态添加根级别的响应式属性。但是，可以使用<code>Vue.set(object,propertyName,value)</code>方法向嵌套对象添加响应式属性（响应式属性指的是vue会在初始化实例时对属性执行<code>getter/setter</code>转化）。</p>\n</blockquote>\n<blockquote>\n<p>如果需要为已有对象赋值多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。但是这样添加到对象上的新属性不会去触发更新。在这种情况下，需要用原对象与要混入进去的对象的属性一起创建一个新的对象。</p>\n</blockquote>\n<pre><code class=\"js\">// 代替 Object.assign(this.someObject,{a: 1, b: 2})\nthis.someObject = Object.assign({},this.someObject,{a:1,b:2})\n</code></pre>\n<h3 id=\"数据检测监听注意事项\"><a href=\"#数据检测监听注意事项\" class=\"headerlink\" title=\"数据检测监听注意事项\"></a>数据检测监听注意事项</h3><blockquote>\n<p>由于js的限制，Vue不能检测以下数组的变动：</p>\n</blockquote>\n<ol>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code><pre><code class=\"js\">var vm = new Vue({\ndata: {\n items: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n}\n})\nvm.items[1] = &#39;x&#39; // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n</code></pre>\n解决方式：</li>\n</ol>\n<pre><code class=\"js\">// 以下两种方式都可以实现直接赋值相同的效果，同时也将在响应式系统内触发更新状态\n\n// 方式1 Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// 或者全局使用`vm.$set`实例方法\nvm.$set(vm.items, indexOfItem, newValue)\n\n// 方式2  Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n</code></pre>\n<p>为了解决第二类问题，你可以使用 splice：</p>\n<pre><code class=\"vm.items.splice(newLength)```\">\n&gt; 由于js的限制，Vue不能检测对象属性的添加或删除：需要使用`Vue.set(object, propertyName, value)`。如果想要为已有对象赋值多个属性，可以使用`Object.assign()` 或 `_.extend()`。\n\n### 异步更新队列\n\n&gt; Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n\n&gt; 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用\n\n&gt; 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情：\n\n```js\nmethods: {\n  updateMessage: async function () {\n    this.message = &#39;已更新&#39;\n    console.log(this.$el.textContent) // =&gt; &#39;未更新&#39;\n    await this.$nextTick()\n    console.log(this.$el.textContent) // =&gt; &#39;已更新&#39;\n  }\n}\n</code></pre>\n"},{"title":"vue组件间通信方式","date":"2019-04-28T08:19:02.000Z","_content":"\n### vue组件间通信方式\n\n##### 通信种类\n\n1. 父组件向子组件通信\n2. 子组件向父组件通信\n3. 隔代组件间通信\n4. 兄弟组件间通信\n\n##### 实现通信方式\n\n1. props\n2. vue自定义事件\n3. 消息订阅与发布\n4. vuex\n5. slot\n\n##### 方式1：props\n\n1. 通过一般属性实现父向子通信\n2. 通过函数属性实现子向父通信\n3. 缺点：隔代组件和兄弟组件间通信比较麻烦\n\n##### 方式2：vue自定义事件\n\n1. vue内置实现，可以代替函数类型的props\n   - 绑定监听：`<MyComp @eventName=\"callback\"></MyComp>`\n   - 触发（分发）事件：`this.$emit(\"eventName\",data)`\n2. 缺点：只适合于子向父通信\n\n##### 方式3：消息订阅与发布\n\n1. 需要引入消息订阅与发布的实现库，如：`pubsub-js`\n   - 订阅消息：`PubSub.subscript('msg',function(msg,data){})`\n   - 发布消息：`PubSub.publish('msg',data)`\n2. 优点：此方式可实现任意关系组件间通信\n\n##### 方式4：vuex\n\n1. vuex是vue\u0001官方提供的集中式管理vue多组间共享状态数据的vue插件\n2. 优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便\n\n##### 方式5：slot\n\n1. 专门用来实现父向子传递带数据的标签\n   - 子组件\n   - 父组件\n2. 注意：通信的标签模板是在父组件中解析好后再传递给子组件的","source":"_posts/vue组件间通信方式.md","raw":"---\ntitle: vue组件间通信方式\ndate: 2019-04-28 16:19:02\ntags: Vue\ncategories: 前端\n---\n\n### vue组件间通信方式\n\n##### 通信种类\n\n1. 父组件向子组件通信\n2. 子组件向父组件通信\n3. 隔代组件间通信\n4. 兄弟组件间通信\n\n##### 实现通信方式\n\n1. props\n2. vue自定义事件\n3. 消息订阅与发布\n4. vuex\n5. slot\n\n##### 方式1：props\n\n1. 通过一般属性实现父向子通信\n2. 通过函数属性实现子向父通信\n3. 缺点：隔代组件和兄弟组件间通信比较麻烦\n\n##### 方式2：vue自定义事件\n\n1. vue内置实现，可以代替函数类型的props\n   - 绑定监听：`<MyComp @eventName=\"callback\"></MyComp>`\n   - 触发（分发）事件：`this.$emit(\"eventName\",data)`\n2. 缺点：只适合于子向父通信\n\n##### 方式3：消息订阅与发布\n\n1. 需要引入消息订阅与发布的实现库，如：`pubsub-js`\n   - 订阅消息：`PubSub.subscript('msg',function(msg,data){})`\n   - 发布消息：`PubSub.publish('msg',data)`\n2. 优点：此方式可实现任意关系组件间通信\n\n##### 方式4：vuex\n\n1. vuex是vue\u0001官方提供的集中式管理vue多组间共享状态数据的vue插件\n2. 优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便\n\n##### 方式5：slot\n\n1. 专门用来实现父向子传递带数据的标签\n   - 子组件\n   - 父组件\n2. 注意：通信的标签模板是在父组件中解析好后再传递给子组件的","slug":"vue组件间通信方式","published":1,"updated":"2024-02-19T07:42:51.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb8004e1xop9czec9qt","content":"<h3 id=\"vue组件间通信方式\"><a href=\"#vue组件间通信方式\" class=\"headerlink\" title=\"vue组件间通信方式\"></a>vue组件间通信方式</h3><h5 id=\"通信种类\"><a href=\"#通信种类\" class=\"headerlink\" title=\"通信种类\"></a>通信种类</h5><ol>\n<li>父组件向子组件通信</li>\n<li>子组件向父组件通信</li>\n<li>隔代组件间通信</li>\n<li>兄弟组件间通信</li>\n</ol>\n<h5 id=\"实现通信方式\"><a href=\"#实现通信方式\" class=\"headerlink\" title=\"实现通信方式\"></a>实现通信方式</h5><ol>\n<li>props</li>\n<li>vue自定义事件</li>\n<li>消息订阅与发布</li>\n<li>vuex</li>\n<li>slot</li>\n</ol>\n<h5 id=\"方式1：props\"><a href=\"#方式1：props\" class=\"headerlink\" title=\"方式1：props\"></a>方式1：props</h5><ol>\n<li>通过一般属性实现父向子通信</li>\n<li>通过函数属性实现子向父通信</li>\n<li>缺点：隔代组件和兄弟组件间通信比较麻烦</li>\n</ol>\n<h5 id=\"方式2：vue自定义事件\"><a href=\"#方式2：vue自定义事件\" class=\"headerlink\" title=\"方式2：vue自定义事件\"></a>方式2：vue自定义事件</h5><ol>\n<li>vue内置实现，可以代替函数类型的props<ul>\n<li>绑定监听：<code>&lt;MyComp @eventName=&quot;callback&quot;&gt;&lt;/MyComp&gt;</code></li>\n<li>触发（分发）事件：<code>this.$emit(&quot;eventName&quot;,data)</code></li>\n</ul>\n</li>\n<li>缺点：只适合于子向父通信</li>\n</ol>\n<h5 id=\"方式3：消息订阅与发布\"><a href=\"#方式3：消息订阅与发布\" class=\"headerlink\" title=\"方式3：消息订阅与发布\"></a>方式3：消息订阅与发布</h5><ol>\n<li>需要引入消息订阅与发布的实现库，如：<code>pubsub-js</code><ul>\n<li>订阅消息：<code>PubSub.subscript(&#39;msg&#39;,function(msg,data){})</code></li>\n<li>发布消息：<code>PubSub.publish(&#39;msg&#39;,data)</code></li>\n</ul>\n</li>\n<li>优点：此方式可实现任意关系组件间通信</li>\n</ol>\n<h5 id=\"方式4：vuex\"><a href=\"#方式4：vuex\" class=\"headerlink\" title=\"方式4：vuex\"></a>方式4：vuex</h5><ol>\n<li>vuex是vue\u0001官方提供的集中式管理vue多组间共享状态数据的vue插件</li>\n<li>优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便</li>\n</ol>\n<h5 id=\"方式5：slot\"><a href=\"#方式5：slot\" class=\"headerlink\" title=\"方式5：slot\"></a>方式5：slot</h5><ol>\n<li>专门用来实现父向子传递带数据的标签<ul>\n<li>子组件</li>\n<li>父组件</li>\n</ul>\n</li>\n<li>注意：通信的标签模板是在父组件中解析好后再传递给子组件的</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue组件间通信方式\"><a href=\"#vue组件间通信方式\" class=\"headerlink\" title=\"vue组件间通信方式\"></a>vue组件间通信方式</h3><h5 id=\"通信种类\"><a href=\"#通信种类\" class=\"headerlink\" title=\"通信种类\"></a>通信种类</h5><ol>\n<li>父组件向子组件通信</li>\n<li>子组件向父组件通信</li>\n<li>隔代组件间通信</li>\n<li>兄弟组件间通信</li>\n</ol>\n<h5 id=\"实现通信方式\"><a href=\"#实现通信方式\" class=\"headerlink\" title=\"实现通信方式\"></a>实现通信方式</h5><ol>\n<li>props</li>\n<li>vue自定义事件</li>\n<li>消息订阅与发布</li>\n<li>vuex</li>\n<li>slot</li>\n</ol>\n<h5 id=\"方式1：props\"><a href=\"#方式1：props\" class=\"headerlink\" title=\"方式1：props\"></a>方式1：props</h5><ol>\n<li>通过一般属性实现父向子通信</li>\n<li>通过函数属性实现子向父通信</li>\n<li>缺点：隔代组件和兄弟组件间通信比较麻烦</li>\n</ol>\n<h5 id=\"方式2：vue自定义事件\"><a href=\"#方式2：vue自定义事件\" class=\"headerlink\" title=\"方式2：vue自定义事件\"></a>方式2：vue自定义事件</h5><ol>\n<li>vue内置实现，可以代替函数类型的props<ul>\n<li>绑定监听：<code>&lt;MyComp @eventName=&quot;callback&quot;&gt;&lt;/MyComp&gt;</code></li>\n<li>触发（分发）事件：<code>this.$emit(&quot;eventName&quot;,data)</code></li>\n</ul>\n</li>\n<li>缺点：只适合于子向父通信</li>\n</ol>\n<h5 id=\"方式3：消息订阅与发布\"><a href=\"#方式3：消息订阅与发布\" class=\"headerlink\" title=\"方式3：消息订阅与发布\"></a>方式3：消息订阅与发布</h5><ol>\n<li>需要引入消息订阅与发布的实现库，如：<code>pubsub-js</code><ul>\n<li>订阅消息：<code>PubSub.subscript(&#39;msg&#39;,function(msg,data){})</code></li>\n<li>发布消息：<code>PubSub.publish(&#39;msg&#39;,data)</code></li>\n</ul>\n</li>\n<li>优点：此方式可实现任意关系组件间通信</li>\n</ol>\n<h5 id=\"方式4：vuex\"><a href=\"#方式4：vuex\" class=\"headerlink\" title=\"方式4：vuex\"></a>方式4：vuex</h5><ol>\n<li>vuex是vue\u0001官方提供的集中式管理vue多组间共享状态数据的vue插件</li>\n<li>优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便</li>\n</ol>\n<h5 id=\"方式5：slot\"><a href=\"#方式5：slot\" class=\"headerlink\" title=\"方式5：slot\"></a>方式5：slot</h5><ol>\n<li>专门用来实现父向子传递带数据的标签<ul>\n<li>子组件</li>\n<li>父组件</li>\n</ul>\n</li>\n<li>注意：通信的标签模板是在父组件中解析好后再传递给子组件的</li>\n</ol>\n"},{"title":"vue计算属性和侦听器","date":"2018-12-09T04:32:11.000Z","_content":"\n### Vue的计算属性和侦听器\n\n> 在模板中使用表达式以及相关的逻辑，会使得模板看起来过重且难以维护。\n>\n> 对于任何的复杂逻辑，你都应当使用计算属性。\n\n```jsx\n<template>\n    <div id=\"example\">\n      <p>Original message: \"{{ message }}\"</p>\n      <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n    </div>\n</template>\n<script>\n\texport default({\n        data: {\n            message: 'Hello'\n        },\n        computed: {\n            // 计算属性的 getter\n            reversedMessage: function () {\n                // `this` 指向 vm 实例\n                return this.message.split('').reverse().join('')\n            }\n        }\n\t})\n</script>\n```\n\n使用计算属性时，直接使用相关的方法名，就可以得到相关的返回结果。\n\n##### 计算属性vs方法\n\n计算属性跟调用方法非常的类似\n\n```jsx\n<p>Reversed message: \"{{ reversedMessage() }}\"</p>\n// 在组件中\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n我们可以将同一个函数定义为方法而不是计算属性，两种方法得到的结果是完全相同的。**不同的是：计算属性是基于它们的依赖进行缓存的。**只有在相关的依赖发生变化时，它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n> 参考官方文档：[https://cn.vuejs.org/v2/guide/computed.html#计算属性](https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7)","source":"_posts/vue计算属性和侦听器.md","raw":"---\ntitle: vue计算属性和侦听器\ndate: 2018-12-09 12:32:11\ntags: Vue\ncategories: 前端\n---\n\n### Vue的计算属性和侦听器\n\n> 在模板中使用表达式以及相关的逻辑，会使得模板看起来过重且难以维护。\n>\n> 对于任何的复杂逻辑，你都应当使用计算属性。\n\n```jsx\n<template>\n    <div id=\"example\">\n      <p>Original message: \"{{ message }}\"</p>\n      <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n    </div>\n</template>\n<script>\n\texport default({\n        data: {\n            message: 'Hello'\n        },\n        computed: {\n            // 计算属性的 getter\n            reversedMessage: function () {\n                // `this` 指向 vm 实例\n                return this.message.split('').reverse().join('')\n            }\n        }\n\t})\n</script>\n```\n\n使用计算属性时，直接使用相关的方法名，就可以得到相关的返回结果。\n\n##### 计算属性vs方法\n\n计算属性跟调用方法非常的类似\n\n```jsx\n<p>Reversed message: \"{{ reversedMessage() }}\"</p>\n// 在组件中\nmethods: {\n  reversedMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\n我们可以将同一个函数定义为方法而不是计算属性，两种方法得到的结果是完全相同的。**不同的是：计算属性是基于它们的依赖进行缓存的。**只有在相关的依赖发生变化时，它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n> 参考官方文档：[https://cn.vuejs.org/v2/guide/computed.html#计算属性](https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7)","slug":"vue计算属性和侦听器","published":1,"updated":"2024-02-19T07:42:51.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrb8004h1xopdb1j6cil","content":"<h3 id=\"Vue的计算属性和侦听器\"><a href=\"#Vue的计算属性和侦听器\" class=\"headerlink\" title=\"Vue的计算属性和侦听器\"></a>Vue的计算属性和侦听器</h3><blockquote>\n<p>在模板中使用表达式以及相关的逻辑，会使得模板看起来过重且难以维护。</p>\n<p>对于任何的复杂逻辑，你都应当使用计算属性。</p>\n</blockquote>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>example<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Original message<span class=\"token punctuation\">:</span> <span class=\"token string\">\"{{ message }}\"</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Computed reversed message<span class=\"token punctuation\">:</span> <span class=\"token string\">\"{{ reversedMessage }}\"</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        data<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            message<span class=\"token punctuation\">:</span> <span class=\"token string\">'Hello'</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        computed<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 计算属性的 getter</span>\n            reversedMessage<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// `this` 指向 vm 实例</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用计算属性时，直接使用相关的方法名，就可以得到相关的返回结果。</p>\n<h5 id=\"计算属性vs方法\"><a href=\"#计算属性vs方法\" class=\"headerlink\" title=\"计算属性vs方法\"></a>计算属性vs方法</h5><p>计算属性跟调用方法非常的类似</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Reversed message<span class=\"token punctuation\">:</span> <span class=\"token string\">\"{{ reversedMessage() }}\"</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">// 在组件中</span>\nmethods<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  reversedMessage<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>我们可以将同一个函数定义为方法而不是计算属性，两种方法得到的结果是完全相同的。<strong>不同的是：计算属性是基于它们的依赖进行缓存的。</strong>只有在相关的依赖发生变化时，它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<blockquote>\n<p>参考官方文档：<a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/computed.html#计算属性</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Vue的计算属性和侦听器\"><a href=\"#Vue的计算属性和侦听器\" class=\"headerlink\" title=\"Vue的计算属性和侦听器\"></a>Vue的计算属性和侦听器</h3><blockquote>\n<p>在模板中使用表达式以及相关的逻辑，会使得模板看起来过重且难以维护。</p>\n<p>对于任何的复杂逻辑，你都应当使用计算属性。</p>\n</blockquote>\n<pre><code class=\"jsx\">&lt;template&gt;\n    &lt;div id=&quot;example&quot;&gt;\n      &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;\n      &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default({\n        data: {\n            message: &#39;Hello&#39;\n        },\n        computed: {\n            // 计算属性的 getter\n            reversedMessage: function () {\n                // `this` 指向 vm 实例\n                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n            }\n        }\n    })\n&lt;/script&gt;\n</code></pre>\n<p>使用计算属性时，直接使用相关的方法名，就可以得到相关的返回结果。</p>\n<h5 id=\"计算属性vs方法\"><a href=\"#计算属性vs方法\" class=\"headerlink\" title=\"计算属性vs方法\"></a>计算属性vs方法</h5><p>计算属性跟调用方法非常的类似</p>\n<pre><code class=\"jsx\">&lt;p&gt;Reversed message: &quot;{{ reversedMessage() }}&quot;&lt;/p&gt;\n// 在组件中\nmethods: {\n  reversedMessage: function () {\n    return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n  }\n}\n</code></pre>\n<p>我们可以将同一个函数定义为方法而不是计算属性，两种方法得到的结果是完全相同的。<strong>不同的是：计算属性是基于它们的依赖进行缓存的。</strong>只有在相关的依赖发生变化时，它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>\n<blockquote>\n<p>参考官方文档：<a href=\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/computed.html#计算属性</a></p>\n</blockquote>\n"},{"title":"vue自定义指令","date":"2019-04-24T04:34:43.000Z","_content":"\n### vue自定义指令用法\n\n##### 可以通过`Vue.directive`来定义全局指令\n```javaScript\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n##### 如果想注册局部指令，组件中也接受`directives`选项\n\n```javaScript\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n##### 可以在模板中任何元素上使用`v-focus`\n\n```html\n<input v-focus>\n```\n##### 提供的钩子函数\n- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n- update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n- componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n\n- unbind：只调用一次，指令与元素解绑时调用。\n\n- 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\n##### 钩子函数参数\n- el：指令所绑定的元素，可以用来直接操作 DOM 。\n\n- binding：一个对象，包含以下属性：\n    name：指令名，不包括 v- 前缀。\n\n    1. value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n\n    2. oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n\n    3. expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n\n    4. arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n\n    5. modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n\n- vnode：Vue 编译生成的虚拟节点。\n\n- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n> 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。\n\n##### 通过全局指令实现img默认图片\n\n\n```javaScript\n//默认图片\nVue.directive('defaultImg', {\n    bind: function(el) {\n        //在图片加载失败时执行onerror\n        el.onerror = function(){\n            el.src = require('../src/assets/images/pic_small.png');\n        }\n    }\n})\n\n```","source":"_posts/vue自定义指令.md","raw":"---\ntitle: vue自定义指令\ndate: 2019-04-24 12:34:43\ntags: Vue\ncategories: 前端\n---\n\n### vue自定义指令用法\n\n##### 可以通过`Vue.directive`来定义全局指令\n```javaScript\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n```\n##### 如果想注册局部指令，组件中也接受`directives`选项\n\n```javaScript\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n##### 可以在模板中任何元素上使用`v-focus`\n\n```html\n<input v-focus>\n```\n##### 提供的钩子函数\n- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n\n- inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n\n- update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n\n- componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n\n- unbind：只调用一次，指令与元素解绑时调用。\n\n- 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\n##### 钩子函数参数\n- el：指令所绑定的元素，可以用来直接操作 DOM 。\n\n- binding：一个对象，包含以下属性：\n    name：指令名，不包括 v- 前缀。\n\n    1. value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n\n    2. oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n\n    3. expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n\n    4. arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n\n    5. modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n\n- vnode：Vue 编译生成的虚拟节点。\n\n- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。\n\n> 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。\n\n##### 通过全局指令实现img默认图片\n\n\n```javaScript\n//默认图片\nVue.directive('defaultImg', {\n    bind: function(el) {\n        //在图片加载失败时执行onerror\n        el.onerror = function(){\n            el.src = require('../src/assets/images/pic_small.png');\n        }\n    }\n})\n\n```","slug":"vue自定义指令","published":1,"updated":"2024-02-19T07:42:51.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrh4005b1xop50k077lb","content":"<h3 id=\"vue自定义指令用法\"><a href=\"#vue自定义指令用法\" class=\"headerlink\" title=\"vue自定义指令用法\"></a>vue自定义指令用法</h3><h5 id=\"可以通过Vue-directive来定义全局指令\"><a href=\"#可以通过Vue-directive来定义全局指令\" class=\"headerlink\" title=\"可以通过Vue.directive来定义全局指令\"></a>可以通过<code>Vue.directive</code>来定义全局指令</h5><pre class=\"line-numbers language-javaScript\"><code class=\"language-javaScript\">// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"如果想注册局部指令，组件中也接受directives选项\"><a href=\"#如果想注册局部指令，组件中也接受directives选项\" class=\"headerlink\" title=\"如果想注册局部指令，组件中也接受directives选项\"></a>如果想注册局部指令，组件中也接受<code>directives</code>选项</h5><pre class=\"line-numbers language-javaScript\"><code class=\"language-javaScript\">directives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"可以在模板中任何元素上使用v-focus\"><a href=\"#可以在模板中任何元素上使用v-focus\" class=\"headerlink\" title=\"可以在模板中任何元素上使用v-focus\"></a>可以在模板中任何元素上使用<code>v-focus</code></h5><pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">v-focus</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h5 id=\"提供的钩子函数\"><a href=\"#提供的钩子函数\" class=\"headerlink\" title=\"提供的钩子函数\"></a>提供的钩子函数</h5><ul>\n<li><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n</li>\n<li><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>\n</li>\n<li><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>\n</li>\n<li><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>\n</li>\n<li><p>unbind：只调用一次，指令与元素解绑时调用。</p>\n</li>\n<li><p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p>\n</li>\n</ul>\n<h5 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h5><ul>\n<li><p>el：指令所绑定的元素，可以用来直接操作 DOM 。</p>\n</li>\n<li><p>binding：一个对象，包含以下属性：<br>  name：指令名，不包括 v- 前缀。</p>\n<ol>\n<li><p>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</p>\n</li>\n<li><p>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</p>\n</li>\n<li><p>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</p>\n</li>\n<li><p>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</p>\n</li>\n<li><p>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</p>\n</li>\n</ol>\n</li>\n<li><p>vnode：Vue 编译生成的虚拟节点。</p>\n</li>\n<li><p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>\n</li>\n</ul>\n<blockquote>\n<p>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>\n</blockquote>\n<h5 id=\"通过全局指令实现img默认图片\"><a href=\"#通过全局指令实现img默认图片\" class=\"headerlink\" title=\"通过全局指令实现img默认图片\"></a>通过全局指令实现img默认图片</h5><pre class=\"line-numbers language-javaScript\"><code class=\"language-javaScript\">//默认图片\nVue.directive('defaultImg', {\n    bind: function(el) {\n        //在图片加载失败时执行onerror\n        el.onerror = function(){\n            el.src = require('../src/assets/images/pic_small.png');\n        }\n    }\n})\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue自定义指令用法\"><a href=\"#vue自定义指令用法\" class=\"headerlink\" title=\"vue自定义指令用法\"></a>vue自定义指令用法</h3><h5 id=\"可以通过Vue-directive来定义全局指令\"><a href=\"#可以通过Vue-directive来定义全局指令\" class=\"headerlink\" title=\"可以通过Vue.directive来定义全局指令\"></a>可以通过<code>Vue.directive</code>来定义全局指令</h5><pre><code class=\"javaScript\">// 注册一个全局自定义指令 `v-focus`\nVue.directive(&#39;focus&#39;, {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n</code></pre>\n<h5 id=\"如果想注册局部指令，组件中也接受directives选项\"><a href=\"#如果想注册局部指令，组件中也接受directives选项\" class=\"headerlink\" title=\"如果想注册局部指令，组件中也接受directives选项\"></a>如果想注册局部指令，组件中也接受<code>directives</code>选项</h5><pre><code class=\"javaScript\">directives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n</code></pre>\n<h5 id=\"可以在模板中任何元素上使用v-focus\"><a href=\"#可以在模板中任何元素上使用v-focus\" class=\"headerlink\" title=\"可以在模板中任何元素上使用v-focus\"></a>可以在模板中任何元素上使用<code>v-focus</code></h5><pre><code class=\"html\">&lt;input v-focus&gt;\n</code></pre>\n<h5 id=\"提供的钩子函数\"><a href=\"#提供的钩子函数\" class=\"headerlink\" title=\"提供的钩子函数\"></a>提供的钩子函数</h5><ul>\n<li><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n</li>\n<li><p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>\n</li>\n<li><p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</p>\n</li>\n<li><p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p>\n</li>\n<li><p>unbind：只调用一次，指令与元素解绑时调用。</p>\n</li>\n<li><p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p>\n</li>\n</ul>\n<h5 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h5><ul>\n<li><p>el：指令所绑定的元素，可以用来直接操作 DOM 。</p>\n</li>\n<li><p>binding：一个对象，包含以下属性：<br>  name：指令名，不包括 v- 前缀。</p>\n<ol>\n<li><p>value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。</p>\n</li>\n<li><p>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</p>\n</li>\n<li><p>expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。</p>\n</li>\n<li><p>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</p>\n</li>\n<li><p>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。</p>\n</li>\n</ol>\n</li>\n<li><p>vnode：Vue 编译生成的虚拟节点。</p>\n</li>\n<li><p>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</p>\n</li>\n</ul>\n<blockquote>\n<p>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。</p>\n</blockquote>\n<h5 id=\"通过全局指令实现img默认图片\"><a href=\"#通过全局指令实现img默认图片\" class=\"headerlink\" title=\"通过全局指令实现img默认图片\"></a>通过全局指令实现img默认图片</h5><pre><code class=\"javaScript\">//默认图片\nVue.directive(&#39;defaultImg&#39;, {\n    bind: function(el) {\n        //在图片加载失败时执行onerror\n        el.onerror = function(){\n            el.src = require(&#39;../src/assets/images/pic_small.png&#39;);\n        }\n    }\n})\n\n</code></pre>\n"},{"title":"word-break、overflow-wrap、white-space","date":"2020-08-05T06:46:17.000Z","_content":"\n##### **word-break、overflow-wrap、white-space**\n\n> [本文参考]: https://juejin.im/post/5b8905456fb9a01a105966b4\n\n- **white-space**\n\n  > 属性设置如何处理元素内的空白\n  >\n  > 值：\n  >\n  > \n  >\n  > |     值     |                             描述                             |\n  > | :--------: | :----------------------------------------------------------: |\n  > |  `normal`  |              默认值。代码中的空白会被浏览器忽略              |\n  > |   `pre`    | 空白会被浏览器保留并渲染。自动换行（文本超过一行后自动换行）不会保留。 |\n  > |  `nowrap`  |   文本不会换行，会在同一行上继续，直到遇到`<br>`标签为止。   |\n  > | `pre-line` |                 合并空白符序列，但保留换行。                 |\n  > | `pre-wrap` |              保留空格和换行符，且可以自动换行。              |\n  > | `ingerit`  |                    规定从父元素继承该属性                    |\n  > |            |                                                              |\n  >\n  > \n\n- **word-break**\n\n  > 属性处理单词如何进行换行\n  >\n  > 值：\n  >\n  > |     值      |             描述             |\n  > | :---------: | :--------------------------: |\n  > |  `normal`   |   使用浏览器默认的换行规则   |\n  > | `break-all` | 所有单词碰到边界一律拆分换行 |\n  > | `keep-all`  | 只能在半角空格或连字符处换行 |\n  > |             |                              |\n\n- **overflow-wrap**\n\n  > 属性用来处理某个太长的单词超出其包裹盒时的换行行为\n  >\n  > 值：\n  >\n  > | 值       | 描述                                       |\n  > | :------: | :----------------------------------------: |\n  > | `normal` | 浏览器默认行为。表示在正常的单词结束处换行 |\n  > | `break-word` | 如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（只有长单词遇到边界才会换行） |\n  > |          |                                            |\n  > \n  >","source":"_posts/word-break、overflow-wrap、white-space.md","raw":"---\ntitle: word-break、overflow-wrap、white-space\ndate: 2020-08-05 14:46:17\ntags: css\ncategories: 前端\n---\n\n##### **word-break、overflow-wrap、white-space**\n\n> [本文参考]: https://juejin.im/post/5b8905456fb9a01a105966b4\n\n- **white-space**\n\n  > 属性设置如何处理元素内的空白\n  >\n  > 值：\n  >\n  > \n  >\n  > |     值     |                             描述                             |\n  > | :--------: | :----------------------------------------------------------: |\n  > |  `normal`  |              默认值。代码中的空白会被浏览器忽略              |\n  > |   `pre`    | 空白会被浏览器保留并渲染。自动换行（文本超过一行后自动换行）不会保留。 |\n  > |  `nowrap`  |   文本不会换行，会在同一行上继续，直到遇到`<br>`标签为止。   |\n  > | `pre-line` |                 合并空白符序列，但保留换行。                 |\n  > | `pre-wrap` |              保留空格和换行符，且可以自动换行。              |\n  > | `ingerit`  |                    规定从父元素继承该属性                    |\n  > |            |                                                              |\n  >\n  > \n\n- **word-break**\n\n  > 属性处理单词如何进行换行\n  >\n  > 值：\n  >\n  > |     值      |             描述             |\n  > | :---------: | :--------------------------: |\n  > |  `normal`   |   使用浏览器默认的换行规则   |\n  > | `break-all` | 所有单词碰到边界一律拆分换行 |\n  > | `keep-all`  | 只能在半角空格或连字符处换行 |\n  > |             |                              |\n\n- **overflow-wrap**\n\n  > 属性用来处理某个太长的单词超出其包裹盒时的换行行为\n  >\n  > 值：\n  >\n  > | 值       | 描述                                       |\n  > | :------: | :----------------------------------------: |\n  > | `normal` | 浏览器默认行为。表示在正常的单词结束处换行 |\n  > | `break-word` | 如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（只有长单词遇到边界才会换行） |\n  > |          |                                            |\n  > \n  >","slug":"word-break、overflow-wrap、white-space","published":1,"updated":"2024-02-19T07:42:51.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrhj005d1xopc7ej76yv","content":"<h5 id=\"word-break、overflow-wrap、white-space\"><a href=\"#word-break、overflow-wrap、white-space\" class=\"headerlink\" title=\"word-break、overflow-wrap、white-space\"></a><strong>word-break、overflow-wrap、white-space</strong></h5><blockquote>\n</blockquote>\n<ul>\n<li><p><strong>white-space</strong></p>\n<blockquote>\n<p>属性设置如何处理元素内的空白</p>\n<p>值：</p>\n<p>|     值     |                             描述                             |<br>| :——–: | :———————————————————-: |<br>|  <code>normal</code>  |              默认值。代码中的空白会被浏览器忽略              |<br>|   <code>pre</code>    | 空白会被浏览器保留并渲染。自动换行（文本超过一行后自动换行）不会保留。 |<br>|  <code>nowrap</code>  |   文本不会换行，会在同一行上继续，直到遇到<code>&lt;br&gt;</code>标签为止。   |<br>| <code>pre-line</code> |                 合并空白符序列，但保留换行。                 |<br>| <code>pre-wrap</code> |              保留空格和换行符，且可以自动换行。              |<br>| <code>ingerit</code>  |                    规定从父元素继承该属性                    |<br>|            |                                                              |</p>\n</blockquote>\n</li>\n<li><p><strong>word-break</strong></p>\n<blockquote>\n<p>属性处理单词如何进行换行</p>\n<p>值：</p>\n<p>|     值      |             描述             |<br>| :———: | :————————–: |<br>|  <code>normal</code>   |   使用浏览器默认的换行规则   |<br>| <code>break-all</code> | 所有单词碰到边界一律拆分换行 |<br>| <code>keep-all</code>  | 只能在半角空格或连字符处换行 |<br>|             |                              |</p>\n</blockquote>\n</li>\n<li><p><strong>overflow-wrap</strong></p>\n<blockquote>\n<p>属性用来处理某个太长的单词超出其包裹盒时的换行行为</p>\n<p>值：</p>\n<p>| 值       | 描述                                       |<br>| :——: | :—————————————-: |<br>| <code>normal</code> | 浏览器默认行为。表示在正常的单词结束处换行 |<br>| <code>break-word</code> | 如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（只有长单词遇到边界才会换行） |<br>|          |                                            |</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"word-break、overflow-wrap、white-space\"><a href=\"#word-break、overflow-wrap、white-space\" class=\"headerlink\" title=\"word-break、overflow-wrap、white-space\"></a><strong>word-break、overflow-wrap、white-space</strong></h5><blockquote>\n</blockquote>\n<ul>\n<li><p><strong>white-space</strong></p>\n<blockquote>\n<p>属性设置如何处理元素内的空白</p>\n<p>值：</p>\n<p>|     值     |                             描述                             |<br>| :——–: | :———————————————————-: |<br>|  <code>normal</code>  |              默认值。代码中的空白会被浏览器忽略              |<br>|   <code>pre</code>    | 空白会被浏览器保留并渲染。自动换行（文本超过一行后自动换行）不会保留。 |<br>|  <code>nowrap</code>  |   文本不会换行，会在同一行上继续，直到遇到<code>&lt;br&gt;</code>标签为止。   |<br>| <code>pre-line</code> |                 合并空白符序列，但保留换行。                 |<br>| <code>pre-wrap</code> |              保留空格和换行符，且可以自动换行。              |<br>| <code>ingerit</code>  |                    规定从父元素继承该属性                    |<br>|            |                                                              |</p>\n</blockquote>\n</li>\n<li><p><strong>word-break</strong></p>\n<blockquote>\n<p>属性处理单词如何进行换行</p>\n<p>值：</p>\n<p>|     值      |             描述             |<br>| :———: | :————————–: |<br>|  <code>normal</code>   |   使用浏览器默认的换行规则   |<br>| <code>break-all</code> | 所有单词碰到边界一律拆分换行 |<br>| <code>keep-all</code>  | 只能在半角空格或连字符处换行 |<br>|             |                              |</p>\n</blockquote>\n</li>\n<li><p><strong>overflow-wrap</strong></p>\n<blockquote>\n<p>属性用来处理某个太长的单词超出其包裹盒时的换行行为</p>\n<p>值：</p>\n<p>| 值       | 描述                                       |<br>| :——: | :—————————————-: |<br>| <code>normal</code> | 浏览器默认行为。表示在正常的单词结束处换行 |<br>| <code>break-word</code> | 如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（只有长单词遇到边界才会换行） |<br>|          |                                            |</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"vue组件生命周期","date":"2018-10-21T08:30:32.000Z","_content":"\n### vue组件生命周期\n\n参考自Vue官方：https://cn.vuejs.org/v2/api/\n\n生命周期的概念：每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会发生一系列事件，这些事件就叫做组件的生命周期函数。\n\n**需要注意的是：**\n\n> 所有的生命周期钩子自动绑定`this`上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此`this`与你期待的Vue实例不同。\n\n![](vue组件声明周期/da4542b8404aacff8083b804fa48db76.png)\n\n> 参考：https://cn.vuejs.org/v2/guide/instance.html\n\n1. beforeCreate：这是第一个生命周期函数，此时组件的data和methods以及页面DOM结构，都还没有初始化，所以此阶段，什么都做不了。\n\n2. create：此时，组件的data和methods已经可用。在这一步，实例已经完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，`$el`属性目前不可见。**在这个生命周期函数中，我们经常会发起Ajax请求。**\n\n3. beforeMount：在挂载开始之前被调用：相关的`render`函数首次被调用。\n\n4. mounted：`el`被新创建的`vm.$el`替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当`mounted`被调用时`vm.$el`也在文档内。**需要注意的是：`mounted`不会承诺所有的子组件也都一起被加载，如果你希望等到整个视图都渲染完毕，可以用`vm.$nextTick`替换掉`mounted`**，如果页面用到了第三方UI插件，而且这个插件还需要被初始化，那么必需在mounted中来初始化插件。\n\n   ```js\n   mounted:function(){\n       this.$nextTick(function(){\n           //等到整个视图加载完成后的操作\n       })\n   }\n   ```\n\n5. beforeUpdate：数据更新时的调用，在此阶段，数据是最新的，但是页面是旧的。\n\n6. updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n   当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](https://cn.vuejs.org/v2/api/#computed)或 [watcher](https://cn.vuejs.org/v2/api/#watch) 取而代之。\n\n   **注意 `updated` 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick) 替换掉 `updated`**：\n\n   ```js\n   updated: function () {\n     this.$nextTick(function () {\n       // Code that will run only after the\n       // entire view has been re-rendered\n     })\n   }\n   ```\n\n7. activated：`keep-alive`组件激活时调用。\n8. deactivated：`keep-alive`组件停用时调用。\n9. beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\n10. destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","source":"_posts/vue组件生命周期.md","raw":"---\ntitle: vue组件生命周期\ndate: 2018-10-21 16:30:32\ntags: Vue\ncategories: 前端\n---\n\n### vue组件生命周期\n\n参考自Vue官方：https://cn.vuejs.org/v2/api/\n\n生命周期的概念：每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会发生一系列事件，这些事件就叫做组件的生命周期函数。\n\n**需要注意的是：**\n\n> 所有的生命周期钩子自动绑定`this`上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此`this`与你期待的Vue实例不同。\n\n![](vue组件声明周期/da4542b8404aacff8083b804fa48db76.png)\n\n> 参考：https://cn.vuejs.org/v2/guide/instance.html\n\n1. beforeCreate：这是第一个生命周期函数，此时组件的data和methods以及页面DOM结构，都还没有初始化，所以此阶段，什么都做不了。\n\n2. create：此时，组件的data和methods已经可用。在这一步，实例已经完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，`$el`属性目前不可见。**在这个生命周期函数中，我们经常会发起Ajax请求。**\n\n3. beforeMount：在挂载开始之前被调用：相关的`render`函数首次被调用。\n\n4. mounted：`el`被新创建的`vm.$el`替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当`mounted`被调用时`vm.$el`也在文档内。**需要注意的是：`mounted`不会承诺所有的子组件也都一起被加载，如果你希望等到整个视图都渲染完毕，可以用`vm.$nextTick`替换掉`mounted`**，如果页面用到了第三方UI插件，而且这个插件还需要被初始化，那么必需在mounted中来初始化插件。\n\n   ```js\n   mounted:function(){\n       this.$nextTick(function(){\n           //等到整个视图加载完成后的操作\n       })\n   }\n   ```\n\n5. beforeUpdate：数据更新时的调用，在此阶段，数据是最新的，但是页面是旧的。\n\n6. updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。\n\n   当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用[计算属性](https://cn.vuejs.org/v2/api/#computed)或 [watcher](https://cn.vuejs.org/v2/api/#watch) 取而代之。\n\n   **注意 `updated` 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 [vm.$nextTick](https://cn.vuejs.org/v2/api/#vm-nextTick) 替换掉 `updated`**：\n\n   ```js\n   updated: function () {\n     this.$nextTick(function () {\n       // Code that will run only after the\n       // entire view has been re-rendered\n     })\n   }\n   ```\n\n7. activated：`keep-alive`组件激活时调用。\n8. deactivated：`keep-alive`组件停用时调用。\n9. beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。\n10. destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","slug":"vue组件生命周期","published":1,"updated":"2024-02-19T07:42:51.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrhx005f1xophu36ebx7","content":"<h3 id=\"vue组件生命周期\"><a href=\"#vue组件生命周期\" class=\"headerlink\" title=\"vue组件生命周期\"></a>vue组件生命周期</h3><p>参考自Vue官方：<a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/api/</a></p>\n<p>生命周期的概念：每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会发生一系列事件，这些事件就叫做组件的生命周期函数。</p>\n<p><strong>需要注意的是：</strong></p>\n<blockquote>\n<p>所有的生命周期钩子自动绑定<code>this</code>上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此<code>this</code>与你期待的Vue实例不同。</p>\n</blockquote>\n<p><img src=\"/2018/10/21/vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/da4542b8404aacff8083b804fa48db76.png\" alt></p>\n<blockquote>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/guide/instance.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/instance.html</a></p>\n</blockquote>\n<ol>\n<li><p>beforeCreate：这是第一个生命周期函数，此时组件的data和methods以及页面DOM结构，都还没有初始化，所以此阶段，什么都做不了。</p>\n</li>\n<li><p>create：此时，组件的data和methods已经可用。在这一步，实例已经完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，<code>$el</code>属性目前不可见。<strong>在这个生命周期函数中，我们经常会发起Ajax请求。</strong></p>\n</li>\n<li><p>beforeMount：在挂载开始之前被调用：相关的<code>render</code>函数首次被调用。</p>\n</li>\n<li><p>mounted：<code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。<strong>需要注意的是：<code>mounted</code>不会承诺所有的子组件也都一起被加载，如果你希望等到整个视图都渲染完毕，可以用<code>vm.$nextTick</code>替换掉<code>mounted</code></strong>，如果页面用到了第三方UI插件，而且这个插件还需要被初始化，那么必需在mounted中来初始化插件。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">mounted<span class=\"token punctuation\">:</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$nextTick</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//等到整个视图加载完成后的操作</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>beforeUpdate：数据更新时的调用，在此阶段，数据是最新的，但是页面是旧的。</p>\n</li>\n<li><p>updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href=\"https://cn.vuejs.org/v2/api/#computed\" target=\"_blank\" rel=\"noopener\">计算属性</a>或 <a href=\"https://cn.vuejs.org/v2/api/#watch\" target=\"_blank\" rel=\"noopener\">watcher</a> 取而代之。</p>\n<p><strong>注意 <code>updated</code> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 <a href=\"https://cn.vuejs.org/v2/api/#vm-nextTick\" target=\"_blank\" rel=\"noopener\">vm.$nextTick</a> 替换掉 <code>updated</code></strong>：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">updated<span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">$nextTick</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// Code that will run only after the</span>\n    <span class=\"token comment\" spellcheck=\"true\">// entire view has been re-rendered</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>activated：<code>keep-alive</code>组件激活时调用。</p>\n</li>\n<li>deactivated：<code>keep-alive</code>组件停用时调用。</li>\n<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue组件生命周期\"><a href=\"#vue组件生命周期\" class=\"headerlink\" title=\"vue组件生命周期\"></a>vue组件生命周期</h3><p>参考自Vue官方：<a href=\"https://cn.vuejs.org/v2/api/\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/api/</a></p>\n<p>生命周期的概念：每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会发生一系列事件，这些事件就叫做组件的生命周期函数。</p>\n<p><strong>需要注意的是：</strong></p>\n<blockquote>\n<p>所有的生命周期钩子自动绑定<code>this</code>上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此<code>this</code>与你期待的Vue实例不同。</p>\n</blockquote>\n<p><img src=\"/2018/10/21/vue%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/da4542b8404aacff8083b804fa48db76.png\" alt></p>\n<blockquote>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/guide/instance.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/instance.html</a></p>\n</blockquote>\n<ol>\n<li><p>beforeCreate：这是第一个生命周期函数，此时组件的data和methods以及页面DOM结构，都还没有初始化，所以此阶段，什么都做不了。</p>\n</li>\n<li><p>create：此时，组件的data和methods已经可用。在这一步，实例已经完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，<code>$el</code>属性目前不可见。<strong>在这个生命周期函数中，我们经常会发起Ajax请求。</strong></p>\n</li>\n<li><p>beforeMount：在挂载开始之前被调用：相关的<code>render</code>函数首次被调用。</p>\n</li>\n<li><p>mounted：<code>el</code>被新创建的<code>vm.$el</code>替换，并挂载到实例上去之后调用该钩子。如果root实例挂载了一个文档内元素，当<code>mounted</code>被调用时<code>vm.$el</code>也在文档内。<strong>需要注意的是：<code>mounted</code>不会承诺所有的子组件也都一起被加载，如果你希望等到整个视图都渲染完毕，可以用<code>vm.$nextTick</code>替换掉<code>mounted</code></strong>，如果页面用到了第三方UI插件，而且这个插件还需要被初始化，那么必需在mounted中来初始化插件。</p>\n<pre><code class=\"js\">mounted:function(){\n    this.$nextTick(function(){\n        //等到整个视图加载完成后的操作\n    })\n}\n</code></pre>\n</li>\n<li><p>beforeUpdate：数据更新时的调用，在此阶段，数据是最新的，但是页面是旧的。</p>\n</li>\n<li><p>updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>\n<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href=\"https://cn.vuejs.org/v2/api/#computed\" target=\"_blank\" rel=\"noopener\">计算属性</a>或 <a href=\"https://cn.vuejs.org/v2/api/#watch\" target=\"_blank\" rel=\"noopener\">watcher</a> 取而代之。</p>\n<p><strong>注意 <code>updated</code> 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 <a href=\"https://cn.vuejs.org/v2/api/#vm-nextTick\" target=\"_blank\" rel=\"noopener\">vm.$nextTick</a> 替换掉 <code>updated</code></strong>：</p>\n<pre><code class=\"js\">updated: function () {\n  this.$nextTick(function () {\n    // Code that will run only after the\n    // entire view has been re-rendered\n  })\n}\n</code></pre>\n</li>\n<li><p>activated：<code>keep-alive</code>组件激活时调用。</p>\n</li>\n<li>deactivated：<code>keep-alive</code>组件停用时调用。</li>\n<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li>\n<li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ol>\n"},{"title":"webpack","date":"2018-10-25T02:37:09.000Z","_content":"\n### webpack\n\n##### 创建基本的webpack4.x项目\n\n1. 运行`npm init -y`快速初始化项目\n2. 在项目根目录创建`src`源代码目录和`dist`产品目录\n3. 在`src`目录下创建`index.html`\n4. 使用npm安装webpack，运行`cnpm i webpack webpack-cli -D`\n   - 全局运行`npm i cnpm -g`\n\n5. 注意：webpack4.x提供了约定大于配置的概念，目的是为了尽量减少配置文件的体积\n   - 默认约定了：\n   - 打包入口是`src`->`index.js`\n   - 打包的输出文件是`dist`->`main.js`\n   - 4.x中新增了`mode`选项（**必需**），可选的值为：`development`和`production`\n\n**webpack的配置文件：**`webpack.config.js`:\n\n```js\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:'production', //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n}\n```\n\n##### 安装webpack-dev-server\n\n**命令：**`npm i webpack-dev-server -D`\n\n在`package.json`中的`scripts`中添加`dev`选项：\n\n```json\n{\n    ...\n   \"scripts\":{\n\t\t...\n    \t\"dev\": \"webpack-dev-server --open --port 3000\"  //--open 自动打开浏览器 --port 指定端口\n\t} \n}\n```\n\n配置好之后，运行：`npm run dev`\n\n**webpack-dev-server**打包好的`main.js`是托管到内存中的，所以在项目根目录中找不到。\n\n##### 安装相关插件：\n\n**命令：**`npm i html-webpack-plugin -D`\n\n**作用：**将主页面生成到内存中去。\n\n配置`webpack.config.js`文件：\n\n```js\nconst path = require('path')\nconst HtmlWebPackPlugin = require('html-webpack-plugin') //导入 在内存中自动生成index页面的插件\n\n//创建一个插件实例对象\nconst htmlPlugin = new HtmlWebPackPlugin({\n    template: path.join(__dirname, './src/index.html'), //源文件\n    filename: 'index.html' //生成的内存中首页名称\n})\n\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:'production', //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n    plugins:[\n        htmlPlugin\n    ]\n}\n```\n\n","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2018-10-25 10:37:09\ntags: webpack使用\ncategories: 前端\n---\n\n### webpack\n\n##### 创建基本的webpack4.x项目\n\n1. 运行`npm init -y`快速初始化项目\n2. 在项目根目录创建`src`源代码目录和`dist`产品目录\n3. 在`src`目录下创建`index.html`\n4. 使用npm安装webpack，运行`cnpm i webpack webpack-cli -D`\n   - 全局运行`npm i cnpm -g`\n\n5. 注意：webpack4.x提供了约定大于配置的概念，目的是为了尽量减少配置文件的体积\n   - 默认约定了：\n   - 打包入口是`src`->`index.js`\n   - 打包的输出文件是`dist`->`main.js`\n   - 4.x中新增了`mode`选项（**必需**），可选的值为：`development`和`production`\n\n**webpack的配置文件：**`webpack.config.js`:\n\n```js\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:'production', //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n}\n```\n\n##### 安装webpack-dev-server\n\n**命令：**`npm i webpack-dev-server -D`\n\n在`package.json`中的`scripts`中添加`dev`选项：\n\n```json\n{\n    ...\n   \"scripts\":{\n\t\t...\n    \t\"dev\": \"webpack-dev-server --open --port 3000\"  //--open 自动打开浏览器 --port 指定端口\n\t} \n}\n```\n\n配置好之后，运行：`npm run dev`\n\n**webpack-dev-server**打包好的`main.js`是托管到内存中的，所以在项目根目录中找不到。\n\n##### 安装相关插件：\n\n**命令：**`npm i html-webpack-plugin -D`\n\n**作用：**将主页面生成到内存中去。\n\n配置`webpack.config.js`文件：\n\n```js\nconst path = require('path')\nconst HtmlWebPackPlugin = require('html-webpack-plugin') //导入 在内存中自动生成index页面的插件\n\n//创建一个插件实例对象\nconst htmlPlugin = new HtmlWebPackPlugin({\n    template: path.join(__dirname, './src/index.html'), //源文件\n    filename: 'index.html' //生成的内存中首页名称\n})\n\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:'production', //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js\n    plugins:[\n        htmlPlugin\n    ]\n}\n```\n\n","slug":"webpack","published":1,"updated":"2024-02-19T07:42:51.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri0005h1xopdaol47bk","content":"<h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h3><h5 id=\"创建基本的webpack4-x项目\"><a href=\"#创建基本的webpack4-x项目\" class=\"headerlink\" title=\"创建基本的webpack4.x项目\"></a>创建基本的webpack4.x项目</h5><ol>\n<li>运行<code>npm init -y</code>快速初始化项目</li>\n<li>在项目根目录创建<code>src</code>源代码目录和<code>dist</code>产品目录</li>\n<li>在<code>src</code>目录下创建<code>index.html</code></li>\n<li><p>使用npm安装webpack，运行<code>cnpm i webpack webpack-cli -D</code></p>\n<ul>\n<li>全局运行<code>npm i cnpm -g</code></li>\n</ul>\n</li>\n<li><p>注意：webpack4.x提供了约定大于配置的概念，目的是为了尽量减少配置文件的体积</p>\n<ul>\n<li>默认约定了：</li>\n<li>打包入口是<code>src</code>-&gt;<code>index.js</code></li>\n<li>打包的输出文件是<code>dist</code>-&gt;<code>main.js</code></li>\n<li>4.x中新增了<code>mode</code>选项（<strong>必需</strong>），可选的值为：<code>development</code>和<code>production</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>webpack的配置文件：</strong><code>webpack.config.js</code>:</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法</span>\nmodule<span class=\"token punctuation\">.</span>exports<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    mode<span class=\"token punctuation\">:</span><span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//development production</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"安装webpack-dev-server\"><a href=\"#安装webpack-dev-server\" class=\"headerlink\" title=\"安装webpack-dev-server\"></a>安装webpack-dev-server</h5><p><strong>命令：</strong><code>npm i webpack-dev-server -D</code></p>\n<p>在<code>package.json</code>中的<code>scripts</code>中添加<code>dev</code>选项：</p>\n<pre class=\"line-numbers language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n    ...\n   <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span><span class=\"token punctuation\">{</span>\n        ...\n        <span class=\"token property\">\"dev\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"webpack-dev-server --open --port 3000\"</span>  //--open 自动打开浏览器 --port 指定端口\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>配置好之后，运行：<code>npm run dev</code></p>\n<p><strong>webpack-dev-server</strong>打包好的<code>main.js</code>是托管到内存中的，所以在项目根目录中找不到。</p>\n<h5 id=\"安装相关插件：\"><a href=\"#安装相关插件：\" class=\"headerlink\" title=\"安装相关插件：\"></a>安装相关插件：</h5><p><strong>命令：</strong><code>npm i html-webpack-plugin -D</code></p>\n<p><strong>作用：</strong>将主页面生成到内存中去。</p>\n<p>配置<code>webpack.config.js</code>文件：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> path <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'path'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> HtmlWebPackPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'html-webpack-plugin'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//导入 在内存中自动生成index页面的插件</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//创建一个插件实例对象</span>\n<span class=\"token keyword\">const</span> htmlPlugin <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HtmlWebPackPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    template<span class=\"token punctuation\">:</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token string\">'./src/index.html'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//源文件</span>\n    filename<span class=\"token punctuation\">:</span> <span class=\"token string\">'index.html'</span> <span class=\"token comment\" spellcheck=\"true\">//生成的内存中首页名称</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法</span>\nmodule<span class=\"token punctuation\">.</span>exports<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    mode<span class=\"token punctuation\">:</span><span class=\"token string\">'production'</span><span class=\"token punctuation\">,</span> <span class=\"token comment\" spellcheck=\"true\">//development production</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -> index.js</span>\n    plugins<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span>\n        htmlPlugin\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h3><h5 id=\"创建基本的webpack4-x项目\"><a href=\"#创建基本的webpack4-x项目\" class=\"headerlink\" title=\"创建基本的webpack4.x项目\"></a>创建基本的webpack4.x项目</h5><ol>\n<li>运行<code>npm init -y</code>快速初始化项目</li>\n<li>在项目根目录创建<code>src</code>源代码目录和<code>dist</code>产品目录</li>\n<li>在<code>src</code>目录下创建<code>index.html</code></li>\n<li><p>使用npm安装webpack，运行<code>cnpm i webpack webpack-cli -D</code></p>\n<ul>\n<li>全局运行<code>npm i cnpm -g</code></li>\n</ul>\n</li>\n<li><p>注意：webpack4.x提供了约定大于配置的概念，目的是为了尽量减少配置文件的体积</p>\n<ul>\n<li>默认约定了：</li>\n<li>打包入口是<code>src</code>-&gt;<code>index.js</code></li>\n<li>打包的输出文件是<code>dist</code>-&gt;<code>main.js</code></li>\n<li>4.x中新增了<code>mode</code>选项（<strong>必需</strong>），可选的值为：<code>development</code>和<code>production</code></li>\n</ul>\n</li>\n</ol>\n<p><strong>webpack的配置文件：</strong><code>webpack.config.js</code>:</p>\n<pre><code class=\"js\">//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:&#39;production&#39;, //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -&gt; index.js\n}\n</code></pre>\n<h5 id=\"安装webpack-dev-server\"><a href=\"#安装webpack-dev-server\" class=\"headerlink\" title=\"安装webpack-dev-server\"></a>安装webpack-dev-server</h5><p><strong>命令：</strong><code>npm i webpack-dev-server -D</code></p>\n<p>在<code>package.json</code>中的<code>scripts</code>中添加<code>dev</code>选项：</p>\n<pre><code class=\"json\">{\n    ...\n   &quot;scripts&quot;:{\n        ...\n        &quot;dev&quot;: &quot;webpack-dev-server --open --port 3000&quot;  //--open 自动打开浏览器 --port 指定端口\n    } \n}\n</code></pre>\n<p>配置好之后，运行：<code>npm run dev</code></p>\n<p><strong>webpack-dev-server</strong>打包好的<code>main.js</code>是托管到内存中的，所以在项目根目录中找不到。</p>\n<h5 id=\"安装相关插件：\"><a href=\"#安装相关插件：\" class=\"headerlink\" title=\"安装相关插件：\"></a>安装相关插件：</h5><p><strong>命令：</strong><code>npm i html-webpack-plugin -D</code></p>\n<p><strong>作用：</strong>将主页面生成到内存中去。</p>\n<p>配置<code>webpack.config.js</code>文件：</p>\n<pre><code class=\"js\">const path = require(&#39;path&#39;)\nconst HtmlWebPackPlugin = require(&#39;html-webpack-plugin&#39;) //导入 在内存中自动生成index页面的插件\n\n//创建一个插件实例对象\nconst htmlPlugin = new HtmlWebPackPlugin({\n    template: path.join(__dirname, &#39;./src/index.html&#39;), //源文件\n    filename: &#39;index.html&#39; //生成的内存中首页名称\n})\n\n//向外暴露一个打包的配置对象， 因为webpack是基于Node构建的，所以webpack支持所有的Node API和语法\nmodule.exports={\n    mode:&#39;production&#39;, //development production\n    //在webpack 4.x中，有一个很大的特性，就是约定大于配置，默认的打包入口路径是src -&gt; index.js\n    plugins:[\n        htmlPlugin\n    ]\n}\n</code></pre>\n"},{"title":"二叉树","date":"2018-10-16T09:53:00.000Z","_content":"\n### 二叉树\n\n**二叉树是一种典型的数据结构，是树的特殊一种。**\n\n##### 特点：\n\n1. 每个结点最多有两个子树，结点的度最大为2。\n\n2. ##### 结点有左右之分，不能颠倒。\n\n##### 相关概念：\n\n1. **度：子树就是二叉树的分支，度就是分支的个数。**\n2. **结点层：根结点的层定义为1，以此类推。**\n3. **树的深度：树中最大的结点层。**\n4. **叶子结点：度为0的结点。**\n\n##### 二叉树又分为几种特殊情况：\n\n- 完全二叉树：假设二叉树高度为h，从1~（h-1）层的结点个数达到最大，第h层有叶子结点，且从左到右依次排列，称为完全二叉树。\n\n  ![参考https://www.cnblogs.com/polly333/p/4740355.html](二叉树/f2b1e4ea4075a3078066c8279e3b8028.png)\n\n- 满二叉树：除了叶子结点外，所有结点都有左右子树，且所有叶子结点都处在最底层，称为满二叉树。\n\n  ![参考https://www.cnblogs.com/polly333/p/4740355.html](二叉树/2153c29240544948808c3bd9081b6a74.png)\n\n- 平衡二叉树（AVL树）：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。\n\n  ![](二叉树/f8f24bb14013ad4f806d1ec8bec299bd.jpg)\n\n##### 二叉树的三种遍历方式：\n\n1. 中序遍历：左根右。\n2. 前序遍历：根左右。\n3. 后序遍历：左右根。\n\n**代码实现**\n\n```javascript\n//构建排序二叉树\n\t\tfunction getTree(){\n\t\t\t//创建结点方法\n\t\t\tvar node = function(key){\n\t\t\t\tthis.key=key;\n\t\t\t\tthis.left=null;\n\t\t\t\tthis.right=null;\n\t\t\t}\n\t\t\tvar root=null; //初始化根节点\n\t\t\tvar insertTrees=function(node,newNode){\t//插入结点\n\t\t\t\tif(node.key>newNode.key){\n\t\t\t\t\tif(node.left===null){\n\t\t\t\t\t\tnode.left=newNode;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinsertTrees(node.left,newNode);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(node.right===null){\n\t\t\t\t\t\tnode.right=newNode;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinsertTrees(node.right,newNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar zxSortSelect=function(node,callback){\t//中序遍历方法\n\t\t\t\tif(node!==null){\n\t\t\t\t\tzxSortSelect(node.left,callback);\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t\tzxSortSelect(node.right,callback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar qxSortSelect=function(node,callback){\t//前序遍历\n\t\t\t\tif(node!==null){\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t\tqxSortSelect(node.left,callback);\n\t\t\t\t\tqxSortSelect(node.right,callback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar hxSortSelect=function(node,callback){\t//后序遍历\n\t\t\t\tif(node!==null){\n\t\t\t\t\thxSortSelect(node.left,callback);\n\t\t\t\t\thxSortSelect(node.right,callback);\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar min=function(node){\t//求最小值\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t}\n\t\t\t\t\treturn node.key;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t\tvar max=function(node){\t//求最大值\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.right!==null){\n\t\t\t\t\t\tnode=node.right;\n\t\t\t\t\t}\n\t\t\t\t\treturn node.key;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar select=function(node,key){\t//查找值\n\t\t\t\tif(node===null){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(node!==null){\n\t\t\t\t\tif(node.key>key){\n\t\t\t\t\t\treturn select(node.left,key);\n\t\t\t\t\t}else if(node.key<key){\n\t\t\t\t\t\treturn select(node.right,key);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar getmin=function(node){\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar remove=function(node,key){\t//删除值\n\t\t\t\tif(node===null){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(key<node.key){\n\t\t\t\t\tnode.left=remove(node.left,key);\n\t\t\t\t\treturn node;\n\t\t\t\t}else if(key>node.key){\n\t\t\t\t\tnode.right=remove(node.right,key);\n\t\t\t\t\treturn node;\n\t\t\t\t}else{\n\t\t\t\t\tif(node.left===null&&node.right===null){\n\t\t\t\t\t\tnode=null;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else if(node.left===null&&node.right!==null){\n\t\t\t\t\t\tnode=node.right;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else if(node.right===null&&node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar zx=getmin(node.right);\n\t\t\t\t\t\tnode.key=zx.key;\n\t\t\t\t\t\tnode.right=remove(node.right,zx.key);\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tthis.insert=function(key){\n\t\t\t\tvar newNode=new node(key);\n\t\t\t\tif(root===null){\n\t\t\t\t\troot=newNode;\n\t\t\t\t}else{\n\t\t\t\t\tinsertTrees(root,newNode);\n\t\t\t\t}\n\t\t\t\t// console.log(root);\n\t\t\t};\n\t\t\t//中序遍历\n\t\t\tthis.zxSelect=function(callback){\n\t\t\t\tzxSortSelect(root,callback);\n\t\t\t};\n\t\t\t//前序遍历\n\t\t\tthis.qxSelect=function(callback){\n\t\t\t\tqxSortSelect(root,callback);\n\t\t\t}\n\t\t\t//后序遍历\n\t\t\tthis.hxSelect=function(callback){\n\t\t\t\thxSortSelect(root,callback);\n\t\t\t}\n\t\t\t//查找最小值\n\t\t\tthis.minKey=function(){\n\t\t\t\treturn min(root);\n\t\t\t}\n\t\t\t//查找最大值\n\t\t\tthis.maxKey=function(){\n\t\t\t\treturn max(root);\n\t\t\t}\n\t\t\t//查询指定值\n\t\t\tthis.selectKey=function(key){\n\t\t\t\treturn select(root,key);\n\t\t\t}\n\t\t\t//删除值\n\t\t\tthis.removeKey=function(key){\n\t\t\t\troot=remove(root,key);\n\t\t\t}\n\t\t}\n```\n\n**调用**\n\n```javascript\nvar arr=[8,3,10,1,6,14,4,7,13];\nvar tree=new getTree();\narr.forEach(function(key,index){\t\t//构建二叉树\n    tree.insert(key);\n});\ntree.zxSelect(callback); //1,3,4,6,7,8,10,13,14\ntree.qxSelect(callback); //8,3,1,6,4,7,10,14,13\ntree.hxSelect(callback); //1，4，7，6，3，13，14，10，8\nconsole.log('最小值：',tree.minKey());\nconsole.log('最大值：',tree.maxKey());\nconsole.log('查找值：',tree.selectKey(6));\ntree.removeKey(14);\n```\n\n**构建好的二叉树：**\n\n![](二叉树/31c90baf409ce7088051e95c118005e1.png)","source":"_posts/二叉树.md","raw":"---\ntitle: 二叉树\ndate: 2018-10-16 17:53:00\ntags: 树\ncategories: 数据结构\n---\n\n### 二叉树\n\n**二叉树是一种典型的数据结构，是树的特殊一种。**\n\n##### 特点：\n\n1. 每个结点最多有两个子树，结点的度最大为2。\n\n2. ##### 结点有左右之分，不能颠倒。\n\n##### 相关概念：\n\n1. **度：子树就是二叉树的分支，度就是分支的个数。**\n2. **结点层：根结点的层定义为1，以此类推。**\n3. **树的深度：树中最大的结点层。**\n4. **叶子结点：度为0的结点。**\n\n##### 二叉树又分为几种特殊情况：\n\n- 完全二叉树：假设二叉树高度为h，从1~（h-1）层的结点个数达到最大，第h层有叶子结点，且从左到右依次排列，称为完全二叉树。\n\n  ![参考https://www.cnblogs.com/polly333/p/4740355.html](二叉树/f2b1e4ea4075a3078066c8279e3b8028.png)\n\n- 满二叉树：除了叶子结点外，所有结点都有左右子树，且所有叶子结点都处在最底层，称为满二叉树。\n\n  ![参考https://www.cnblogs.com/polly333/p/4740355.html](二叉树/2153c29240544948808c3bd9081b6a74.png)\n\n- 平衡二叉树（AVL树）：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。\n\n  ![](二叉树/f8f24bb14013ad4f806d1ec8bec299bd.jpg)\n\n##### 二叉树的三种遍历方式：\n\n1. 中序遍历：左根右。\n2. 前序遍历：根左右。\n3. 后序遍历：左右根。\n\n**代码实现**\n\n```javascript\n//构建排序二叉树\n\t\tfunction getTree(){\n\t\t\t//创建结点方法\n\t\t\tvar node = function(key){\n\t\t\t\tthis.key=key;\n\t\t\t\tthis.left=null;\n\t\t\t\tthis.right=null;\n\t\t\t}\n\t\t\tvar root=null; //初始化根节点\n\t\t\tvar insertTrees=function(node,newNode){\t//插入结点\n\t\t\t\tif(node.key>newNode.key){\n\t\t\t\t\tif(node.left===null){\n\t\t\t\t\t\tnode.left=newNode;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinsertTrees(node.left,newNode);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(node.right===null){\n\t\t\t\t\t\tnode.right=newNode;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinsertTrees(node.right,newNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar zxSortSelect=function(node,callback){\t//中序遍历方法\n\t\t\t\tif(node!==null){\n\t\t\t\t\tzxSortSelect(node.left,callback);\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t\tzxSortSelect(node.right,callback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar qxSortSelect=function(node,callback){\t//前序遍历\n\t\t\t\tif(node!==null){\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t\tqxSortSelect(node.left,callback);\n\t\t\t\t\tqxSortSelect(node.right,callback);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar hxSortSelect=function(node,callback){\t//后序遍历\n\t\t\t\tif(node!==null){\n\t\t\t\t\thxSortSelect(node.left,callback);\n\t\t\t\t\thxSortSelect(node.right,callback);\n\t\t\t\t\tcallback(node.key);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar min=function(node){\t//求最小值\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t}\n\t\t\t\t\treturn node.key;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t};\n\t\t\tvar max=function(node){\t//求最大值\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.right!==null){\n\t\t\t\t\t\tnode=node.right;\n\t\t\t\t\t}\n\t\t\t\t\treturn node.key;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar select=function(node,key){\t//查找值\n\t\t\t\tif(node===null){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(node!==null){\n\t\t\t\t\tif(node.key>key){\n\t\t\t\t\t\treturn select(node.left,key);\n\t\t\t\t\t}else if(node.key<key){\n\t\t\t\t\t\treturn select(node.right,key);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar getmin=function(node){\n\t\t\t\tif(node!==null){\n\t\t\t\t\twhile(node && node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar remove=function(node,key){\t//删除值\n\t\t\t\tif(node===null){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(key<node.key){\n\t\t\t\t\tnode.left=remove(node.left,key);\n\t\t\t\t\treturn node;\n\t\t\t\t}else if(key>node.key){\n\t\t\t\t\tnode.right=remove(node.right,key);\n\t\t\t\t\treturn node;\n\t\t\t\t}else{\n\t\t\t\t\tif(node.left===null&&node.right===null){\n\t\t\t\t\t\tnode=null;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else if(node.left===null&&node.right!==null){\n\t\t\t\t\t\tnode=node.right;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else if(node.right===null&&node.left!==null){\n\t\t\t\t\t\tnode=node.left;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvar zx=getmin(node.right);\n\t\t\t\t\t\tnode.key=zx.key;\n\t\t\t\t\t\tnode.right=remove(node.right,zx.key);\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tthis.insert=function(key){\n\t\t\t\tvar newNode=new node(key);\n\t\t\t\tif(root===null){\n\t\t\t\t\troot=newNode;\n\t\t\t\t}else{\n\t\t\t\t\tinsertTrees(root,newNode);\n\t\t\t\t}\n\t\t\t\t// console.log(root);\n\t\t\t};\n\t\t\t//中序遍历\n\t\t\tthis.zxSelect=function(callback){\n\t\t\t\tzxSortSelect(root,callback);\n\t\t\t};\n\t\t\t//前序遍历\n\t\t\tthis.qxSelect=function(callback){\n\t\t\t\tqxSortSelect(root,callback);\n\t\t\t}\n\t\t\t//后序遍历\n\t\t\tthis.hxSelect=function(callback){\n\t\t\t\thxSortSelect(root,callback);\n\t\t\t}\n\t\t\t//查找最小值\n\t\t\tthis.minKey=function(){\n\t\t\t\treturn min(root);\n\t\t\t}\n\t\t\t//查找最大值\n\t\t\tthis.maxKey=function(){\n\t\t\t\treturn max(root);\n\t\t\t}\n\t\t\t//查询指定值\n\t\t\tthis.selectKey=function(key){\n\t\t\t\treturn select(root,key);\n\t\t\t}\n\t\t\t//删除值\n\t\t\tthis.removeKey=function(key){\n\t\t\t\troot=remove(root,key);\n\t\t\t}\n\t\t}\n```\n\n**调用**\n\n```javascript\nvar arr=[8,3,10,1,6,14,4,7,13];\nvar tree=new getTree();\narr.forEach(function(key,index){\t\t//构建二叉树\n    tree.insert(key);\n});\ntree.zxSelect(callback); //1,3,4,6,7,8,10,13,14\ntree.qxSelect(callback); //8,3,1,6,4,7,10,14,13\ntree.hxSelect(callback); //1，4，7，6，3，13，14，10，8\nconsole.log('最小值：',tree.minKey());\nconsole.log('最大值：',tree.maxKey());\nconsole.log('查找值：',tree.selectKey(6));\ntree.removeKey(14);\n```\n\n**构建好的二叉树：**\n\n![](二叉树/31c90baf409ce7088051e95c118005e1.png)","slug":"二叉树","published":1,"updated":"2024-02-19T07:42:51.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri2005k1xop1t0sddoe","content":"<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p><strong>二叉树是一种典型的数据结构，是树的特殊一种。</strong></p>\n<h5 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h5><ol>\n<li><p>每个结点最多有两个子树，结点的度最大为2。</p>\n</li>\n<li><h5 id=\"结点有左右之分，不能颠倒。\"><a href=\"#结点有左右之分，不能颠倒。\" class=\"headerlink\" title=\"结点有左右之分，不能颠倒。\"></a>结点有左右之分，不能颠倒。</h5></li>\n</ol>\n<h5 id=\"相关概念：\"><a href=\"#相关概念：\" class=\"headerlink\" title=\"相关概念：\"></a>相关概念：</h5><ol>\n<li><strong>度：子树就是二叉树的分支，度就是分支的个数。</strong></li>\n<li><strong>结点层：根结点的层定义为1，以此类推。</strong></li>\n<li><strong>树的深度：树中最大的结点层。</strong></li>\n<li><strong>叶子结点：度为0的结点。</strong></li>\n</ol>\n<h5 id=\"二叉树又分为几种特殊情况：\"><a href=\"#二叉树又分为几种特殊情况：\" class=\"headerlink\" title=\"二叉树又分为几种特殊情况：\"></a>二叉树又分为几种特殊情况：</h5><ul>\n<li><p>完全二叉树：假设二叉树高度为h，从1~（h-1）层的结点个数达到最大，第h层有叶子结点，且从左到右依次排列，称为完全二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/f2b1e4ea4075a3078066c8279e3b8028.png\" alt=\"参考https://www.cnblogs.com/polly333/p/4740355.html\"></p>\n</li>\n<li><p>满二叉树：除了叶子结点外，所有结点都有左右子树，且所有叶子结点都处在最底层，称为满二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/2153c29240544948808c3bd9081b6a74.png\" alt=\"参考https://www.cnblogs.com/polly333/p/4740355.html\"></p>\n</li>\n<li><p>平衡二叉树（AVL树）：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/f8f24bb14013ad4f806d1ec8bec299bd.jpg\" alt></p>\n</li>\n</ul>\n<h5 id=\"二叉树的三种遍历方式：\"><a href=\"#二叉树的三种遍历方式：\" class=\"headerlink\" title=\"二叉树的三种遍历方式：\"></a>二叉树的三种遍历方式：</h5><ol>\n<li>中序遍历：左根右。</li>\n<li>前序遍历：根左右。</li>\n<li>后序遍历：左右根。</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//构建排序二叉树</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">getTree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//创建结点方法</span>\n            <span class=\"token keyword\">var</span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key<span class=\"token operator\">=</span>key<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>left<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>right<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">var</span> root<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//初始化根节点</span>\n            <span class=\"token keyword\">var</span> insertTrees<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>newNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//插入结点</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token operator\">></span>newNode<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">=</span>newNode<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">insertTrees</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>newNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">=</span>newNode<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token function\">insertTrees</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>newNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> zxSortSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//中序遍历方法</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">zxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">zxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> qxSortSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//前序遍历</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">qxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">qxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> hxSortSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//后序遍历</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">hxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">hxSortSelect</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> min<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//求最小值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>node <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">var</span> max<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//求最大值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>node <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">var</span> select<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//查找值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token operator\">></span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>key<span class=\"token operator\">&lt;</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">var</span> getmin<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>node <span class=\"token operator\">&amp;&amp;</span> node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">var</span> remove<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//删除值</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">&lt;</span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">=</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>key<span class=\"token operator\">></span>node<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">=</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token operator\">&amp;&amp;</span>node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token operator\">&amp;&amp;</span>node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token operator\">&amp;&amp;</span>node<span class=\"token punctuation\">.</span>left<span class=\"token operator\">!==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                        node<span class=\"token operator\">=</span>node<span class=\"token punctuation\">.</span>left<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">var</span> zx<span class=\"token operator\">=</span><span class=\"token function\">getmin</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        node<span class=\"token punctuation\">.</span>key<span class=\"token operator\">=</span>zx<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">;</span>\n                        node<span class=\"token punctuation\">.</span>right<span class=\"token operator\">=</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>right<span class=\"token punctuation\">,</span>zx<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>    \n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>insert<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">var</span> newNode<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">node</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>root<span class=\"token operator\">===</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    root<span class=\"token operator\">=</span>newNode<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">insertTrees</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>newNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token comment\" spellcheck=\"true\">// console.log(root);</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//中序遍历</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>zxSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token function\">zxSortSelect</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//前序遍历</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>qxSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token function\">qxSortSelect</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//后序遍历</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hxSelect<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token function\">hxSortSelect</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//查找最小值</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>minKey<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//查找最大值</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>maxKey<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//查询指定值</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>selectKey<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">select</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//删除值</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>removeKey<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                root<span class=\"token operator\">=</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>调用</strong></p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> arr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">14</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">13</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> tree<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">getTree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>        <span class=\"token comment\" spellcheck=\"true\">//构建二叉树</span>\n    tree<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntree<span class=\"token punctuation\">.</span><span class=\"token function\">zxSelect</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1,3,4,6,7,8,10,13,14</span>\ntree<span class=\"token punctuation\">.</span><span class=\"token function\">qxSelect</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//8,3,1,6,4,7,10,14,13</span>\ntree<span class=\"token punctuation\">.</span><span class=\"token function\">hxSelect</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1，4，7，6，3，13，14，10，8</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'最小值：'</span><span class=\"token punctuation\">,</span>tree<span class=\"token punctuation\">.</span><span class=\"token function\">minKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'最大值：'</span><span class=\"token punctuation\">,</span>tree<span class=\"token punctuation\">.</span><span class=\"token function\">maxKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'查找值：'</span><span class=\"token punctuation\">,</span>tree<span class=\"token punctuation\">.</span><span class=\"token function\">selectKey</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntree<span class=\"token punctuation\">.</span><span class=\"token function\">removeKey</span><span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>构建好的二叉树：</strong></p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/31c90baf409ce7088051e95c118005e1.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p><strong>二叉树是一种典型的数据结构，是树的特殊一种。</strong></p>\n<h5 id=\"特点：\"><a href=\"#特点：\" class=\"headerlink\" title=\"特点：\"></a>特点：</h5><ol>\n<li><p>每个结点最多有两个子树，结点的度最大为2。</p>\n</li>\n<li><h5 id=\"结点有左右之分，不能颠倒。\"><a href=\"#结点有左右之分，不能颠倒。\" class=\"headerlink\" title=\"结点有左右之分，不能颠倒。\"></a>结点有左右之分，不能颠倒。</h5></li>\n</ol>\n<h5 id=\"相关概念：\"><a href=\"#相关概念：\" class=\"headerlink\" title=\"相关概念：\"></a>相关概念：</h5><ol>\n<li><strong>度：子树就是二叉树的分支，度就是分支的个数。</strong></li>\n<li><strong>结点层：根结点的层定义为1，以此类推。</strong></li>\n<li><strong>树的深度：树中最大的结点层。</strong></li>\n<li><strong>叶子结点：度为0的结点。</strong></li>\n</ol>\n<h5 id=\"二叉树又分为几种特殊情况：\"><a href=\"#二叉树又分为几种特殊情况：\" class=\"headerlink\" title=\"二叉树又分为几种特殊情况：\"></a>二叉树又分为几种特殊情况：</h5><ul>\n<li><p>完全二叉树：假设二叉树高度为h，从1~（h-1）层的结点个数达到最大，第h层有叶子结点，且从左到右依次排列，称为完全二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/f2b1e4ea4075a3078066c8279e3b8028.png\" alt=\"参考https://www.cnblogs.com/polly333/p/4740355.html\"></p>\n</li>\n<li><p>满二叉树：除了叶子结点外，所有结点都有左右子树，且所有叶子结点都处在最底层，称为满二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/2153c29240544948808c3bd9081b6a74.png\" alt=\"参考https://www.cnblogs.com/polly333/p/4740355.html\"></p>\n</li>\n<li><p>平衡二叉树（AVL树）：它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树。</p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/f8f24bb14013ad4f806d1ec8bec299bd.jpg\" alt></p>\n</li>\n</ul>\n<h5 id=\"二叉树的三种遍历方式：\"><a href=\"#二叉树的三种遍历方式：\" class=\"headerlink\" title=\"二叉树的三种遍历方式：\"></a>二叉树的三种遍历方式：</h5><ol>\n<li>中序遍历：左根右。</li>\n<li>前序遍历：根左右。</li>\n<li>后序遍历：左右根。</li>\n</ol>\n<p><strong>代码实现</strong></p>\n<pre><code class=\"javascript\">//构建排序二叉树\n        function getTree(){\n            //创建结点方法\n            var node = function(key){\n                this.key=key;\n                this.left=null;\n                this.right=null;\n            }\n            var root=null; //初始化根节点\n            var insertTrees=function(node,newNode){    //插入结点\n                if(node.key&gt;newNode.key){\n                    if(node.left===null){\n                        node.left=newNode;\n                    }else{\n                        insertTrees(node.left,newNode);\n                    }\n                }else{\n                    if(node.right===null){\n                        node.right=newNode;\n                    }else{\n                        insertTrees(node.right,newNode);\n                    }\n                }\n            };\n            var zxSortSelect=function(node,callback){    //中序遍历方法\n                if(node!==null){\n                    zxSortSelect(node.left,callback);\n                    callback(node.key);\n                    zxSortSelect(node.right,callback);\n                }\n            };\n            var qxSortSelect=function(node,callback){    //前序遍历\n                if(node!==null){\n                    callback(node.key);\n                    qxSortSelect(node.left,callback);\n                    qxSortSelect(node.right,callback);\n                }\n            };\n            var hxSortSelect=function(node,callback){    //后序遍历\n                if(node!==null){\n                    hxSortSelect(node.left,callback);\n                    hxSortSelect(node.right,callback);\n                    callback(node.key);\n                }\n            };\n            var min=function(node){    //求最小值\n                if(node!==null){\n                    while(node &amp;&amp; node.left!==null){\n                        node=node.left;\n                    }\n                    return node.key;\n                }\n                return null;\n            };\n            var max=function(node){    //求最大值\n                if(node!==null){\n                    while(node &amp;&amp; node.right!==null){\n                        node=node.right;\n                    }\n                    return node.key;\n                }\n                return null;\n            }\n            var select=function(node,key){    //查找值\n                if(node===null){\n                    return false;\n                }\n                if(node!==null){\n                    if(node.key&gt;key){\n                        return select(node.left,key);\n                    }else if(node.key&lt;key){\n                        return select(node.right,key);\n                    }else{\n                        return node;\n                    }\n                }\n            }\n            var getmin=function(node){\n                if(node!==null){\n                    while(node &amp;&amp; node.left!==null){\n                        node=node.left;\n                    }\n                    return node;\n                }\n                return null;\n            }\n            var remove=function(node,key){    //删除值\n                if(node===null){\n                    return false;\n                }\n                if(key&lt;node.key){\n                    node.left=remove(node.left,key);\n                    return node;\n                }else if(key&gt;node.key){\n                    node.right=remove(node.right,key);\n                    return node;\n                }else{\n                    if(node.left===null&amp;&amp;node.right===null){\n                        node=null;\n                        return node;\n                    }else if(node.left===null&amp;&amp;node.right!==null){\n                        node=node.right;\n                        return node;\n                    }else if(node.right===null&amp;&amp;node.left!==null){\n                        node=node.left;\n                        return node;\n                    }else{\n                        var zx=getmin(node.right);\n                        node.key=zx.key;\n                        node.right=remove(node.right,zx.key);\n                        return node;\n                    }\n                }    \n            }\n            this.insert=function(key){\n                var newNode=new node(key);\n                if(root===null){\n                    root=newNode;\n                }else{\n                    insertTrees(root,newNode);\n                }\n                // console.log(root);\n            };\n            //中序遍历\n            this.zxSelect=function(callback){\n                zxSortSelect(root,callback);\n            };\n            //前序遍历\n            this.qxSelect=function(callback){\n                qxSortSelect(root,callback);\n            }\n            //后序遍历\n            this.hxSelect=function(callback){\n                hxSortSelect(root,callback);\n            }\n            //查找最小值\n            this.minKey=function(){\n                return min(root);\n            }\n            //查找最大值\n            this.maxKey=function(){\n                return max(root);\n            }\n            //查询指定值\n            this.selectKey=function(key){\n                return select(root,key);\n            }\n            //删除值\n            this.removeKey=function(key){\n                root=remove(root,key);\n            }\n        }\n</code></pre>\n<p><strong>调用</strong></p>\n<pre><code class=\"javascript\">var arr=[8,3,10,1,6,14,4,7,13];\nvar tree=new getTree();\narr.forEach(function(key,index){        //构建二叉树\n    tree.insert(key);\n});\ntree.zxSelect(callback); //1,3,4,6,7,8,10,13,14\ntree.qxSelect(callback); //8,3,1,6,4,7,10,14,13\ntree.hxSelect(callback); //1，4，7，6，3，13，14，10，8\nconsole.log(&#39;最小值：&#39;,tree.minKey());\nconsole.log(&#39;最大值：&#39;,tree.maxKey());\nconsole.log(&#39;查找值：&#39;,tree.selectKey(6));\ntree.removeKey(14);\n</code></pre>\n<p><strong>构建好的二叉树：</strong></p>\n<p><img src=\"/2018/10/16/%E4%BA%8C%E5%8F%89%E6%A0%91/31c90baf409ce7088051e95c118005e1.png\" alt></p>\n"},{"title":"事件捕获和事件冒泡","date":"2018-10-18T05:58:44.000Z","_content":"\n### 事件捕获和事件冒泡\n\n在介绍两者之前首先需要了解监听器:\n\n> `EventTarget.addEventListener()`：方法将指定的监听器注册到`EventTarget`上，当该对象触发指定的事件时，指定的回掉函数就会被执行。事件的目标可以是一个文档上的元素`Element,Document`和`Window`或者任何其他支持事件的对象（比如`XMLHttpRequest`）。\n>\n> 语法：\n>\n> ```js\n> element.addEventListener(event,function,useCapture)\n> ```\n>\n> - event（必需）：字符串，指定事件名。*注意不要使用\"on\"前缀，例如\"onclick\"应该使用\"click\"*\n>\n> - function（必需）：指定被监听的事件触发时所要执行的回掉函数。\n>\n> - useCapture（可选）：布尔值，指定事件是否在捕获或冒泡阶段执行。可能值：true :事件句柄在捕获阶段执行。false:默认。事件句柄在冒泡阶段执行。\n\n```html\n<script>\n\tdocument.getElementById(\"myBtn\").addEventListener(\"click\",callfunction,true); //事件捕获\n    document.getElementById(\"myBtn\").addEventListener(\"click\",callfunction,false); //事件冒泡\n    function callfunction(){\n        document.getElementById(\"demo\").innerHTML=\"hello world!\"\n    }\n</script>\n<body>\n\t<button id=\"myBtn\">\n        点击\n    </button>\n    <div id=\"demo\">\n    \t\n    </div>\n</body>\n\n```\n\n**一个完整的事件流：从window开始，最后回到window的过程。**\n\n1. ##### 事件捕获：window> document>body>button（从window开始一层一层到真正触发事件的元素）\n\n2. ##### 事件冒泡：button>body>document>window（从当前触发事件的元素开始，一层一层冒泡到window）\n\n3. ##### 两者刚好相反\n\n![](事件捕获和事件冒泡/b2a98b1d408c0923807704ad7ac95fde.png)\n\n##### 如何阻止事件冒泡/捕获和默认行为\n\n```js\n//jquery阻止默认行为和冒泡\n$(\"#myBtn\").on('click',function(){\n    return false;\n})\n//js\nlet Obtn=document.getElementById(\"myBtn\");\nObtn.onclick=function(e){\n    let e=ev||event;\n    //阻止事件冒泡  \n    e.cancelBubble=true;\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    //阻止默认行为，但不阻止冒泡\n    e.preventDefault();\n    return false;\n}\n```\n\n*stoppropagation属于W3C标准，试用于Firefox等浏览器，但是不支持IE浏览器相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。*\n\n**也可以使用新增事件stopImmediatePropagation()方法来阻止事件捕获和事件冒泡**\n\n那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？\n\n　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生\n\n##### 事件代理（事件委托）\n\n**原理：利用事件的冒泡原理来实现的。处在深层的元素触发的事件，最终会冒泡到其父层上，在绑定事件时，利用这个原理，对其父级进行事件绑定。**\n\n**举例：实现鼠标滑过，改变背景**\n\n```html\n<body>\n    <ul>\n        <li>li1</li>\n        <li>li2</li>\n        <li>li3</li>\n    </ul>\n</body>\n```\n\n**不使用事件代理：**\n\n```js\n$(\"li\").on(\"mouseover\",function(){\n    $(this).css(\"background\",\"red\").siblings().css(\"background\",\"white\");\n})\n```\n\n**使用事件代理：**\n\n```js\n$(\"ul\").on(\"mouseover\",function(e){\n    let e=e||event;\n    $(e.target).css(\"background\",\"red\").siblings().css(\"background\",\"white\");\n})\n```\n\n**事件委托与事件不委托之间区别：**\n\n1. 事件委托不需要遍历要操作的元素结点，事件不委托需要遍历要操作的元素结点\n2. 事件委托减少操作dom的次数，对性能优化，事件不委托操作的dom次数较多\n3. 事件委托所定义的事件，对新创建的元素结点也可起到作用，而不使用事件委托，对新添加的结点，需要重新为其绑定相关事件。\n\n**event.target & event.currentTarget两者的区别**\n\n```jsx\n<div id=\"a\">\n  <div id=\"b\">\n    <div id=\"c\"><div id=\"d\"></div></div>\n  </div>\n</div>\n<script>\n  document.getElementById('a').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('b').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('c').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('d').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n</script>\n```\n\n当我们点击最里层的元素d的时候，会依次输出:\n\n```js\ntarget:d&currentTarget:d\ntarget:d&currentTarget:c\ntarget:d&currentTarget:b\ntarget:d&currentTarget:a\n```\n\n从输出中我们可以看到，`event.target`指向引起触发事件的元素，而`event.currentTarget`则是事件绑定的元素，只有被点击的那个目标元素的`event.target`才会等于`event.currentTarget`。**也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者**。","source":"_posts/事件捕获和事件冒泡.md","raw":"---\ntitle: 事件捕获和事件冒泡\ndate: 2018-10-18 13:58:44\ntags: js\ncategories: 前端\n---\n\n### 事件捕获和事件冒泡\n\n在介绍两者之前首先需要了解监听器:\n\n> `EventTarget.addEventListener()`：方法将指定的监听器注册到`EventTarget`上，当该对象触发指定的事件时，指定的回掉函数就会被执行。事件的目标可以是一个文档上的元素`Element,Document`和`Window`或者任何其他支持事件的对象（比如`XMLHttpRequest`）。\n>\n> 语法：\n>\n> ```js\n> element.addEventListener(event,function,useCapture)\n> ```\n>\n> - event（必需）：字符串，指定事件名。*注意不要使用\"on\"前缀，例如\"onclick\"应该使用\"click\"*\n>\n> - function（必需）：指定被监听的事件触发时所要执行的回掉函数。\n>\n> - useCapture（可选）：布尔值，指定事件是否在捕获或冒泡阶段执行。可能值：true :事件句柄在捕获阶段执行。false:默认。事件句柄在冒泡阶段执行。\n\n```html\n<script>\n\tdocument.getElementById(\"myBtn\").addEventListener(\"click\",callfunction,true); //事件捕获\n    document.getElementById(\"myBtn\").addEventListener(\"click\",callfunction,false); //事件冒泡\n    function callfunction(){\n        document.getElementById(\"demo\").innerHTML=\"hello world!\"\n    }\n</script>\n<body>\n\t<button id=\"myBtn\">\n        点击\n    </button>\n    <div id=\"demo\">\n    \t\n    </div>\n</body>\n\n```\n\n**一个完整的事件流：从window开始，最后回到window的过程。**\n\n1. ##### 事件捕获：window> document>body>button（从window开始一层一层到真正触发事件的元素）\n\n2. ##### 事件冒泡：button>body>document>window（从当前触发事件的元素开始，一层一层冒泡到window）\n\n3. ##### 两者刚好相反\n\n![](事件捕获和事件冒泡/b2a98b1d408c0923807704ad7ac95fde.png)\n\n##### 如何阻止事件冒泡/捕获和默认行为\n\n```js\n//jquery阻止默认行为和冒泡\n$(\"#myBtn\").on('click',function(){\n    return false;\n})\n//js\nlet Obtn=document.getElementById(\"myBtn\");\nObtn.onclick=function(e){\n    let e=ev||event;\n    //阻止事件冒泡  \n    e.cancelBubble=true;\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    //阻止默认行为，但不阻止冒泡\n    e.preventDefault();\n    return false;\n}\n```\n\n*stoppropagation属于W3C标准，试用于Firefox等浏览器，但是不支持IE浏览器相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。*\n\n**也可以使用新增事件stopImmediatePropagation()方法来阻止事件捕获和事件冒泡**\n\n那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？\n\n　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生\n\n##### 事件代理（事件委托）\n\n**原理：利用事件的冒泡原理来实现的。处在深层的元素触发的事件，最终会冒泡到其父层上，在绑定事件时，利用这个原理，对其父级进行事件绑定。**\n\n**举例：实现鼠标滑过，改变背景**\n\n```html\n<body>\n    <ul>\n        <li>li1</li>\n        <li>li2</li>\n        <li>li3</li>\n    </ul>\n</body>\n```\n\n**不使用事件代理：**\n\n```js\n$(\"li\").on(\"mouseover\",function(){\n    $(this).css(\"background\",\"red\").siblings().css(\"background\",\"white\");\n})\n```\n\n**使用事件代理：**\n\n```js\n$(\"ul\").on(\"mouseover\",function(e){\n    let e=e||event;\n    $(e.target).css(\"background\",\"red\").siblings().css(\"background\",\"white\");\n})\n```\n\n**事件委托与事件不委托之间区别：**\n\n1. 事件委托不需要遍历要操作的元素结点，事件不委托需要遍历要操作的元素结点\n2. 事件委托减少操作dom的次数，对性能优化，事件不委托操作的dom次数较多\n3. 事件委托所定义的事件，对新创建的元素结点也可起到作用，而不使用事件委托，对新添加的结点，需要重新为其绑定相关事件。\n\n**event.target & event.currentTarget两者的区别**\n\n```jsx\n<div id=\"a\">\n  <div id=\"b\">\n    <div id=\"c\"><div id=\"d\"></div></div>\n  </div>\n</div>\n<script>\n  document.getElementById('a').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('b').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('c').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n  document.getElementById('d').addEventListener('click', function(e) {\n    console.log(\n      'target:' + e.target.id + '&currentTarget:' + e.currentTarget.id\n    )\n  })\n</script>\n```\n\n当我们点击最里层的元素d的时候，会依次输出:\n\n```js\ntarget:d&currentTarget:d\ntarget:d&currentTarget:c\ntarget:d&currentTarget:b\ntarget:d&currentTarget:a\n```\n\n从输出中我们可以看到，`event.target`指向引起触发事件的元素，而`event.currentTarget`则是事件绑定的元素，只有被点击的那个目标元素的`event.target`才会等于`event.currentTarget`。**也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者**。","slug":"事件捕获和事件冒泡","published":1,"updated":"2024-02-19T07:42:51.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri5005n1xopegca7em8","content":"<h3 id=\"事件捕获和事件冒泡\"><a href=\"#事件捕获和事件冒泡\" class=\"headerlink\" title=\"事件捕获和事件冒泡\"></a>事件捕获和事件冒泡</h3><p>在介绍两者之前首先需要了解监听器:</p>\n<blockquote>\n<p><code>EventTarget.addEventListener()</code>：方法将指定的监听器注册到<code>EventTarget</code>上，当该对象触发指定的事件时，指定的回掉函数就会被执行。事件的目标可以是一个文档上的元素<code>Element,Document</code>和<code>Window</code>或者任何其他支持事件的对象（比如<code>XMLHttpRequest</code>）。</p>\n<p>语法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">element<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">,</span>useCapture<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li><p>event（必需）：字符串，指定事件名。<em>注意不要使用”on”前缀，例如”onclick”应该使用”click”</em></p>\n</li>\n<li><p>function（必需）：指定被监听的事件触发时所要执行的回掉函数。</p>\n</li>\n<li><p>useCapture（可选）：布尔值，指定事件是否在捕获或冒泡阶段执行。可能值：true :事件句柄在捕获阶段执行。false:默认。事件句柄在冒泡阶段执行。</p>\n</li>\n</ul>\n</blockquote>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myBtn\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span>callfunction<span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//事件捕获</span>\n    document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myBtn\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span>callfunction<span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//事件冒泡</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">callfunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"demo\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerHTML<span class=\"token operator\">=</span><span class=\"token string\">\"hello world!\"</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>myBtn<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        点击\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>demo<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>一个完整的事件流：从window开始，最后回到window的过程。</strong></p>\n<ol>\n<li><h5 id=\"事件捕获：window-gt-document-gt-body-gt-button（从window开始一层一层到真正触发事件的元素）\"><a href=\"#事件捕获：window-gt-document-gt-body-gt-button（从window开始一层一层到真正触发事件的元素）\" class=\"headerlink\" title=\"事件捕获：window&gt; document&gt;body&gt;button（从window开始一层一层到真正触发事件的元素）\"></a>事件捕获：window&gt; document&gt;body&gt;button（从window开始一层一层到真正触发事件的元素）</h5></li>\n<li><h5 id=\"事件冒泡：button-gt-body-gt-document-gt-window（从当前触发事件的元素开始，一层一层冒泡到window）\"><a href=\"#事件冒泡：button-gt-body-gt-document-gt-window（从当前触发事件的元素开始，一层一层冒泡到window）\" class=\"headerlink\" title=\"事件冒泡：button&gt;body&gt;document&gt;window（从当前触发事件的元素开始，一层一层冒泡到window）\"></a>事件冒泡：button&gt;body&gt;document&gt;window（从当前触发事件的元素开始，一层一层冒泡到window）</h5></li>\n<li><h5 id=\"两者刚好相反\"><a href=\"#两者刚好相反\" class=\"headerlink\" title=\"两者刚好相反\"></a>两者刚好相反</h5></li>\n</ol>\n<p><img src=\"/2018/10/18/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/b2a98b1d408c0923807704ad7ac95fde.png\" alt></p>\n<h5 id=\"如何阻止事件冒泡-捕获和默认行为\"><a href=\"#如何阻止事件冒泡-捕获和默认行为\" class=\"headerlink\" title=\"如何阻止事件冒泡/捕获和默认行为\"></a>如何阻止事件冒泡/捕获和默认行为</h5><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//jquery阻止默认行为和冒泡</span>\n<span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"#myBtn\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//js</span>\n<span class=\"token keyword\">let</span> Obtn<span class=\"token operator\">=</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"myBtn\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nObtn<span class=\"token punctuation\">.</span>onclick<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> e<span class=\"token operator\">=</span>ev<span class=\"token operator\">||</span>event<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//阻止事件冒泡  </span>\n    e<span class=\"token punctuation\">.</span>cancelBubble<span class=\"token operator\">=</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">stopPropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">stopImmediatePropagation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//阻止默认行为，但不阻止冒泡</span>\n    e<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em>stoppropagation属于W3C标准，试用于Firefox等浏览器，但是不支持IE浏览器相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。</em></p>\n<p><strong>也可以使用新增事件stopImmediatePropagation()方法来阻止事件捕获和事件冒泡</strong></p>\n<p>那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？</p>\n<p>　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生</p>\n<h5 id=\"事件代理（事件委托）\"><a href=\"#事件代理（事件委托）\" class=\"headerlink\" title=\"事件代理（事件委托）\"></a>事件代理（事件委托）</h5><p><strong>原理：利用事件的冒泡原理来实现的。处在深层的元素触发的事件，最终会冒泡到其父层上，在绑定事件时，利用这个原理，对其父级进行事件绑定。</strong></p>\n<p><strong>举例：实现鼠标滑过，改变背景</strong></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>li1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>li2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span><span class=\"token punctuation\">></span></span>li3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>不使用事件代理：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"li\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mouseover\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">css</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"background\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">siblings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">css</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"background\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"white\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>使用事件代理：</strong></p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token function\">$</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ul\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mouseover\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> e<span class=\"token operator\">=</span>e<span class=\"token operator\">||</span>event<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">$</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">css</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"background\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"red\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">siblings</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">css</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"background\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"white\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>事件委托与事件不委托之间区别：</strong></p>\n<ol>\n<li>事件委托不需要遍历要操作的元素结点，事件不委托需要遍历要操作的元素结点</li>\n<li>事件委托减少操作dom的次数，对性能优化，事件不委托操作的dom次数较多</li>\n<li>事件委托所定义的事件，对新创建的元素结点也可起到作用，而不使用事件委托，对新添加的结点，需要重新为其绑定相关事件。</li>\n</ol>\n<p><strong>event.target &amp; event.currentTarget两者的区别</strong></p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>a<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>b<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>c<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>d<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'target:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>id <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;currentTarget:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">.</span>id\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'target:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>id <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;currentTarget:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">.</span>id\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'target:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>id <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;currentTarget:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">.</span>id\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>\n      <span class=\"token string\">'target:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>id <span class=\"token operator\">+</span> <span class=\"token string\">'&amp;currentTarget:'</span> <span class=\"token operator\">+</span> e<span class=\"token punctuation\">.</span>currentTarget<span class=\"token punctuation\">.</span>id\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当我们点击最里层的元素d的时候，会依次输出:</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">target<span class=\"token punctuation\">:</span>d<span class=\"token operator\">&amp;</span>currentTarget<span class=\"token punctuation\">:</span>d\ntarget<span class=\"token punctuation\">:</span>d<span class=\"token operator\">&amp;</span>currentTarget<span class=\"token punctuation\">:</span>c\ntarget<span class=\"token punctuation\">:</span>d<span class=\"token operator\">&amp;</span>currentTarget<span class=\"token punctuation\">:</span>b\ntarget<span class=\"token punctuation\">:</span>d<span class=\"token operator\">&amp;</span>currentTarget<span class=\"token punctuation\">:</span>a\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从输出中我们可以看到，<code>event.target</code>指向引起触发事件的元素，而<code>event.currentTarget</code>则是事件绑定的元素，只有被点击的那个目标元素的<code>event.target</code>才会等于<code>event.currentTarget</code>。<strong>也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事件捕获和事件冒泡\"><a href=\"#事件捕获和事件冒泡\" class=\"headerlink\" title=\"事件捕获和事件冒泡\"></a>事件捕获和事件冒泡</h3><p>在介绍两者之前首先需要了解监听器:</p>\n<blockquote>\n<p><code>EventTarget.addEventListener()</code>：方法将指定的监听器注册到<code>EventTarget</code>上，当该对象触发指定的事件时，指定的回掉函数就会被执行。事件的目标可以是一个文档上的元素<code>Element,Document</code>和<code>Window</code>或者任何其他支持事件的对象（比如<code>XMLHttpRequest</code>）。</p>\n<p>语法：</p>\n<pre><code class=\"js\">element.addEventListener(event,function,useCapture)\n</code></pre>\n<ul>\n<li><p>event（必需）：字符串，指定事件名。<em>注意不要使用”on”前缀，例如”onclick”应该使用”click”</em></p>\n</li>\n<li><p>function（必需）：指定被监听的事件触发时所要执行的回掉函数。</p>\n</li>\n<li><p>useCapture（可选）：布尔值，指定事件是否在捕获或冒泡阶段执行。可能值：true :事件句柄在捕获阶段执行。false:默认。事件句柄在冒泡阶段执行。</p>\n</li>\n</ul>\n</blockquote>\n<pre><code class=\"html\">&lt;script&gt;\n    document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,callfunction,true); //事件捕获\n    document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;,callfunction,false); //事件冒泡\n    function callfunction(){\n        document.getElementById(&quot;demo&quot;).innerHTML=&quot;hello world!&quot;\n    }\n&lt;/script&gt;\n&lt;body&gt;\n    &lt;button id=&quot;myBtn&quot;&gt;\n        点击\n    &lt;/button&gt;\n    &lt;div id=&quot;demo&quot;&gt;\n\n    &lt;/div&gt;\n&lt;/body&gt;\n\n</code></pre>\n<p><strong>一个完整的事件流：从window开始，最后回到window的过程。</strong></p>\n<ol>\n<li><h5 id=\"事件捕获：window-gt-document-gt-body-gt-button（从window开始一层一层到真正触发事件的元素）\"><a href=\"#事件捕获：window-gt-document-gt-body-gt-button（从window开始一层一层到真正触发事件的元素）\" class=\"headerlink\" title=\"事件捕获：window&gt; document&gt;body&gt;button（从window开始一层一层到真正触发事件的元素）\"></a>事件捕获：window&gt; document&gt;body&gt;button（从window开始一层一层到真正触发事件的元素）</h5></li>\n<li><h5 id=\"事件冒泡：button-gt-body-gt-document-gt-window（从当前触发事件的元素开始，一层一层冒泡到window）\"><a href=\"#事件冒泡：button-gt-body-gt-document-gt-window（从当前触发事件的元素开始，一层一层冒泡到window）\" class=\"headerlink\" title=\"事件冒泡：button&gt;body&gt;document&gt;window（从当前触发事件的元素开始，一层一层冒泡到window）\"></a>事件冒泡：button&gt;body&gt;document&gt;window（从当前触发事件的元素开始，一层一层冒泡到window）</h5></li>\n<li><h5 id=\"两者刚好相反\"><a href=\"#两者刚好相反\" class=\"headerlink\" title=\"两者刚好相反\"></a>两者刚好相反</h5></li>\n</ol>\n<p><img src=\"/2018/10/18/%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/b2a98b1d408c0923807704ad7ac95fde.png\" alt></p>\n<h5 id=\"如何阻止事件冒泡-捕获和默认行为\"><a href=\"#如何阻止事件冒泡-捕获和默认行为\" class=\"headerlink\" title=\"如何阻止事件冒泡/捕获和默认行为\"></a>如何阻止事件冒泡/捕获和默认行为</h5><pre><code class=\"js\">//jquery阻止默认行为和冒泡\n$(&quot;#myBtn&quot;).on(&#39;click&#39;,function(){\n    return false;\n})\n//js\nlet Obtn=document.getElementById(&quot;myBtn&quot;);\nObtn.onclick=function(e){\n    let e=ev||event;\n    //阻止事件冒泡  \n    e.cancelBubble=true;\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n    //阻止默认行为，但不阻止冒泡\n    e.preventDefault();\n    return false;\n}\n</code></pre>\n<p><em>stoppropagation属于W3C标准，试用于Firefox等浏览器，但是不支持IE浏览器相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。</em></p>\n<p><strong>也可以使用新增事件stopImmediatePropagation()方法来阻止事件捕获和事件冒泡</strong></p>\n<p>那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？</p>\n<p>　　后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，但是后者就不会阻止其他事件的发生</p>\n<h5 id=\"事件代理（事件委托）\"><a href=\"#事件代理（事件委托）\" class=\"headerlink\" title=\"事件代理（事件委托）\"></a>事件代理（事件委托）</h5><p><strong>原理：利用事件的冒泡原理来实现的。处在深层的元素触发的事件，最终会冒泡到其父层上，在绑定事件时，利用这个原理，对其父级进行事件绑定。</strong></p>\n<p><strong>举例：实现鼠标滑过，改变背景</strong></p>\n<pre><code class=\"html\">&lt;body&gt;\n    &lt;ul&gt;\n        &lt;li&gt;li1&lt;/li&gt;\n        &lt;li&gt;li2&lt;/li&gt;\n        &lt;li&gt;li3&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;/body&gt;\n</code></pre>\n<p><strong>不使用事件代理：</strong></p>\n<pre><code class=\"js\">$(&quot;li&quot;).on(&quot;mouseover&quot;,function(){\n    $(this).css(&quot;background&quot;,&quot;red&quot;).siblings().css(&quot;background&quot;,&quot;white&quot;);\n})\n</code></pre>\n<p><strong>使用事件代理：</strong></p>\n<pre><code class=\"js\">$(&quot;ul&quot;).on(&quot;mouseover&quot;,function(e){\n    let e=e||event;\n    $(e.target).css(&quot;background&quot;,&quot;red&quot;).siblings().css(&quot;background&quot;,&quot;white&quot;);\n})\n</code></pre>\n<p><strong>事件委托与事件不委托之间区别：</strong></p>\n<ol>\n<li>事件委托不需要遍历要操作的元素结点，事件不委托需要遍历要操作的元素结点</li>\n<li>事件委托减少操作dom的次数，对性能优化，事件不委托操作的dom次数较多</li>\n<li>事件委托所定义的事件，对新创建的元素结点也可起到作用，而不使用事件委托，对新添加的结点，需要重新为其绑定相关事件。</li>\n</ol>\n<p><strong>event.target &amp; event.currentTarget两者的区别</strong></p>\n<pre><code class=\"jsx\">&lt;div id=&quot;a&quot;&gt;\n  &lt;div id=&quot;b&quot;&gt;\n    &lt;div id=&quot;c&quot;&gt;&lt;div id=&quot;d&quot;&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;script&gt;\n  document.getElementById(&#39;a&#39;).addEventListener(&#39;click&#39;, function(e) {\n    console.log(\n      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id\n    )\n  })\n  document.getElementById(&#39;b&#39;).addEventListener(&#39;click&#39;, function(e) {\n    console.log(\n      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id\n    )\n  })\n  document.getElementById(&#39;c&#39;).addEventListener(&#39;click&#39;, function(e) {\n    console.log(\n      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id\n    )\n  })\n  document.getElementById(&#39;d&#39;).addEventListener(&#39;click&#39;, function(e) {\n    console.log(\n      &#39;target:&#39; + e.target.id + &#39;&amp;currentTarget:&#39; + e.currentTarget.id\n    )\n  })\n&lt;/script&gt;\n</code></pre>\n<p>当我们点击最里层的元素d的时候，会依次输出:</p>\n<pre><code class=\"js\">target:d&amp;currentTarget:d\ntarget:d&amp;currentTarget:c\ntarget:d&amp;currentTarget:b\ntarget:d&amp;currentTarget:a\n</code></pre>\n<p>从输出中我们可以看到，<code>event.target</code>指向引起触发事件的元素，而<code>event.currentTarget</code>则是事件绑定的元素，只有被点击的那个目标元素的<code>event.target</code>才会等于<code>event.currentTarget</code>。<strong>也就是说，event.currentTarget始终是监听事件者，而event.target是事件的真正发出者</strong>。</p>\n"},{"title":"使用Hexo+Github搭建属于自己的博客","date":"2018-09-25T09:11:08.000Z","_content":"# 使用Hexo+Github搭建属于自己的博客\n\n##### 1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功\n`node -v`\n`npm -v`\n![](你好,潘君毅/b8d6706040d9ab598087e7c4a291315c.png)\n\n##### 2.安装Git环境\n![](你好,潘君毅/1c358a084065a55f8028d9539dc1c22d.png)\n***注意:***一般为了安全考虑，只有在Git Bash Here中才能进行Git的相关操作。\n`git --version`查看是否配置成功\n\n##### 3.登陆Github账号，新建项目：账户名.github.io\n![](你好,潘君毅/87c8b71a404cbce3800d7150d62e3572.png)\n项目建好后，可以访问[https://用户名.github.io/](#)\n\n##### 4.安装Hexo，新建blog目录，在当前目录下命令行中执行：\n`npm install hexo -g`\n![](你好,潘君毅/0a07ba0c40de774980cb892145452fea.png)\n之后输入:`hexo -v`查看版本\n![](你好,潘君毅/7b48d7ea40865e3d801a612431c2226f.png)\n初始化该文件夹`hexo init`\n![](你好,潘君毅/437fc07240469c578002a18d7c179695.png)\n接着`npm install`，安装相关组件\n输入`hexo g`\n输入`hexo s`，开启服务器，访问该网址，正式体验Hexo\n![](你好,潘君毅/5c56223d40e8e14e80409b9863cc9563.png)\n如果成功，则显示：\n![](你好,潘君毅/76e9c5364021748380332bcda0314c0e.png)\n\n##### 5.接下来配置ssh，首先配置Git，打开Git Bash Here\n1. 设置用户名：\n`git config --global user.name '用户名'`\n2. 设置用户邮箱\n`git config --global user.email 'user@163.com'`\n3. 查看设置\n`git config --list`\n查看C:\\Users\\Administrator\\.ssh是否存在\n不存在输入：`ssh-keygen -t rsa -C \"user@163.com\"`回车生成密钥\n`cd ~/.ssh`\n`ls`\n可以看到两个文件：id_rsa和id_rsa.pub\n输入`eval \"$(ssh-agent -s)\"`,添加密钥到ssh-agent\n再输入`ssh-add ~/.ssh/id_rsa`，添加生成的ssh key到ssh-agent\n之后登录Github，点击头像，选择头像下的settings，添加ssh\n![](你好,潘君毅/6ba821354070efd88095cc946e5f084f.png)\n新建一个new ssh key，将id_rsa.pub文件里的内容复制到Key中\n输入`ssh -T git@github.com`，测试添加的ssh是否成功，如果看到Hi你的用户名，则表示成功了。\n如果出错ssh: connect to host github.com port 22: Connection timed out\n需要在C:\\Users\\Administrator\\.ssh目录下配置config文件，输入\n`touch config`\n![](你好,潘君毅/d082fa4140ed737780aa3a6599da6a8f.png)\n内容为：\n```javascipt\nHost github.com  \nUser user@163.com  \nHostname ssh.github.com  \nPreferredAuthentications publickey  \nIdentityFile ~/.ssh/id_rsa  \nPort 443\n```\n***user为用户邮箱***\n在项目目录下找到_config.yml文件，在末尾修改\n```javascipt\ndeploy:\n   type: git\n   repository: 你自己的github项目里的ssh\n   branch: master\n```\nrepository的值：\n![](你好,潘君毅/1be67f4740ae60fa8083591da8f65bfa.png)\n\n##### 6.新建一篇博客，在cmd执行命令：`hexo new post \"博客名\"`\n在文件夹——posts目录下可以看到\n\n在生成以及部署文章之前，需要安装一个扩展：`npm install hexo-deployer-git --save`\n使用编辑器编好文章，那么就可以使用命令：`hexo d -g`，生成以及部署了\n部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章","source":"_posts/你好，潘君毅.md","raw":"---\ntitle: 使用Hexo+Github搭建属于自己的博客\ndate: 2018-09-25 17:11:08\ntags: hexo\ncategories: git\n---\n# 使用Hexo+Github搭建属于自己的博客\n\n##### 1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功\n`node -v`\n`npm -v`\n![](你好,潘君毅/b8d6706040d9ab598087e7c4a291315c.png)\n\n##### 2.安装Git环境\n![](你好,潘君毅/1c358a084065a55f8028d9539dc1c22d.png)\n***注意:***一般为了安全考虑，只有在Git Bash Here中才能进行Git的相关操作。\n`git --version`查看是否配置成功\n\n##### 3.登陆Github账号，新建项目：账户名.github.io\n![](你好,潘君毅/87c8b71a404cbce3800d7150d62e3572.png)\n项目建好后，可以访问[https://用户名.github.io/](#)\n\n##### 4.安装Hexo，新建blog目录，在当前目录下命令行中执行：\n`npm install hexo -g`\n![](你好,潘君毅/0a07ba0c40de774980cb892145452fea.png)\n之后输入:`hexo -v`查看版本\n![](你好,潘君毅/7b48d7ea40865e3d801a612431c2226f.png)\n初始化该文件夹`hexo init`\n![](你好,潘君毅/437fc07240469c578002a18d7c179695.png)\n接着`npm install`，安装相关组件\n输入`hexo g`\n输入`hexo s`，开启服务器，访问该网址，正式体验Hexo\n![](你好,潘君毅/5c56223d40e8e14e80409b9863cc9563.png)\n如果成功，则显示：\n![](你好,潘君毅/76e9c5364021748380332bcda0314c0e.png)\n\n##### 5.接下来配置ssh，首先配置Git，打开Git Bash Here\n1. 设置用户名：\n`git config --global user.name '用户名'`\n2. 设置用户邮箱\n`git config --global user.email 'user@163.com'`\n3. 查看设置\n`git config --list`\n查看C:\\Users\\Administrator\\.ssh是否存在\n不存在输入：`ssh-keygen -t rsa -C \"user@163.com\"`回车生成密钥\n`cd ~/.ssh`\n`ls`\n可以看到两个文件：id_rsa和id_rsa.pub\n输入`eval \"$(ssh-agent -s)\"`,添加密钥到ssh-agent\n再输入`ssh-add ~/.ssh/id_rsa`，添加生成的ssh key到ssh-agent\n之后登录Github，点击头像，选择头像下的settings，添加ssh\n![](你好,潘君毅/6ba821354070efd88095cc946e5f084f.png)\n新建一个new ssh key，将id_rsa.pub文件里的内容复制到Key中\n输入`ssh -T git@github.com`，测试添加的ssh是否成功，如果看到Hi你的用户名，则表示成功了。\n如果出错ssh: connect to host github.com port 22: Connection timed out\n需要在C:\\Users\\Administrator\\.ssh目录下配置config文件，输入\n`touch config`\n![](你好,潘君毅/d082fa4140ed737780aa3a6599da6a8f.png)\n内容为：\n```javascipt\nHost github.com  \nUser user@163.com  \nHostname ssh.github.com  \nPreferredAuthentications publickey  \nIdentityFile ~/.ssh/id_rsa  \nPort 443\n```\n***user为用户邮箱***\n在项目目录下找到_config.yml文件，在末尾修改\n```javascipt\ndeploy:\n   type: git\n   repository: 你自己的github项目里的ssh\n   branch: master\n```\nrepository的值：\n![](你好,潘君毅/1be67f4740ae60fa8083591da8f65bfa.png)\n\n##### 6.新建一篇博客，在cmd执行命令：`hexo new post \"博客名\"`\n在文件夹——posts目录下可以看到\n\n在生成以及部署文章之前，需要安装一个扩展：`npm install hexo-deployer-git --save`\n使用编辑器编好文章，那么就可以使用命令：`hexo d -g`，生成以及部署了\n部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章","slug":"你好，潘君毅","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri6005q1xop1gp98c4s","content":"<h1 id=\"使用Hexo-Github搭建属于自己的博客\"><a href=\"#使用Hexo-Github搭建属于自己的博客\" class=\"headerlink\" title=\"使用Hexo+Github搭建属于自己的博客\"></a>使用Hexo+Github搭建属于自己的博客</h1><h5 id=\"1-安装Node-js和配置好Node-js环境，打开cmd命令行，输入一下命令查看安装是否成功\"><a href=\"#1-安装Node-js和配置好Node-js环境，打开cmd命令行，输入一下命令查看安装是否成功\" class=\"headerlink\" title=\"1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功\"></a>1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功</h5><p><code>node -v</code><br><code>npm -v</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/b8d6706040d9ab598087e7c4a291315c.png\" alt></p>\n<h5 id=\"2-安装Git环境\"><a href=\"#2-安装Git环境\" class=\"headerlink\" title=\"2.安装Git环境\"></a>2.安装Git环境</h5><p><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/1c358a084065a55f8028d9539dc1c22d.png\" alt><br><strong><em>注意:</em></strong>一般为了安全考虑，只有在Git Bash Here中才能进行Git的相关操作。<br><code>git --version</code>查看是否配置成功</p>\n<h5 id=\"3-登陆Github账号，新建项目：账户名-github-io\"><a href=\"#3-登陆Github账号，新建项目：账户名-github-io\" class=\"headerlink\" title=\"3.登陆Github账号，新建项目：账户名.github.io\"></a>3.登陆Github账号，新建项目：账户名.github.io</h5><p><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/87c8b71a404cbce3800d7150d62e3572.png\" alt><br>项目建好后，可以访问<a href=\"#\">https://用户名.github.io/</a></p>\n<h5 id=\"4-安装Hexo，新建blog目录，在当前目录下命令行中执行：\"><a href=\"#4-安装Hexo，新建blog目录，在当前目录下命令行中执行：\" class=\"headerlink\" title=\"4.安装Hexo，新建blog目录，在当前目录下命令行中执行：\"></a>4.安装Hexo，新建blog目录，在当前目录下命令行中执行：</h5><p><code>npm install hexo -g</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/0a07ba0c40de774980cb892145452fea.png\" alt><br>之后输入:<code>hexo -v</code>查看版本<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/7b48d7ea40865e3d801a612431c2226f.png\" alt><br>初始化该文件夹<code>hexo init</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/437fc07240469c578002a18d7c179695.png\" alt><br>接着<code>npm install</code>，安装相关组件<br>输入<code>hexo g</code><br>输入<code>hexo s</code>，开启服务器，访问该网址，正式体验Hexo<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/5c56223d40e8e14e80409b9863cc9563.png\" alt><br>如果成功，则显示：<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/76e9c5364021748380332bcda0314c0e.png\" alt></p>\n<h5 id=\"5-接下来配置ssh，首先配置Git，打开Git-Bash-Here\"><a href=\"#5-接下来配置ssh，首先配置Git，打开Git-Bash-Here\" class=\"headerlink\" title=\"5.接下来配置ssh，首先配置Git，打开Git Bash Here\"></a>5.接下来配置ssh，首先配置Git，打开Git Bash Here</h5><ol>\n<li>设置用户名：<br><code>git config --global user.name &#39;用户名&#39;</code></li>\n<li>设置用户邮箱<br><code>git config --global user.email &#39;user@163.com&#39;</code></li>\n<li>查看设置<br><code>git config --list</code><br>查看C:\\Users\\Administrator.ssh是否存在<br>不存在输入：<code>ssh-keygen -t rsa -C &quot;user@163.com&quot;</code>回车生成密钥<br><code>cd ~/.ssh</code><br><code>ls</code><br>可以看到两个文件：id_rsa和id_rsa.pub<br>输入<code>eval &quot;$(ssh-agent -s)&quot;</code>,添加密钥到ssh-agent<br>再输入<code>ssh-add ~/.ssh/id_rsa</code>，添加生成的ssh key到ssh-agent<br>之后登录Github，点击头像，选择头像下的settings，添加ssh<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/6ba821354070efd88095cc946e5f084f.png\" alt><br>新建一个new ssh key，将id_rsa.pub文件里的内容复制到Key中<br>输入<code>ssh -T git@github.com</code>，测试添加的ssh是否成功，如果看到Hi你的用户名，则表示成功了。<br>如果出错ssh: connect to host github.com port 22: Connection timed out<br>需要在C:\\Users\\Administrator.ssh目录下配置config文件，输入<br><code>touch config</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/d082fa4140ed737780aa3a6599da6a8f.png\" alt><br>内容为：<pre class=\"line-numbers language-javascipt\"><code class=\"language-javascipt\">Host github.com  \nUser user@163.com  \nHostname ssh.github.com  \nPreferredAuthentications publickey  \nIdentityFile ~/.ssh/id_rsa  \nPort 443\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<strong><em>user为用户邮箱</em></strong><br>在项目目录下找到_config.yml文件，在末尾修改<pre class=\"line-numbers language-javascipt\"><code class=\"language-javascipt\">deploy:\ntype: git\nrepository: 你自己的github项目里的ssh\nbranch: master\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\nrepository的值：<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/1be67f4740ae60fa8083591da8f65bfa.png\" alt></li>\n</ol>\n<h5 id=\"6-新建一篇博客，在cmd执行命令：hexo-new-post-quot-博客名-quot\"><a href=\"#6-新建一篇博客，在cmd执行命令：hexo-new-post-quot-博客名-quot\" class=\"headerlink\" title=\"6.新建一篇博客，在cmd执行命令：hexo new post &quot;博客名&quot;\"></a>6.新建一篇博客，在cmd执行命令：<code>hexo new post &quot;博客名&quot;</code></h5><p>在文件夹——posts目录下可以看到</p>\n<p>在生成以及部署文章之前，需要安装一个扩展：<code>npm install hexo-deployer-git --save</code><br>使用编辑器编好文章，那么就可以使用命令：<code>hexo d -g</code>，生成以及部署了<br>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Hexo-Github搭建属于自己的博客\"><a href=\"#使用Hexo-Github搭建属于自己的博客\" class=\"headerlink\" title=\"使用Hexo+Github搭建属于自己的博客\"></a>使用Hexo+Github搭建属于自己的博客</h1><h5 id=\"1-安装Node-js和配置好Node-js环境，打开cmd命令行，输入一下命令查看安装是否成功\"><a href=\"#1-安装Node-js和配置好Node-js环境，打开cmd命令行，输入一下命令查看安装是否成功\" class=\"headerlink\" title=\"1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功\"></a>1.安装Node.js和配置好Node.js环境，打开cmd命令行，输入一下命令查看安装是否成功</h5><p><code>node -v</code><br><code>npm -v</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/b8d6706040d9ab598087e7c4a291315c.png\" alt></p>\n<h5 id=\"2-安装Git环境\"><a href=\"#2-安装Git环境\" class=\"headerlink\" title=\"2.安装Git环境\"></a>2.安装Git环境</h5><p><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/1c358a084065a55f8028d9539dc1c22d.png\" alt><br><strong><em>注意:</em></strong>一般为了安全考虑，只有在Git Bash Here中才能进行Git的相关操作。<br><code>git --version</code>查看是否配置成功</p>\n<h5 id=\"3-登陆Github账号，新建项目：账户名-github-io\"><a href=\"#3-登陆Github账号，新建项目：账户名-github-io\" class=\"headerlink\" title=\"3.登陆Github账号，新建项目：账户名.github.io\"></a>3.登陆Github账号，新建项目：账户名.github.io</h5><p><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/87c8b71a404cbce3800d7150d62e3572.png\" alt><br>项目建好后，可以访问<a href=\"#\">https://用户名.github.io/</a></p>\n<h5 id=\"4-安装Hexo，新建blog目录，在当前目录下命令行中执行：\"><a href=\"#4-安装Hexo，新建blog目录，在当前目录下命令行中执行：\" class=\"headerlink\" title=\"4.安装Hexo，新建blog目录，在当前目录下命令行中执行：\"></a>4.安装Hexo，新建blog目录，在当前目录下命令行中执行：</h5><p><code>npm install hexo -g</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/0a07ba0c40de774980cb892145452fea.png\" alt><br>之后输入:<code>hexo -v</code>查看版本<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/7b48d7ea40865e3d801a612431c2226f.png\" alt><br>初始化该文件夹<code>hexo init</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/437fc07240469c578002a18d7c179695.png\" alt><br>接着<code>npm install</code>，安装相关组件<br>输入<code>hexo g</code><br>输入<code>hexo s</code>，开启服务器，访问该网址，正式体验Hexo<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/5c56223d40e8e14e80409b9863cc9563.png\" alt><br>如果成功，则显示：<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/76e9c5364021748380332bcda0314c0e.png\" alt></p>\n<h5 id=\"5-接下来配置ssh，首先配置Git，打开Git-Bash-Here\"><a href=\"#5-接下来配置ssh，首先配置Git，打开Git-Bash-Here\" class=\"headerlink\" title=\"5.接下来配置ssh，首先配置Git，打开Git Bash Here\"></a>5.接下来配置ssh，首先配置Git，打开Git Bash Here</h5><ol>\n<li>设置用户名：<br><code>git config --global user.name &#39;用户名&#39;</code></li>\n<li>设置用户邮箱<br><code>git config --global user.email &#39;user@163.com&#39;</code></li>\n<li>查看设置<br><code>git config --list</code><br>查看C:\\Users\\Administrator.ssh是否存在<br>不存在输入：<code>ssh-keygen -t rsa -C &quot;user@163.com&quot;</code>回车生成密钥<br><code>cd ~/.ssh</code><br><code>ls</code><br>可以看到两个文件：id_rsa和id_rsa.pub<br>输入<code>eval &quot;$(ssh-agent -s)&quot;</code>,添加密钥到ssh-agent<br>再输入<code>ssh-add ~/.ssh/id_rsa</code>，添加生成的ssh key到ssh-agent<br>之后登录Github，点击头像，选择头像下的settings，添加ssh<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/6ba821354070efd88095cc946e5f084f.png\" alt><br>新建一个new ssh key，将id_rsa.pub文件里的内容复制到Key中<br>输入<code>ssh -T git@github.com</code>，测试添加的ssh是否成功，如果看到Hi你的用户名，则表示成功了。<br>如果出错ssh: connect to host github.com port 22: Connection timed out<br>需要在C:\\Users\\Administrator.ssh目录下配置config文件，输入<br><code>touch config</code><br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/d082fa4140ed737780aa3a6599da6a8f.png\" alt><br>内容为：<pre><code class=\"javascipt\">Host github.com  \nUser user@163.com  \nHostname ssh.github.com  \nPreferredAuthentications publickey  \nIdentityFile ~/.ssh/id_rsa  \nPort 443\n</code></pre>\n<strong><em>user为用户邮箱</em></strong><br>在项目目录下找到_config.yml文件，在末尾修改<pre><code class=\"javascipt\">deploy:\ntype: git\nrepository: 你自己的github项目里的ssh\nbranch: master\n</code></pre>\nrepository的值：<br><img src=\"/2018/09/25/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E6%BD%98%E5%90%9B%E6%AF%85/1be67f4740ae60fa8083591da8f65bfa.png\" alt></li>\n</ol>\n<h5 id=\"6-新建一篇博客，在cmd执行命令：hexo-new-post-quot-博客名-quot\"><a href=\"#6-新建一篇博客，在cmd执行命令：hexo-new-post-quot-博客名-quot\" class=\"headerlink\" title=\"6.新建一篇博客，在cmd执行命令：hexo new post &quot;博客名&quot;\"></a>6.新建一篇博客，在cmd执行命令：<code>hexo new post &quot;博客名&quot;</code></h5><p>在文件夹——posts目录下可以看到</p>\n<p>在生成以及部署文章之前，需要安装一个扩展：<code>npm install hexo-deployer-git --save</code><br>使用编辑器编好文章，那么就可以使用命令：<code>hexo d -g</code>，生成以及部署了<br>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</p>\n"},{"title":"函数柯里化","date":"2020-08-09T02:35:08.000Z","_content":"\n### **函数柯里化**\n\n```js\nfunction sub_curry(fn) {\n\tlet args = Array.from(arguments).slice(1)\n\treturn function () {\n\t\tlet allArgs = args.concat(Array.from(arguments).slice())\n\t\treturn fn.apply(this, allArgs)\n\t}\n}\n\nfunction curry(fn, length) {\n\tlet len = fn.length || length\n\treturn function () {\n\t\tlet args = Array.from(arguments).slice()\n\t\tif (args.length < len) {\n\t\t\tlet combined = [fn].concat(args)\n\t\t\treturn curry(sub_curry.apply(this, combined), len - args.length)\n\t\t} else {\n\t\t\treturn fn.apply(this, args)\n\t\t}\n\t}\n}\n```\n\n","source":"_posts/函数柯里化.md","raw":"---\ntitle: 函数柯里化\ndate: 2020-08-09 10:35:08\ntags: js\ncategories: 前端\n---\n\n### **函数柯里化**\n\n```js\nfunction sub_curry(fn) {\n\tlet args = Array.from(arguments).slice(1)\n\treturn function () {\n\t\tlet allArgs = args.concat(Array.from(arguments).slice())\n\t\treturn fn.apply(this, allArgs)\n\t}\n}\n\nfunction curry(fn, length) {\n\tlet len = fn.length || length\n\treturn function () {\n\t\tlet args = Array.from(arguments).slice()\n\t\tif (args.length < len) {\n\t\t\tlet combined = [fn].concat(args)\n\t\t\treturn curry(sub_curry.apply(this, combined), len - args.length)\n\t\t} else {\n\t\t\treturn fn.apply(this, args)\n\t\t}\n\t}\n}\n```\n\n","slug":"函数柯里化","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri7005t1xop1fi788c3","content":"<h3 id=\"函数柯里化\"><a href=\"#函数柯里化\" class=\"headerlink\" title=\"函数柯里化\"></a><strong>函数柯里化</strong></h3><pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">sub_curry</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> allArgs <span class=\"token operator\">=</span> args<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> allArgs<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> len <span class=\"token operator\">=</span> fn<span class=\"token punctuation\">.</span>length <span class=\"token operator\">||</span> length\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> combined <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>fn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">curry</span><span class=\"token punctuation\">(</span>sub_curry<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> combined<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> args<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"函数柯里化\"><a href=\"#函数柯里化\" class=\"headerlink\" title=\"函数柯里化\"></a><strong>函数柯里化</strong></h3><pre><code class=\"js\">function sub_curry(fn) {\n    let args = Array.from(arguments).slice(1)\n    return function () {\n        let allArgs = args.concat(Array.from(arguments).slice())\n        return fn.apply(this, allArgs)\n    }\n}\n\nfunction curry(fn, length) {\n    let len = fn.length || length\n    return function () {\n        let args = Array.from(arguments).slice()\n        if (args.length &lt; len) {\n            let combined = [fn].concat(args)\n            return curry(sub_curry.apply(this, combined), len - args.length)\n        } else {\n            return fn.apply(this, args)\n        }\n    }\n}\n</code></pre>\n"},{"title":"前端性能优化","date":"2019-03-10T14:10:13.000Z","_content":"\n### 前端性能优化\n\n- 2.5.1 数据存取\n\n☆ 尽量使用局部变量\n\n☆ 对象成员的嵌套深度与读取时间成正比，嵌套过深要进行优化\n\n- 2.5.2 DOM ☆ 尽量减少DOM操作（访问和修改都算）的次数\n\n☆ 访问元素时使用最快的API\n\n☆ 使用事件委托来减少事件处理器的数量\n\n☆ 减少重绘和重排的次数\n\n- 2.5.3 算法和流程\n\n☆ for循环、while循环、do-whild循环比for in 要快 ☆ 优化循环体的复杂度\n\n☆ 最小化属性查找\n\n☆ 当条件较少时 使用if-else更易读，而当条件较多时if-else性能负担比switch大，易读性也没switch好。\n\n☆ 对于if else 概率越大的条件越靠前判断 比如：\n\n☆ 当计算量很大且重复的时候，用Memoization缓存计算结果\n\n- 2.5.5 Ajax\n\n☆ 服务端设置HTTP头信息确保响应会被浏览器缓存\n\n☆ 客户端将获取的信息存到本地避免再次请求（localstorage sessionstorage cookice）\n\n☆ 设置HTTP头信息，expiresgaosu告诉浏览器缓存多久\n\n☆ 减少HTTP请求，合并css、js、图片资源文件等或使用MXHR\n\n☆ 通过次要文件用Ajax获取可缩短页面加载时间\n\n#### js标签的放置位置\n\n由于外部引入的js代码，在浏览器加载过程中会出现阻塞的情况，为了避免出现加载时间过长而导致的页面空白，可以考虑将javaScript标签放在body标签中的页面内容之后\n\nJavaScript是单线程，所以JavaScript的加载和执行是从上至下加载执行完一个再继续加载执行下一个文件，会阻塞页面资源的加载，所以一般情况下JavaScript文件放在body标签内底部，很多后端开发人员放在body标签外下面，这样做不好的地方有两处：1、不规范 2、可能会造成js获取不到页面元素而导致报错。而放在body标签内底部可以确保js执行前页面渲染完成\n\n\n\n### 防抖 (debounce):\n\n将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。\n\n```js\nfunction debounce(fn, wait) { //防抖函数\n    let timer = null;\n    return function() {\n        let args = arguments;\n        let context = this;\n        \n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, wait)\n    }\n}\n```\n\n### 节流(throttle):\n\n每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。\n\n```js\nfunction throttle(func, delay) { //节流函数，用于高频触发时\n  let timer = null;\n  let startTime = Date.now();\n  return function() {\n    let curTime = Date.now();\n    let remaining = delay - (curTime - startTime);\n    let context = this;\n    let args = arguments;\n    clearTimeout(timer);\n    if( remaining <= 0) {\n      func.apply(context, args);\n      startTime = Date.now();\n    }else {\n      timer = setTimeout(func, remaining);\n    }\n  }\n}\n```\n\n### 函数柯里化：\n\n在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。\n\n```js\nconst add = function add(x) {\n\treturn function (y) {\n\t\treturn x + y\n\t}\n}\n\nconst add1 = add(1)\n\nadd1(2) === 3\nadd1(20) === 21\n```\n\n```js\n\nfunction sum(a) { \n    return function(b) {\n        return function(c) { \n            return a+b+c; \n        } \n    } \n} \nconsole.log(sum(1)(2)(3)); // 6\n\n// -------------------------------------\n\nfunction _curry(fn, args = []) {\n    return function() {\n        let rest = [...args, ...arguments];\n        if(rest.length < fn.length) {\n        \treturn _curry.call(this,fn,rest)\n        }else {\n        \treturn fn.apply(this,rest);\n        }\n    }\n}\n\nfunction sum(a,b,c) {\n    return a+b+c\n}\nlet sumFn = _curry(sum);\n\nconsole.log(sumFn(1)(2)(3));  // 6\n```\n\n**雪碧图，移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析**\n\n**将图片转为Base64格式，存储在Storage中**\n\n#### **base64格式的优势**\n\n1. base64格式的图片是文本格式，占用内存小\n2. 使用base64格式的图片，图片会随着html一同下载，不需要建立新的http请求，降低服务器请求压力\n3. 没有跨域问题\n\n#### **缺点**\n\n1. 无法使用缓存\n2. css体积增大（css加载会阻塞DOM树渲染，导致页面长时间出现空白屏幕）\n\n#### **使用场景**\n\n1. 对于极小的极简单的图片比如一些小的logo（转换为base64后，不至于产生太大的文本）\n\n#### **CssSprites**\n\n1. 将多张图合为一张，减少http请求数量\n2. 页面换肤功能\n3. 网站图片改动小，基本不变","source":"_posts/前端性能优化.md","raw":"---\ntitle: 前端性能优化\ndate: 2019-03-10 22:10:13\ntags: 前端性能相关\ncategories: 前端\n---\n\n### 前端性能优化\n\n- 2.5.1 数据存取\n\n☆ 尽量使用局部变量\n\n☆ 对象成员的嵌套深度与读取时间成正比，嵌套过深要进行优化\n\n- 2.5.2 DOM ☆ 尽量减少DOM操作（访问和修改都算）的次数\n\n☆ 访问元素时使用最快的API\n\n☆ 使用事件委托来减少事件处理器的数量\n\n☆ 减少重绘和重排的次数\n\n- 2.5.3 算法和流程\n\n☆ for循环、while循环、do-whild循环比for in 要快 ☆ 优化循环体的复杂度\n\n☆ 最小化属性查找\n\n☆ 当条件较少时 使用if-else更易读，而当条件较多时if-else性能负担比switch大，易读性也没switch好。\n\n☆ 对于if else 概率越大的条件越靠前判断 比如：\n\n☆ 当计算量很大且重复的时候，用Memoization缓存计算结果\n\n- 2.5.5 Ajax\n\n☆ 服务端设置HTTP头信息确保响应会被浏览器缓存\n\n☆ 客户端将获取的信息存到本地避免再次请求（localstorage sessionstorage cookice）\n\n☆ 设置HTTP头信息，expiresgaosu告诉浏览器缓存多久\n\n☆ 减少HTTP请求，合并css、js、图片资源文件等或使用MXHR\n\n☆ 通过次要文件用Ajax获取可缩短页面加载时间\n\n#### js标签的放置位置\n\n由于外部引入的js代码，在浏览器加载过程中会出现阻塞的情况，为了避免出现加载时间过长而导致的页面空白，可以考虑将javaScript标签放在body标签中的页面内容之后\n\nJavaScript是单线程，所以JavaScript的加载和执行是从上至下加载执行完一个再继续加载执行下一个文件，会阻塞页面资源的加载，所以一般情况下JavaScript文件放在body标签内底部，很多后端开发人员放在body标签外下面，这样做不好的地方有两处：1、不规范 2、可能会造成js获取不到页面元素而导致报错。而放在body标签内底部可以确保js执行前页面渲染完成\n\n\n\n### 防抖 (debounce):\n\n将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。\n\n```js\nfunction debounce(fn, wait) { //防抖函数\n    let timer = null;\n    return function() {\n        let args = arguments;\n        let context = this;\n        \n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, wait)\n    }\n}\n```\n\n### 节流(throttle):\n\n每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。\n\n```js\nfunction throttle(func, delay) { //节流函数，用于高频触发时\n  let timer = null;\n  let startTime = Date.now();\n  return function() {\n    let curTime = Date.now();\n    let remaining = delay - (curTime - startTime);\n    let context = this;\n    let args = arguments;\n    clearTimeout(timer);\n    if( remaining <= 0) {\n      func.apply(context, args);\n      startTime = Date.now();\n    }else {\n      timer = setTimeout(func, remaining);\n    }\n  }\n}\n```\n\n### 函数柯里化：\n\n在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。\n\n```js\nconst add = function add(x) {\n\treturn function (y) {\n\t\treturn x + y\n\t}\n}\n\nconst add1 = add(1)\n\nadd1(2) === 3\nadd1(20) === 21\n```\n\n```js\n\nfunction sum(a) { \n    return function(b) {\n        return function(c) { \n            return a+b+c; \n        } \n    } \n} \nconsole.log(sum(1)(2)(3)); // 6\n\n// -------------------------------------\n\nfunction _curry(fn, args = []) {\n    return function() {\n        let rest = [...args, ...arguments];\n        if(rest.length < fn.length) {\n        \treturn _curry.call(this,fn,rest)\n        }else {\n        \treturn fn.apply(this,rest);\n        }\n    }\n}\n\nfunction sum(a,b,c) {\n    return a+b+c\n}\nlet sumFn = _curry(sum);\n\nconsole.log(sumFn(1)(2)(3));  // 6\n```\n\n**雪碧图，移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析**\n\n**将图片转为Base64格式，存储在Storage中**\n\n#### **base64格式的优势**\n\n1. base64格式的图片是文本格式，占用内存小\n2. 使用base64格式的图片，图片会随着html一同下载，不需要建立新的http请求，降低服务器请求压力\n3. 没有跨域问题\n\n#### **缺点**\n\n1. 无法使用缓存\n2. css体积增大（css加载会阻塞DOM树渲染，导致页面长时间出现空白屏幕）\n\n#### **使用场景**\n\n1. 对于极小的极简单的图片比如一些小的logo（转换为base64后，不至于产生太大的文本）\n\n#### **CssSprites**\n\n1. 将多张图合为一张，减少http请求数量\n2. 页面换肤功能\n3. 网站图片改动小，基本不变","slug":"前端性能优化","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri8005w1xopdxje81jl","content":"<h3 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h3><ul>\n<li>2.5.1 数据存取</li>\n</ul>\n<p>☆ 尽量使用局部变量</p>\n<p>☆ 对象成员的嵌套深度与读取时间成正比，嵌套过深要进行优化</p>\n<ul>\n<li>2.5.2 DOM ☆ 尽量减少DOM操作（访问和修改都算）的次数</li>\n</ul>\n<p>☆ 访问元素时使用最快的API</p>\n<p>☆ 使用事件委托来减少事件处理器的数量</p>\n<p>☆ 减少重绘和重排的次数</p>\n<ul>\n<li>2.5.3 算法和流程</li>\n</ul>\n<p>☆ for循环、while循环、do-whild循环比for in 要快 ☆ 优化循环体的复杂度</p>\n<p>☆ 最小化属性查找</p>\n<p>☆ 当条件较少时 使用if-else更易读，而当条件较多时if-else性能负担比switch大，易读性也没switch好。</p>\n<p>☆ 对于if else 概率越大的条件越靠前判断 比如：</p>\n<p>☆ 当计算量很大且重复的时候，用Memoization缓存计算结果</p>\n<ul>\n<li>2.5.5 Ajax</li>\n</ul>\n<p>☆ 服务端设置HTTP头信息确保响应会被浏览器缓存</p>\n<p>☆ 客户端将获取的信息存到本地避免再次请求（localstorage sessionstorage cookice）</p>\n<p>☆ 设置HTTP头信息，expiresgaosu告诉浏览器缓存多久</p>\n<p>☆ 减少HTTP请求，合并css、js、图片资源文件等或使用MXHR</p>\n<p>☆ 通过次要文件用Ajax获取可缩短页面加载时间</p>\n<h4 id=\"js标签的放置位置\"><a href=\"#js标签的放置位置\" class=\"headerlink\" title=\"js标签的放置位置\"></a>js标签的放置位置</h4><p>由于外部引入的js代码，在浏览器加载过程中会出现阻塞的情况，为了避免出现加载时间过长而导致的页面空白，可以考虑将javaScript标签放在body标签中的页面内容之后</p>\n<p>JavaScript是单线程，所以JavaScript的加载和执行是从上至下加载执行完一个再继续加载执行下一个文件，会阻塞页面资源的加载，所以一般情况下JavaScript文件放在body标签内底部，很多后端开发人员放在body标签外下面，这样做不好的地方有两处：1、不规范 2、可能会造成js获取不到页面元素而导致报错。而放在body标签内底部可以确保js执行前页面渲染完成</p>\n<h3 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖 (debounce):\"></a>防抖 (debounce):</h3><p>将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">debounce</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//防抖函数</span>\n    <span class=\"token keyword\">let</span> timer <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span> <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span>\n        timer <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            fn<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> wait<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle):\"></a>节流(throttle):</h3><p>每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">throttle</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> delay<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//节流函数，用于高频触发时</span>\n  <span class=\"token keyword\">let</span> timer <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> startTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> curTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> remaining <span class=\"token operator\">=</span> delay <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>curTime <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> args <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">clearTimeout</span><span class=\"token punctuation\">(</span>timer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span> remaining <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      func<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      startTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      timer <span class=\"token operator\">=</span> <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> remaining<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数柯里化：\"><a href=\"#函数柯里化：\" class=\"headerlink\" title=\"函数柯里化：\"></a>函数柯里化：</h3><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> add <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> y\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> add1 <span class=\"token operator\">=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">add1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">3</span>\n<span class=\"token function\">add1</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token number\">21</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n            <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span>b<span class=\"token operator\">+</span>c<span class=\"token punctuation\">;</span> \n        <span class=\"token punctuation\">}</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span> \nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 6</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// -------------------------------------</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">_curry</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">,</span> args <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>rest<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> fn<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> _curry<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>fn<span class=\"token punctuation\">,</span>rest<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> fn<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>rest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span>b<span class=\"token operator\">+</span>c\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> sumFn <span class=\"token operator\">=</span> <span class=\"token function\">_curry</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">sumFn</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">// 6</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>雪碧图，移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析</strong></p>\n<p><strong>将图片转为Base64格式，存储在Storage中</strong></p>\n<h4 id=\"base64格式的优势\"><a href=\"#base64格式的优势\" class=\"headerlink\" title=\"base64格式的优势\"></a><strong>base64格式的优势</strong></h4><ol>\n<li>base64格式的图片是文本格式，占用内存小</li>\n<li>使用base64格式的图片，图片会随着html一同下载，不需要建立新的http请求，降低服务器请求压力</li>\n<li>没有跨域问题</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ol>\n<li>无法使用缓存</li>\n<li>css体积增大（css加载会阻塞DOM树渲染，导致页面长时间出现空白屏幕）</li>\n</ol>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a><strong>使用场景</strong></h4><ol>\n<li>对于极小的极简单的图片比如一些小的logo（转换为base64后，不至于产生太大的文本）</li>\n</ol>\n<h4 id=\"CssSprites\"><a href=\"#CssSprites\" class=\"headerlink\" title=\"CssSprites\"></a><strong>CssSprites</strong></h4><ol>\n<li>将多张图合为一张，减少http请求数量</li>\n<li>页面换肤功能</li>\n<li>网站图片改动小，基本不变</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h3><ul>\n<li>2.5.1 数据存取</li>\n</ul>\n<p>☆ 尽量使用局部变量</p>\n<p>☆ 对象成员的嵌套深度与读取时间成正比，嵌套过深要进行优化</p>\n<ul>\n<li>2.5.2 DOM ☆ 尽量减少DOM操作（访问和修改都算）的次数</li>\n</ul>\n<p>☆ 访问元素时使用最快的API</p>\n<p>☆ 使用事件委托来减少事件处理器的数量</p>\n<p>☆ 减少重绘和重排的次数</p>\n<ul>\n<li>2.5.3 算法和流程</li>\n</ul>\n<p>☆ for循环、while循环、do-whild循环比for in 要快 ☆ 优化循环体的复杂度</p>\n<p>☆ 最小化属性查找</p>\n<p>☆ 当条件较少时 使用if-else更易读，而当条件较多时if-else性能负担比switch大，易读性也没switch好。</p>\n<p>☆ 对于if else 概率越大的条件越靠前判断 比如：</p>\n<p>☆ 当计算量很大且重复的时候，用Memoization缓存计算结果</p>\n<ul>\n<li>2.5.5 Ajax</li>\n</ul>\n<p>☆ 服务端设置HTTP头信息确保响应会被浏览器缓存</p>\n<p>☆ 客户端将获取的信息存到本地避免再次请求（localstorage sessionstorage cookice）</p>\n<p>☆ 设置HTTP头信息，expiresgaosu告诉浏览器缓存多久</p>\n<p>☆ 减少HTTP请求，合并css、js、图片资源文件等或使用MXHR</p>\n<p>☆ 通过次要文件用Ajax获取可缩短页面加载时间</p>\n<h4 id=\"js标签的放置位置\"><a href=\"#js标签的放置位置\" class=\"headerlink\" title=\"js标签的放置位置\"></a>js标签的放置位置</h4><p>由于外部引入的js代码，在浏览器加载过程中会出现阻塞的情况，为了避免出现加载时间过长而导致的页面空白，可以考虑将javaScript标签放在body标签中的页面内容之后</p>\n<p>JavaScript是单线程，所以JavaScript的加载和执行是从上至下加载执行完一个再继续加载执行下一个文件，会阻塞页面资源的加载，所以一般情况下JavaScript文件放在body标签内底部，很多后端开发人员放在body标签外下面，这样做不好的地方有两处：1、不规范 2、可能会造成js获取不到页面元素而导致报错。而放在body标签内底部可以确保js执行前页面渲染完成</p>\n<h3 id=\"防抖-debounce\"><a href=\"#防抖-debounce\" class=\"headerlink\" title=\"防抖 (debounce):\"></a>防抖 (debounce):</h3><p>将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</p>\n<pre><code class=\"js\">function debounce(fn, wait) { //防抖函数\n    let timer = null;\n    return function() {\n        let args = arguments;\n        let context = this;\n\n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() =&gt; {\n            fn.apply(context, args)\n        }, wait)\n    }\n}\n</code></pre>\n<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle):\"></a>节流(throttle):</h3><p>每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。</p>\n<pre><code class=\"js\">function throttle(func, delay) { //节流函数，用于高频触发时\n  let timer = null;\n  let startTime = Date.now();\n  return function() {\n    let curTime = Date.now();\n    let remaining = delay - (curTime - startTime);\n    let context = this;\n    let args = arguments;\n    clearTimeout(timer);\n    if( remaining &lt;= 0) {\n      func.apply(context, args);\n      startTime = Date.now();\n    }else {\n      timer = setTimeout(func, remaining);\n    }\n  }\n}\n</code></pre>\n<h3 id=\"函数柯里化：\"><a href=\"#函数柯里化：\" class=\"headerlink\" title=\"函数柯里化：\"></a>函数柯里化：</h3><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</p>\n<pre><code class=\"js\">const add = function add(x) {\n    return function (y) {\n        return x + y\n    }\n}\n\nconst add1 = add(1)\n\nadd1(2) === 3\nadd1(20) === 21\n</code></pre>\n<pre><code class=\"js\">\nfunction sum(a) { \n    return function(b) {\n        return function(c) { \n            return a+b+c; \n        } \n    } \n} \nconsole.log(sum(1)(2)(3)); // 6\n\n// -------------------------------------\n\nfunction _curry(fn, args = []) {\n    return function() {\n        let rest = [...args, ...arguments];\n        if(rest.length &lt; fn.length) {\n            return _curry.call(this,fn,rest)\n        }else {\n            return fn.apply(this,rest);\n        }\n    }\n}\n\nfunction sum(a,b,c) {\n    return a+b+c\n}\nlet sumFn = _curry(sum);\n\nconsole.log(sumFn(1)(2)(3));  // 6\n</code></pre>\n<p><strong>雪碧图，移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析</strong></p>\n<p><strong>将图片转为Base64格式，存储在Storage中</strong></p>\n<h4 id=\"base64格式的优势\"><a href=\"#base64格式的优势\" class=\"headerlink\" title=\"base64格式的优势\"></a><strong>base64格式的优势</strong></h4><ol>\n<li>base64格式的图片是文本格式，占用内存小</li>\n<li>使用base64格式的图片，图片会随着html一同下载，不需要建立新的http请求，降低服务器请求压力</li>\n<li>没有跨域问题</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h4><ol>\n<li>无法使用缓存</li>\n<li>css体积增大（css加载会阻塞DOM树渲染，导致页面长时间出现空白屏幕）</li>\n</ol>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a><strong>使用场景</strong></h4><ol>\n<li>对于极小的极简单的图片比如一些小的logo（转换为base64后，不至于产生太大的文本）</li>\n</ol>\n<h4 id=\"CssSprites\"><a href=\"#CssSprites\" class=\"headerlink\" title=\"CssSprites\"></a><strong>CssSprites</strong></h4><ol>\n<li>将多张图合为一张，减少http请求数量</li>\n<li>页面换肤功能</li>\n<li>网站图片改动小，基本不变</li>\n</ol>\n"},{"title":"开发编码规范","date":"2018-12-09T04:29:47.000Z","_content":"\n### 开发编码规范\n\n1. 标注必要的注释\n\n   js中少用全局变量，加上必要的注释，思维逻辑清晰方便他人维护。\n\n2. 名正言顺\n\n   命名函数、路由或者实体时，要简单明了。\n\n   在编写前端代码时，命名标签id、class时要符合场景不能有歧义，不要写没地方用到的id、class，命名id的时候，一定要先全局搜索这个名字是否已经被使用了。\n\n3. DRY原则\n\n   写方法前，一定要看一下是否已经有类似的方法满足需求了，不要重复编写。\n\n   编写前段代码的时候，要善用bootstrap自带样式，一般的表格、弹出层都已经支持，不需要自己写，不确定的话可以百度下bootstrap官方文档。\n\n4. 去掉没用的\n\n   代码中不要出现长篇的注释代码，不用了就干掉！我保证你以后也不会用！\n\n   方法体内多余的空行删掉\n\n5. 缩减代码长度\n\n   一个方法的长度不要超过一屏，翻滚代码的时候容易出错，从现在开始大家要拒绝意大利面条式代码！\n\n6. 注意代码风格\n\n   JAVA和JS代码提交之前格式化下，不用的话平时自己敲代码注意下格式，如等号两边空一格等，代码尽量不要揉成一块。\n\n   HTML代码不要格式化，一格式化就各种换行，同一个标签里有两个及以上子标签则换行便于查看。因为IDEA对HTML代码的格式化做的不是很好，很多模板引擎的写法不兼容。\n\n7. 代码的自我审查\n\n   使用command+K提交代码，在提交代码之前必须diff所有的文件，不管有多少，这样可以避免将不必要的代码和文件上传到git上影响他人工作，如果不需要提交的代码建议加入IDEA其他的change list里面。\n\n8. 注意文件缓存\n\n   修改js和css后必须改html或者config文件中的版本号，例如：2015123v1，不然js可能未及时生效需要强刷页面。\n\n9. 路由命名规范\n\n   比如客户管理，新建了个CustomerController，mapping是customer，那么资讯分类的路由应该是news/detail，而不是customer/customerDetail 添加编辑页面路由统一命名：addPage，如customer/addPage，后面跟参数区分是添加还是编辑，以便在面包屑上显示不同文案 列表页路由统一命名：listPage，如customer/listPage 取列表页数据路由统一命名：list，如customer/list 保存接口统一命名：save，如customer/save 获取详情统一命名：detail，如customer/detail 下拉列表数据接口统一命名：listForSelect，如customer/listForSelect 删除数据接口统一命名：delete，如customer/delete\n\n10. 文件名命名规范\n\n    添加/编辑页面统一命名：addXXPage.ftl，如addCustomerPage.ftl 列表页面统一命名：XXListPage.ftl，如customerListPage.ftl underscore模板统一命名：xx_list.html，如customer_list.html js统一命名：与相应ftl页面命名一致，去掉Page后缀即可，如addNews.js，newsList.js","source":"_posts/开发编码规范.md","raw":"---\ntitle: 开发编码规范\ndate: 2018-12-09 12:29:47\ntags: 规范\ncategories: 前端\n---\n\n### 开发编码规范\n\n1. 标注必要的注释\n\n   js中少用全局变量，加上必要的注释，思维逻辑清晰方便他人维护。\n\n2. 名正言顺\n\n   命名函数、路由或者实体时，要简单明了。\n\n   在编写前端代码时，命名标签id、class时要符合场景不能有歧义，不要写没地方用到的id、class，命名id的时候，一定要先全局搜索这个名字是否已经被使用了。\n\n3. DRY原则\n\n   写方法前，一定要看一下是否已经有类似的方法满足需求了，不要重复编写。\n\n   编写前段代码的时候，要善用bootstrap自带样式，一般的表格、弹出层都已经支持，不需要自己写，不确定的话可以百度下bootstrap官方文档。\n\n4. 去掉没用的\n\n   代码中不要出现长篇的注释代码，不用了就干掉！我保证你以后也不会用！\n\n   方法体内多余的空行删掉\n\n5. 缩减代码长度\n\n   一个方法的长度不要超过一屏，翻滚代码的时候容易出错，从现在开始大家要拒绝意大利面条式代码！\n\n6. 注意代码风格\n\n   JAVA和JS代码提交之前格式化下，不用的话平时自己敲代码注意下格式，如等号两边空一格等，代码尽量不要揉成一块。\n\n   HTML代码不要格式化，一格式化就各种换行，同一个标签里有两个及以上子标签则换行便于查看。因为IDEA对HTML代码的格式化做的不是很好，很多模板引擎的写法不兼容。\n\n7. 代码的自我审查\n\n   使用command+K提交代码，在提交代码之前必须diff所有的文件，不管有多少，这样可以避免将不必要的代码和文件上传到git上影响他人工作，如果不需要提交的代码建议加入IDEA其他的change list里面。\n\n8. 注意文件缓存\n\n   修改js和css后必须改html或者config文件中的版本号，例如：2015123v1，不然js可能未及时生效需要强刷页面。\n\n9. 路由命名规范\n\n   比如客户管理，新建了个CustomerController，mapping是customer，那么资讯分类的路由应该是news/detail，而不是customer/customerDetail 添加编辑页面路由统一命名：addPage，如customer/addPage，后面跟参数区分是添加还是编辑，以便在面包屑上显示不同文案 列表页路由统一命名：listPage，如customer/listPage 取列表页数据路由统一命名：list，如customer/list 保存接口统一命名：save，如customer/save 获取详情统一命名：detail，如customer/detail 下拉列表数据接口统一命名：listForSelect，如customer/listForSelect 删除数据接口统一命名：delete，如customer/delete\n\n10. 文件名命名规范\n\n    添加/编辑页面统一命名：addXXPage.ftl，如addCustomerPage.ftl 列表页面统一命名：XXListPage.ftl，如customerListPage.ftl underscore模板统一命名：xx_list.html，如customer_list.html js统一命名：与相应ftl页面命名一致，去掉Page后缀即可，如addNews.js，newsList.js","slug":"开发编码规范","published":1,"updated":"2024-02-19T07:42:51.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri8005z1xop4h2s34gb","content":"<h3 id=\"开发编码规范\"><a href=\"#开发编码规范\" class=\"headerlink\" title=\"开发编码规范\"></a>开发编码规范</h3><ol>\n<li><p>标注必要的注释</p>\n<p>js中少用全局变量，加上必要的注释，思维逻辑清晰方便他人维护。</p>\n</li>\n<li><p>名正言顺</p>\n<p>命名函数、路由或者实体时，要简单明了。</p>\n<p>在编写前端代码时，命名标签id、class时要符合场景不能有歧义，不要写没地方用到的id、class，命名id的时候，一定要先全局搜索这个名字是否已经被使用了。</p>\n</li>\n<li><p>DRY原则</p>\n<p>写方法前，一定要看一下是否已经有类似的方法满足需求了，不要重复编写。</p>\n<p>编写前段代码的时候，要善用bootstrap自带样式，一般的表格、弹出层都已经支持，不需要自己写，不确定的话可以百度下bootstrap官方文档。</p>\n</li>\n<li><p>去掉没用的</p>\n<p>代码中不要出现长篇的注释代码，不用了就干掉！我保证你以后也不会用！</p>\n<p>方法体内多余的空行删掉</p>\n</li>\n<li><p>缩减代码长度</p>\n<p>一个方法的长度不要超过一屏，翻滚代码的时候容易出错，从现在开始大家要拒绝意大利面条式代码！</p>\n</li>\n<li><p>注意代码风格</p>\n<p>JAVA和JS代码提交之前格式化下，不用的话平时自己敲代码注意下格式，如等号两边空一格等，代码尽量不要揉成一块。</p>\n<p>HTML代码不要格式化，一格式化就各种换行，同一个标签里有两个及以上子标签则换行便于查看。因为IDEA对HTML代码的格式化做的不是很好，很多模板引擎的写法不兼容。</p>\n</li>\n<li><p>代码的自我审查</p>\n<p>使用command+K提交代码，在提交代码之前必须diff所有的文件，不管有多少，这样可以避免将不必要的代码和文件上传到git上影响他人工作，如果不需要提交的代码建议加入IDEA其他的change list里面。</p>\n</li>\n<li><p>注意文件缓存</p>\n<p>修改js和css后必须改html或者config文件中的版本号，例如：2015123v1，不然js可能未及时生效需要强刷页面。</p>\n</li>\n<li><p>路由命名规范</p>\n<p>比如客户管理，新建了个CustomerController，mapping是customer，那么资讯分类的路由应该是news/detail，而不是customer/customerDetail 添加编辑页面路由统一命名：addPage，如customer/addPage，后面跟参数区分是添加还是编辑，以便在面包屑上显示不同文案 列表页路由统一命名：listPage，如customer/listPage 取列表页数据路由统一命名：list，如customer/list 保存接口统一命名：save，如customer/save 获取详情统一命名：detail，如customer/detail 下拉列表数据接口统一命名：listForSelect，如customer/listForSelect 删除数据接口统一命名：delete，如customer/delete</p>\n</li>\n<li><p>文件名命名规范</p>\n<p>添加/编辑页面统一命名：addXXPage.ftl，如addCustomerPage.ftl 列表页面统一命名：XXListPage.ftl，如customerListPage.ftl underscore模板统一命名：xx_list.html，如customer_list.html js统一命名：与相应ftl页面命名一致，去掉Page后缀即可，如addNews.js，newsList.js</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"开发编码规范\"><a href=\"#开发编码规范\" class=\"headerlink\" title=\"开发编码规范\"></a>开发编码规范</h3><ol>\n<li><p>标注必要的注释</p>\n<p>js中少用全局变量，加上必要的注释，思维逻辑清晰方便他人维护。</p>\n</li>\n<li><p>名正言顺</p>\n<p>命名函数、路由或者实体时，要简单明了。</p>\n<p>在编写前端代码时，命名标签id、class时要符合场景不能有歧义，不要写没地方用到的id、class，命名id的时候，一定要先全局搜索这个名字是否已经被使用了。</p>\n</li>\n<li><p>DRY原则</p>\n<p>写方法前，一定要看一下是否已经有类似的方法满足需求了，不要重复编写。</p>\n<p>编写前段代码的时候，要善用bootstrap自带样式，一般的表格、弹出层都已经支持，不需要自己写，不确定的话可以百度下bootstrap官方文档。</p>\n</li>\n<li><p>去掉没用的</p>\n<p>代码中不要出现长篇的注释代码，不用了就干掉！我保证你以后也不会用！</p>\n<p>方法体内多余的空行删掉</p>\n</li>\n<li><p>缩减代码长度</p>\n<p>一个方法的长度不要超过一屏，翻滚代码的时候容易出错，从现在开始大家要拒绝意大利面条式代码！</p>\n</li>\n<li><p>注意代码风格</p>\n<p>JAVA和JS代码提交之前格式化下，不用的话平时自己敲代码注意下格式，如等号两边空一格等，代码尽量不要揉成一块。</p>\n<p>HTML代码不要格式化，一格式化就各种换行，同一个标签里有两个及以上子标签则换行便于查看。因为IDEA对HTML代码的格式化做的不是很好，很多模板引擎的写法不兼容。</p>\n</li>\n<li><p>代码的自我审查</p>\n<p>使用command+K提交代码，在提交代码之前必须diff所有的文件，不管有多少，这样可以避免将不必要的代码和文件上传到git上影响他人工作，如果不需要提交的代码建议加入IDEA其他的change list里面。</p>\n</li>\n<li><p>注意文件缓存</p>\n<p>修改js和css后必须改html或者config文件中的版本号，例如：2015123v1，不然js可能未及时生效需要强刷页面。</p>\n</li>\n<li><p>路由命名规范</p>\n<p>比如客户管理，新建了个CustomerController，mapping是customer，那么资讯分类的路由应该是news/detail，而不是customer/customerDetail 添加编辑页面路由统一命名：addPage，如customer/addPage，后面跟参数区分是添加还是编辑，以便在面包屑上显示不同文案 列表页路由统一命名：listPage，如customer/listPage 取列表页数据路由统一命名：list，如customer/list 保存接口统一命名：save，如customer/save 获取详情统一命名：detail，如customer/detail 下拉列表数据接口统一命名：listForSelect，如customer/listForSelect 删除数据接口统一命名：delete，如customer/delete</p>\n</li>\n<li><p>文件名命名规范</p>\n<p>添加/编辑页面统一命名：addXXPage.ftl，如addCustomerPage.ftl 列表页面统一命名：XXListPage.ftl，如customerListPage.ftl underscore模板统一命名：xx_list.html，如customer_list.html js统一命名：与相应ftl页面命名一致，去掉Page后缀即可，如addNews.js，newsList.js</p>\n</li>\n</ol>\n"},{"title":"常见的几种布局","date":"2018-10-10T09:04:18.000Z","_content":"\n### 几种常见的布局方式\n\n1. ##### 固定布局（静态布局）\n\n   特点：采用px作为单位，固定宽高大小。\n\n   适用于设备较少的页面设计，当页面内容显示不全时，会采用滚动条的方式显示。\n\n   如果需要在移动设备上显示，一般需要设计两套页面，一个适配PC端，一个用来在移动端使用显示。\n\n   移动端开发：\n\n   1. 需要设置在viewport meta标签上设置相关属性，例如：width=320，页面的各个元素采用px作为大小单位，通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。\n\n   2. 在viewport meta标签上content\"width=640,user-scalable=no\"。\n\n      [参考]: https://www.zhihu.com/question/32090605\n\n2. ##### 流式布局\n\n   1. 特点：页面元素宽度按照屏幕分辨率进行适配调整，但整体布局不变。（例如：栅格系统）。\n\n   2. 设计方法：使用%百分比定义宽度，高度大都使用px固定，配合max-width、min-width使用，避免出现类似图片被拉伸过度而失真的情况，尽可能适应各种分辨率。\n\n      无法满足设备跨度太大的情况，在这种情况下，往往会出现元素被拉伸导致页面看起来不合理。（因为高度、文字大小始终是固定的）\n\n3. ##### 弹性布局\n\n   1. 特点：页面采用em、rem作为单位，对于这两个单位不了解的可以去看\n\n      [参考]: https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/\n\n   2. 设计方法：包裹文字的各个元素采用em、rem作为单位，而页面整体的划分区域的地方仍然采用百分比或px作为单位。**早期浏览器不支持整个页面按比例缩放**，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。\n\n4. ##### 自适应布局\n\n   1. 特点：分别为不同屏幕设置布局格式，随着屏幕大小而改变布局格式，可以看成是由多个静态布局组成。\n   2. 设计方法：采用@media媒体查询给不同尺寸的设备进行切换。\n\n5. ##### 响应式布局\n\n   1. 特点：流式布局和自适应布局相结合，配合媒体查询，实现不同设备，元素的大小位置均发生改变。\n\n   2. 设计方法：媒体查询+自适应布局+流式布局。结合多种技术，实现页面适配多种设备。\n\n   3. 优点：能够适配PC、移动端。\n\n      设置meta标签：\n\n      ```html\n      <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\" />\n      ```\n\n\n","source":"_posts/常见的几种布局.md","raw":"---\ntitle: 常见的几种布局\ndate: 2018-10-10 17:04:18\ntags: 常见布局\ncategories: 前端\n---\n\n### 几种常见的布局方式\n\n1. ##### 固定布局（静态布局）\n\n   特点：采用px作为单位，固定宽高大小。\n\n   适用于设备较少的页面设计，当页面内容显示不全时，会采用滚动条的方式显示。\n\n   如果需要在移动设备上显示，一般需要设计两套页面，一个适配PC端，一个用来在移动端使用显示。\n\n   移动端开发：\n\n   1. 需要设置在viewport meta标签上设置相关属性，例如：width=320，页面的各个元素采用px作为大小单位，通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。\n\n   2. 在viewport meta标签上content\"width=640,user-scalable=no\"。\n\n      [参考]: https://www.zhihu.com/question/32090605\n\n2. ##### 流式布局\n\n   1. 特点：页面元素宽度按照屏幕分辨率进行适配调整，但整体布局不变。（例如：栅格系统）。\n\n   2. 设计方法：使用%百分比定义宽度，高度大都使用px固定，配合max-width、min-width使用，避免出现类似图片被拉伸过度而失真的情况，尽可能适应各种分辨率。\n\n      无法满足设备跨度太大的情况，在这种情况下，往往会出现元素被拉伸导致页面看起来不合理。（因为高度、文字大小始终是固定的）\n\n3. ##### 弹性布局\n\n   1. 特点：页面采用em、rem作为单位，对于这两个单位不了解的可以去看\n\n      [参考]: https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/\n\n   2. 设计方法：包裹文字的各个元素采用em、rem作为单位，而页面整体的划分区域的地方仍然采用百分比或px作为单位。**早期浏览器不支持整个页面按比例缩放**，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。\n\n4. ##### 自适应布局\n\n   1. 特点：分别为不同屏幕设置布局格式，随着屏幕大小而改变布局格式，可以看成是由多个静态布局组成。\n   2. 设计方法：采用@media媒体查询给不同尺寸的设备进行切换。\n\n5. ##### 响应式布局\n\n   1. 特点：流式布局和自适应布局相结合，配合媒体查询，实现不同设备，元素的大小位置均发生改变。\n\n   2. 设计方法：媒体查询+自适应布局+流式布局。结合多种技术，实现页面适配多种设备。\n\n   3. 优点：能够适配PC、移动端。\n\n      设置meta标签：\n\n      ```html\n      <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no\" />\n      ```\n\n\n","slug":"常见的几种布局","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdri900631xopcrtufom0","content":"<h3 id=\"几种常见的布局方式\"><a href=\"#几种常见的布局方式\" class=\"headerlink\" title=\"几种常见的布局方式\"></a>几种常见的布局方式</h3><ol>\n<li><h5 id=\"固定布局（静态布局）\"><a href=\"#固定布局（静态布局）\" class=\"headerlink\" title=\"固定布局（静态布局）\"></a>固定布局（静态布局）</h5><p>特点：采用px作为单位，固定宽高大小。</p>\n<p>适用于设备较少的页面设计，当页面内容显示不全时，会采用滚动条的方式显示。</p>\n<p>如果需要在移动设备上显示，一般需要设计两套页面，一个适配PC端，一个用来在移动端使用显示。</p>\n<p>移动端开发：</p>\n<ol>\n<li><p>需要设置在viewport meta标签上设置相关属性，例如：width=320，页面的各个元素采用px作为大小单位，通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。</p>\n</li>\n<li><p>在viewport meta标签上content”width=640,user-scalable=no”。</p>\n</li>\n</ol>\n<p>   [参考]: <a href=\"https://www.zhihu.com/question/32090605\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/32090605</a></p>\n</li>\n<li><h5 id=\"流式布局\"><a href=\"#流式布局\" class=\"headerlink\" title=\"流式布局\"></a>流式布局</h5><ol>\n<li><p>特点：页面元素宽度按照屏幕分辨率进行适配调整，但整体布局不变。（例如：栅格系统）。</p>\n</li>\n<li><p>设计方法：使用%百分比定义宽度，高度大都使用px固定，配合max-width、min-width使用，避免出现类似图片被拉伸过度而失真的情况，尽可能适应各种分辨率。</p>\n<p>无法满足设备跨度太大的情况，在这种情况下，往往会出现元素被拉伸导致页面看起来不合理。（因为高度、文字大小始终是固定的）</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h5><ol>\n<li>特点：页面采用em、rem作为单位，对于这两个单位不了解的可以去看</li>\n</ol>\n<p>   [参考]: <a href=\"https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/\" target=\"_blank\" rel=\"noopener\">https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/</a></p>\n<ol start=\"2\">\n<li>设计方法：包裹文字的各个元素采用em、rem作为单位，而页面整体的划分区域的地方仍然采用百分比或px作为单位。<strong>早期浏览器不支持整个页面按比例缩放</strong>，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。</li>\n</ol>\n</li>\n<li><h5 id=\"自适应布局\"><a href=\"#自适应布局\" class=\"headerlink\" title=\"自适应布局\"></a>自适应布局</h5><ol>\n<li>特点：分别为不同屏幕设置布局格式，随着屏幕大小而改变布局格式，可以看成是由多个静态布局组成。</li>\n<li>设计方法：采用@media媒体查询给不同尺寸的设备进行切换。</li>\n</ol>\n</li>\n<li><h5 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h5><ol>\n<li><p>特点：流式布局和自适应布局相结合，配合媒体查询，实现不同设备，元素的大小位置均发生改变。</p>\n</li>\n<li><p>设计方法：媒体查询+自适应布局+流式布局。结合多种技术，实现页面适配多种设备。</p>\n</li>\n<li><p>优点：能够适配PC、移动端。</p>\n<p>设置meta标签：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>viewport<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>width<span class=\"token punctuation\">=</span>device-width,initial-scale<span class=\"token punctuation\">=</span>1.0,maximum-scale<span class=\"token punctuation\">=</span>1.0,minimum-scale<span class=\"token punctuation\">=</span>1.0,user-scalable<span class=\"token punctuation\">=</span>no<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"几种常见的布局方式\"><a href=\"#几种常见的布局方式\" class=\"headerlink\" title=\"几种常见的布局方式\"></a>几种常见的布局方式</h3><ol>\n<li><h5 id=\"固定布局（静态布局）\"><a href=\"#固定布局（静态布局）\" class=\"headerlink\" title=\"固定布局（静态布局）\"></a>固定布局（静态布局）</h5><p>特点：采用px作为单位，固定宽高大小。</p>\n<p>适用于设备较少的页面设计，当页面内容显示不全时，会采用滚动条的方式显示。</p>\n<p>如果需要在移动设备上显示，一般需要设计两套页面，一个适配PC端，一个用来在移动端使用显示。</p>\n<p>移动端开发：</p>\n<ol>\n<li><p>需要设置在viewport meta标签上设置相关属性，例如：width=320，页面的各个元素采用px作为大小单位，通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。</p>\n</li>\n<li><p>在viewport meta标签上content”width=640,user-scalable=no”。</p>\n</li>\n</ol>\n<p>   [参考]: <a href=\"https://www.zhihu.com/question/32090605\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/32090605</a></p>\n</li>\n<li><h5 id=\"流式布局\"><a href=\"#流式布局\" class=\"headerlink\" title=\"流式布局\"></a>流式布局</h5><ol>\n<li><p>特点：页面元素宽度按照屏幕分辨率进行适配调整，但整体布局不变。（例如：栅格系统）。</p>\n</li>\n<li><p>设计方法：使用%百分比定义宽度，高度大都使用px固定，配合max-width、min-width使用，避免出现类似图片被拉伸过度而失真的情况，尽可能适应各种分辨率。</p>\n<p>无法满足设备跨度太大的情况，在这种情况下，往往会出现元素被拉伸导致页面看起来不合理。（因为高度、文字大小始终是固定的）</p>\n</li>\n</ol>\n</li>\n<li><h5 id=\"弹性布局\"><a href=\"#弹性布局\" class=\"headerlink\" title=\"弹性布局\"></a>弹性布局</h5><ol>\n<li>特点：页面采用em、rem作为单位，对于这两个单位不了解的可以去看</li>\n</ol>\n<p>   [参考]: <a href=\"https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/\" target=\"_blank\" rel=\"noopener\">https://yymfp.github.io/2018/09/27/px%E3%80%81em%E3%80%81rem%E5%8C%BA%E5%88%AB/</a></p>\n<ol start=\"2\">\n<li>设计方法：包裹文字的各个元素采用em、rem作为单位，而页面整体的划分区域的地方仍然采用百分比或px作为单位。<strong>早期浏览器不支持整个页面按比例缩放</strong>，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。</li>\n</ol>\n</li>\n<li><h5 id=\"自适应布局\"><a href=\"#自适应布局\" class=\"headerlink\" title=\"自适应布局\"></a>自适应布局</h5><ol>\n<li>特点：分别为不同屏幕设置布局格式，随着屏幕大小而改变布局格式，可以看成是由多个静态布局组成。</li>\n<li>设计方法：采用@media媒体查询给不同尺寸的设备进行切换。</li>\n</ol>\n</li>\n<li><h5 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h5><ol>\n<li><p>特点：流式布局和自适应布局相结合，配合媒体查询，实现不同设备，元素的大小位置均发生改变。</p>\n</li>\n<li><p>设计方法：媒体查询+自适应布局+流式布局。结合多种技术，实现页面适配多种设备。</p>\n</li>\n<li><p>优点：能够适配PC、移动端。</p>\n<p>设置meta标签：</p>\n<pre><code class=\"html\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"数据结构","date":"2019-03-10T14:26:14.000Z","_content":"\n### 数据结构\n\n1. ##### 数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\n\n   特点：\n\n   - 线性表：每个线性表上的数据最多只有前和后两个方向。\n   - 连续的内存空间和相同类型的数据。\n\n   ##### 数组和链表的区别：\n\n   ​\t数组适合查找，支持随机访问，根据下标随机访问的时间复杂度为O(1)。链表适合插入、删除，时间复杂度O(1)。\n\n   ##### 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?\n\n   从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式:\n\n   ```\n   a[k]_address = base_address + k * type_size\n   ```\n\n   但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为:\n\n   ```\n   a[k]_address = base_address + (k-1)*type_size\n   ```\n\n   对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。\n\n   数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优 化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开 始。\n\n2. ##### 链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过\"指针\"将一组零散的内存块串联起来。\n\n   - 单链表：\n\n     1. 单链表为了将所有的节点串起来，每个链表的节点出了存储数据之外，还需要记录链上的下一个节点地址，叫做后继指针next。\n\n     2. 有两个特殊的节点，第一个节点和最后一个节点，分别叫做头结点和尾节点。头结点作为记录链表的基地址，可以用来遍历得到整条链表。尾节点不是指向下一个节点，而是指向一个空地址null，代表这是链表的最后一个节点。\n\n        > 链表特点：\n        >\n        > 1. 相比于数组，链表再插入和删除操作时，并不需要保持内存的连续性而搬移节点，因为链表的存储空间本身就是不连续的，只需要考虑相邻接点的指针改变。\n        > 2. 但是链表想要去访问第k个元素，就没有数组方便，无法利用数组中通过寻址公式直接计算，因为内存是不连续的，需要从头开始依次遍历。\n\n   - 双向链表：双向链表出了有指向下一个结点的next指针外，还有一个前驱指针prev指向前面的结点。\n\n     特点：\n\n     1. 相对于单链表，存储同样多的数据，需要占用更多的内存空间。\n     2. 支持双向遍历，更加灵活。\n\n   - 循环链表：循环链表的尾结点指针指向链表的头结点。\n\n     ​\t优点：从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表。\n\n3. ##### 栈：\n\n4. ##### 队列：\n\n5. ##### 散列表：\n\n6. ##### 二叉树：\n\n7. ##### 堆：\n\n8. ##### 跳表：\n\n9. ##### 图：\n\n10. ##### Trie树：","source":"_posts/数据结构.md","raw":"---\ntitle: 数据结构\ndate: 2019-03-10 22:26:14\ntags: 数据结构\ncategories: 数据结构\n---\n\n### 数据结构\n\n1. ##### 数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\n\n   特点：\n\n   - 线性表：每个线性表上的数据最多只有前和后两个方向。\n   - 连续的内存空间和相同类型的数据。\n\n   ##### 数组和链表的区别：\n\n   ​\t数组适合查找，支持随机访问，根据下标随机访问的时间复杂度为O(1)。链表适合插入、删除，时间复杂度O(1)。\n\n   ##### 为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?\n\n   从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式:\n\n   ```\n   a[k]_address = base_address + k * type_size\n   ```\n\n   但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为:\n\n   ```\n   a[k]_address = base_address + (k-1)*type_size\n   ```\n\n   对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。\n\n   数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优 化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开 始。\n\n2. ##### 链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过\"指针\"将一组零散的内存块串联起来。\n\n   - 单链表：\n\n     1. 单链表为了将所有的节点串起来，每个链表的节点出了存储数据之外，还需要记录链上的下一个节点地址，叫做后继指针next。\n\n     2. 有两个特殊的节点，第一个节点和最后一个节点，分别叫做头结点和尾节点。头结点作为记录链表的基地址，可以用来遍历得到整条链表。尾节点不是指向下一个节点，而是指向一个空地址null，代表这是链表的最后一个节点。\n\n        > 链表特点：\n        >\n        > 1. 相比于数组，链表再插入和删除操作时，并不需要保持内存的连续性而搬移节点，因为链表的存储空间本身就是不连续的，只需要考虑相邻接点的指针改变。\n        > 2. 但是链表想要去访问第k个元素，就没有数组方便，无法利用数组中通过寻址公式直接计算，因为内存是不连续的，需要从头开始依次遍历。\n\n   - 双向链表：双向链表出了有指向下一个结点的next指针外，还有一个前驱指针prev指向前面的结点。\n\n     特点：\n\n     1. 相对于单链表，存储同样多的数据，需要占用更多的内存空间。\n     2. 支持双向遍历，更加灵活。\n\n   - 循环链表：循环链表的尾结点指针指向链表的头结点。\n\n     ​\t优点：从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表。\n\n3. ##### 栈：\n\n4. ##### 队列：\n\n5. ##### 散列表：\n\n6. ##### 二叉树：\n\n7. ##### 堆：\n\n8. ##### 跳表：\n\n9. ##### 图：\n\n10. ##### Trie树：","slug":"数据结构","published":1,"updated":"2024-02-19T07:42:51.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdria00661xop6tmldad1","content":"<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ol>\n<li><h5 id=\"数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\"><a href=\"#数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\" class=\"headerlink\" title=\"数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\"></a>数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。</h5><p>特点：</p>\n<ul>\n<li>线性表：每个线性表上的数据最多只有前和后两个方向。</li>\n<li>连续的内存空间和相同类型的数据。</li>\n</ul>\n<h5 id=\"数组和链表的区别：\"><a href=\"#数组和链表的区别：\" class=\"headerlink\" title=\"数组和链表的区别：\"></a>数组和链表的区别：</h5><p>​    数组适合查找，支持随机访问，根据下标随机访问的时间复杂度为O(1)。链表适合插入、删除，时间复杂度O(1)。</p>\n<h5 id=\"为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始-呢\"><a href=\"#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始-呢\" class=\"headerlink\" title=\"为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?\"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?</h5><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式:</p>\n<pre><code>a[k]_address = base_address + k * type_size\n</code></pre><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为:</p>\n<pre><code>a[k]_address = base_address + (k-1)*type_size\n</code></pre><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>\n<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优 化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开 始。</p>\n</li>\n<li><h5 id=\"链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\"><a href=\"#链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\" class=\"headerlink\" title=\"链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\"></a>链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。</h5><ul>\n<li><p>单链表：</p>\n<ol>\n<li><p>单链表为了将所有的节点串起来，每个链表的节点出了存储数据之外，还需要记录链上的下一个节点地址，叫做后继指针next。</p>\n</li>\n<li><p>有两个特殊的节点，第一个节点和最后一个节点，分别叫做头结点和尾节点。头结点作为记录链表的基地址，可以用来遍历得到整条链表。尾节点不是指向下一个节点，而是指向一个空地址null，代表这是链表的最后一个节点。</p>\n<blockquote>\n<p>链表特点：</p>\n<ol>\n<li>相比于数组，链表再插入和删除操作时，并不需要保持内存的连续性而搬移节点，因为链表的存储空间本身就是不连续的，只需要考虑相邻接点的指针改变。</li>\n<li>但是链表想要去访问第k个元素，就没有数组方便，无法利用数组中通过寻址公式直接计算，因为内存是不连续的，需要从头开始依次遍历。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>双向链表：双向链表出了有指向下一个结点的next指针外，还有一个前驱指针prev指向前面的结点。</p>\n<p>特点：</p>\n<ol>\n<li>相对于单链表，存储同样多的数据，需要占用更多的内存空间。</li>\n<li>支持双向遍历，更加灵活。</li>\n</ol>\n</li>\n<li><p>循环链表：循环链表的尾结点指针指向链表的头结点。</p>\n<p>​    优点：从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"栈：\"><a href=\"#栈：\" class=\"headerlink\" title=\"栈：\"></a>栈：</h5></li>\n<li><h5 id=\"队列：\"><a href=\"#队列：\" class=\"headerlink\" title=\"队列：\"></a>队列：</h5></li>\n<li><h5 id=\"散列表：\"><a href=\"#散列表：\" class=\"headerlink\" title=\"散列表：\"></a>散列表：</h5></li>\n<li><h5 id=\"二叉树：\"><a href=\"#二叉树：\" class=\"headerlink\" title=\"二叉树：\"></a>二叉树：</h5></li>\n<li><h5 id=\"堆：\"><a href=\"#堆：\" class=\"headerlink\" title=\"堆：\"></a>堆：</h5></li>\n<li><h5 id=\"跳表：\"><a href=\"#跳表：\" class=\"headerlink\" title=\"跳表：\"></a>跳表：</h5></li>\n<li><h5 id=\"图：\"><a href=\"#图：\" class=\"headerlink\" title=\"图：\"></a>图：</h5></li>\n<li><h5 id=\"Trie树：\"><a href=\"#Trie树：\" class=\"headerlink\" title=\"Trie树：\"></a>Trie树：</h5></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ol>\n<li><h5 id=\"数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\"><a href=\"#数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\" class=\"headerlink\" title=\"数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。\"></a>数组：数组是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。</h5><p>特点：</p>\n<ul>\n<li>线性表：每个线性表上的数据最多只有前和后两个方向。</li>\n<li>连续的内存空间和相同类型的数据。</li>\n</ul>\n<h5 id=\"数组和链表的区别：\"><a href=\"#数组和链表的区别：\" class=\"headerlink\" title=\"数组和链表的区别：\"></a>数组和链表的区别：</h5><p>​    数组适合查找，支持随机访问，根据下标随机访问的时间复杂度为O(1)。链表适合插入、删除，时间复杂度O(1)。</p>\n<h5 id=\"为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始-呢\"><a href=\"#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始-呢\" class=\"headerlink\" title=\"为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?\"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始 呢?</h5><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移(offset)”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式:</p>\n<pre><code>a[k]_address = base_address + k * type_size\n</code></pre><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为:</p>\n<pre><code>a[k]_address = base_address + (k-1)*type_size\n</code></pre><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>\n<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优 化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开 始。</p>\n</li>\n<li><h5 id=\"链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\"><a href=\"#链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\" class=\"headerlink\" title=\"链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。\"></a>链表：是一种物理存储单元上的非连续、非顺序的存储结构，通过”指针”将一组零散的内存块串联起来。</h5><ul>\n<li><p>单链表：</p>\n<ol>\n<li><p>单链表为了将所有的节点串起来，每个链表的节点出了存储数据之外，还需要记录链上的下一个节点地址，叫做后继指针next。</p>\n</li>\n<li><p>有两个特殊的节点，第一个节点和最后一个节点，分别叫做头结点和尾节点。头结点作为记录链表的基地址，可以用来遍历得到整条链表。尾节点不是指向下一个节点，而是指向一个空地址null，代表这是链表的最后一个节点。</p>\n<blockquote>\n<p>链表特点：</p>\n<ol>\n<li>相比于数组，链表再插入和删除操作时，并不需要保持内存的连续性而搬移节点，因为链表的存储空间本身就是不连续的，只需要考虑相邻接点的指针改变。</li>\n<li>但是链表想要去访问第k个元素，就没有数组方便，无法利用数组中通过寻址公式直接计算，因为内存是不连续的，需要从头开始依次遍历。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>双向链表：双向链表出了有指向下一个结点的next指针外，还有一个前驱指针prev指向前面的结点。</p>\n<p>特点：</p>\n<ol>\n<li>相对于单链表，存储同样多的数据，需要占用更多的内存空间。</li>\n<li>支持双向遍历，更加灵活。</li>\n</ol>\n</li>\n<li><p>循环链表：循环链表的尾结点指针指向链表的头结点。</p>\n<p>​    优点：从链尾到链头比较方便，当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p>\n</li>\n</ul>\n</li>\n<li><h5 id=\"栈：\"><a href=\"#栈：\" class=\"headerlink\" title=\"栈：\"></a>栈：</h5></li>\n<li><h5 id=\"队列：\"><a href=\"#队列：\" class=\"headerlink\" title=\"队列：\"></a>队列：</h5></li>\n<li><h5 id=\"散列表：\"><a href=\"#散列表：\" class=\"headerlink\" title=\"散列表：\"></a>散列表：</h5></li>\n<li><h5 id=\"二叉树：\"><a href=\"#二叉树：\" class=\"headerlink\" title=\"二叉树：\"></a>二叉树：</h5></li>\n<li><h5 id=\"堆：\"><a href=\"#堆：\" class=\"headerlink\" title=\"堆：\"></a>堆：</h5></li>\n<li><h5 id=\"跳表：\"><a href=\"#跳表：\" class=\"headerlink\" title=\"跳表：\"></a>跳表：</h5></li>\n<li><h5 id=\"图：\"><a href=\"#图：\" class=\"headerlink\" title=\"图：\"></a>图：</h5></li>\n<li><h5 id=\"Trie树：\"><a href=\"#Trie树：\" class=\"headerlink\" title=\"Trie树：\"></a>Trie树：</h5></li>\n</ol>\n"},{"title":"发布订阅模式","date":"2020-08-11T01:58:03.000Z","_content":"\n### **发布订阅模式**\n\n\n\n- **订阅者**\n\n- **发布者**\n\n- **信号中心**\n\n  > 我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。\n\n\n\n```js\n// 发布订阅\nclass EventEmitter {\n\tconstructor() {\n\t\tthis.subs = Object.create(null)\n\t}\n\n\t// 订阅事件\n\t$on(eventType, callback) {\n\t\tthis.subs[eventType] = this.subs[eventType] || []\n\t\tthis.subs[eventType].push(callback)\n\t}\n\t// 发布\n\t$emit(eventType) {\n\t\tif (this.subs[eventType]) {\n\t\t\tthis.subs[eventType].forEach(fn => fn())\n\t\t}\n\t}\n}\n```\n\n","source":"_posts/发布订阅模式.md","raw":"---\ntitle: 发布订阅模式\ndate: 2020-08-11 09:58:03\ntags: 设计模式\ncategories: 前端\n---\n\n### **发布订阅模式**\n\n\n\n- **订阅者**\n\n- **发布者**\n\n- **信号中心**\n\n  > 我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。\n\n\n\n```js\n// 发布订阅\nclass EventEmitter {\n\tconstructor() {\n\t\tthis.subs = Object.create(null)\n\t}\n\n\t// 订阅事件\n\t$on(eventType, callback) {\n\t\tthis.subs[eventType] = this.subs[eventType] || []\n\t\tthis.subs[eventType].push(callback)\n\t}\n\t// 发布\n\t$emit(eventType) {\n\t\tif (this.subs[eventType]) {\n\t\t\tthis.subs[eventType].forEach(fn => fn())\n\t\t}\n\t}\n}\n```\n\n","slug":"发布订阅模式","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrib00691xop6lh64dt8","content":"<h3 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a><strong>发布订阅模式</strong></h3><ul>\n<li><p><strong>订阅者</strong></p>\n</li>\n<li><p><strong>发布者</strong></p>\n</li>\n<li><p><strong>信号中心</strong></p>\n<blockquote>\n<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。</p>\n</blockquote>\n</li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 发布订阅</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">EventEmitter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 订阅事件</span>\n    <span class=\"token function\">$on</span><span class=\"token punctuation\">(</span>eventType<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">[</span>eventType<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">[</span>eventType<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">[</span>eventType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 发布</span>\n    <span class=\"token function\">$emit</span><span class=\"token punctuation\">(</span>eventType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">[</span>eventType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">[</span>eventType<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>fn <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"发布订阅模式\"><a href=\"#发布订阅模式\" class=\"headerlink\" title=\"发布订阅模式\"></a><strong>发布订阅模式</strong></h3><ul>\n<li><p><strong>订阅者</strong></p>\n</li>\n<li><p><strong>发布者</strong></p>\n</li>\n<li><p><strong>信号中心</strong></p>\n<blockquote>\n<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执行。</p>\n</blockquote>\n</li>\n</ul>\n<pre><code class=\"js\">// 发布订阅\nclass EventEmitter {\n    constructor() {\n        this.subs = Object.create(null)\n    }\n\n    // 订阅事件\n    $on(eventType, callback) {\n        this.subs[eventType] = this.subs[eventType] || []\n        this.subs[eventType].push(callback)\n    }\n    // 发布\n    $emit(eventType) {\n        if (this.subs[eventType]) {\n            this.subs[eventType].forEach(fn =&gt; fn())\n        }\n    }\n}\n</code></pre>\n"},{"title":"浏览器兼容问题","date":"2019-03-10T14:13:51.000Z","_content":"\n### 浏览器兼容相关\n\n- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.\n- 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}","source":"_posts/浏览器兼容问题.md","raw":"---\ntitle: 浏览器兼容问题\ndate: 2019-03-10 22:13:51\ntags: 浏览器\ncategories: 前端\n---\n\n### 浏览器兼容相关\n\n- Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.\n- 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}","slug":"浏览器兼容问题","published":1,"updated":"2024-02-19T07:42:51.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrib006c1xopaggqgkfa","content":"<h3 id=\"浏览器兼容相关\"><a href=\"#浏览器兼容相关\" class=\"headerlink\" title=\"浏览器兼容相关\"></a>浏览器兼容相关</h3><ul>\n<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li>\n<li>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器兼容相关\"><a href=\"#浏览器兼容相关\" class=\"headerlink\" title=\"浏览器兼容相关\"></a>浏览器兼容相关</h3><ul>\n<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li>\n<li>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</li>\n</ul>\n"},{"title":"浏览器存储","date":"2019-06-01T03:43:04.000Z","_content":"\n### 浏览器存储\n\n- sessionStorage 、localStorage 和 cookie 之间的区别\n\n- cookie\n\n    >主要用来记录用户身份信息，因为HTTP是无状态的应用层协议，服务器不会记住客户端本次的请求操作。\n    >\n    >大小：4kb\n    >\n    >特点：无论请求是否用得到，都会被来回传递。可以设置过期时间\n    >\n    >安全性：js脚本可以通过`document.cookie`获取或者设置cookie。通过设置cookie时，添加httpOnly禁止js读取，从而可以预防xss攻击。（不要用cookie传递敏感信息）\n\n    共同点：用于浏览器端存储的缓存数据,都遵循同源策略。\n\n    不同点：\n\n    1. 存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；web storage,会将数据保存到本地，不会造成宽带浪费；\n    2. 数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;\n    3. 数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即关闭窗口或者浏览器；sessionStorage仅在关闭浏览器之前有效（会话级别）；localStorage,除非手动删除，否则数据存储永久有效；\n    4. 作用域不同：cookie和localStorage是在同源中共享的，即只要在相同协议、相同主机名、相同端口下；sessionStorage除了同源外，还必须是同一个窗口（也就是浏览器的标签页）；\n\n- Web Storage与Cookie相比存在的优势：\n    1. 存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。\n    \n    2. 存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送到服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本\n    \n       地，不会与服务器发生任何交互。\n    \n    3. 更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。\n    \n    4. 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。\n    \n- 使用sessionStorage遇到的坑\n\n    1. sessionStorage有要求必须是同一个浏览器标签tab下的才可以访问。\n\n       > 但实际在运用中发现，通过页面内的链接（必须是鼠标左键点击，chrome89版本后通过代码动态创建a标签的方式也是不行的）（或者用window.open）打开新的标签页，它们之间也是可以读取到session的（但感觉不是共享的，修改了新开页的session值，原来的并不受影响）。而通过浏览器直接新开一个tab是，即使网站一样，也是读取不到的。\n\n       [这里参考]https://github.com/lmk123/blog/issues/66","source":"_posts/浏览器存储.md","raw":"---\ntitle: 浏览器存储\ndate: 2019-06-01 11:43:04\ntags: 浏览器\ncategories: 前端\n---\n\n### 浏览器存储\n\n- sessionStorage 、localStorage 和 cookie 之间的区别\n\n- cookie\n\n    >主要用来记录用户身份信息，因为HTTP是无状态的应用层协议，服务器不会记住客户端本次的请求操作。\n    >\n    >大小：4kb\n    >\n    >特点：无论请求是否用得到，都会被来回传递。可以设置过期时间\n    >\n    >安全性：js脚本可以通过`document.cookie`获取或者设置cookie。通过设置cookie时，添加httpOnly禁止js读取，从而可以预防xss攻击。（不要用cookie传递敏感信息）\n\n    共同点：用于浏览器端存储的缓存数据,都遵循同源策略。\n\n    不同点：\n\n    1. 存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；web storage,会将数据保存到本地，不会造成宽带浪费；\n    2. 数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;\n    3. 数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即关闭窗口或者浏览器；sessionStorage仅在关闭浏览器之前有效（会话级别）；localStorage,除非手动删除，否则数据存储永久有效；\n    4. 作用域不同：cookie和localStorage是在同源中共享的，即只要在相同协议、相同主机名、相同端口下；sessionStorage除了同源外，还必须是同一个窗口（也就是浏览器的标签页）；\n\n- Web Storage与Cookie相比存在的优势：\n    1. 存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。\n    \n    2. 存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送到服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本\n    \n       地，不会与服务器发生任何交互。\n    \n    3. 更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。\n    \n    4. 独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。\n    \n- 使用sessionStorage遇到的坑\n\n    1. sessionStorage有要求必须是同一个浏览器标签tab下的才可以访问。\n\n       > 但实际在运用中发现，通过页面内的链接（必须是鼠标左键点击，chrome89版本后通过代码动态创建a标签的方式也是不行的）（或者用window.open）打开新的标签页，它们之间也是可以读取到session的（但感觉不是共享的，修改了新开页的session值，原来的并不受影响）。而通过浏览器直接新开一个tab是，即使网站一样，也是读取不到的。\n\n       [这里参考]https://github.com/lmk123/blog/issues/66","slug":"浏览器存储","published":1,"updated":"2024-02-19T07:42:51.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdric006f1xopb3nmhqbg","content":"<h3 id=\"浏览器存储\"><a href=\"#浏览器存储\" class=\"headerlink\" title=\"浏览器存储\"></a>浏览器存储</h3><ul>\n<li><p>sessionStorage 、localStorage 和 cookie 之间的区别</p>\n</li>\n<li><p>cookie</p>\n<blockquote>\n<p>主要用来记录用户身份信息，因为HTTP是无状态的应用层协议，服务器不会记住客户端本次的请求操作。</p>\n<p>大小：4kb</p>\n<p>特点：无论请求是否用得到，都会被来回传递。可以设置过期时间</p>\n<p>安全性：js脚本可以通过<code>document.cookie</code>获取或者设置cookie。通过设置cookie时，添加httpOnly禁止js读取，从而可以预防xss攻击。（不要用cookie传递敏感信息）</p>\n</blockquote>\n<p>  共同点：用于浏览器端存储的缓存数据,都遵循同源策略。</p>\n<p>  不同点：</p>\n<ol>\n<li>存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；web storage,会将数据保存到本地，不会造成宽带浪费；</li>\n<li>数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</li>\n<li>数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即关闭窗口或者浏览器；sessionStorage仅在关闭浏览器之前有效（会话级别）；localStorage,除非手动删除，否则数据存储永久有效；</li>\n<li>作用域不同：cookie和localStorage是在同源中共享的，即只要在相同协议、相同主机名、相同端口下；sessionStorage除了同源外，还必须是同一个窗口（也就是浏览器的标签页）；</li>\n</ol>\n</li>\n<li><p>Web Storage与Cookie相比存在的优势：</p>\n<ol>\n<li><p>存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。</p>\n</li>\n<li><p>存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送到服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本</p>\n<p>地，不会与服务器发生任何交互。</p>\n</li>\n<li><p>更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。</p>\n</li>\n<li><p>独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。</p>\n</li>\n</ol>\n</li>\n<li><p>使用sessionStorage遇到的坑</p>\n<ol>\n<li><p>sessionStorage有要求必须是同一个浏览器标签tab下的才可以访问。</p>\n<blockquote>\n<p>但实际在运用中发现，通过页面内的链接（必须是鼠标左键点击，chrome89版本后通过代码动态创建a标签的方式也是不行的）（或者用window.open）打开新的标签页，它们之间也是可以读取到session的（但感觉不是共享的，修改了新开页的session值，原来的并不受影响）。而通过浏览器直接新开一个tab是，即使网站一样，也是读取不到的。</p>\n</blockquote>\n<p>[这里参考]<a href=\"https://github.com/lmk123/blog/issues/66\" target=\"_blank\" rel=\"noopener\">https://github.com/lmk123/blog/issues/66</a></p>\n</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器存储\"><a href=\"#浏览器存储\" class=\"headerlink\" title=\"浏览器存储\"></a>浏览器存储</h3><ul>\n<li><p>sessionStorage 、localStorage 和 cookie 之间的区别</p>\n</li>\n<li><p>cookie</p>\n<blockquote>\n<p>主要用来记录用户身份信息，因为HTTP是无状态的应用层协议，服务器不会记住客户端本次的请求操作。</p>\n<p>大小：4kb</p>\n<p>特点：无论请求是否用得到，都会被来回传递。可以设置过期时间</p>\n<p>安全性：js脚本可以通过<code>document.cookie</code>获取或者设置cookie。通过设置cookie时，添加httpOnly禁止js读取，从而可以预防xss攻击。（不要用cookie传递敏感信息）</p>\n</blockquote>\n<p>  共同点：用于浏览器端存储的缓存数据,都遵循同源策略。</p>\n<p>  不同点：</p>\n<ol>\n<li>存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；web storage,会将数据保存到本地，不会造成宽带浪费；</li>\n<li>数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</li>\n<li>数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即关闭窗口或者浏览器；sessionStorage仅在关闭浏览器之前有效（会话级别）；localStorage,除非手动删除，否则数据存储永久有效；</li>\n<li>作用域不同：cookie和localStorage是在同源中共享的，即只要在相同协议、相同主机名、相同端口下；sessionStorage除了同源外，还必须是同一个窗口（也就是浏览器的标签页）；</li>\n</ol>\n</li>\n<li><p>Web Storage与Cookie相比存在的优势：</p>\n<ol>\n<li><p>存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。</p>\n</li>\n<li><p>存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送到服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本</p>\n<p>地，不会与服务器发生任何交互。</p>\n</li>\n<li><p>更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。</p>\n</li>\n<li><p>独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。</p>\n</li>\n</ol>\n</li>\n<li><p>使用sessionStorage遇到的坑</p>\n<ol>\n<li><p>sessionStorage有要求必须是同一个浏览器标签tab下的才可以访问。</p>\n<blockquote>\n<p>但实际在运用中发现，通过页面内的链接（必须是鼠标左键点击，chrome89版本后通过代码动态创建a标签的方式也是不行的）（或者用window.open）打开新的标签页，它们之间也是可以读取到session的（但感觉不是共享的，修改了新开页的session值，原来的并不受影响）。而通过浏览器直接新开一个tab是，即使网站一样，也是读取不到的。</p>\n</blockquote>\n<p>[这里参考]<a href=\"https://github.com/lmk123/blog/issues/66\" target=\"_blank\" rel=\"noopener\">https://github.com/lmk123/blog/issues/66</a></p>\n</li>\n</ol>\n</li>\n</ul>\n"},{"title":"浏览器渲染流程","date":"2018-10-11T04:12:15.000Z","_content":"\n### 浏览器渲染流程\n\n##### 浏览器内核：\n\n主要分成两部分：渲染引擎和JS引擎。\n\n渲染引擎：负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入css等），以及计算机网页的显示方式，然后输出至显示器或打印机。浏览器的内核的不同对网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎：解析和执行javascript来实现网页的动态效果。\n\n> 在最开始的时候渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于指渲染引擎。\n\n##### 常见的浏览器内核：\n\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\n\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\n\nPresto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]\n\nWebkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]\n\n##### 渲染前：\n\n1. 浏览器通过dns查找到域名映射的ip地址，成功后取得连接。\n2. 浏览器通过HTTP协议向web服务器发起请求，服务器等待处理，并响应。\n3. 浏览器接收到服务器返回的html页面代码，并获取服务器端静态资源相关文件如：图片等。\n4. 最终渲染显示页面。\n\n##### 浏览器加载html页面内容的顺序：\n\n![](浏览器渲染流程/5aa1c0da40be870480eef4f2f8b77931.png)\n\n**js的加载：**\n\njs不能并行下载和解析（阻塞下载）。\n\n当引用js的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而js中很可能出现直接改变DOM树结构的代码，比如添加一个节点等，所以会出现加载js文件时，阻塞其他的下载和呈现。\n\n##### 浏览器渲染页面流程：\n\n1. 解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）\n\n2. 解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式\n\n3. 将CSS与DOM合并，构建渲染树（Render Tree）\n\n4. 布局和绘制，重绘（repaint）和重排（reflow）\n\n##### 浏览器的重绘和重排：\n\n一个页面由两部分组成：\n\nDOM：描述该页面的结构\n\nrender：描述 DOM 节点 (nodes) 在页面上如何呈现\n\n当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint（重绘）。\n\n如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow（重排）。\n\n这两个过程是很耗费浏览器性能的, 从 IE 系列和 Chrome 渲染页面速度上的差距即可看出渲染引擎计算对应值和呈现并不一定高效, 而每次对元素的操作都会发生 repaint 或 reflow, 因此编写 DOM 交互时如果不注意就会导致页面性能低下。\n\n页面的渲染过程如下：\n\n![](浏览器渲染流程/f339212b403299f1802345e04edc3c3e.png)\n\n**不管页面发生了重绘还是重排，它们都会影响性能（最可怕的是重排 ，应尽量避免）**\n\n下列情况会发生重排\n\n- 页面初始渲染\n- 添加/删除可见DOM元素\n- 改变元素位置\n- 改变元素尺寸（宽、高、内外边距、边框等）\n- 改变元素内容（文本或图片等）\n- 改变窗口尺寸\n\n##### 如何减少重排\n\n1. 分离读写操作\n\n   ```javascript\n   let mdiv=document.getElementById(mydiv);\n   let dLeft=mdiv.offsetLeft;\n   mdiv.style.left=dLeft+1+'px';\n   ```\n\n\n2. 样式集中改变\n\n   ```css\n   .div1{\n       width:200px;\n       height:200px;\n   }\n   .div2{\n       width:200px;\n       height:200px;\n   }\n   .div3{\n       width:200px;\n       height:200px;\n   }\n   /*集中改变样式*/\n   .div1 .div2 .div3{\n       width:200px;\n       height:200px;\n   }\n   ```\n\n   3. 可以使用absolute脱离文档流\n   4. 使用`display:none`，不使用visibility，也不要改变它的z-index\n   5. 动画尽量使用css3实现\n\n**重排重绘这些步骤都是在cpu中发生的。**\n\n在compostite Layers阶段，cpu 把生成的 BitMap（位图）传输到GPU，渲染到屏幕。 css3就是在GPU发生的：transform  opacity。\n\n在 GPU发生的属性比较高效。所以css3性能比较高。\n\n小结：\n\n渲染的三个阶段 Layout ,Paint,Composite Layers。\n\n修改不同的css属性会触发不同阶段。\n\n触发的阶段越前，渲染的代价越高。\n\n##### 从url输入网址到浏览器页面加载成功所经历的完整过程\n\n1. DNS解析：将域名地址解析为ip地址\n   - 浏览器DNS缓存\n   - 系统DNS缓存\n   - 路由器DNS缓存\n   - 网络运营商DNS缓存\n   - 递归搜索：www.baidu.com\n     1. .com域名下查找DNS解析\n     2. .baidu域名下查找DNS解析\n     3. www域名下查找DNS解析\n     4. 如果都没有解析出来，则报错\n2. TCP连接：TCP三次握手\n   - 第一次握手：由浏览器发起请求到服务器，告诉服务器我将要发送请求了\n   \n   - 第二次握手：由服务器发起，告诉浏览器我准备好了，你开始发送吧\n   \n   - 第三次握手：由浏览器发起，告诉服务器，我准备好发送了，你准备接收吧\n   \n     > TCP/IP协议的三次握手是客户端和服务端通信前的连接，作用就是双方都能明确自己和对方的收、发能力是正常的。\n     >\n     > 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n     >\n     > 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。\n     >\n     > 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的\n3. 发送请求\n   \n   - 请求报文：HTTP协议的通信内容\n4. 接收响应\n   \n   - 响应报文\n5. 渲染页面\n   - 遇见HTML标签，浏览器调用HTML解析器解析成Token并构建DOM树\n   - 遇见Style/link标记：浏览器调用css解析器，处理css标记并构建cssom树\n   - 遇到script标记：调用javaScript解析器，处理script代码（绑定事件，修改dom树/cssom树）\n   - 将dom树和cssom树合并成一个渲染树\n   - 根据渲染树计算布局，计算每个节点的几何信息（布局）\n   - 将各个节点颜色绘制到屏幕上（渲染）\n6. 断开连接：TCP四次挥手\n   - 第一次挥手：由浏览器发起，告诉服务器我发送结束了（请求报文），你准备关闭吧\n   - 第二次挥手：由服务器发起，告诉浏览器我接收完了（请求报文），我准备关闭\n   - 第三次挥手：由服务器发起，告诉浏览器我发送完了（响应报文），你准备关闭吧\n   - 第四次挥手：由浏览器发起，告诉服务器我接收完了（响应报文），我准备关闭，你也关闭吧","source":"_posts/浏览器渲染流程.md","raw":"---\ntitle: 浏览器渲染流程\ndate: 2018-10-11 12:12:15\ntags: 浏览器\ncategories: 前端\n---\n\n### 浏览器渲染流程\n\n##### 浏览器内核：\n\n主要分成两部分：渲染引擎和JS引擎。\n\n渲染引擎：负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入css等），以及计算机网页的显示方式，然后输出至显示器或打印机。浏览器的内核的不同对网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎：解析和执行javascript来实现网页的动态效果。\n\n> 在最开始的时候渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于指渲染引擎。\n\n##### 常见的浏览器内核：\n\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\n\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\n\nPresto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]\n\nWebkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]\n\n##### 渲染前：\n\n1. 浏览器通过dns查找到域名映射的ip地址，成功后取得连接。\n2. 浏览器通过HTTP协议向web服务器发起请求，服务器等待处理，并响应。\n3. 浏览器接收到服务器返回的html页面代码，并获取服务器端静态资源相关文件如：图片等。\n4. 最终渲染显示页面。\n\n##### 浏览器加载html页面内容的顺序：\n\n![](浏览器渲染流程/5aa1c0da40be870480eef4f2f8b77931.png)\n\n**js的加载：**\n\njs不能并行下载和解析（阻塞下载）。\n\n当引用js的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而js中很可能出现直接改变DOM树结构的代码，比如添加一个节点等，所以会出现加载js文件时，阻塞其他的下载和呈现。\n\n##### 浏览器渲染页面流程：\n\n1. 解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）\n\n2. 解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式\n\n3. 将CSS与DOM合并，构建渲染树（Render Tree）\n\n4. 布局和绘制，重绘（repaint）和重排（reflow）\n\n##### 浏览器的重绘和重排：\n\n一个页面由两部分组成：\n\nDOM：描述该页面的结构\n\nrender：描述 DOM 节点 (nodes) 在页面上如何呈现\n\n当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint（重绘）。\n\n如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow（重排）。\n\n这两个过程是很耗费浏览器性能的, 从 IE 系列和 Chrome 渲染页面速度上的差距即可看出渲染引擎计算对应值和呈现并不一定高效, 而每次对元素的操作都会发生 repaint 或 reflow, 因此编写 DOM 交互时如果不注意就会导致页面性能低下。\n\n页面的渲染过程如下：\n\n![](浏览器渲染流程/f339212b403299f1802345e04edc3c3e.png)\n\n**不管页面发生了重绘还是重排，它们都会影响性能（最可怕的是重排 ，应尽量避免）**\n\n下列情况会发生重排\n\n- 页面初始渲染\n- 添加/删除可见DOM元素\n- 改变元素位置\n- 改变元素尺寸（宽、高、内外边距、边框等）\n- 改变元素内容（文本或图片等）\n- 改变窗口尺寸\n\n##### 如何减少重排\n\n1. 分离读写操作\n\n   ```javascript\n   let mdiv=document.getElementById(mydiv);\n   let dLeft=mdiv.offsetLeft;\n   mdiv.style.left=dLeft+1+'px';\n   ```\n\n\n2. 样式集中改变\n\n   ```css\n   .div1{\n       width:200px;\n       height:200px;\n   }\n   .div2{\n       width:200px;\n       height:200px;\n   }\n   .div3{\n       width:200px;\n       height:200px;\n   }\n   /*集中改变样式*/\n   .div1 .div2 .div3{\n       width:200px;\n       height:200px;\n   }\n   ```\n\n   3. 可以使用absolute脱离文档流\n   4. 使用`display:none`，不使用visibility，也不要改变它的z-index\n   5. 动画尽量使用css3实现\n\n**重排重绘这些步骤都是在cpu中发生的。**\n\n在compostite Layers阶段，cpu 把生成的 BitMap（位图）传输到GPU，渲染到屏幕。 css3就是在GPU发生的：transform  opacity。\n\n在 GPU发生的属性比较高效。所以css3性能比较高。\n\n小结：\n\n渲染的三个阶段 Layout ,Paint,Composite Layers。\n\n修改不同的css属性会触发不同阶段。\n\n触发的阶段越前，渲染的代价越高。\n\n##### 从url输入网址到浏览器页面加载成功所经历的完整过程\n\n1. DNS解析：将域名地址解析为ip地址\n   - 浏览器DNS缓存\n   - 系统DNS缓存\n   - 路由器DNS缓存\n   - 网络运营商DNS缓存\n   - 递归搜索：www.baidu.com\n     1. .com域名下查找DNS解析\n     2. .baidu域名下查找DNS解析\n     3. www域名下查找DNS解析\n     4. 如果都没有解析出来，则报错\n2. TCP连接：TCP三次握手\n   - 第一次握手：由浏览器发起请求到服务器，告诉服务器我将要发送请求了\n   \n   - 第二次握手：由服务器发起，告诉浏览器我准备好了，你开始发送吧\n   \n   - 第三次握手：由浏览器发起，告诉服务器，我准备好发送了，你准备接收吧\n   \n     > TCP/IP协议的三次握手是客户端和服务端通信前的连接，作用就是双方都能明确自己和对方的收、发能力是正常的。\n     >\n     > 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n     >\n     > 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。\n     >\n     > 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的\n3. 发送请求\n   \n   - 请求报文：HTTP协议的通信内容\n4. 接收响应\n   \n   - 响应报文\n5. 渲染页面\n   - 遇见HTML标签，浏览器调用HTML解析器解析成Token并构建DOM树\n   - 遇见Style/link标记：浏览器调用css解析器，处理css标记并构建cssom树\n   - 遇到script标记：调用javaScript解析器，处理script代码（绑定事件，修改dom树/cssom树）\n   - 将dom树和cssom树合并成一个渲染树\n   - 根据渲染树计算布局，计算每个节点的几何信息（布局）\n   - 将各个节点颜色绘制到屏幕上（渲染）\n6. 断开连接：TCP四次挥手\n   - 第一次挥手：由浏览器发起，告诉服务器我发送结束了（请求报文），你准备关闭吧\n   - 第二次挥手：由服务器发起，告诉浏览器我接收完了（请求报文），我准备关闭\n   - 第三次挥手：由服务器发起，告诉浏览器我发送完了（响应报文），你准备关闭吧\n   - 第四次挥手：由浏览器发起，告诉服务器我接收完了（响应报文），我准备关闭，你也关闭吧","slug":"浏览器渲染流程","published":1,"updated":"2024-02-19T07:42:51.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdric006i1xop7tfo5umz","content":"<h3 id=\"浏览器渲染流程\"><a href=\"#浏览器渲染流程\" class=\"headerlink\" title=\"浏览器渲染流程\"></a>浏览器渲染流程</h3><h5 id=\"浏览器内核：\"><a href=\"#浏览器内核：\" class=\"headerlink\" title=\"浏览器内核：\"></a>浏览器内核：</h5><p>主要分成两部分：渲染引擎和JS引擎。</p>\n<p>渲染引擎：负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入css等），以及计算机网页的显示方式，然后输出至显示器或打印机。浏览器的内核的不同对网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p>JS引擎：解析和执行javascript来实现网页的动态效果。</p>\n<blockquote>\n<p>在最开始的时候渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于指渲染引擎。</p>\n</blockquote>\n<h5 id=\"常见的浏览器内核：\"><a href=\"#常见的浏览器内核：\" class=\"headerlink\" title=\"常见的浏览器内核：\"></a>常见的浏览器内核：</h5><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p>\n<p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p>\n<p>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</p>\n<p>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]</p>\n<h5 id=\"渲染前：\"><a href=\"#渲染前：\" class=\"headerlink\" title=\"渲染前：\"></a>渲染前：</h5><ol>\n<li>浏览器通过dns查找到域名映射的ip地址，成功后取得连接。</li>\n<li>浏览器通过HTTP协议向web服务器发起请求，服务器等待处理，并响应。</li>\n<li>浏览器接收到服务器返回的html页面代码，并获取服务器端静态资源相关文件如：图片等。</li>\n<li>最终渲染显示页面。</li>\n</ol>\n<h5 id=\"浏览器加载html页面内容的顺序：\"><a href=\"#浏览器加载html页面内容的顺序：\" class=\"headerlink\" title=\"浏览器加载html页面内容的顺序：\"></a>浏览器加载html页面内容的顺序：</h5><p><img src=\"/2018/10/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/5aa1c0da40be870480eef4f2f8b77931.png\" alt></p>\n<p><strong>js的加载：</strong></p>\n<p>js不能并行下载和解析（阻塞下载）。</p>\n<p>当引用js的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而js中很可能出现直接改变DOM树结构的代码，比如添加一个节点等，所以会出现加载js文件时，阻塞其他的下载和呈现。</p>\n<h5 id=\"浏览器渲染页面流程：\"><a href=\"#浏览器渲染页面流程：\" class=\"headerlink\" title=\"浏览器渲染页面流程：\"></a>浏览器渲染页面流程：</h5><ol>\n<li><p>解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）</p>\n</li>\n<li><p>解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式</p>\n</li>\n<li><p>将CSS与DOM合并，构建渲染树（Render Tree）</p>\n</li>\n<li><p>布局和绘制，重绘（repaint）和重排（reflow）</p>\n</li>\n</ol>\n<h5 id=\"浏览器的重绘和重排：\"><a href=\"#浏览器的重绘和重排：\" class=\"headerlink\" title=\"浏览器的重绘和重排：\"></a>浏览器的重绘和重排：</h5><p>一个页面由两部分组成：</p>\n<p>DOM：描述该页面的结构</p>\n<p>render：描述 DOM 节点 (nodes) 在页面上如何呈现</p>\n<p>当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint（重绘）。</p>\n<p>如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow（重排）。</p>\n<p>这两个过程是很耗费浏览器性能的, 从 IE 系列和 Chrome 渲染页面速度上的差距即可看出渲染引擎计算对应值和呈现并不一定高效, 而每次对元素的操作都会发生 repaint 或 reflow, 因此编写 DOM 交互时如果不注意就会导致页面性能低下。</p>\n<p>页面的渲染过程如下：</p>\n<p><img src=\"/2018/10/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/f339212b403299f1802345e04edc3c3e.png\" alt></p>\n<p><strong>不管页面发生了重绘还是重排，它们都会影响性能（最可怕的是重排 ，应尽量避免）</strong></p>\n<p>下列情况会发生重排</p>\n<ul>\n<li>页面初始渲染</li>\n<li>添加/删除可见DOM元素</li>\n<li>改变元素位置</li>\n<li>改变元素尺寸（宽、高、内外边距、边框等）</li>\n<li>改变元素内容（文本或图片等）</li>\n<li>改变窗口尺寸</li>\n</ul>\n<h5 id=\"如何减少重排\"><a href=\"#如何减少重排\" class=\"headerlink\" title=\"如何减少重排\"></a>如何减少重排</h5><ol>\n<li><p>分离读写操作</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> mdiv<span class=\"token operator\">=</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span>mydiv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> dLeft<span class=\"token operator\">=</span>mdiv<span class=\"token punctuation\">.</span>offsetLeft<span class=\"token punctuation\">;</span>\nmdiv<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">.</span>left<span class=\"token operator\">=</span>dLeft<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token operator\">+</span><span class=\"token string\">'px'</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>样式集中改变</p>\n<pre class=\"line-numbers language-css\"><code class=\"language-css\"><span class=\"token selector\"><span class=\"token class\">.div1</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\"><span class=\"token class\">.div2</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token selector\"><span class=\"token class\">.div3</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">/*集中改变样式*/</span>\n<span class=\"token selector\"><span class=\"token class\">.div1</span> <span class=\"token class\">.div2</span> <span class=\"token class\">.div3</span></span><span class=\"token punctuation\">{</span>\n    <span class=\"token property\">width</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n    <span class=\"token property\">height</span><span class=\"token punctuation\">:</span><span class=\"token number\">200</span>px<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ol start=\"3\">\n<li>可以使用absolute脱离文档流</li>\n<li>使用<code>display:none</code>，不使用visibility，也不要改变它的z-index</li>\n<li>动画尽量使用css3实现</li>\n</ol>\n</li>\n</ol>\n<p><strong>重排重绘这些步骤都是在cpu中发生的。</strong></p>\n<p>在compostite Layers阶段，cpu 把生成的 BitMap（位图）传输到GPU，渲染到屏幕。 css3就是在GPU发生的：transform  opacity。</p>\n<p>在 GPU发生的属性比较高效。所以css3性能比较高。</p>\n<p>小结：</p>\n<p>渲染的三个阶段 Layout ,Paint,Composite Layers。</p>\n<p>修改不同的css属性会触发不同阶段。</p>\n<p>触发的阶段越前，渲染的代价越高。</p>\n<h5 id=\"从url输入网址到浏览器页面加载成功所经历的完整过程\"><a href=\"#从url输入网址到浏览器页面加载成功所经历的完整过程\" class=\"headerlink\" title=\"从url输入网址到浏览器页面加载成功所经历的完整过程\"></a>从url输入网址到浏览器页面加载成功所经历的完整过程</h5><ol>\n<li>DNS解析：将域名地址解析为ip地址<ul>\n<li>浏览器DNS缓存</li>\n<li>系统DNS缓存</li>\n<li>路由器DNS缓存</li>\n<li>网络运营商DNS缓存</li>\n<li>递归搜索：<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a><ol>\n<li>.com域名下查找DNS解析</li>\n<li>.baidu域名下查找DNS解析</li>\n<li>www域名下查找DNS解析</li>\n<li>如果都没有解析出来，则报错</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>TCP连接：TCP三次握手</p>\n<ul>\n<li><p>第一次握手：由浏览器发起请求到服务器，告诉服务器我将要发送请求了</p>\n</li>\n<li><p>第二次握手：由服务器发起，告诉浏览器我准备好了，你开始发送吧</p>\n</li>\n<li><p>第三次握手：由浏览器发起，告诉服务器，我准备好发送了，你准备接收吧</p>\n<blockquote>\n<p>TCP/IP协议的三次握手是客户端和服务端通信前的连接，作用就是双方都能明确自己和对方的收、发能力是正常的。</p>\n<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>\n<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>\n<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>发送请求</p>\n<ul>\n<li>请求报文：HTTP协议的通信内容</li>\n</ul>\n</li>\n<li><p>接收响应</p>\n<ul>\n<li>响应报文</li>\n</ul>\n</li>\n<li>渲染页面<ul>\n<li>遇见HTML标签，浏览器调用HTML解析器解析成Token并构建DOM树</li>\n<li>遇见Style/link标记：浏览器调用css解析器，处理css标记并构建cssom树</li>\n<li>遇到script标记：调用javaScript解析器，处理script代码（绑定事件，修改dom树/cssom树）</li>\n<li>将dom树和cssom树合并成一个渲染树</li>\n<li>根据渲染树计算布局，计算每个节点的几何信息（布局）</li>\n<li>将各个节点颜色绘制到屏幕上（渲染）</li>\n</ul>\n</li>\n<li>断开连接：TCP四次挥手<ul>\n<li>第一次挥手：由浏览器发起，告诉服务器我发送结束了（请求报文），你准备关闭吧</li>\n<li>第二次挥手：由服务器发起，告诉浏览器我接收完了（请求报文），我准备关闭</li>\n<li>第三次挥手：由服务器发起，告诉浏览器我发送完了（响应报文），你准备关闭吧</li>\n<li>第四次挥手：由浏览器发起，告诉服务器我接收完了（响应报文），我准备关闭，你也关闭吧</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浏览器渲染流程\"><a href=\"#浏览器渲染流程\" class=\"headerlink\" title=\"浏览器渲染流程\"></a>浏览器渲染流程</h3><h5 id=\"浏览器内核：\"><a href=\"#浏览器内核：\" class=\"headerlink\" title=\"浏览器内核：\"></a>浏览器内核：</h5><p>主要分成两部分：渲染引擎和JS引擎。</p>\n<p>渲染引擎：负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入css等），以及计算机网页的显示方式，然后输出至显示器或打印机。浏览器的内核的不同对网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p>JS引擎：解析和执行javascript来实现网页的动态效果。</p>\n<blockquote>\n<p>在最开始的时候渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于指渲染引擎。</p>\n</blockquote>\n<h5 id=\"常见的浏览器内核：\"><a href=\"#常见的浏览器内核：\" class=\"headerlink\" title=\"常见的浏览器内核：\"></a>常见的浏览器内核：</h5><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</p>\n<p>Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等</p>\n<p>Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;]</p>\n<p>Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）]</p>\n<h5 id=\"渲染前：\"><a href=\"#渲染前：\" class=\"headerlink\" title=\"渲染前：\"></a>渲染前：</h5><ol>\n<li>浏览器通过dns查找到域名映射的ip地址，成功后取得连接。</li>\n<li>浏览器通过HTTP协议向web服务器发起请求，服务器等待处理，并响应。</li>\n<li>浏览器接收到服务器返回的html页面代码，并获取服务器端静态资源相关文件如：图片等。</li>\n<li>最终渲染显示页面。</li>\n</ol>\n<h5 id=\"浏览器加载html页面内容的顺序：\"><a href=\"#浏览器加载html页面内容的顺序：\" class=\"headerlink\" title=\"浏览器加载html页面内容的顺序：\"></a>浏览器加载html页面内容的顺序：</h5><p><img src=\"/2018/10/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/5aa1c0da40be870480eef4f2f8b77931.png\" alt></p>\n<p><strong>js的加载：</strong></p>\n<p>js不能并行下载和解析（阻塞下载）。</p>\n<p>当引用js的时候，浏览器发送一个js request就会一直等待该request的返回。因为浏览器需要一个稳定的DOM树结构，而js中很可能出现直接改变DOM树结构的代码，比如添加一个节点等，所以会出现加载js文件时，阻塞其他的下载和呈现。</p>\n<h5 id=\"浏览器渲染页面流程：\"><a href=\"#浏览器渲染页面流程：\" class=\"headerlink\" title=\"浏览器渲染页面流程：\"></a>浏览器渲染页面流程：</h5><ol>\n<li><p>解析HTML文件，创建DOM树。自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）</p>\n</li>\n<li><p>解析CSS。优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式</p>\n</li>\n<li><p>将CSS与DOM合并，构建渲染树（Render Tree）</p>\n</li>\n<li><p>布局和绘制，重绘（repaint）和重排（reflow）</p>\n</li>\n</ol>\n<h5 id=\"浏览器的重绘和重排：\"><a href=\"#浏览器的重绘和重排：\" class=\"headerlink\" title=\"浏览器的重绘和重排：\"></a>浏览器的重绘和重排：</h5><p>一个页面由两部分组成：</p>\n<p>DOM：描述该页面的结构</p>\n<p>render：描述 DOM 节点 (nodes) 在页面上如何呈现</p>\n<p>当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint（重绘）。</p>\n<p>如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow（重排）。</p>\n<p>这两个过程是很耗费浏览器性能的, 从 IE 系列和 Chrome 渲染页面速度上的差距即可看出渲染引擎计算对应值和呈现并不一定高效, 而每次对元素的操作都会发生 repaint 或 reflow, 因此编写 DOM 交互时如果不注意就会导致页面性能低下。</p>\n<p>页面的渲染过程如下：</p>\n<p><img src=\"/2018/10/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/f339212b403299f1802345e04edc3c3e.png\" alt></p>\n<p><strong>不管页面发生了重绘还是重排，它们都会影响性能（最可怕的是重排 ，应尽量避免）</strong></p>\n<p>下列情况会发生重排</p>\n<ul>\n<li>页面初始渲染</li>\n<li>添加/删除可见DOM元素</li>\n<li>改变元素位置</li>\n<li>改变元素尺寸（宽、高、内外边距、边框等）</li>\n<li>改变元素内容（文本或图片等）</li>\n<li>改变窗口尺寸</li>\n</ul>\n<h5 id=\"如何减少重排\"><a href=\"#如何减少重排\" class=\"headerlink\" title=\"如何减少重排\"></a>如何减少重排</h5><ol>\n<li><p>分离读写操作</p>\n<pre><code class=\"javascript\">let mdiv=document.getElementById(mydiv);\nlet dLeft=mdiv.offsetLeft;\nmdiv.style.left=dLeft+1+&#39;px&#39;;\n</code></pre>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>样式集中改变</p>\n<pre><code class=\"css\">.div1{\n    width:200px;\n    height:200px;\n}\n.div2{\n    width:200px;\n    height:200px;\n}\n.div3{\n    width:200px;\n    height:200px;\n}\n/*集中改变样式*/\n.div1 .div2 .div3{\n    width:200px;\n    height:200px;\n}\n</code></pre>\n<ol start=\"3\">\n<li>可以使用absolute脱离文档流</li>\n<li>使用<code>display:none</code>，不使用visibility，也不要改变它的z-index</li>\n<li>动画尽量使用css3实现</li>\n</ol>\n</li>\n</ol>\n<p><strong>重排重绘这些步骤都是在cpu中发生的。</strong></p>\n<p>在compostite Layers阶段，cpu 把生成的 BitMap（位图）传输到GPU，渲染到屏幕。 css3就是在GPU发生的：transform  opacity。</p>\n<p>在 GPU发生的属性比较高效。所以css3性能比较高。</p>\n<p>小结：</p>\n<p>渲染的三个阶段 Layout ,Paint,Composite Layers。</p>\n<p>修改不同的css属性会触发不同阶段。</p>\n<p>触发的阶段越前，渲染的代价越高。</p>\n<h5 id=\"从url输入网址到浏览器页面加载成功所经历的完整过程\"><a href=\"#从url输入网址到浏览器页面加载成功所经历的完整过程\" class=\"headerlink\" title=\"从url输入网址到浏览器页面加载成功所经历的完整过程\"></a>从url输入网址到浏览器页面加载成功所经历的完整过程</h5><ol>\n<li>DNS解析：将域名地址解析为ip地址<ul>\n<li>浏览器DNS缓存</li>\n<li>系统DNS缓存</li>\n<li>路由器DNS缓存</li>\n<li>网络运营商DNS缓存</li>\n<li>递归搜索：<a href=\"http://www.baidu.com\" target=\"_blank\" rel=\"noopener\">www.baidu.com</a><ol>\n<li>.com域名下查找DNS解析</li>\n<li>.baidu域名下查找DNS解析</li>\n<li>www域名下查找DNS解析</li>\n<li>如果都没有解析出来，则报错</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>TCP连接：TCP三次握手</p>\n<ul>\n<li><p>第一次握手：由浏览器发起请求到服务器，告诉服务器我将要发送请求了</p>\n</li>\n<li><p>第二次握手：由服务器发起，告诉浏览器我准备好了，你开始发送吧</p>\n</li>\n<li><p>第三次握手：由浏览器发起，告诉服务器，我准备好发送了，你准备接收吧</p>\n<blockquote>\n<p>TCP/IP协议的三次握手是客户端和服务端通信前的连接，作用就是双方都能明确自己和对方的收、发能力是正常的。</p>\n<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>\n<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p>\n<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>发送请求</p>\n<ul>\n<li>请求报文：HTTP协议的通信内容</li>\n</ul>\n</li>\n<li><p>接收响应</p>\n<ul>\n<li>响应报文</li>\n</ul>\n</li>\n<li>渲染页面<ul>\n<li>遇见HTML标签，浏览器调用HTML解析器解析成Token并构建DOM树</li>\n<li>遇见Style/link标记：浏览器调用css解析器，处理css标记并构建cssom树</li>\n<li>遇到script标记：调用javaScript解析器，处理script代码（绑定事件，修改dom树/cssom树）</li>\n<li>将dom树和cssom树合并成一个渲染树</li>\n<li>根据渲染树计算布局，计算每个节点的几何信息（布局）</li>\n<li>将各个节点颜色绘制到屏幕上（渲染）</li>\n</ul>\n</li>\n<li>断开连接：TCP四次挥手<ul>\n<li>第一次挥手：由浏览器发起，告诉服务器我发送结束了（请求报文），你准备关闭吧</li>\n<li>第二次挥手：由服务器发起，告诉浏览器我接收完了（请求报文），我准备关闭</li>\n<li>第三次挥手：由服务器发起，告诉浏览器我发送完了（响应报文），你准备关闭吧</li>\n<li>第四次挥手：由浏览器发起，告诉服务器我接收完了（响应报文），我准备关闭，你也关闭吧</li>\n</ul>\n</li>\n</ol>\n"},{"title":"编写可维护的JavaScript笔记","date":"2019-06-01T03:52:38.000Z","_content":"\n### 换行\n逗号也是运算符，例如下面，逗号应该作为前一行的结尾。如果把它放在第二行的开始，自动分号插入机制会在某些场景下在前一行结束的位置自动插入分号，导致错误发生。\n\n```js\n//好的代码风格\n\nfunction(document, element, window, strings, navigator,\ndiv_somediv) {\n\n    // Here is some code \n}\n\n//不好的代码风格\n\nfunction(document, element, window, strings, navigator\n, div_somediv) {\n\n    // Here is some code\n}\n\n```\n### 注释\n单行注释应该有一个空行。多行注释最好如下所示进行标注以及缩进\n\n```js\nfunction(document, element, window, strings) {\n    \n    // 单行注释\n    fun(document, window);\n}\n\nfunction(document, element) {\n    /*\n     * 这里是多行注释\n     * 星号后面有个空格\n     */\n     console.log(document);\n}\n```\n### 花括号的对齐方式\n对于JavaScript，花括号最好放在块语句中第一句代码的末尾，原因就是对于换行规范的解释：避免错误的分号自动插入。Google JavaScript风格指南明确禁止将花括号放在块语句首行的下一行：\n\n\n```js\n// 推荐的做法\nif (condition) {\n    doSomething();\n}else {\n    doSomething();\n}\n\n// 不好的做法\nif (condition)\n{\n    doSomething();\n}\nelse \n{\n    doSomething();\n}\n```\n### switch的default\n如果`switch`的`default`分支什么也不做，可以省略掉default，因为这可以节省一些字节。\n### for-in 循环\nfor-in循环遍历相对来说是比较慢的，主要用来“枚举”对象的属性，不应用来遍历数组。\nfor-in循环会把对象的全部属性--包括从原型继承的属性都遍历出来，如果想要去除这些原型上的属性，可以使用`hasOwnProperty()`方法为`for-in`循环过滤出实例属性。\n\n```js\nvar obj = {name: 'Tom', age: 20};\nfor (prop in obj) {\n\n// 通过hasOwnProperty判断\n    if(obj.hasOwnProperty(prop)) {\n    \n    // 此时prop不包含原型中的属性\n        console.log(prop);\n    }\n```\n### 变量声明和函数声明\n1. 总数将局部变量的定义作为函数内第一条语句\n2. 使用单`var`语句--每个变量的初始化独占一行；对于那些没有进行初始化的变量，它们应当出现在`var`语句的尾部。\n3. 哪怕是写在for循环里临时使用的变量，也最好放到函数顶部的变量语句中。\n4. 函数声明不应当出现在语句块之内。（这个只针对使用`var`语句来声明的变量，对于es6的`let`语句，有自己独立的作用域）\n\n### 原始包装类型\nJavaScript有三种原始包装类型：`String`、`Boolean`、`Number`。每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。\n\n```js\nvar name = 'Tom';\nname.author = 'Jack';\nconsole.log(name.author); // undefined\n```\n第二行，js引擎会根据name的上下文类型临时创建了`String`对象，为这个临时对象添加了autor属性，当执行完后，临时`String`对象就被销毁了。\n\n*不推荐使用`new`关键字来创建原始包装类型对象*\n\n### 将CSS从js中抽离\njs不应直接操作样式，以便保持和CSS的松耦合。在js中将样式添加至元素的几种方法：\n\n```js\n// 好的写法 - 原生js\nelement.className += ' active';\n\n// 好的写法 - HTML5\nelement.classList,add('active');\n\n// 好的写法 - jQuery\n$(element).addClass('active');\n\n// 好的写法 - YUI\nY.one(element).addClass('active');\n\n// 好的写法 -Dojo\ndojo.addClass(element, 'active');\n```\n\n### 单全局变量模式\n单全局变量模式已经在各种流行的js类库中广泛的应用了。\n单全局变量模式是指，在整个上下文中，只创建一个全局变量；它不会和内置的API冲突，并将你所有的功能代码都挂载到这个全局对象上。","source":"_posts/编写可维护的JavaScript笔记.md","raw":"---\ntitle: 编写可维护的JavaScript笔记\ndate: 2019-06-01 11:52:38\ntags: axios\ncategories: 读书笔记\n---\n\n### 换行\n逗号也是运算符，例如下面，逗号应该作为前一行的结尾。如果把它放在第二行的开始，自动分号插入机制会在某些场景下在前一行结束的位置自动插入分号，导致错误发生。\n\n```js\n//好的代码风格\n\nfunction(document, element, window, strings, navigator,\ndiv_somediv) {\n\n    // Here is some code \n}\n\n//不好的代码风格\n\nfunction(document, element, window, strings, navigator\n, div_somediv) {\n\n    // Here is some code\n}\n\n```\n### 注释\n单行注释应该有一个空行。多行注释最好如下所示进行标注以及缩进\n\n```js\nfunction(document, element, window, strings) {\n    \n    // 单行注释\n    fun(document, window);\n}\n\nfunction(document, element) {\n    /*\n     * 这里是多行注释\n     * 星号后面有个空格\n     */\n     console.log(document);\n}\n```\n### 花括号的对齐方式\n对于JavaScript，花括号最好放在块语句中第一句代码的末尾，原因就是对于换行规范的解释：避免错误的分号自动插入。Google JavaScript风格指南明确禁止将花括号放在块语句首行的下一行：\n\n\n```js\n// 推荐的做法\nif (condition) {\n    doSomething();\n}else {\n    doSomething();\n}\n\n// 不好的做法\nif (condition)\n{\n    doSomething();\n}\nelse \n{\n    doSomething();\n}\n```\n### switch的default\n如果`switch`的`default`分支什么也不做，可以省略掉default，因为这可以节省一些字节。\n### for-in 循环\nfor-in循环遍历相对来说是比较慢的，主要用来“枚举”对象的属性，不应用来遍历数组。\nfor-in循环会把对象的全部属性--包括从原型继承的属性都遍历出来，如果想要去除这些原型上的属性，可以使用`hasOwnProperty()`方法为`for-in`循环过滤出实例属性。\n\n```js\nvar obj = {name: 'Tom', age: 20};\nfor (prop in obj) {\n\n// 通过hasOwnProperty判断\n    if(obj.hasOwnProperty(prop)) {\n    \n    // 此时prop不包含原型中的属性\n        console.log(prop);\n    }\n```\n### 变量声明和函数声明\n1. 总数将局部变量的定义作为函数内第一条语句\n2. 使用单`var`语句--每个变量的初始化独占一行；对于那些没有进行初始化的变量，它们应当出现在`var`语句的尾部。\n3. 哪怕是写在for循环里临时使用的变量，也最好放到函数顶部的变量语句中。\n4. 函数声明不应当出现在语句块之内。（这个只针对使用`var`语句来声明的变量，对于es6的`let`语句，有自己独立的作用域）\n\n### 原始包装类型\nJavaScript有三种原始包装类型：`String`、`Boolean`、`Number`。每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。\n\n```js\nvar name = 'Tom';\nname.author = 'Jack';\nconsole.log(name.author); // undefined\n```\n第二行，js引擎会根据name的上下文类型临时创建了`String`对象，为这个临时对象添加了autor属性，当执行完后，临时`String`对象就被销毁了。\n\n*不推荐使用`new`关键字来创建原始包装类型对象*\n\n### 将CSS从js中抽离\njs不应直接操作样式，以便保持和CSS的松耦合。在js中将样式添加至元素的几种方法：\n\n```js\n// 好的写法 - 原生js\nelement.className += ' active';\n\n// 好的写法 - HTML5\nelement.classList,add('active');\n\n// 好的写法 - jQuery\n$(element).addClass('active');\n\n// 好的写法 - YUI\nY.one(element).addClass('active');\n\n// 好的写法 -Dojo\ndojo.addClass(element, 'active');\n```\n\n### 单全局变量模式\n单全局变量模式已经在各种流行的js类库中广泛的应用了。\n单全局变量模式是指，在整个上下文中，只创建一个全局变量；它不会和内置的API冲突，并将你所有的功能代码都挂载到这个全局对象上。","slug":"编写可维护的JavaScript笔记","published":1,"updated":"2024-02-19T07:42:51.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrid006k1xop44t2290y","content":"<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>逗号也是运算符，例如下面，逗号应该作为前一行的结尾。如果把它放在第二行的开始，自动分号插入机制会在某些场景下在前一行结束的位置自动插入分号，导致错误发生。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">//好的代码风格</span>\n\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">,</span> strings<span class=\"token punctuation\">,</span> navigator<span class=\"token punctuation\">,</span>\ndiv_somediv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Here is some code </span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//不好的代码风格</span>\n\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">,</span> strings<span class=\"token punctuation\">,</span> navigator\n<span class=\"token punctuation\">,</span> div_somediv<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// Here is some code</span>\n<span class=\"token punctuation\">}</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>单行注释应该有一个空行。多行注释最好如下所示进行标注以及缩进</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">,</span> strings<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 单行注释</span>\n    <span class=\"token function\">fun</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">,</span> element<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n     * 这里是多行注释\n     * 星号后面有个空格\n     */</span>\n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"花括号的对齐方式\"><a href=\"#花括号的对齐方式\" class=\"headerlink\" title=\"花括号的对齐方式\"></a>花括号的对齐方式</h3><p>对于JavaScript，花括号最好放在块语句中第一句代码的末尾，原因就是对于换行规范的解释：避免错误的分号自动插入。Google JavaScript风格指南明确禁止将花括号放在块语句首行的下一行：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 推荐的做法</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 不好的做法</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>condition<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">else</span> \n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"switch的default\"><a href=\"#switch的default\" class=\"headerlink\" title=\"switch的default\"></a>switch的default</h3><p>如果<code>switch</code>的<code>default</code>分支什么也不做，可以省略掉default，因为这可以节省一些字节。</p>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>for-in循环遍历相对来说是比较慢的，主要用来“枚举”对象的属性，不应用来遍历数组。<br>for-in循环会把对象的全部属性–包括从原型继承的属性都遍历出来，如果想要去除这些原型上的属性，可以使用<code>hasOwnProperty()</code>方法为<code>for-in</code>循环过滤出实例属性。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">,</span> age<span class=\"token punctuation\">:</span> <span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>prop <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 通过hasOwnProperty判断</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>prop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 此时prop不包含原型中的属性</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>prop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"变量声明和函数声明\"><a href=\"#变量声明和函数声明\" class=\"headerlink\" title=\"变量声明和函数声明\"></a>变量声明和函数声明</h3><ol>\n<li>总数将局部变量的定义作为函数内第一条语句</li>\n<li>使用单<code>var</code>语句–每个变量的初始化独占一行；对于那些没有进行初始化的变量，它们应当出现在<code>var</code>语句的尾部。</li>\n<li>哪怕是写在for循环里临时使用的变量，也最好放到函数顶部的变量语句中。</li>\n<li>函数声明不应当出现在语句块之内。（这个只针对使用<code>var</code>语句来声明的变量，对于es6的<code>let</code>语句，有自己独立的作用域）</li>\n</ol>\n<h3 id=\"原始包装类型\"><a href=\"#原始包装类型\" class=\"headerlink\" title=\"原始包装类型\"></a>原始包装类型</h3><p>JavaScript有三种原始包装类型：<code>String</code>、<code>Boolean</code>、<code>Number</code>。每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">;</span>\nname<span class=\"token punctuation\">.</span>author <span class=\"token operator\">=</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">.</span>author<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// undefined</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>第二行，js引擎会根据name的上下文类型临时创建了<code>String</code>对象，为这个临时对象添加了autor属性，当执行完后，临时<code>String</code>对象就被销毁了。</p>\n<p><em>不推荐使用<code>new</code>关键字来创建原始包装类型对象</em></p>\n<h3 id=\"将CSS从js中抽离\"><a href=\"#将CSS从js中抽离\" class=\"headerlink\" title=\"将CSS从js中抽离\"></a>将CSS从js中抽离</h3><p>js不应直接操作样式，以便保持和CSS的松耦合。在js中将样式添加至元素的几种方法：</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 好的写法 - 原生js</span>\nelement<span class=\"token punctuation\">.</span>className <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token string\">' active'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 好的写法 - HTML5</span>\nelement<span class=\"token punctuation\">.</span>classList<span class=\"token punctuation\">,</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'active'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 好的写法 - jQuery</span>\n<span class=\"token function\">$</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">'active'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 好的写法 - YUI</span>\nY<span class=\"token punctuation\">.</span><span class=\"token function\">one</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addClass</span><span class=\"token punctuation\">(</span><span class=\"token string\">'active'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// 好的写法 -Dojo</span>\ndojo<span class=\"token punctuation\">.</span><span class=\"token function\">addClass</span><span class=\"token punctuation\">(</span>element<span class=\"token punctuation\">,</span> <span class=\"token string\">'active'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"单全局变量模式\"><a href=\"#单全局变量模式\" class=\"headerlink\" title=\"单全局变量模式\"></a>单全局变量模式</h3><p>单全局变量模式已经在各种流行的js类库中广泛的应用了。<br>单全局变量模式是指，在整个上下文中，只创建一个全局变量；它不会和内置的API冲突，并将你所有的功能代码都挂载到这个全局对象上。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>逗号也是运算符，例如下面，逗号应该作为前一行的结尾。如果把它放在第二行的开始，自动分号插入机制会在某些场景下在前一行结束的位置自动插入分号，导致错误发生。</p>\n<pre><code class=\"js\">//好的代码风格\n\nfunction(document, element, window, strings, navigator,\ndiv_somediv) {\n\n    // Here is some code \n}\n\n//不好的代码风格\n\nfunction(document, element, window, strings, navigator\n, div_somediv) {\n\n    // Here is some code\n}\n\n</code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>单行注释应该有一个空行。多行注释最好如下所示进行标注以及缩进</p>\n<pre><code class=\"js\">function(document, element, window, strings) {\n\n    // 单行注释\n    fun(document, window);\n}\n\nfunction(document, element) {\n    /*\n     * 这里是多行注释\n     * 星号后面有个空格\n     */\n     console.log(document);\n}\n</code></pre>\n<h3 id=\"花括号的对齐方式\"><a href=\"#花括号的对齐方式\" class=\"headerlink\" title=\"花括号的对齐方式\"></a>花括号的对齐方式</h3><p>对于JavaScript，花括号最好放在块语句中第一句代码的末尾，原因就是对于换行规范的解释：避免错误的分号自动插入。Google JavaScript风格指南明确禁止将花括号放在块语句首行的下一行：</p>\n<pre><code class=\"js\">// 推荐的做法\nif (condition) {\n    doSomething();\n}else {\n    doSomething();\n}\n\n// 不好的做法\nif (condition)\n{\n    doSomething();\n}\nelse \n{\n    doSomething();\n}\n</code></pre>\n<h3 id=\"switch的default\"><a href=\"#switch的default\" class=\"headerlink\" title=\"switch的default\"></a>switch的default</h3><p>如果<code>switch</code>的<code>default</code>分支什么也不做，可以省略掉default，因为这可以节省一些字节。</p>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>for-in循环遍历相对来说是比较慢的，主要用来“枚举”对象的属性，不应用来遍历数组。<br>for-in循环会把对象的全部属性–包括从原型继承的属性都遍历出来，如果想要去除这些原型上的属性，可以使用<code>hasOwnProperty()</code>方法为<code>for-in</code>循环过滤出实例属性。</p>\n<pre><code class=\"js\">var obj = {name: &#39;Tom&#39;, age: 20};\nfor (prop in obj) {\n\n// 通过hasOwnProperty判断\n    if(obj.hasOwnProperty(prop)) {\n\n    // 此时prop不包含原型中的属性\n        console.log(prop);\n    }\n</code></pre>\n<h3 id=\"变量声明和函数声明\"><a href=\"#变量声明和函数声明\" class=\"headerlink\" title=\"变量声明和函数声明\"></a>变量声明和函数声明</h3><ol>\n<li>总数将局部变量的定义作为函数内第一条语句</li>\n<li>使用单<code>var</code>语句–每个变量的初始化独占一行；对于那些没有进行初始化的变量，它们应当出现在<code>var</code>语句的尾部。</li>\n<li>哪怕是写在for循环里临时使用的变量，也最好放到函数顶部的变量语句中。</li>\n<li>函数声明不应当出现在语句块之内。（这个只针对使用<code>var</code>语句来声明的变量，对于es6的<code>let</code>语句，有自己独立的作用域）</li>\n</ol>\n<h3 id=\"原始包装类型\"><a href=\"#原始包装类型\" class=\"headerlink\" title=\"原始包装类型\"></a>原始包装类型</h3><p>JavaScript有三种原始包装类型：<code>String</code>、<code>Boolean</code>、<code>Number</code>。每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。</p>\n<pre><code class=\"js\">var name = &#39;Tom&#39;;\nname.author = &#39;Jack&#39;;\nconsole.log(name.author); // undefined\n</code></pre>\n<p>第二行，js引擎会根据name的上下文类型临时创建了<code>String</code>对象，为这个临时对象添加了autor属性，当执行完后，临时<code>String</code>对象就被销毁了。</p>\n<p><em>不推荐使用<code>new</code>关键字来创建原始包装类型对象</em></p>\n<h3 id=\"将CSS从js中抽离\"><a href=\"#将CSS从js中抽离\" class=\"headerlink\" title=\"将CSS从js中抽离\"></a>将CSS从js中抽离</h3><p>js不应直接操作样式，以便保持和CSS的松耦合。在js中将样式添加至元素的几种方法：</p>\n<pre><code class=\"js\">// 好的写法 - 原生js\nelement.className += &#39; active&#39;;\n\n// 好的写法 - HTML5\nelement.classList,add(&#39;active&#39;);\n\n// 好的写法 - jQuery\n$(element).addClass(&#39;active&#39;);\n\n// 好的写法 - YUI\nY.one(element).addClass(&#39;active&#39;);\n\n// 好的写法 -Dojo\ndojo.addClass(element, &#39;active&#39;);\n</code></pre>\n<h3 id=\"单全局变量模式\"><a href=\"#单全局变量模式\" class=\"headerlink\" title=\"单全局变量模式\"></a>单全局变量模式</h3><p>单全局变量模式已经在各种流行的js类库中广泛的应用了。<br>单全局变量模式是指，在整个上下文中，只创建一个全局变量；它不会和内置的API冲突，并将你所有的功能代码都挂载到这个全局对象上。</p>\n"},{"title":"常见的排序算法","date":"2018-10-01T10:23:22.000Z","_content":"# 运用js实现简单的几种排序算法\n\n#### 时间复杂度排序：\n![](常见的排序算法/9a8c68df405b4ae980c7a100d9395d26.png)\n##### 如何分析时间复杂度\n\n1. 只关注循环执行次数最多的一段代码。\n\n   > 大o这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。\n\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度。\n\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。\n\n##### 最好、最坏、平均、均摊时间复杂度\n\n1. 最好时间复杂度：在最理想的情况下所执行代码的时间复杂度。\n2. 最坏时间复杂度：在最糟糕的情况下所执行代码的时间复杂度。\n3. 平均时间复杂度：加权平均时间复杂度。\n4. 均摊时间复杂度：看能否将最高时间复杂度的那次操作平摊到其他那些时间复杂度比较低的操作上。一般均摊时间复杂度就等于最好情况时间复杂度。\n\n### 二分查找(折半查找)\n\n> #####算法思想：\n\t搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n***注意：查找必须是大小排好序的***\n#### 时间复杂度：O(log2n)\n##### 代码实现：\n```javascript\n\tlet arr=[1,2,3,4,5,6,7,8,9];\n\tfunction erfen(arr,val){\n\t \tlet left=0;\n\t \tlet right=arr.length-1;\n\t \twhile(left<=right){\n\t \t\tlet mid=parseInt((left+right)/2);\n\t \t\tif(val>arr[mid]){\n\t \t\t\tleft=mid+1;\n\t \t\t}else if(val<arr[mid]){\n\t \t\t\tright=mid-1;\n\t \t\t}else{\n\t \t\t\treturn mid;\n\t \t\t}\n\t \t}\n\t}\n\tlet res=erfen(arr,1);\n\tconsole.log('二分查找：',res);\n```\n### 冒泡排序\n\n> #####算法思想：\n\t1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\t2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n\t3. 针对所有的元素重复以上的步骤，除了最后一个。\n\t4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 \n#### 时间复杂度：O(n^2)\n##### 代码实现：\n```javascript\n\tfunction mp(arr){\n\t \tfor(let i=0;i<arr.length-1;i++){\n\t \t\tfor(let j=0;j<arr.length-i-1;j++){\n\t \t\t\tif(arr[j]>arr[j+1]){\n\t \t\t\t\tlet tmp=arr[j];\n\t \t\t\t\tarr[j]=arr[j+1];\n\t \t\t\t\tarr[j+1]=tmp;\n\t \t\t\t}\n\t \t\t}\n\t \t}\n\t \treturn arr;\n\t }\n\t res=mp(array);\n\t console.log('冒泡排序：',res);\n```\n### 快速排序\n\n> #####算法思想：\n\t1. 选出一个基准数，一般为第一个元素。\n\t2. 比较后边的所有数值，大的放右边，小的放左边（也就是一趟之后，将排序的数据分成两块，一部分是比基准数都小的，一部分是比基准数都大的）。\n\t3. 最后分别对两块数据进行重复1、2步骤。（递归进行）。\n#### 时间复杂度：O(nlogn) \n##### 代码实现：\n```javascript\n\tfunction kp(arr,left,right){\n\t\tif(left<right){\n\t\t\tlet mid=q(arr,left,right);\n\t\t\tkp(arr,mid+1,right);\n\t\t\tkp(arr,left,mid-1);\n\t\t}\n\t}\n\tfunction q(arr,left,right){\n\t\tlet tmp=arr[left];\n\t\twhile(left<right){\n\t\t\twhile(left<right&&tmp<=arr[right]){\t//从右开始找\n\t\t\t\tright=right-1;\n\t\t\t}\n\t\t\tarr[left]=arr[right];\t//找到比基准数小的放到左边\n\t\t\twhile(left<right&&tmp>=arr[left]){\t//从左开始找\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tarr[right]=arr[left];\t//找到比基准数大的放到右边\n\t\t}\n\t\tarr[left]=tmp;\t\t//将基准数放到中间\n\t\treturn left;\n\t}\n\tkp(array,0,array.length-1);\n\tconsole.log('快速排序：',array);\n```\n\n### 选择排序\n\n> #####算法思想：\n\t每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。\n#### 时间复杂度：O(n^2) \n##### 代码实现：\n```javascript\n\tfunction xz(arr){\n\t\tfor(let i=0;i<arr.length;i++){\n\t\t\tlet min = i;\n\t\t\tfor(let j=i+1;j<arr.length;j++){\n\t\t\t\tif(arr[j]<arr[min]){\n\t\t\t\t\tmin=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min!=i){\n\t\t\t\tlet tmp=arr[i];\n\t\t\t\tarr[i]=arr[min];\n\t\t\t\tarr[min]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\txz(array);\n\tconsole.log('选择排序：',array);\n```\n\n### 插入排序\n\n> #####算法思想：\n\t输入一个元素，检查数组列表中的每个元素，将其插入到一个已经排好序的数列中的适当位置，使数列依然有序，当最后一个元素放入合适位置时，该数组排序完毕。\n#### 时间复杂度：O(n^2) \n##### 代码实现：\n```javascript\n\tfunction cr(arr){\n\t\tfor(let i=1;i<arr.length;i++){\n\t\t\tlet tmp=arr[i];\n\t\t\tlet j=i-1;\n\t\t\twhile(j>=0&&tmp<arr[j]){\n\t\t\t\tarr[j+1]=arr[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tarr[j+1]=tmp;\n\t\t}\n\t}\n\tcr(array);\n\tconsole.log('插入排序：',array);\n```\n\n","source":"_posts/常见的排序算法.md","raw":"---\ntitle: 常见的排序算法\ndate: 2018-10-01 18:23:22\ntags: 算法\ncategories: 算法\n---\n# 运用js实现简单的几种排序算法\n\n#### 时间复杂度排序：\n![](常见的排序算法/9a8c68df405b4ae980c7a100d9395d26.png)\n##### 如何分析时间复杂度\n\n1. 只关注循环执行次数最多的一段代码。\n\n   > 大o这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。\n\n2. 加法法则：总复杂度等于量级最大的那段代码的复杂度。\n\n3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。\n\n##### 最好、最坏、平均、均摊时间复杂度\n\n1. 最好时间复杂度：在最理想的情况下所执行代码的时间复杂度。\n2. 最坏时间复杂度：在最糟糕的情况下所执行代码的时间复杂度。\n3. 平均时间复杂度：加权平均时间复杂度。\n4. 均摊时间复杂度：看能否将最高时间复杂度的那次操作平摊到其他那些时间复杂度比较低的操作上。一般均摊时间复杂度就等于最好情况时间复杂度。\n\n### 二分查找(折半查找)\n\n> #####算法思想：\n\t搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。\n***注意：查找必须是大小排好序的***\n#### 时间复杂度：O(log2n)\n##### 代码实现：\n```javascript\n\tlet arr=[1,2,3,4,5,6,7,8,9];\n\tfunction erfen(arr,val){\n\t \tlet left=0;\n\t \tlet right=arr.length-1;\n\t \twhile(left<=right){\n\t \t\tlet mid=parseInt((left+right)/2);\n\t \t\tif(val>arr[mid]){\n\t \t\t\tleft=mid+1;\n\t \t\t}else if(val<arr[mid]){\n\t \t\t\tright=mid-1;\n\t \t\t}else{\n\t \t\t\treturn mid;\n\t \t\t}\n\t \t}\n\t}\n\tlet res=erfen(arr,1);\n\tconsole.log('二分查找：',res);\n```\n### 冒泡排序\n\n> #####算法思想：\n\t1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\t2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n\t3. 针对所有的元素重复以上的步骤，除了最后一个。\n\t4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 \n#### 时间复杂度：O(n^2)\n##### 代码实现：\n```javascript\n\tfunction mp(arr){\n\t \tfor(let i=0;i<arr.length-1;i++){\n\t \t\tfor(let j=0;j<arr.length-i-1;j++){\n\t \t\t\tif(arr[j]>arr[j+1]){\n\t \t\t\t\tlet tmp=arr[j];\n\t \t\t\t\tarr[j]=arr[j+1];\n\t \t\t\t\tarr[j+1]=tmp;\n\t \t\t\t}\n\t \t\t}\n\t \t}\n\t \treturn arr;\n\t }\n\t res=mp(array);\n\t console.log('冒泡排序：',res);\n```\n### 快速排序\n\n> #####算法思想：\n\t1. 选出一个基准数，一般为第一个元素。\n\t2. 比较后边的所有数值，大的放右边，小的放左边（也就是一趟之后，将排序的数据分成两块，一部分是比基准数都小的，一部分是比基准数都大的）。\n\t3. 最后分别对两块数据进行重复1、2步骤。（递归进行）。\n#### 时间复杂度：O(nlogn) \n##### 代码实现：\n```javascript\n\tfunction kp(arr,left,right){\n\t\tif(left<right){\n\t\t\tlet mid=q(arr,left,right);\n\t\t\tkp(arr,mid+1,right);\n\t\t\tkp(arr,left,mid-1);\n\t\t}\n\t}\n\tfunction q(arr,left,right){\n\t\tlet tmp=arr[left];\n\t\twhile(left<right){\n\t\t\twhile(left<right&&tmp<=arr[right]){\t//从右开始找\n\t\t\t\tright=right-1;\n\t\t\t}\n\t\t\tarr[left]=arr[right];\t//找到比基准数小的放到左边\n\t\t\twhile(left<right&&tmp>=arr[left]){\t//从左开始找\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tarr[right]=arr[left];\t//找到比基准数大的放到右边\n\t\t}\n\t\tarr[left]=tmp;\t\t//将基准数放到中间\n\t\treturn left;\n\t}\n\tkp(array,0,array.length-1);\n\tconsole.log('快速排序：',array);\n```\n\n### 选择排序\n\n> #####算法思想：\n\t每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。\n#### 时间复杂度：O(n^2) \n##### 代码实现：\n```javascript\n\tfunction xz(arr){\n\t\tfor(let i=0;i<arr.length;i++){\n\t\t\tlet min = i;\n\t\t\tfor(let j=i+1;j<arr.length;j++){\n\t\t\t\tif(arr[j]<arr[min]){\n\t\t\t\t\tmin=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min!=i){\n\t\t\t\tlet tmp=arr[i];\n\t\t\t\tarr[i]=arr[min];\n\t\t\t\tarr[min]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\txz(array);\n\tconsole.log('选择排序：',array);\n```\n\n### 插入排序\n\n> #####算法思想：\n\t输入一个元素，检查数组列表中的每个元素，将其插入到一个已经排好序的数列中的适当位置，使数列依然有序，当最后一个元素放入合适位置时，该数组排序完毕。\n#### 时间复杂度：O(n^2) \n##### 代码实现：\n```javascript\n\tfunction cr(arr){\n\t\tfor(let i=1;i<arr.length;i++){\n\t\t\tlet tmp=arr[i];\n\t\t\tlet j=i-1;\n\t\t\twhile(j>=0&&tmp<arr[j]){\n\t\t\t\tarr[j+1]=arr[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tarr[j+1]=tmp;\n\t\t}\n\t}\n\tcr(array);\n\tconsole.log('插入排序：',array);\n```\n\n","slug":"常见的排序算法","published":1,"updated":"2024-02-19T07:42:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrid006o1xop3w5a9b9o","content":"<h1 id=\"运用js实现简单的几种排序算法\"><a href=\"#运用js实现简单的几种排序算法\" class=\"headerlink\" title=\"运用js实现简单的几种排序算法\"></a>运用js实现简单的几种排序算法</h1><h4 id=\"时间复杂度排序：\"><a href=\"#时间复杂度排序：\" class=\"headerlink\" title=\"时间复杂度排序：\"></a>时间复杂度排序：</h4><p><img src=\"/2018/10/01/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9a8c68df405b4ae980c7a100d9395d26.png\" alt></p>\n<h5 id=\"如何分析时间复杂度\"><a href=\"#如何分析时间复杂度\" class=\"headerlink\" title=\"如何分析时间复杂度\"></a>如何分析时间复杂度</h5><ol>\n<li><p>只关注循环执行次数最多的一段代码。</p>\n<blockquote>\n<p>大o这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p>\n</blockquote>\n</li>\n<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度。</p>\n</li>\n<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</p>\n</li>\n</ol>\n<h5 id=\"最好、最坏、平均、均摊时间复杂度\"><a href=\"#最好、最坏、平均、均摊时间复杂度\" class=\"headerlink\" title=\"最好、最坏、平均、均摊时间复杂度\"></a>最好、最坏、平均、均摊时间复杂度</h5><ol>\n<li>最好时间复杂度：在最理想的情况下所执行代码的时间复杂度。</li>\n<li>最坏时间复杂度：在最糟糕的情况下所执行代码的时间复杂度。</li>\n<li>平均时间复杂度：加权平均时间复杂度。</li>\n<li>均摊时间复杂度：看能否将最高时间复杂度的那次操作平摊到其他那些时间复杂度比较低的操作上。一般均摊时间复杂度就等于最好情况时间复杂度。</li>\n</ol>\n<h3 id=\"二分查找-折半查找\"><a href=\"#二分查找-折半查找\" class=\"headerlink\" title=\"二分查找(折半查找)\"></a>二分查找(折半查找)</h3><blockquote>\n<p>#####算法思想：<br>    搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br><strong><em>注意：查找必须是大小排好序的</em></strong></p>\n</blockquote>\n<h4 id=\"时间复杂度：O-log2n\"><a href=\"#时间复杂度：O-log2n\" class=\"headerlink\" title=\"时间复杂度：O(log2n)\"></a>时间复杂度：O(log2n)</h4><h5 id=\"代码实现：\"><a href=\"#代码实现：\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">let</span> arr<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">erfen</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">let</span> left<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">let</span> right<span class=\"token operator\">=</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;=</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">let</span> mid<span class=\"token operator\">=</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">+</span>right<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">></span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                 left<span class=\"token operator\">=</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>val<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                 right<span class=\"token operator\">=</span>mid<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n             <span class=\"token punctuation\">}</span>\n         <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> res<span class=\"token operator\">=</span><span class=\"token function\">erfen</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'二分查找：'</span><span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>#####算法思想：</p>\n<pre><code>1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 \n</code></pre></blockquote>\n<h4 id=\"时间复杂度：O-n-2\"><a href=\"#时间复杂度：O-n-2\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-1\"><a href=\"#代码实现：-1\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">function</span> <span class=\"token function\">mp</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n             <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                     <span class=\"token keyword\">let</span> tmp<span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                     arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                     arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>tmp<span class=\"token punctuation\">;</span>\n                 <span class=\"token punctuation\">}</span>\n             <span class=\"token punctuation\">}</span>\n         <span class=\"token punctuation\">}</span>\n         <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n     res<span class=\"token operator\">=</span><span class=\"token function\">mp</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'冒泡排序：'</span><span class=\"token punctuation\">,</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><blockquote>\n<p>#####算法思想：</p>\n<pre><code>1. 选出一个基准数，一般为第一个元素。\n2. 比较后边的所有数值，大的放右边，小的放左边（也就是一趟之后，将排序的数据分成两块，一部分是比基准数都小的，一部分是比基准数都大的）。\n3. 最后分别对两块数据进行重复1、2步骤。（递归进行）。\n</code></pre></blockquote>\n<h4 id=\"时间复杂度：O-nlogn\"><a href=\"#时间复杂度：O-nlogn\" class=\"headerlink\" title=\"时间复杂度：O(nlogn)\"></a>时间复杂度：O(nlogn)</h4><h5 id=\"代码实现：-2\"><a href=\"#代码实现：-2\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">function</span> <span class=\"token function\">kp</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> mid<span class=\"token operator\">=</span><span class=\"token function\">q</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">kp</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">kp</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">,</span>mid<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">q</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span>left<span class=\"token punctuation\">,</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> tmp<span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>tmp<span class=\"token operator\">&lt;=</span>arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//从右开始找</span>\n                right<span class=\"token operator\">=</span>right<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//找到比基准数小的放到左边</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;</span>right<span class=\"token operator\">&amp;&amp;</span>tmp<span class=\"token operator\">>=</span>arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//从左开始找</span>\n                left<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            arr<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//找到比基准数大的放到右边</span>\n        <span class=\"token punctuation\">}</span>\n        arr<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>tmp<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">//将基准数放到中间</span>\n        <span class=\"token keyword\">return</span> left<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">kp</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">.</span>length<span class=\"token number\">-1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'快速排序：'</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>#####算法思想：<br>    每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p>\n</blockquote>\n<h4 id=\"时间复杂度：O-n-2-1\"><a href=\"#时间复杂度：O-n-2-1\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-3\"><a href=\"#代码实现：-3\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">function</span> <span class=\"token function\">xz</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> min <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j<span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    min<span class=\"token operator\">=</span>j<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>min<span class=\"token operator\">!=</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">let</span> tmp<span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>tmp<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">xz</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'选择排序：'</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><blockquote>\n<p>#####算法思想：<br>    输入一个元素，检查数组列表中的每个元素，将其插入到一个已经排好序的数列中的适当位置，使数列依然有序，当最后一个元素放入合适位置时，该数组排序完毕。</p>\n</blockquote>\n<h4 id=\"时间复杂度：O-n-2-2\"><a href=\"#时间复杂度：O-n-2-2\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-4\"><a href=\"#代码实现：-4\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\">    <span class=\"token keyword\">function</span> <span class=\"token function\">cr</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> tmp<span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">let</span> j<span class=\"token operator\">=</span>i<span class=\"token number\">-1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token operator\">&amp;&amp;</span>tmp<span class=\"token operator\">&lt;</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>tmp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">cr</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'插入排序：'</span><span class=\"token punctuation\">,</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"运用js实现简单的几种排序算法\"><a href=\"#运用js实现简单的几种排序算法\" class=\"headerlink\" title=\"运用js实现简单的几种排序算法\"></a>运用js实现简单的几种排序算法</h1><h4 id=\"时间复杂度排序：\"><a href=\"#时间复杂度排序：\" class=\"headerlink\" title=\"时间复杂度排序：\"></a>时间复杂度排序：</h4><p><img src=\"/2018/10/01/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/9a8c68df405b4ae980c7a100d9395d26.png\" alt></p>\n<h5 id=\"如何分析时间复杂度\"><a href=\"#如何分析时间复杂度\" class=\"headerlink\" title=\"如何分析时间复杂度\"></a>如何分析时间复杂度</h5><ol>\n<li><p>只关注循环执行次数最多的一段代码。</p>\n<blockquote>\n<p>大o这种复杂度表示方法只是表示一种变化趋势，我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p>\n</blockquote>\n</li>\n<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度。</p>\n</li>\n<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</p>\n</li>\n</ol>\n<h5 id=\"最好、最坏、平均、均摊时间复杂度\"><a href=\"#最好、最坏、平均、均摊时间复杂度\" class=\"headerlink\" title=\"最好、最坏、平均、均摊时间复杂度\"></a>最好、最坏、平均、均摊时间复杂度</h5><ol>\n<li>最好时间复杂度：在最理想的情况下所执行代码的时间复杂度。</li>\n<li>最坏时间复杂度：在最糟糕的情况下所执行代码的时间复杂度。</li>\n<li>平均时间复杂度：加权平均时间复杂度。</li>\n<li>均摊时间复杂度：看能否将最高时间复杂度的那次操作平摊到其他那些时间复杂度比较低的操作上。一般均摊时间复杂度就等于最好情况时间复杂度。</li>\n</ol>\n<h3 id=\"二分查找-折半查找\"><a href=\"#二分查找-折半查找\" class=\"headerlink\" title=\"二分查找(折半查找)\"></a>二分查找(折半查找)</h3><blockquote>\n<p>#####算法思想：<br>    搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br><strong><em>注意：查找必须是大小排好序的</em></strong></p>\n</blockquote>\n<h4 id=\"时间复杂度：O-log2n\"><a href=\"#时间复杂度：O-log2n\" class=\"headerlink\" title=\"时间复杂度：O(log2n)\"></a>时间复杂度：O(log2n)</h4><h5 id=\"代码实现：\"><a href=\"#代码实现：\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre><code class=\"javascript\">    let arr=[1,2,3,4,5,6,7,8,9];\n    function erfen(arr,val){\n         let left=0;\n         let right=arr.length-1;\n         while(left&lt;=right){\n             let mid=parseInt((left+right)/2);\n             if(val&gt;arr[mid]){\n                 left=mid+1;\n             }else if(val&lt;arr[mid]){\n                 right=mid-1;\n             }else{\n                 return mid;\n             }\n         }\n    }\n    let res=erfen(arr,1);\n    console.log(&#39;二分查找：&#39;,res);\n</code></pre>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><blockquote>\n<p>#####算法思想：</p>\n<pre><code>1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 \n</code></pre></blockquote>\n<h4 id=\"时间复杂度：O-n-2\"><a href=\"#时间复杂度：O-n-2\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-1\"><a href=\"#代码实现：-1\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre><code class=\"javascript\">    function mp(arr){\n         for(let i=0;i&lt;arr.length-1;i++){\n             for(let j=0;j&lt;arr.length-i-1;j++){\n                 if(arr[j]&gt;arr[j+1]){\n                     let tmp=arr[j];\n                     arr[j]=arr[j+1];\n                     arr[j+1]=tmp;\n                 }\n             }\n         }\n         return arr;\n     }\n     res=mp(array);\n     console.log(&#39;冒泡排序：&#39;,res);\n</code></pre>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><blockquote>\n<p>#####算法思想：</p>\n<pre><code>1. 选出一个基准数，一般为第一个元素。\n2. 比较后边的所有数值，大的放右边，小的放左边（也就是一趟之后，将排序的数据分成两块，一部分是比基准数都小的，一部分是比基准数都大的）。\n3. 最后分别对两块数据进行重复1、2步骤。（递归进行）。\n</code></pre></blockquote>\n<h4 id=\"时间复杂度：O-nlogn\"><a href=\"#时间复杂度：O-nlogn\" class=\"headerlink\" title=\"时间复杂度：O(nlogn)\"></a>时间复杂度：O(nlogn)</h4><h5 id=\"代码实现：-2\"><a href=\"#代码实现：-2\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre><code class=\"javascript\">    function kp(arr,left,right){\n        if(left&lt;right){\n            let mid=q(arr,left,right);\n            kp(arr,mid+1,right);\n            kp(arr,left,mid-1);\n        }\n    }\n    function q(arr,left,right){\n        let tmp=arr[left];\n        while(left&lt;right){\n            while(left&lt;right&amp;&amp;tmp&lt;=arr[right]){    //从右开始找\n                right=right-1;\n            }\n            arr[left]=arr[right];    //找到比基准数小的放到左边\n            while(left&lt;right&amp;&amp;tmp&gt;=arr[left]){    //从左开始找\n                left++;\n            }\n            arr[right]=arr[left];    //找到比基准数大的放到右边\n        }\n        arr[left]=tmp;        //将基准数放到中间\n        return left;\n    }\n    kp(array,0,array.length-1);\n    console.log(&#39;快速排序：&#39;,array);\n</code></pre>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><blockquote>\n<p>#####算法思想：<br>    每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p>\n</blockquote>\n<h4 id=\"时间复杂度：O-n-2-1\"><a href=\"#时间复杂度：O-n-2-1\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-3\"><a href=\"#代码实现：-3\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre><code class=\"javascript\">    function xz(arr){\n        for(let i=0;i&lt;arr.length;i++){\n            let min = i;\n            for(let j=i+1;j&lt;arr.length;j++){\n                if(arr[j]&lt;arr[min]){\n                    min=j;\n                }\n            }\n            if(min!=i){\n                let tmp=arr[i];\n                arr[i]=arr[min];\n                arr[min]=tmp;\n            }\n        }\n    }\n    xz(array);\n    console.log(&#39;选择排序：&#39;,array);\n</code></pre>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><blockquote>\n<p>#####算法思想：<br>    输入一个元素，检查数组列表中的每个元素，将其插入到一个已经排好序的数列中的适当位置，使数列依然有序，当最后一个元素放入合适位置时，该数组排序完毕。</p>\n</blockquote>\n<h4 id=\"时间复杂度：O-n-2-2\"><a href=\"#时间复杂度：O-n-2-2\" class=\"headerlink\" title=\"时间复杂度：O(n^2)\"></a>时间复杂度：O(n^2)</h4><h5 id=\"代码实现：-4\"><a href=\"#代码实现：-4\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h5><pre><code class=\"javascript\">    function cr(arr){\n        for(let i=1;i&lt;arr.length;i++){\n            let tmp=arr[i];\n            let j=i-1;\n            while(j&gt;=0&amp;&amp;tmp&lt;arr[j]){\n                arr[j+1]=arr[j];\n                j--;\n            }\n            arr[j+1]=tmp;\n        }\n    }\n    cr(array);\n    console.log(&#39;插入排序：&#39;,array);\n</code></pre>\n"},{"title":"观察者模式","date":"2020-08-11T01:58:16.000Z","_content":"\n### **观察者模式**\n\n\n\n- **观察者（订阅者）** -- Watcher\n  - ​\tupdate()：当事件发生时，具体要做的事情\n- **目标（发布者）**--Dep\n  - subs数组：存储所有的观察者\n  - addSub()：添加观察者\n  - notify()：当事件发生，调用所有观察者的update()方法\n- **没有事件中心**\n\n\n\n```js\n// 发布者\nclass Dep {\n\tconstructor() {\n\t\tthis.subs = []\n\t}\n\t// 添加观察者\n\taddSub(sub) {\n\t\tif (sub && sub.update) {\n\t\t\tthis.subs.push(sub)\n\t\t}\n\t}\n\n\tnotify() {\n\t\tthis.subs.forEach(sub => sub.update())\n\t}\n}\n// 观察者\nclass Watcher {\n\tupdate() {\n\t\tconsole.log('update')\n\t}\n}\n```\n\n","source":"_posts/观察者模式.md","raw":"---\ntitle: 观察者模式\ndate: 2020-08-11 09:58:16\ntags: 设计模式\ncategories: 前端\n---\n\n### **观察者模式**\n\n\n\n- **观察者（订阅者）** -- Watcher\n  - ​\tupdate()：当事件发生时，具体要做的事情\n- **目标（发布者）**--Dep\n  - subs数组：存储所有的观察者\n  - addSub()：添加观察者\n  - notify()：当事件发生，调用所有观察者的update()方法\n- **没有事件中心**\n\n\n\n```js\n// 发布者\nclass Dep {\n\tconstructor() {\n\t\tthis.subs = []\n\t}\n\t// 添加观察者\n\taddSub(sub) {\n\t\tif (sub && sub.update) {\n\t\t\tthis.subs.push(sub)\n\t\t}\n\t}\n\n\tnotify() {\n\t\tthis.subs.forEach(sub => sub.update())\n\t}\n}\n// 观察者\nclass Watcher {\n\tupdate() {\n\t\tconsole.log('update')\n\t}\n}\n```\n\n","slug":"观察者模式","published":1,"updated":"2024-02-19T07:42:51.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrie006r1xop987vdfwm","content":"<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a><strong>观察者模式</strong></h3><ul>\n<li><strong>观察者（订阅者）</strong> – Watcher<ul>\n<li>​    update()：当事件发生时，具体要做的事情</li>\n</ul>\n</li>\n<li><strong>目标（发布者）</strong>–Dep<ul>\n<li>subs数组：存储所有的观察者</li>\n<li>addSub()：添加观察者</li>\n<li>notify()：当事件发生，调用所有观察者的update()方法</li>\n</ul>\n</li>\n<li><strong>没有事件中心</strong></li>\n</ul>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\"><span class=\"token comment\" spellcheck=\"true\">// 发布者</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Dep</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 添加观察者</span>\n    <span class=\"token function\">addSub</span><span class=\"token punctuation\">(</span>sub<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sub <span class=\"token operator\">&amp;&amp;</span> sub<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>sub<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">notify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>subs<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>sub <span class=\"token operator\">=</span><span class=\"token operator\">></span> sub<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 观察者</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Watcher</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'update'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a><strong>观察者模式</strong></h3><ul>\n<li><strong>观察者（订阅者）</strong> – Watcher<ul>\n<li>​    update()：当事件发生时，具体要做的事情</li>\n</ul>\n</li>\n<li><strong>目标（发布者）</strong>–Dep<ul>\n<li>subs数组：存储所有的观察者</li>\n<li>addSub()：添加观察者</li>\n<li>notify()：当事件发生，调用所有观察者的update()方法</li>\n</ul>\n</li>\n<li><strong>没有事件中心</strong></li>\n</ul>\n<pre><code class=\"js\">// 发布者\nclass Dep {\n    constructor() {\n        this.subs = []\n    }\n    // 添加观察者\n    addSub(sub) {\n        if (sub &amp;&amp; sub.update) {\n            this.subs.push(sub)\n        }\n    }\n\n    notify() {\n        this.subs.forEach(sub =&gt; sub.update())\n    }\n}\n// 观察者\nclass Watcher {\n    update() {\n        console.log(&#39;update&#39;)\n    }\n}\n</code></pre>\n"},{"title":"计算机网络","date":"2018-10-16T04:43:15.000Z","_content":"\n### 计算机网络\n\n##### 网络互连的设备\n\n中间设备有称为中间系统或中继系统。\n\n- 物理层中继系统：转发器。\n- 数据链路层中继系统：网桥或桥接器。\n- 网络层中继系统：路由器。\n- 网络层以上的的中继系统：网关。\n\n##### 计算机数据交换方式：\n\n1. 电路交换\n\n   步骤：建立连接、通话、释放连接。\n\n   特点：面向连接、通话过程中一直占用资源。\n\n2. 报文交换\n\n   特点：报文比分组长、时延较长。\n\n3. 分组交换\n\n   特点：将数据拆分成一块一块的发送、不需要建立特定的路线。\n\n   优点：高效，灵活，迅速，可靠。\n\n   缺点：时延。开销。\n\n##### 计算机网络的性能：\n\n1. 速率：连接在计算机网络上的主机在数字信道上传送数据位数的速率。\n\n2. 带宽：数据通信领域中，数字信道所能传送的最高数据率。\n\n3. 吞吐量：单位时间内通过某个网络的数据量。\n\n4. 时延：分为发送时延、传播时延、处理时延、排队时延等。\n\n   > 发送时延=数据块长度（比特）/信道带宽（比特/秒）\n   >\n   > 信道时延=信道长度/信号在信道上的传播速率\n   >\n   > 处理时延=网络节点存储转发处理时间\n\n5. 利用率：信道利用率、网络利用率。\n\n##### OSI参考模型：\n\n1. 应用层：能够产生网络流量能够和用户交互的应用程序\n2. 表示层：加密、压缩 （开发人员考虑的问题）\n3. 会话层：服务和客户端建立的会话\n4. 传输层： 可靠传输（建立会话）、不可靠传输、流量控制\n5. 网络层：IP地址编址、选择最佳路径\n6. 数据链路层：数据如何封装、添加物理地址(MAC)\n7. 物理层：规定电压、接口标准等\n\n##### 物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n\n- 机械特性：接口形状，大小，阴线数目\n- 电气特性：规定电压范围\n- 功能特性：例规定-5V表示0，+5V表示1\n- 过程特性：规定建立连接时，各个相关部件的工作步骤\n\n**频分复用（FDM）：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。**\n\n**时分复用：用户在不同的时间占用同样的频带宽度。**\n\n**码分复用：分割成码片序列**\n\n​\t任何一个码片向量和该码片向量自己的规格化内积都是1。\n\n​\t一个码片向量和该码片反码的向量的规格化内积值是-1。\n\n​\t**公式：**\n\n![](计算机网络/8b9c50964095160480f00995d28b8ac3.png)\n\n![](计算机网络/ffd0bea740c395d2807ae91fd1a27a4f.png)\n\n##### 数据链路层\n\n1. 封装成帧\n\n   > 封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。\n   >\n   > 首部和尾部的一个重要作用就是进行帧的定界。\n   >\n   > ![](计算机网络/a5edd4d540ed8572803058f6a9f0c854.png)\n   >\n   > MTU：每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元（MTU）。\n\n2. 可靠传输\n\n   > 保证数据的完整一致性，即发送端发送什么，在对应的接收端就能收到什么。\n\n3. 差错检验\n\n   > 在传输过程中可能会产生比特差错：1变成0，0变成1等。\n   >\n   > 在一段时间内，传输错误的比特所占传输比特总数的比率称为误码率（BER）。\n   >\n   > - ##### 循环冗余检验（CRC）\n\n##### 网络层\n\n1. 网际协议（IP）\n\n   IP层次结构：层次IP地址将32位的IP地址分为网络ID和主机ID。\n\n   IP地址的分类\n\n   ![](计算机网络/e0e0be624093114e805cd93918b993b9.png)\n\n   **子网掩码：又叫做网络掩码，它是一种用来指明IP地址的哪些位标识的是IP地址，哪些位是主机部分。**\n\n2. 地址解析协议（ARP）：\n\n3. 网际控制报文协议（ICMP）：\n\n4. 网际组管理协议（IGMP）：\n\n##### 运输层\n\n##### 应用层","source":"_posts/计算机网络.md","raw":"---\ntitle: 计算机网络\ndate: 2018-10-16 12:43:15\ntags: 计算机网络\ncategories: 计算机网络\n---\n\n### 计算机网络\n\n##### 网络互连的设备\n\n中间设备有称为中间系统或中继系统。\n\n- 物理层中继系统：转发器。\n- 数据链路层中继系统：网桥或桥接器。\n- 网络层中继系统：路由器。\n- 网络层以上的的中继系统：网关。\n\n##### 计算机数据交换方式：\n\n1. 电路交换\n\n   步骤：建立连接、通话、释放连接。\n\n   特点：面向连接、通话过程中一直占用资源。\n\n2. 报文交换\n\n   特点：报文比分组长、时延较长。\n\n3. 分组交换\n\n   特点：将数据拆分成一块一块的发送、不需要建立特定的路线。\n\n   优点：高效，灵活，迅速，可靠。\n\n   缺点：时延。开销。\n\n##### 计算机网络的性能：\n\n1. 速率：连接在计算机网络上的主机在数字信道上传送数据位数的速率。\n\n2. 带宽：数据通信领域中，数字信道所能传送的最高数据率。\n\n3. 吞吐量：单位时间内通过某个网络的数据量。\n\n4. 时延：分为发送时延、传播时延、处理时延、排队时延等。\n\n   > 发送时延=数据块长度（比特）/信道带宽（比特/秒）\n   >\n   > 信道时延=信道长度/信号在信道上的传播速率\n   >\n   > 处理时延=网络节点存储转发处理时间\n\n5. 利用率：信道利用率、网络利用率。\n\n##### OSI参考模型：\n\n1. 应用层：能够产生网络流量能够和用户交互的应用程序\n2. 表示层：加密、压缩 （开发人员考虑的问题）\n3. 会话层：服务和客户端建立的会话\n4. 传输层： 可靠传输（建立会话）、不可靠传输、流量控制\n5. 网络层：IP地址编址、选择最佳路径\n6. 数据链路层：数据如何封装、添加物理地址(MAC)\n7. 物理层：规定电压、接口标准等\n\n##### 物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\n\n- 机械特性：接口形状，大小，阴线数目\n- 电气特性：规定电压范围\n- 功能特性：例规定-5V表示0，+5V表示1\n- 过程特性：规定建立连接时，各个相关部件的工作步骤\n\n**频分复用（FDM）：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。**\n\n**时分复用：用户在不同的时间占用同样的频带宽度。**\n\n**码分复用：分割成码片序列**\n\n​\t任何一个码片向量和该码片向量自己的规格化内积都是1。\n\n​\t一个码片向量和该码片反码的向量的规格化内积值是-1。\n\n​\t**公式：**\n\n![](计算机网络/8b9c50964095160480f00995d28b8ac3.png)\n\n![](计算机网络/ffd0bea740c395d2807ae91fd1a27a4f.png)\n\n##### 数据链路层\n\n1. 封装成帧\n\n   > 封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。\n   >\n   > 首部和尾部的一个重要作用就是进行帧的定界。\n   >\n   > ![](计算机网络/a5edd4d540ed8572803058f6a9f0c854.png)\n   >\n   > MTU：每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元（MTU）。\n\n2. 可靠传输\n\n   > 保证数据的完整一致性，即发送端发送什么，在对应的接收端就能收到什么。\n\n3. 差错检验\n\n   > 在传输过程中可能会产生比特差错：1变成0，0变成1等。\n   >\n   > 在一段时间内，传输错误的比特所占传输比特总数的比率称为误码率（BER）。\n   >\n   > - ##### 循环冗余检验（CRC）\n\n##### 网络层\n\n1. 网际协议（IP）\n\n   IP层次结构：层次IP地址将32位的IP地址分为网络ID和主机ID。\n\n   IP地址的分类\n\n   ![](计算机网络/e0e0be624093114e805cd93918b993b9.png)\n\n   **子网掩码：又叫做网络掩码，它是一种用来指明IP地址的哪些位标识的是IP地址，哪些位是主机部分。**\n\n2. 地址解析协议（ARP）：\n\n3. 网际控制报文协议（ICMP）：\n\n4. 网际组管理协议（IGMP）：\n\n##### 运输层\n\n##### 应用层","slug":"计算机网络","published":1,"updated":"2024-02-19T07:42:51.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrif006w1xop7lipa19u","content":"<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><h5 id=\"网络互连的设备\"><a href=\"#网络互连的设备\" class=\"headerlink\" title=\"网络互连的设备\"></a>网络互连的设备</h5><p>中间设备有称为中间系统或中继系统。</p>\n<ul>\n<li>物理层中继系统：转发器。</li>\n<li>数据链路层中继系统：网桥或桥接器。</li>\n<li>网络层中继系统：路由器。</li>\n<li>网络层以上的的中继系统：网关。</li>\n</ul>\n<h5 id=\"计算机数据交换方式：\"><a href=\"#计算机数据交换方式：\" class=\"headerlink\" title=\"计算机数据交换方式：\"></a>计算机数据交换方式：</h5><ol>\n<li><p>电路交换</p>\n<p>步骤：建立连接、通话、释放连接。</p>\n<p>特点：面向连接、通话过程中一直占用资源。</p>\n</li>\n<li><p>报文交换</p>\n<p>特点：报文比分组长、时延较长。</p>\n</li>\n<li><p>分组交换</p>\n<p>特点：将数据拆分成一块一块的发送、不需要建立特定的路线。</p>\n<p>优点：高效，灵活，迅速，可靠。</p>\n<p>缺点：时延。开销。</p>\n</li>\n</ol>\n<h5 id=\"计算机网络的性能：\"><a href=\"#计算机网络的性能：\" class=\"headerlink\" title=\"计算机网络的性能：\"></a>计算机网络的性能：</h5><ol>\n<li><p>速率：连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p>\n</li>\n<li><p>带宽：数据通信领域中，数字信道所能传送的最高数据率。</p>\n</li>\n<li><p>吞吐量：单位时间内通过某个网络的数据量。</p>\n</li>\n<li><p>时延：分为发送时延、传播时延、处理时延、排队时延等。</p>\n<blockquote>\n<p>发送时延=数据块长度（比特）/信道带宽（比特/秒）</p>\n<p>信道时延=信道长度/信号在信道上的传播速率</p>\n<p>处理时延=网络节点存储转发处理时间</p>\n</blockquote>\n</li>\n<li><p>利用率：信道利用率、网络利用率。</p>\n</li>\n</ol>\n<h5 id=\"OSI参考模型：\"><a href=\"#OSI参考模型：\" class=\"headerlink\" title=\"OSI参考模型：\"></a>OSI参考模型：</h5><ol>\n<li>应用层：能够产生网络流量能够和用户交互的应用程序</li>\n<li>表示层：加密、压缩 （开发人员考虑的问题）</li>\n<li>会话层：服务和客户端建立的会话</li>\n<li>传输层： 可靠传输（建立会话）、不可靠传输、流量控制</li>\n<li>网络层：IP地址编址、选择最佳路径</li>\n<li>数据链路层：数据如何封装、添加物理地址(MAC)</li>\n<li>物理层：规定电压、接口标准等</li>\n</ol>\n<h5 id=\"物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\"><a href=\"#物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\" class=\"headerlink\" title=\"物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\"></a>物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</h5><ul>\n<li>机械特性：接口形状，大小，阴线数目</li>\n<li>电气特性：规定电压范围</li>\n<li>功能特性：例规定-5V表示0，+5V表示1</li>\n<li>过程特性：规定建立连接时，各个相关部件的工作步骤</li>\n</ul>\n<p><strong>频分复用（FDM）：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</strong></p>\n<p><strong>时分复用：用户在不同的时间占用同样的频带宽度。</strong></p>\n<p><strong>码分复用：分割成码片序列</strong></p>\n<p>​    任何一个码片向量和该码片向量自己的规格化内积都是1。</p>\n<p>​    一个码片向量和该码片反码的向量的规格化内积值是-1。</p>\n<p>​    <strong>公式：</strong></p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8b9c50964095160480f00995d28b8ac3.png\" alt></p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ffd0bea740c395d2807ae91fd1a27a4f.png\" alt></p>\n<h5 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h5><ol>\n<li><p>封装成帧</p>\n<blockquote>\n<p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p>\n<p>首部和尾部的一个重要作用就是进行帧的定界。</p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/a5edd4d540ed8572803058f6a9f0c854.png\" alt></p>\n<p>MTU：每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元（MTU）。</p>\n</blockquote>\n</li>\n<li><p>可靠传输</p>\n<blockquote>\n<p>保证数据的完整一致性，即发送端发送什么，在对应的接收端就能收到什么。</p>\n</blockquote>\n</li>\n<li><p>差错检验</p>\n<blockquote>\n<p>在传输过程中可能会产生比特差错：1变成0，0变成1等。</p>\n<p>在一段时间内，传输错误的比特所占传输比特总数的比率称为误码率（BER）。</p>\n<ul>\n<li><h5 id=\"循环冗余检验（CRC）\"><a href=\"#循环冗余检验（CRC）\" class=\"headerlink\" title=\"循环冗余检验（CRC）\"></a>循环冗余检验（CRC）</h5></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h5><ol>\n<li><p>网际协议（IP）</p>\n<p>IP层次结构：层次IP地址将32位的IP地址分为网络ID和主机ID。</p>\n<p>IP地址的分类</p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/e0e0be624093114e805cd93918b993b9.png\" alt></p>\n<p><strong>子网掩码：又叫做网络掩码，它是一种用来指明IP地址的哪些位标识的是IP地址，哪些位是主机部分。</strong></p>\n</li>\n<li><p>地址解析协议（ARP）：</p>\n</li>\n<li><p>网际控制报文协议（ICMP）：</p>\n</li>\n<li><p>网际组管理协议（IGMP）：</p>\n</li>\n</ol>\n<h5 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h5><h5 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h3><h5 id=\"网络互连的设备\"><a href=\"#网络互连的设备\" class=\"headerlink\" title=\"网络互连的设备\"></a>网络互连的设备</h5><p>中间设备有称为中间系统或中继系统。</p>\n<ul>\n<li>物理层中继系统：转发器。</li>\n<li>数据链路层中继系统：网桥或桥接器。</li>\n<li>网络层中继系统：路由器。</li>\n<li>网络层以上的的中继系统：网关。</li>\n</ul>\n<h5 id=\"计算机数据交换方式：\"><a href=\"#计算机数据交换方式：\" class=\"headerlink\" title=\"计算机数据交换方式：\"></a>计算机数据交换方式：</h5><ol>\n<li><p>电路交换</p>\n<p>步骤：建立连接、通话、释放连接。</p>\n<p>特点：面向连接、通话过程中一直占用资源。</p>\n</li>\n<li><p>报文交换</p>\n<p>特点：报文比分组长、时延较长。</p>\n</li>\n<li><p>分组交换</p>\n<p>特点：将数据拆分成一块一块的发送、不需要建立特定的路线。</p>\n<p>优点：高效，灵活，迅速，可靠。</p>\n<p>缺点：时延。开销。</p>\n</li>\n</ol>\n<h5 id=\"计算机网络的性能：\"><a href=\"#计算机网络的性能：\" class=\"headerlink\" title=\"计算机网络的性能：\"></a>计算机网络的性能：</h5><ol>\n<li><p>速率：连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p>\n</li>\n<li><p>带宽：数据通信领域中，数字信道所能传送的最高数据率。</p>\n</li>\n<li><p>吞吐量：单位时间内通过某个网络的数据量。</p>\n</li>\n<li><p>时延：分为发送时延、传播时延、处理时延、排队时延等。</p>\n<blockquote>\n<p>发送时延=数据块长度（比特）/信道带宽（比特/秒）</p>\n<p>信道时延=信道长度/信号在信道上的传播速率</p>\n<p>处理时延=网络节点存储转发处理时间</p>\n</blockquote>\n</li>\n<li><p>利用率：信道利用率、网络利用率。</p>\n</li>\n</ol>\n<h5 id=\"OSI参考模型：\"><a href=\"#OSI参考模型：\" class=\"headerlink\" title=\"OSI参考模型：\"></a>OSI参考模型：</h5><ol>\n<li>应用层：能够产生网络流量能够和用户交互的应用程序</li>\n<li>表示层：加密、压缩 （开发人员考虑的问题）</li>\n<li>会话层：服务和客户端建立的会话</li>\n<li>传输层： 可靠传输（建立会话）、不可靠传输、流量控制</li>\n<li>网络层：IP地址编址、选择最佳路径</li>\n<li>数据链路层：数据如何封装、添加物理地址(MAC)</li>\n<li>物理层：规定电压、接口标准等</li>\n</ol>\n<h5 id=\"物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\"><a href=\"#物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\" class=\"headerlink\" title=\"物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。\"></a>物理层：解决如何再连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</h5><ul>\n<li>机械特性：接口形状，大小，阴线数目</li>\n<li>电气特性：规定电压范围</li>\n<li>功能特性：例规定-5V表示0，+5V表示1</li>\n<li>过程特性：规定建立连接时，各个相关部件的工作步骤</li>\n</ul>\n<p><strong>频分复用（FDM）：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</strong></p>\n<p><strong>时分复用：用户在不同的时间占用同样的频带宽度。</strong></p>\n<p><strong>码分复用：分割成码片序列</strong></p>\n<p>​    任何一个码片向量和该码片向量自己的规格化内积都是1。</p>\n<p>​    一个码片向量和该码片反码的向量的规格化内积值是-1。</p>\n<p>​    <strong>公式：</strong></p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/8b9c50964095160480f00995d28b8ac3.png\" alt></p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ffd0bea740c395d2807ae91fd1a27a4f.png\" alt></p>\n<h5 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h5><ol>\n<li><p>封装成帧</p>\n<blockquote>\n<p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p>\n<p>首部和尾部的一个重要作用就是进行帧的定界。</p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/a5edd4d540ed8572803058f6a9f0c854.png\" alt></p>\n<p>MTU：每一种链路层协议都规定了帧的数据部分长度的上限，即最大传送单元（MTU）。</p>\n</blockquote>\n</li>\n<li><p>可靠传输</p>\n<blockquote>\n<p>保证数据的完整一致性，即发送端发送什么，在对应的接收端就能收到什么。</p>\n</blockquote>\n</li>\n<li><p>差错检验</p>\n<blockquote>\n<p>在传输过程中可能会产生比特差错：1变成0，0变成1等。</p>\n<p>在一段时间内，传输错误的比特所占传输比特总数的比率称为误码率（BER）。</p>\n<ul>\n<li><h5 id=\"循环冗余检验（CRC）\"><a href=\"#循环冗余检验（CRC）\" class=\"headerlink\" title=\"循环冗余检验（CRC）\"></a>循环冗余检验（CRC）</h5></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h5><ol>\n<li><p>网际协议（IP）</p>\n<p>IP层次结构：层次IP地址将32位的IP地址分为网络ID和主机ID。</p>\n<p>IP地址的分类</p>\n<p><img src=\"/2018/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/e0e0be624093114e805cd93918b993b9.png\" alt></p>\n<p><strong>子网掩码：又叫做网络掩码，它是一种用来指明IP地址的哪些位标识的是IP地址，哪些位是主机部分。</strong></p>\n</li>\n<li><p>地址解析协议（ARP）：</p>\n</li>\n<li><p>网际控制报文协议（ICMP）：</p>\n</li>\n<li><p>网际组管理协议（IGMP）：</p>\n</li>\n</ol>\n<h5 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h5><h5 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h5>"},{"title":"跨域问题","date":"2018-10-16T09:11:56.000Z","_content":"\n### 跨域相关总结\n\n##### 为什么会产生跨域：\n\n1. 浏览器的一种安全策略。（同源策略）\n2. 域名、端口、协议任何一方如果不相同，都会产生跨域问题。\n\n##### 解决方法：\n\n1. **使用jsonp**\n\n   实现原理：通过动态创建script标签，来进行跨域数据获取。\n\n   ```javascript\n   //原生js方法\n   function getMsg(jsonData){\n       //jsonData为请求返回的json数据\n       console.log(jsonData);\n   }\n   var JSONP=document.createElement(\"script\");\n   JSONP.type=\"text/javascript\";\n   JSON.src=\"http://example.com/data.php?callback=getMsg\";  //callback回掉函数，用来让后台的数据返回到该函数中进行处理\n   document.getElementByTagName(\"head\")[0].appendChild(JSONP);\n   \n   //jquery方法\n   $.getJSON('http://example.com/data.php?callback=?',function(jsonData){\n       //处理json数据\n   })\n   ```\n\n   ```php\n   $callback= $_GET['callback']; //获取回掉函数名\n   $data=array(1,2,3);\n   echo $callback.'('.json_encode($data).')';\n   ```\n\n2. **通过修改document.domain来跨子域**\n\n   不同iframe中是可以获取到`window`对象的，但是却不能调用`window`对象的属性或方法，可以在所有的iframe中设置`document.domain`为相同的域名。\n\n   *需要注意的是，`document.domain`只能把域名设置成自身或者更高一级的父域，且主域必须相同。例如：`a.example.com`只能设置为自身或者是`example.com`，而不能设置成`b.a.example.com`。*\n\n   ```html\n   <!-- 页面 http://example.com/a.html -->\n   <iframe src=\"http://a.example.com/b.html\" id=\"iframe\" onload=\"load()\">\n   </iframe>\n   <script>\n   \tdocument.domain='example.com'; //设置域\n       function load(){\n           alert(document.getElementById('iframe').contentWindow);\n       }\n   </script>\n   <!-- 页面 http://a.example.com/b.html -->\n   <script>\n   \tdocument.domain='example.com'; //两者保持一致\n   </script>\n   ```\n\n3. **使用window.name**\n\n   `window.name`属性的特征：在一个窗口(window)的生命周期内，当前窗口载入的所有页面(甚至不同域名)都共享一个`window.name`属性的值，每个页面对`window.name`都具有读写权限，并不会因为新的页面的载入而进行重置。\n\n   ```html\n   <!-- 页面 a.html -->\n   <script>\n   \twindow.name=\"我来自页面a\";\n       setTimeout(function(){\n           window.location='b.html'\n       },1000)\n   </script>\n   \n   <!-- 页面 b.html -->\n   <script>\n   \tconsole.log(window.name); //我来自页面a\n   </script>\n   ```\n\n   *`window.name`只能设置值为字符串的形式，大小2m左右，或者更大一点，不同的浏览器规定的大小不同。*\n\n4. **使用window.postMessage方法**\n\n   `window.postMessage`方法可以安全的实现跨域通信\n\n   > 语法：`window.postMessage(message,targetOrigin,[transfer])`\n   >\n   > message：将要发送的数据。\n   >\n   > targetOrigin：指定哪些窗口可以接收到消息事件，可以是字符串\"*\"（无限制）或者一个URI。\n   >\n   > transfer（可选）：是一串和message 同时传递的 [`Transferable`](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable) 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。\n\n   ```html\n   <!-- 页面 http://a.ex.com/a.html -->\n   <script>\n       function test(){\n           var iframe = document.getElementById('iframe');\n           var win=iframe.contentWindow; \n           win.postMessage('页面a的数据啊','*');\n       }\n   </script>\n   <iframe id=\"iframe\" src=\"http://www.test.com/b.html\">\n   </iframe>\n   \n   <!-- 页面 http://www.test.com/b.html -->\n   <script>\n       window.onmessage=function(e){\n           e=e||event; //获取事件对象\n           console.log(e.data); //页面a的数据啊\n       }\n   </script>\n   ```\n\n5. **通过CORS解决AJAX跨域**\n\n   特点：服务端设置头信息，浏览器端不需要处理。\n\n   ```js\n   res.setHeader('Access-Control-Allow-Origin', \"*\"); //针对哪个域名可以访问，*表示所有\n   \n   res.setHeader('Access-Control-Allow-Credentials', true); //是否可以携带cookie\n   \n   res.setHeader('Access-Control-Allow-Methods', 'POST, GET, PUT, DELETE, OPTIONS');\n   ```\n\n6. **通过Nginx反向代理**\n\n   Nginx解决跨域问题通过Nginx反向代理将对真实服务器的请求转移到本机服务器来避免浏览器的\"同源策略限制\"。\n\n","source":"_posts/跨域问题.md","raw":"---\ntitle: 跨域问题\ndate: 2018-10-16 17:11:56\ntags: 跨域\ncategories: 前端\n---\n\n### 跨域相关总结\n\n##### 为什么会产生跨域：\n\n1. 浏览器的一种安全策略。（同源策略）\n2. 域名、端口、协议任何一方如果不相同，都会产生跨域问题。\n\n##### 解决方法：\n\n1. **使用jsonp**\n\n   实现原理：通过动态创建script标签，来进行跨域数据获取。\n\n   ```javascript\n   //原生js方法\n   function getMsg(jsonData){\n       //jsonData为请求返回的json数据\n       console.log(jsonData);\n   }\n   var JSONP=document.createElement(\"script\");\n   JSONP.type=\"text/javascript\";\n   JSON.src=\"http://example.com/data.php?callback=getMsg\";  //callback回掉函数，用来让后台的数据返回到该函数中进行处理\n   document.getElementByTagName(\"head\")[0].appendChild(JSONP);\n   \n   //jquery方法\n   $.getJSON('http://example.com/data.php?callback=?',function(jsonData){\n       //处理json数据\n   })\n   ```\n\n   ```php\n   $callback= $_GET['callback']; //获取回掉函数名\n   $data=array(1,2,3);\n   echo $callback.'('.json_encode($data).')';\n   ```\n\n2. **通过修改document.domain来跨子域**\n\n   不同iframe中是可以获取到`window`对象的，但是却不能调用`window`对象的属性或方法，可以在所有的iframe中设置`document.domain`为相同的域名。\n\n   *需要注意的是，`document.domain`只能把域名设置成自身或者更高一级的父域，且主域必须相同。例如：`a.example.com`只能设置为自身或者是`example.com`，而不能设置成`b.a.example.com`。*\n\n   ```html\n   <!-- 页面 http://example.com/a.html -->\n   <iframe src=\"http://a.example.com/b.html\" id=\"iframe\" onload=\"load()\">\n   </iframe>\n   <script>\n   \tdocument.domain='example.com'; //设置域\n       function load(){\n           alert(document.getElementById('iframe').contentWindow);\n       }\n   </script>\n   <!-- 页面 http://a.example.com/b.html -->\n   <script>\n   \tdocument.domain='example.com'; //两者保持一致\n   </script>\n   ```\n\n3. **使用window.name**\n\n   `window.name`属性的特征：在一个窗口(window)的生命周期内，当前窗口载入的所有页面(甚至不同域名)都共享一个`window.name`属性的值，每个页面对`window.name`都具有读写权限，并不会因为新的页面的载入而进行重置。\n\n   ```html\n   <!-- 页面 a.html -->\n   <script>\n   \twindow.name=\"我来自页面a\";\n       setTimeout(function(){\n           window.location='b.html'\n       },1000)\n   </script>\n   \n   <!-- 页面 b.html -->\n   <script>\n   \tconsole.log(window.name); //我来自页面a\n   </script>\n   ```\n\n   *`window.name`只能设置值为字符串的形式，大小2m左右，或者更大一点，不同的浏览器规定的大小不同。*\n\n4. **使用window.postMessage方法**\n\n   `window.postMessage`方法可以安全的实现跨域通信\n\n   > 语法：`window.postMessage(message,targetOrigin,[transfer])`\n   >\n   > message：将要发送的数据。\n   >\n   > targetOrigin：指定哪些窗口可以接收到消息事件，可以是字符串\"*\"（无限制）或者一个URI。\n   >\n   > transfer（可选）：是一串和message 同时传递的 [`Transferable`](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable) 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。\n\n   ```html\n   <!-- 页面 http://a.ex.com/a.html -->\n   <script>\n       function test(){\n           var iframe = document.getElementById('iframe');\n           var win=iframe.contentWindow; \n           win.postMessage('页面a的数据啊','*');\n       }\n   </script>\n   <iframe id=\"iframe\" src=\"http://www.test.com/b.html\">\n   </iframe>\n   \n   <!-- 页面 http://www.test.com/b.html -->\n   <script>\n       window.onmessage=function(e){\n           e=e||event; //获取事件对象\n           console.log(e.data); //页面a的数据啊\n       }\n   </script>\n   ```\n\n5. **通过CORS解决AJAX跨域**\n\n   特点：服务端设置头信息，浏览器端不需要处理。\n\n   ```js\n   res.setHeader('Access-Control-Allow-Origin', \"*\"); //针对哪个域名可以访问，*表示所有\n   \n   res.setHeader('Access-Control-Allow-Credentials', true); //是否可以携带cookie\n   \n   res.setHeader('Access-Control-Allow-Methods', 'POST, GET, PUT, DELETE, OPTIONS');\n   ```\n\n6. **通过Nginx反向代理**\n\n   Nginx解决跨域问题通过Nginx反向代理将对真实服务器的请求转移到本机服务器来避免浏览器的\"同源策略限制\"。\n\n","slug":"跨域问题","published":1,"updated":"2024-02-19T07:42:51.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrif006z1xopfnin1bwz","content":"<h3 id=\"跨域相关总结\"><a href=\"#跨域相关总结\" class=\"headerlink\" title=\"跨域相关总结\"></a>跨域相关总结</h3><h5 id=\"为什么会产生跨域：\"><a href=\"#为什么会产生跨域：\" class=\"headerlink\" title=\"为什么会产生跨域：\"></a>为什么会产生跨域：</h5><ol>\n<li>浏览器的一种安全策略。（同源策略）</li>\n<li>域名、端口、协议任何一方如果不相同，都会产生跨域问题。</li>\n</ol>\n<h5 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h5><ol>\n<li><p><strong>使用jsonp</strong></p>\n<p>实现原理：通过动态创建script标签，来进行跨域数据获取。</p>\n<pre class=\"line-numbers language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\" spellcheck=\"true\">//原生js方法</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span>jsonData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//jsonData为请求返回的json数据</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>jsonData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> JSONP<span class=\"token operator\">=</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"script\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nJSONP<span class=\"token punctuation\">.</span>type<span class=\"token operator\">=</span><span class=\"token string\">\"text/javascript\"</span><span class=\"token punctuation\">;</span>\nJSON<span class=\"token punctuation\">.</span>src<span class=\"token operator\">=</span><span class=\"token string\">\"http://example.com/data.php?callback=getMsg\"</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//callback回掉函数，用来让后台的数据返回到该函数中进行处理</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"head\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>JSONP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//jquery方法</span>\n$<span class=\"token punctuation\">.</span><span class=\"token function\">getJSON</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://example.com/data.php?callback=?'</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>jsonData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//处理json数据</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-php\"><code class=\"language-php\"><span class=\"token variable\">$callback</span><span class=\"token operator\">=</span> <span class=\"token variable\">$_GET</span><span class=\"token punctuation\">[</span><span class=\"token string\">'callback'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//获取回掉函数名</span>\n<span class=\"token variable\">$data</span><span class=\"token operator\">=</span><span class=\"token keyword\">array</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">echo</span> <span class=\"token variable\">$callback</span><span class=\"token punctuation\">.</span><span class=\"token string\">'('</span><span class=\"token punctuation\">.</span><span class=\"token function\">json_encode</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$data</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token string\">')'</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>通过修改document.domain来跨子域</strong></p>\n<p>不同iframe中是可以获取到<code>window</code>对象的，但是却不能调用<code>window</code>对象的属性或方法，可以在所有的iframe中设置<code>document.domain</code>为相同的域名。</p>\n<p><em>需要注意的是，<code>document.domain</code>只能把域名设置成自身或者更高一级的父域，且主域必须相同。例如：<code>a.example.com</code>只能设置为自身或者是<code>example.com</code>，而不能设置成<code>b.a.example.com</code>。</em></p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 http://example.com/a.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>iframe</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://a.example.com/b.html<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>iframe<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onload</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>load()<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>iframe</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    document<span class=\"token punctuation\">.</span>domain<span class=\"token operator\">=</span><span class=\"token string\">'example.com'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//设置域</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">load</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'iframe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 http://a.example.com/b.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    document<span class=\"token punctuation\">.</span>domain<span class=\"token operator\">=</span><span class=\"token string\">'example.com'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//两者保持一致</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>使用window.name</strong></p>\n<p><code>window.name</code>属性的特征：在一个窗口(window)的生命周期内，当前窗口载入的所有页面(甚至不同域名)都共享一个<code>window.name</code>属性的值，每个页面对<code>window.name</code>都具有读写权限，并不会因为新的页面的载入而进行重置。</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 a.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    window<span class=\"token punctuation\">.</span>name<span class=\"token operator\">=</span><span class=\"token string\">\"我来自页面a\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        window<span class=\"token punctuation\">.</span>location<span class=\"token operator\">=</span><span class=\"token string\">'b.html'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 b.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//我来自页面a</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><em><code>window.name</code>只能设置值为字符串的形式，大小2m左右，或者更大一点，不同的浏览器规定的大小不同。</em></p>\n</li>\n<li><p><strong>使用window.postMessage方法</strong></p>\n<p><code>window.postMessage</code>方法可以安全的实现跨域通信</p>\n<blockquote>\n<p>语法：<code>window.postMessage(message,targetOrigin,[transfer])</code></p>\n<p>message：将要发送的数据。</p>\n<p>targetOrigin：指定哪些窗口可以接收到消息事件，可以是字符串”*”（无限制）或者一个URI。</p>\n<p>transfer（可选）：是一串和message 同时传递的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable\" target=\"_blank\" rel=\"noopener\"><code>Transferable</code></a> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>\n</blockquote>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 http://a.ex.com/a.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> iframe <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'iframe'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> win<span class=\"token operator\">=</span>iframe<span class=\"token punctuation\">.</span>contentWindow<span class=\"token punctuation\">;</span> \n        win<span class=\"token punctuation\">.</span><span class=\"token function\">postMessage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'页面a的数据啊'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>iframe</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>iframe<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://www.test.com/b.html<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>iframe</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token comment\" spellcheck=\"true\">&lt;!-- 页面 http://www.test.com/b.html --></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n    window<span class=\"token punctuation\">.</span>onmessage<span class=\"token operator\">=</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        e<span class=\"token operator\">=</span>e<span class=\"token operator\">||</span>event<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//获取事件对象</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//页面a的数据啊</span>\n    <span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>通过CORS解决AJAX跨域</strong></p>\n<p>特点：服务端设置头信息，浏览器端不需要处理。</p>\n<pre class=\"line-numbers language-js\"><code class=\"language-js\">res<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Access-Control-Allow-Origin'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"*\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//针对哪个域名可以访问，*表示所有</span>\n\nres<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Access-Control-Allow-Credentials'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//是否可以携带cookie</span>\n\nres<span class=\"token punctuation\">.</span><span class=\"token function\">setHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Access-Control-Allow-Methods'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'POST, GET, PUT, DELETE, OPTIONS'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><strong>通过Nginx反向代理</strong></p>\n<p>Nginx解决跨域问题通过Nginx反向代理将对真实服务器的请求转移到本机服务器来避免浏览器的”同源策略限制”。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"跨域相关总结\"><a href=\"#跨域相关总结\" class=\"headerlink\" title=\"跨域相关总结\"></a>跨域相关总结</h3><h5 id=\"为什么会产生跨域：\"><a href=\"#为什么会产生跨域：\" class=\"headerlink\" title=\"为什么会产生跨域：\"></a>为什么会产生跨域：</h5><ol>\n<li>浏览器的一种安全策略。（同源策略）</li>\n<li>域名、端口、协议任何一方如果不相同，都会产生跨域问题。</li>\n</ol>\n<h5 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h5><ol>\n<li><p><strong>使用jsonp</strong></p>\n<p>实现原理：通过动态创建script标签，来进行跨域数据获取。</p>\n<pre><code class=\"javascript\">//原生js方法\nfunction getMsg(jsonData){\n    //jsonData为请求返回的json数据\n    console.log(jsonData);\n}\nvar JSONP=document.createElement(&quot;script&quot;);\nJSONP.type=&quot;text/javascript&quot;;\nJSON.src=&quot;http://example.com/data.php?callback=getMsg&quot;;  //callback回掉函数，用来让后台的数据返回到该函数中进行处理\ndocument.getElementByTagName(&quot;head&quot;)[0].appendChild(JSONP);\n\n//jquery方法\n$.getJSON(&#39;http://example.com/data.php?callback=?&#39;,function(jsonData){\n    //处理json数据\n})\n</code></pre>\n<pre><code class=\"php\">$callback= $_GET[&#39;callback&#39;]; //获取回掉函数名\n$data=array(1,2,3);\necho $callback.&#39;(&#39;.json_encode($data).&#39;)&#39;;\n</code></pre>\n</li>\n<li><p><strong>通过修改document.domain来跨子域</strong></p>\n<p>不同iframe中是可以获取到<code>window</code>对象的，但是却不能调用<code>window</code>对象的属性或方法，可以在所有的iframe中设置<code>document.domain</code>为相同的域名。</p>\n<p><em>需要注意的是，<code>document.domain</code>只能把域名设置成自身或者更高一级的父域，且主域必须相同。例如：<code>a.example.com</code>只能设置为自身或者是<code>example.com</code>，而不能设置成<code>b.a.example.com</code>。</em></p>\n<pre><code class=\"html\">&lt;!-- 页面 http://example.com/a.html --&gt;\n&lt;iframe src=&quot;http://a.example.com/b.html&quot; id=&quot;iframe&quot; onload=&quot;load()&quot;&gt;\n&lt;/iframe&gt;\n&lt;script&gt;\n    document.domain=&#39;example.com&#39;; //设置域\n    function load(){\n        alert(document.getElementById(&#39;iframe&#39;).contentWindow);\n    }\n&lt;/script&gt;\n&lt;!-- 页面 http://a.example.com/b.html --&gt;\n&lt;script&gt;\n    document.domain=&#39;example.com&#39;; //两者保持一致\n&lt;/script&gt;\n</code></pre>\n</li>\n<li><p><strong>使用window.name</strong></p>\n<p><code>window.name</code>属性的特征：在一个窗口(window)的生命周期内，当前窗口载入的所有页面(甚至不同域名)都共享一个<code>window.name</code>属性的值，每个页面对<code>window.name</code>都具有读写权限，并不会因为新的页面的载入而进行重置。</p>\n<pre><code class=\"html\">&lt;!-- 页面 a.html --&gt;\n&lt;script&gt;\n    window.name=&quot;我来自页面a&quot;;\n    setTimeout(function(){\n        window.location=&#39;b.html&#39;\n    },1000)\n&lt;/script&gt;\n\n&lt;!-- 页面 b.html --&gt;\n&lt;script&gt;\n    console.log(window.name); //我来自页面a\n&lt;/script&gt;\n</code></pre>\n<p><em><code>window.name</code>只能设置值为字符串的形式，大小2m左右，或者更大一点，不同的浏览器规定的大小不同。</em></p>\n</li>\n<li><p><strong>使用window.postMessage方法</strong></p>\n<p><code>window.postMessage</code>方法可以安全的实现跨域通信</p>\n<blockquote>\n<p>语法：<code>window.postMessage(message,targetOrigin,[transfer])</code></p>\n<p>message：将要发送的数据。</p>\n<p>targetOrigin：指定哪些窗口可以接收到消息事件，可以是字符串”*”（无限制）或者一个URI。</p>\n<p>transfer（可选）：是一串和message 同时传递的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable\" target=\"_blank\" rel=\"noopener\"><code>Transferable</code></a> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p>\n</blockquote>\n<pre><code class=\"html\">&lt;!-- 页面 http://a.ex.com/a.html --&gt;\n&lt;script&gt;\n    function test(){\n        var iframe = document.getElementById(&#39;iframe&#39;);\n        var win=iframe.contentWindow; \n        win.postMessage(&#39;页面a的数据啊&#39;,&#39;*&#39;);\n    }\n&lt;/script&gt;\n&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.test.com/b.html&quot;&gt;\n&lt;/iframe&gt;\n\n&lt;!-- 页面 http://www.test.com/b.html --&gt;\n&lt;script&gt;\n    window.onmessage=function(e){\n        e=e||event; //获取事件对象\n        console.log(e.data); //页面a的数据啊\n    }\n&lt;/script&gt;\n</code></pre>\n</li>\n<li><p><strong>通过CORS解决AJAX跨域</strong></p>\n<p>特点：服务端设置头信息，浏览器端不需要处理。</p>\n<pre><code class=\"js\">res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &quot;*&quot;); //针对哪个域名可以访问，*表示所有\n\nres.setHeader(&#39;Access-Control-Allow-Credentials&#39;, true); //是否可以携带cookie\n\nres.setHeader(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, GET, PUT, DELETE, OPTIONS&#39;);\n</code></pre>\n</li>\n<li><p><strong>通过Nginx反向代理</strong></p>\n<p>Nginx解决跨域问题通过Nginx反向代理将对真实服务器的请求转移到本机服务器来避免浏览器的”同源策略限制”。</p>\n</li>\n</ol>\n"},{"title":"组件编写命名规范","date":"2018-11-25T07:24:57.000Z","_content":"\n### 组件编写规范\n\n文件名大写：如果一个文件导出的是一个类，那么这个文件名就用大写字母开头。\n\n组件的私有方法都用`_`开头，所有事件监听的方法都用`handle`开头。\n\n把事件监听的方法传递给组件的时候，属性名用`on`开头。例如：\n\n```jsx\n<CommentInput\n  onSubmit={this.handleSubmitComment.bind(this)} />\n```","source":"_posts/组件编写命名规范.md","raw":"---\ntitle: 组件编写命名规范\ndate: 2018-11-25 15:24:57\ntags: 规范\ncategories: 前端\n---\n\n### 组件编写规范\n\n文件名大写：如果一个文件导出的是一个类，那么这个文件名就用大写字母开头。\n\n组件的私有方法都用`_`开头，所有事件监听的方法都用`handle`开头。\n\n把事件监听的方法传递给组件的时候，属性名用`on`开头。例如：\n\n```jsx\n<CommentInput\n  onSubmit={this.handleSubmitComment.bind(this)} />\n```","slug":"组件编写命名规范","published":1,"updated":"2024-02-19T07:42:51.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clsstdrig00721xop36m21gg7","content":"<h3 id=\"组件编写规范\"><a href=\"#组件编写规范\" class=\"headerlink\" title=\"组件编写规范\"></a>组件编写规范</h3><p>文件名大写：如果一个文件导出的是一个类，那么这个文件名就用大写字母开头。</p>\n<p>组件的私有方法都用<code>_</code>开头，所有事件监听的方法都用<code>handle</code>开头。</p>\n<p>把事件监听的方法传递给组件的时候，属性名用<code>on</code>开头。例如：</p>\n<pre class=\"line-numbers language-jsx\"><code class=\"language-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>CommentInput</span>\n  <span class=\"token attr-name\">onSubmit</span><span class=\"token script language-javascript\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleSubmitComment<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"组件编写规范\"><a href=\"#组件编写规范\" class=\"headerlink\" title=\"组件编写规范\"></a>组件编写规范</h3><p>文件名大写：如果一个文件导出的是一个类，那么这个文件名就用大写字母开头。</p>\n<p>组件的私有方法都用<code>_</code>开头，所有事件监听的方法都用<code>handle</code>开头。</p>\n<p>把事件监听的方法传递给组件的时候，属性名用<code>on</code>开头。例如：</p>\n<pre><code class=\"jsx\">&lt;CommentInput\n  onSubmit={this.handleSubmitComment.bind(this)} /&gt;\n</code></pre>\n"},{"title":"WebRtc入门","date":"2024-02-21T10:25:36.000Z","_content":"\n\n## 什么是WebRtc？\n\n> WebRTC（Web Real-Time Communication）是一种用于在Web浏览器之间实现实时通信的开放标准和技术集合。它允许浏览器和移动应用程序之间直接进行音频、视频和数据传输，而无需借助第三方插件或扩展。WebRTC 提供了一种使开发者能够轻松构建实时通信功能的方式。\n\n![image](WebRtc/webrtcJiagou.png)\n\n## WebRtc技术关联的浏览器API\n\n### [`getUserMedia`](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia)\n> 这个API允许Web应用程序访问用户的摄像头和麦克风，以便捕获音频和视频数据。（需要注意安全限制：https协议开头的或者是本地localhost这些才能调通）\n调用成功后会返回**`MediaStream`**.\n**`MediaStream`**：用于表示媒体数据流。流可以是输入或输出，也可以是本地或远程（例如，本地网络摄像头或远程连接，`navigator.mediaDevices.getUserMedia`\n）。\n必须注意，单个 `MediaStream` 可以包含零个或多个轨道。 每个轨道都有一个对应的 `MediaStreamTrack` 对象，该对象代表用户代理中的特定媒体源。\n\n`MediaStream` 中的所有轨道在渲染时进行同步。\n\n`MediaStreamTrack` 表示包含一个或多个通道的内容，其中，通道之间具有定义的已知的关系。 通道是此 API 规范中考虑的最小单位。 下图显示了由单个视频轨道和两个不同的音频（左声道和右声道）轨道组成的 `MediaStream`。\n\n![image](WebRtc/mediaStream.png)\n\n### [`RTCPeerConnection`](https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection)\n\n> `RTCPeerConnection` 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。\n\n![image](WebRtc/RTCPeerConnection.png)\n\n### [`RTCDataChannel`](https://developer.mozilla.org/zh-CN/docs/Web/API/RTCDataChannel)\n\n> `RTCDataChannel` 接口代表在两者之间建立了一个双向数据通道的连接。\n\n因为是浏览器间的直接通信，所以`RTCDataChannel`要比WebSocket快得多。\n很多领域都潜在地使用到了这个API，比如：\n1. 游戏\n2. 远程桌面应用\n3. 实时文字聊天\n4. 文件传输\n5. 分散网络\n\n![image](WebRtc/RTCDataChannel.png)\n\n## WebRtc连接过程\n\n要想知道WebRtc的连接过程就需要先知道什么是NAT（Network Address Translation，网络地址转换）。\n\n### NAT（Network Address Translation，网络地址转换）\n> NAT是一种网络通信技术，用于将一个网络的 IP 地址（本地局域网）转换成另一个网络（公网）的 IP 地址。其主要目的是解决 IPv4 地址不足的问题。\nNAT 技术通过在网络路由器或防火墙上实现地址转换功能，允许多个设备共享一个公共 IP 地址，从而减少了对公共 IP 地址的需求。同时也提高了网络的安全性，因为内部网络的 IP 地址对外部网络是不可见的，从而增加了网络的隐私性和安全性。\n\n![image](WebRtc/NAT.png)\n\n了解了什么是NAT，就知道如果两台设备需要通信，肯定是要能够找到各自对应的ip地址以及对应的端口号（WebRtc也不例外）。这就涉及到了NAT穿透的一些知识。\n\n**常见的网络拓扑图**\n![image](WebRtc/network.png)\n\n### STUN 协议\n> STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，用于解决网络通信中的NAT穿越问题。\nSTUN服务器位于公网上，可以帮助客户端发现自己的公网IP地址。客户端通过向STUN服务器发送请求，服务器会返回客户端的公网IP地址和端口号。\n\n![image](WebRtc/stun.png)\n\n### TURN协议\n> 如果STUN无法穿透NAT，可以考虑使用TURN（Traversal Using Relays around NAT）服务器。TURN服务器可以帮助在无法直接连接的情况下，通过中继服务器进行通信。TURN服务器会接收来自客户端的数据，然后转发给对方，从而实现间接通信。\n\n![image](WebRtc/turn.png)\n\n### NAT类型\n\n#### 完全锥型NAT\n> 完全锥型 NAT 的特点: 一旦打洞成功，所有知道该洞的主机都可以 通过它与内网主机进行通信。\n\n![image](WebRtc/Full%1DConeNAT.png)\n\n当host主机通过NAT访问外网主机B时，就会在NAT 上打个洞。如果主机B将该洞的信息分享给主机A和C，那么知道这个洞 的主机A和C都可以通过该洞给内网的host主机发送信息。\n这里所谓的“洞”就是在NAT上建立了一个内外网的映射 表。你可以将这个映射表简单地理解为一个4元组，包括内网IP、内网 端口、映射的外网IP以及映射的外网端口。\n\n#### IP限制锥型NAT\n> IP 限制锥型 NAT 的特点: 一旦打洞成功，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。 \n\n![image](WebRtc/IPNat.png)\n\nIP限制锥型NAT要比完全锥型NAT严格得多。IP限制锥型NAT的主 要特点:NAT打洞成功后，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。\nhost主机访问主机B时，在NAT上打了一个洞。此 时，只有主机B才能通过该洞向内网host主机发送信息，而其他外网主 机(如A与C)不能再像完全锥型NAT一样通过该洞与内网host主机通信 了。但需要注意的是，主机B上不同的端口(如p1、p2等)是可以向 host主机发送消息的。\n\n#### 端口限制NAT\n> 端口限制锥型 NAT 的特点: 一旦打洞成功，除了像IP限制锥型 NAT 一样需要对IP地址进行检测外，还需要对端口进行检测 。\n\n![image](WebRtc/portNat.png)\n\nhost主机访问主机B时在NAT上打了一个洞，此时外 网主机A和C是访问不了内网host主机的，这与IP限制锥型NAT是一样 的。此外，如果host主机访问的是主机B的p1端口，那么只有主机B的p1 端口发送的消息才能穿越NAT，而主机B的p2端口已无法再通过NAT 了。\n\n#### 对称型NAT\n> 对称型 NAT 的特点: 内网主机每次访问不同的IP或端口时，都会生成一个新洞，而不像前面3种NAT类型使用的是同一个洞。 \n\n![image](WebRtc/SymmetricNat.png)\n\n在对称型NAT中，host主机访问主机B时在NAT上打 了一个洞，此时只有主机B上相应端口发送的数据才能穿越该洞，这一 点与端口限制型NAT是一致的。它与端口限制型NAT最大的不同是当 host主机访问外网主机A时，它与主机A之间会新建一个洞，而不是复用 访问主机B时的洞。\n\n\n#### 打洞举例\n**A B均为完全锥型NAT**\n![image](WebRtc/A%26BFullNat.png)\n\n1. A 向 server 发起与 B 的打洞请求，server 向 B 转发打洞请求，同时A向 PB1 直接发送探测包，那么 A 为 B 在 PA1 已经成功打洞，但是 A 的消息无法到达，因为 B 的 NAT 会将不明的地址(PA1) 丢弃/拒绝。\n2. B 收到从 server 转发过来的打洞请求后，向 PA1 直接发送探测包，这时 B 的 NAT 可以放行 PA1 的消息了，也就是 B 为 A 在 PB1 上完成了打洞。\n3. 至此，A 和 B 消息能够互通，打洞成功\n\n**A为对称型 B为端口限制型**\n![image](WebRtc/AS%26BPNat.png)\n\n由于 B 收到 server 转发过来的打洞请求后，是向 PA1 发送探测包的，因为 B 只知道 PA1（PA1 是 A 与 server 连接是映射的端口号，server 也只知道 PA1)，但是 A 由于是对称型 NAT，所以会拒绝B往PA1发的消息，同时会从一个新端口 PA2 向 B 发包，但是 B 由于是端口限制型，只允许 PA1 端口的包通过，所以 B 会拒绝 PA2。\n\n**A为对称型 B为IP限制型**\n![image](WebRtc/NAT%E7%A9%BF%E9%80%8F%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B.png)\n\n\n#### 各NAT类型打洞可行性\n![image](WebRtc/NATOpen.png)\n\n\n### ICE\n> ICE（Interactive Connectivity Establishment）候选项（ICE candidates）是一组网络地址（包括IP地址和端口号），用于建立对等连接（peer-to-peer connections）的过程中。ICE候选项由WebRTC框架自动收集和处理，用于解决网络中存在的NAT（Network Address Translation）和防火墙问题，以便在不同的网络环境中实现点对点通信。\n\n![image](WebRtc/ICE.png)\n\nWebRtc将Candidate分为四种类型：host、srflx、prflx及 relay，且它们还有优先级次序，其中host优先级最高，relay优先级最低。比如WebRTC收集到了两个Candidate，一个是host类型，另一个是 srflx类型，那么WebRTC一定会先尝试与host类型的Candidate建立连 接，如果不成功，才会使用srflx类型的Candidate。 \n\n#### ICE候选交换过程\n![image](WebRtc/ICESend.png)\n\n\n### 信令交互过程（sdp 主要用来协商媒体格式）\n![image](WebRtc/sdp.png)\n\n\n### WebRtc连接核心过程\n1. 创建 p2p 通道端 A，添加本地视频流至通道，并且本地预览\n2. 创建 p2p 通道端 B，添加本地视频流至通道，并且本地预览\n3. offer、answer 交换\n4. addIceCandidate 候选地址\n5. 通道 A、B 连接建立成功，获取对端视频流，播放","source":"_posts/WebRtc.md","raw":"---\ntitle: WebRtc入门\ndate: 2024-02-21 18:25:36\ntags: 音视频\ncategories: 前端\n---\n\n\n## 什么是WebRtc？\n\n> WebRTC（Web Real-Time Communication）是一种用于在Web浏览器之间实现实时通信的开放标准和技术集合。它允许浏览器和移动应用程序之间直接进行音频、视频和数据传输，而无需借助第三方插件或扩展。WebRTC 提供了一种使开发者能够轻松构建实时通信功能的方式。\n\n![image](WebRtc/webrtcJiagou.png)\n\n## WebRtc技术关联的浏览器API\n\n### [`getUserMedia`](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia)\n> 这个API允许Web应用程序访问用户的摄像头和麦克风，以便捕获音频和视频数据。（需要注意安全限制：https协议开头的或者是本地localhost这些才能调通）\n调用成功后会返回**`MediaStream`**.\n**`MediaStream`**：用于表示媒体数据流。流可以是输入或输出，也可以是本地或远程（例如，本地网络摄像头或远程连接，`navigator.mediaDevices.getUserMedia`\n）。\n必须注意，单个 `MediaStream` 可以包含零个或多个轨道。 每个轨道都有一个对应的 `MediaStreamTrack` 对象，该对象代表用户代理中的特定媒体源。\n\n`MediaStream` 中的所有轨道在渲染时进行同步。\n\n`MediaStreamTrack` 表示包含一个或多个通道的内容，其中，通道之间具有定义的已知的关系。 通道是此 API 规范中考虑的最小单位。 下图显示了由单个视频轨道和两个不同的音频（左声道和右声道）轨道组成的 `MediaStream`。\n\n![image](WebRtc/mediaStream.png)\n\n### [`RTCPeerConnection`](https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection)\n\n> `RTCPeerConnection` 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。\n\n![image](WebRtc/RTCPeerConnection.png)\n\n### [`RTCDataChannel`](https://developer.mozilla.org/zh-CN/docs/Web/API/RTCDataChannel)\n\n> `RTCDataChannel` 接口代表在两者之间建立了一个双向数据通道的连接。\n\n因为是浏览器间的直接通信，所以`RTCDataChannel`要比WebSocket快得多。\n很多领域都潜在地使用到了这个API，比如：\n1. 游戏\n2. 远程桌面应用\n3. 实时文字聊天\n4. 文件传输\n5. 分散网络\n\n![image](WebRtc/RTCDataChannel.png)\n\n## WebRtc连接过程\n\n要想知道WebRtc的连接过程就需要先知道什么是NAT（Network Address Translation，网络地址转换）。\n\n### NAT（Network Address Translation，网络地址转换）\n> NAT是一种网络通信技术，用于将一个网络的 IP 地址（本地局域网）转换成另一个网络（公网）的 IP 地址。其主要目的是解决 IPv4 地址不足的问题。\nNAT 技术通过在网络路由器或防火墙上实现地址转换功能，允许多个设备共享一个公共 IP 地址，从而减少了对公共 IP 地址的需求。同时也提高了网络的安全性，因为内部网络的 IP 地址对外部网络是不可见的，从而增加了网络的隐私性和安全性。\n\n![image](WebRtc/NAT.png)\n\n了解了什么是NAT，就知道如果两台设备需要通信，肯定是要能够找到各自对应的ip地址以及对应的端口号（WebRtc也不例外）。这就涉及到了NAT穿透的一些知识。\n\n**常见的网络拓扑图**\n![image](WebRtc/network.png)\n\n### STUN 协议\n> STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，用于解决网络通信中的NAT穿越问题。\nSTUN服务器位于公网上，可以帮助客户端发现自己的公网IP地址。客户端通过向STUN服务器发送请求，服务器会返回客户端的公网IP地址和端口号。\n\n![image](WebRtc/stun.png)\n\n### TURN协议\n> 如果STUN无法穿透NAT，可以考虑使用TURN（Traversal Using Relays around NAT）服务器。TURN服务器可以帮助在无法直接连接的情况下，通过中继服务器进行通信。TURN服务器会接收来自客户端的数据，然后转发给对方，从而实现间接通信。\n\n![image](WebRtc/turn.png)\n\n### NAT类型\n\n#### 完全锥型NAT\n> 完全锥型 NAT 的特点: 一旦打洞成功，所有知道该洞的主机都可以 通过它与内网主机进行通信。\n\n![image](WebRtc/Full%1DConeNAT.png)\n\n当host主机通过NAT访问外网主机B时，就会在NAT 上打个洞。如果主机B将该洞的信息分享给主机A和C，那么知道这个洞 的主机A和C都可以通过该洞给内网的host主机发送信息。\n这里所谓的“洞”就是在NAT上建立了一个内外网的映射 表。你可以将这个映射表简单地理解为一个4元组，包括内网IP、内网 端口、映射的外网IP以及映射的外网端口。\n\n#### IP限制锥型NAT\n> IP 限制锥型 NAT 的特点: 一旦打洞成功，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。 \n\n![image](WebRtc/IPNat.png)\n\nIP限制锥型NAT要比完全锥型NAT严格得多。IP限制锥型NAT的主 要特点:NAT打洞成功后，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。\nhost主机访问主机B时，在NAT上打了一个洞。此 时，只有主机B才能通过该洞向内网host主机发送信息，而其他外网主 机(如A与C)不能再像完全锥型NAT一样通过该洞与内网host主机通信 了。但需要注意的是，主机B上不同的端口(如p1、p2等)是可以向 host主机发送消息的。\n\n#### 端口限制NAT\n> 端口限制锥型 NAT 的特点: 一旦打洞成功，除了像IP限制锥型 NAT 一样需要对IP地址进行检测外，还需要对端口进行检测 。\n\n![image](WebRtc/portNat.png)\n\nhost主机访问主机B时在NAT上打了一个洞，此时外 网主机A和C是访问不了内网host主机的，这与IP限制锥型NAT是一样 的。此外，如果host主机访问的是主机B的p1端口，那么只有主机B的p1 端口发送的消息才能穿越NAT，而主机B的p2端口已无法再通过NAT 了。\n\n#### 对称型NAT\n> 对称型 NAT 的特点: 内网主机每次访问不同的IP或端口时，都会生成一个新洞，而不像前面3种NAT类型使用的是同一个洞。 \n\n![image](WebRtc/SymmetricNat.png)\n\n在对称型NAT中，host主机访问主机B时在NAT上打 了一个洞，此时只有主机B上相应端口发送的数据才能穿越该洞，这一 点与端口限制型NAT是一致的。它与端口限制型NAT最大的不同是当 host主机访问外网主机A时，它与主机A之间会新建一个洞，而不是复用 访问主机B时的洞。\n\n\n#### 打洞举例\n**A B均为完全锥型NAT**\n![image](WebRtc/A%26BFullNat.png)\n\n1. A 向 server 发起与 B 的打洞请求，server 向 B 转发打洞请求，同时A向 PB1 直接发送探测包，那么 A 为 B 在 PA1 已经成功打洞，但是 A 的消息无法到达，因为 B 的 NAT 会将不明的地址(PA1) 丢弃/拒绝。\n2. B 收到从 server 转发过来的打洞请求后，向 PA1 直接发送探测包，这时 B 的 NAT 可以放行 PA1 的消息了，也就是 B 为 A 在 PB1 上完成了打洞。\n3. 至此，A 和 B 消息能够互通，打洞成功\n\n**A为对称型 B为端口限制型**\n![image](WebRtc/AS%26BPNat.png)\n\n由于 B 收到 server 转发过来的打洞请求后，是向 PA1 发送探测包的，因为 B 只知道 PA1（PA1 是 A 与 server 连接是映射的端口号，server 也只知道 PA1)，但是 A 由于是对称型 NAT，所以会拒绝B往PA1发的消息，同时会从一个新端口 PA2 向 B 发包，但是 B 由于是端口限制型，只允许 PA1 端口的包通过，所以 B 会拒绝 PA2。\n\n**A为对称型 B为IP限制型**\n![image](WebRtc/NAT%E7%A9%BF%E9%80%8F%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B.png)\n\n\n#### 各NAT类型打洞可行性\n![image](WebRtc/NATOpen.png)\n\n\n### ICE\n> ICE（Interactive Connectivity Establishment）候选项（ICE candidates）是一组网络地址（包括IP地址和端口号），用于建立对等连接（peer-to-peer connections）的过程中。ICE候选项由WebRTC框架自动收集和处理，用于解决网络中存在的NAT（Network Address Translation）和防火墙问题，以便在不同的网络环境中实现点对点通信。\n\n![image](WebRtc/ICE.png)\n\nWebRtc将Candidate分为四种类型：host、srflx、prflx及 relay，且它们还有优先级次序，其中host优先级最高，relay优先级最低。比如WebRTC收集到了两个Candidate，一个是host类型，另一个是 srflx类型，那么WebRTC一定会先尝试与host类型的Candidate建立连 接，如果不成功，才会使用srflx类型的Candidate。 \n\n#### ICE候选交换过程\n![image](WebRtc/ICESend.png)\n\n\n### 信令交互过程（sdp 主要用来协商媒体格式）\n![image](WebRtc/sdp.png)\n\n\n### WebRtc连接核心过程\n1. 创建 p2p 通道端 A，添加本地视频流至通道，并且本地预览\n2. 创建 p2p 通道端 B，添加本地视频流至通道，并且本地预览\n3. offer、answer 交换\n4. addIceCandidate 候选地址\n5. 通道 A、B 连接建立成功，获取对端视频流，播放","slug":"WebRtc","published":1,"updated":"2024-02-23T09:36:41.882Z","_id":"clsvnp9mb0000jgopb2vz838l","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是WebRtc？\"><a href=\"#什么是WebRtc？\" class=\"headerlink\" title=\"什么是WebRtc？\"></a>什么是WebRtc？</h2><blockquote>\n<p>WebRTC（Web Real-Time Communication）是一种用于在Web浏览器之间实现实时通信的开放标准和技术集合。它允许浏览器和移动应用程序之间直接进行音频、视频和数据传输，而无需借助第三方插件或扩展。WebRTC 提供了一种使开发者能够轻松构建实时通信功能的方式。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/webrtcJiagou.png\" alt=\"image\"></p>\n<h2 id=\"WebRtc技术关联的浏览器API\"><a href=\"#WebRtc技术关联的浏览器API\" class=\"headerlink\" title=\"WebRtc技术关联的浏览器API\"></a>WebRtc技术关联的浏览器API</h2><h3 id=\"getUserMedia\"><a href=\"#getUserMedia\" class=\"headerlink\" title=\"getUserMedia\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia\" target=\"_blank\" rel=\"noopener\"><code>getUserMedia</code></a></h3><blockquote>\n<p>这个API允许Web应用程序访问用户的摄像头和麦克风，以便捕获音频和视频数据。（需要注意安全限制：https协议开头的或者是本地localhost这些才能调通）<br>调用成功后会返回<strong><code>MediaStream</code></strong>.<br><strong><code>MediaStream</code></strong>：用于表示媒体数据流。流可以是输入或输出，也可以是本地或远程（例如，本地网络摄像头或远程连接，<code>navigator.mediaDevices.getUserMedia</code><br>）。<br>必须注意，单个 <code>MediaStream</code> 可以包含零个或多个轨道。 每个轨道都有一个对应的 <code>MediaStreamTrack</code> 对象，该对象代表用户代理中的特定媒体源。</p>\n</blockquote>\n<p><code>MediaStream</code> 中的所有轨道在渲染时进行同步。</p>\n<p><code>MediaStreamTrack</code> 表示包含一个或多个通道的内容，其中，通道之间具有定义的已知的关系。 通道是此 API 规范中考虑的最小单位。 下图显示了由单个视频轨道和两个不同的音频（左声道和右声道）轨道组成的 <code>MediaStream</code>。</p>\n<p><img src=\"/2024/02/21/WebRtc/mediaStream.png\" alt=\"image\"></p>\n<h3 id=\"RTCPeerConnection\"><a href=\"#RTCPeerConnection\" class=\"headerlink\" title=\"RTCPeerConnection\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection\" target=\"_blank\" rel=\"noopener\"><code>RTCPeerConnection</code></a></h3><blockquote>\n<p><code>RTCPeerConnection</code> 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/RTCPeerConnection.png\" alt=\"image\"></p>\n<h3 id=\"RTCDataChannel\"><a href=\"#RTCDataChannel\" class=\"headerlink\" title=\"RTCDataChannel\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/RTCDataChannel\" target=\"_blank\" rel=\"noopener\"><code>RTCDataChannel</code></a></h3><blockquote>\n<p><code>RTCDataChannel</code> 接口代表在两者之间建立了一个双向数据通道的连接。</p>\n</blockquote>\n<p>因为是浏览器间的直接通信，所以<code>RTCDataChannel</code>要比WebSocket快得多。<br>很多领域都潜在地使用到了这个API，比如：</p>\n<ol>\n<li>游戏</li>\n<li>远程桌面应用</li>\n<li>实时文字聊天</li>\n<li>文件传输</li>\n<li>分散网络</li>\n</ol>\n<p><img src=\"/2024/02/21/WebRtc/RTCDataChannel.png\" alt=\"image\"></p>\n<h2 id=\"WebRtc连接过程\"><a href=\"#WebRtc连接过程\" class=\"headerlink\" title=\"WebRtc连接过程\"></a>WebRtc连接过程</h2><p>要想知道WebRtc的连接过程就需要先知道什么是NAT（Network Address Translation，网络地址转换）。</p>\n<h3 id=\"NAT（Network-Address-Translation，网络地址转换）\"><a href=\"#NAT（Network-Address-Translation，网络地址转换）\" class=\"headerlink\" title=\"NAT（Network Address Translation，网络地址转换）\"></a>NAT（Network Address Translation，网络地址转换）</h3><blockquote>\n<p>NAT是一种网络通信技术，用于将一个网络的 IP 地址（本地局域网）转换成另一个网络（公网）的 IP 地址。其主要目的是解决 IPv4 地址不足的问题。<br>NAT 技术通过在网络路由器或防火墙上实现地址转换功能，允许多个设备共享一个公共 IP 地址，从而减少了对公共 IP 地址的需求。同时也提高了网络的安全性，因为内部网络的 IP 地址对外部网络是不可见的，从而增加了网络的隐私性和安全性。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/NAT.png\" alt=\"image\"></p>\n<p>了解了什么是NAT，就知道如果两台设备需要通信，肯定是要能够找到各自对应的ip地址以及对应的端口号（WebRtc也不例外）。这就涉及到了NAT穿透的一些知识。</p>\n<p><strong>常见的网络拓扑图</strong><br><img src=\"/2024/02/21/WebRtc/network.png\" alt=\"image\"></p>\n<h3 id=\"STUN-协议\"><a href=\"#STUN-协议\" class=\"headerlink\" title=\"STUN 协议\"></a>STUN 协议</h3><blockquote>\n<p>STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，用于解决网络通信中的NAT穿越问题。<br>STUN服务器位于公网上，可以帮助客户端发现自己的公网IP地址。客户端通过向STUN服务器发送请求，服务器会返回客户端的公网IP地址和端口号。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/stun.png\" alt=\"image\"></p>\n<h3 id=\"TURN协议\"><a href=\"#TURN协议\" class=\"headerlink\" title=\"TURN协议\"></a>TURN协议</h3><blockquote>\n<p>如果STUN无法穿透NAT，可以考虑使用TURN（Traversal Using Relays around NAT）服务器。TURN服务器可以帮助在无法直接连接的情况下，通过中继服务器进行通信。TURN服务器会接收来自客户端的数据，然后转发给对方，从而实现间接通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/turn.png\" alt=\"image\"></p>\n<h3 id=\"NAT类型\"><a href=\"#NAT类型\" class=\"headerlink\" title=\"NAT类型\"></a>NAT类型</h3><h4 id=\"完全锥型NAT\"><a href=\"#完全锥型NAT\" class=\"headerlink\" title=\"完全锥型NAT\"></a>完全锥型NAT</h4><blockquote>\n<p>完全锥型 NAT 的特点: 一旦打洞成功，所有知道该洞的主机都可以 通过它与内网主机进行通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/Full%1DConeNAT.png\" alt=\"image\"></p>\n<p>当host主机通过NAT访问外网主机B时，就会在NAT 上打个洞。如果主机B将该洞的信息分享给主机A和C，那么知道这个洞 的主机A和C都可以通过该洞给内网的host主机发送信息。<br>这里所谓的“洞”就是在NAT上建立了一个内外网的映射 表。你可以将这个映射表简单地理解为一个4元组，包括内网IP、内网 端口、映射的外网IP以及映射的外网端口。</p>\n<h4 id=\"IP限制锥型NAT\"><a href=\"#IP限制锥型NAT\" class=\"headerlink\" title=\"IP限制锥型NAT\"></a>IP限制锥型NAT</h4><blockquote>\n<p>IP 限制锥型 NAT 的特点: 一旦打洞成功，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。 </p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/IPNat.png\" alt=\"image\"></p>\n<p>IP限制锥型NAT要比完全锥型NAT严格得多。IP限制锥型NAT的主 要特点:NAT打洞成功后，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。<br>host主机访问主机B时，在NAT上打了一个洞。此 时，只有主机B才能通过该洞向内网host主机发送信息，而其他外网主 机(如A与C)不能再像完全锥型NAT一样通过该洞与内网host主机通信 了。但需要注意的是，主机B上不同的端口(如p1、p2等)是可以向 host主机发送消息的。</p>\n<h4 id=\"端口限制NAT\"><a href=\"#端口限制NAT\" class=\"headerlink\" title=\"端口限制NAT\"></a>端口限制NAT</h4><blockquote>\n<p>端口限制锥型 NAT 的特点: 一旦打洞成功，除了像IP限制锥型 NAT 一样需要对IP地址进行检测外，还需要对端口进行检测 。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/portNat.png\" alt=\"image\"></p>\n<p>host主机访问主机B时在NAT上打了一个洞，此时外 网主机A和C是访问不了内网host主机的，这与IP限制锥型NAT是一样 的。此外，如果host主机访问的是主机B的p1端口，那么只有主机B的p1 端口发送的消息才能穿越NAT，而主机B的p2端口已无法再通过NAT 了。</p>\n<h4 id=\"对称型NAT\"><a href=\"#对称型NAT\" class=\"headerlink\" title=\"对称型NAT\"></a>对称型NAT</h4><blockquote>\n<p>对称型 NAT 的特点: 内网主机每次访问不同的IP或端口时，都会生成一个新洞，而不像前面3种NAT类型使用的是同一个洞。 </p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/SymmetricNat.png\" alt=\"image\"></p>\n<p>在对称型NAT中，host主机访问主机B时在NAT上打 了一个洞，此时只有主机B上相应端口发送的数据才能穿越该洞，这一 点与端口限制型NAT是一致的。它与端口限制型NAT最大的不同是当 host主机访问外网主机A时，它与主机A之间会新建一个洞，而不是复用 访问主机B时的洞。</p>\n<h4 id=\"打洞举例\"><a href=\"#打洞举例\" class=\"headerlink\" title=\"打洞举例\"></a>打洞举例</h4><p><strong>A B均为完全锥型NAT</strong><br><img src=\"/2024/02/21/WebRtc/A%26BFullNat.png\" alt=\"image\"></p>\n<ol>\n<li>A 向 server 发起与 B 的打洞请求，server 向 B 转发打洞请求，同时A向 PB1 直接发送探测包，那么 A 为 B 在 PA1 已经成功打洞，但是 A 的消息无法到达，因为 B 的 NAT 会将不明的地址(PA1) 丢弃/拒绝。</li>\n<li>B 收到从 server 转发过来的打洞请求后，向 PA1 直接发送探测包，这时 B 的 NAT 可以放行 PA1 的消息了，也就是 B 为 A 在 PB1 上完成了打洞。</li>\n<li>至此，A 和 B 消息能够互通，打洞成功</li>\n</ol>\n<p><strong>A为对称型 B为端口限制型</strong><br><img src=\"/2024/02/21/WebRtc/AS%26BPNat.png\" alt=\"image\"></p>\n<p>由于 B 收到 server 转发过来的打洞请求后，是向 PA1 发送探测包的，因为 B 只知道 PA1（PA1 是 A 与 server 连接是映射的端口号，server 也只知道 PA1)，但是 A 由于是对称型 NAT，所以会拒绝B往PA1发的消息，同时会从一个新端口 PA2 向 B 发包，但是 B 由于是端口限制型，只允许 PA1 端口的包通过，所以 B 会拒绝 PA2。</p>\n<p><strong>A为对称型 B为IP限制型</strong><br><img src=\"/2024/02/21/WebRtc/NAT%E7%A9%BF%E9%80%8F%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B.png\" alt=\"image\"></p>\n<h4 id=\"各NAT类型打洞可行性\"><a href=\"#各NAT类型打洞可行性\" class=\"headerlink\" title=\"各NAT类型打洞可行性\"></a>各NAT类型打洞可行性</h4><p><img src=\"/2024/02/21/WebRtc/NATOpen.png\" alt=\"image\"></p>\n<h3 id=\"ICE\"><a href=\"#ICE\" class=\"headerlink\" title=\"ICE\"></a>ICE</h3><blockquote>\n<p>ICE（Interactive Connectivity Establishment）候选项（ICE candidates）是一组网络地址（包括IP地址和端口号），用于建立对等连接（peer-to-peer connections）的过程中。ICE候选项由WebRTC框架自动收集和处理，用于解决网络中存在的NAT（Network Address Translation）和防火墙问题，以便在不同的网络环境中实现点对点通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/ICE.png\" alt=\"image\"></p>\n<p>WebRtc将Candidate分为四种类型：host、srflx、prflx及 relay，且它们还有优先级次序，其中host优先级最高，relay优先级最低。比如WebRTC收集到了两个Candidate，一个是host类型，另一个是 srflx类型，那么WebRTC一定会先尝试与host类型的Candidate建立连 接，如果不成功，才会使用srflx类型的Candidate。 </p>\n<h4 id=\"ICE候选交换过程\"><a href=\"#ICE候选交换过程\" class=\"headerlink\" title=\"ICE候选交换过程\"></a>ICE候选交换过程</h4><p><img src=\"/2024/02/21/WebRtc/ICESend.png\" alt=\"image\"></p>\n<h3 id=\"信令交互过程（sdp-主要用来协商媒体格式）\"><a href=\"#信令交互过程（sdp-主要用来协商媒体格式）\" class=\"headerlink\" title=\"信令交互过程（sdp 主要用来协商媒体格式）\"></a>信令交互过程（sdp 主要用来协商媒体格式）</h3><p><img src=\"/2024/02/21/WebRtc/sdp.png\" alt=\"image\"></p>\n<h3 id=\"WebRtc连接核心过程\"><a href=\"#WebRtc连接核心过程\" class=\"headerlink\" title=\"WebRtc连接核心过程\"></a>WebRtc连接核心过程</h3><ol>\n<li>创建 p2p 通道端 A，添加本地视频流至通道，并且本地预览</li>\n<li>创建 p2p 通道端 B，添加本地视频流至通道，并且本地预览</li>\n<li>offer、answer 交换</li>\n<li>addIceCandidate 候选地址</li>\n<li>通道 A、B 连接建立成功，获取对端视频流，播放</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是WebRtc？\"><a href=\"#什么是WebRtc？\" class=\"headerlink\" title=\"什么是WebRtc？\"></a>什么是WebRtc？</h2><blockquote>\n<p>WebRTC（Web Real-Time Communication）是一种用于在Web浏览器之间实现实时通信的开放标准和技术集合。它允许浏览器和移动应用程序之间直接进行音频、视频和数据传输，而无需借助第三方插件或扩展。WebRTC 提供了一种使开发者能够轻松构建实时通信功能的方式。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/webrtcJiagou.png\" alt=\"image\"></p>\n<h2 id=\"WebRtc技术关联的浏览器API\"><a href=\"#WebRtc技术关联的浏览器API\" class=\"headerlink\" title=\"WebRtc技术关联的浏览器API\"></a>WebRtc技术关联的浏览器API</h2><h3 id=\"getUserMedia\"><a href=\"#getUserMedia\" class=\"headerlink\" title=\"getUserMedia\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia\" target=\"_blank\" rel=\"noopener\"><code>getUserMedia</code></a></h3><blockquote>\n<p>这个API允许Web应用程序访问用户的摄像头和麦克风，以便捕获音频和视频数据。（需要注意安全限制：https协议开头的或者是本地localhost这些才能调通）<br>调用成功后会返回<strong><code>MediaStream</code></strong>.<br><strong><code>MediaStream</code></strong>：用于表示媒体数据流。流可以是输入或输出，也可以是本地或远程（例如，本地网络摄像头或远程连接，<code>navigator.mediaDevices.getUserMedia</code><br>）。<br>必须注意，单个 <code>MediaStream</code> 可以包含零个或多个轨道。 每个轨道都有一个对应的 <code>MediaStreamTrack</code> 对象，该对象代表用户代理中的特定媒体源。</p>\n</blockquote>\n<p><code>MediaStream</code> 中的所有轨道在渲染时进行同步。</p>\n<p><code>MediaStreamTrack</code> 表示包含一个或多个通道的内容，其中，通道之间具有定义的已知的关系。 通道是此 API 规范中考虑的最小单位。 下图显示了由单个视频轨道和两个不同的音频（左声道和右声道）轨道组成的 <code>MediaStream</code>。</p>\n<p><img src=\"/2024/02/21/WebRtc/mediaStream.png\" alt=\"image\"></p>\n<h3 id=\"RTCPeerConnection\"><a href=\"#RTCPeerConnection\" class=\"headerlink\" title=\"RTCPeerConnection\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection\" target=\"_blank\" rel=\"noopener\"><code>RTCPeerConnection</code></a></h3><blockquote>\n<p><code>RTCPeerConnection</code> 接口代表一个由本地计算机到远端的 WebRTC 连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/RTCPeerConnection.png\" alt=\"image\"></p>\n<h3 id=\"RTCDataChannel\"><a href=\"#RTCDataChannel\" class=\"headerlink\" title=\"RTCDataChannel\"></a><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/RTCDataChannel\" target=\"_blank\" rel=\"noopener\"><code>RTCDataChannel</code></a></h3><blockquote>\n<p><code>RTCDataChannel</code> 接口代表在两者之间建立了一个双向数据通道的连接。</p>\n</blockquote>\n<p>因为是浏览器间的直接通信，所以<code>RTCDataChannel</code>要比WebSocket快得多。<br>很多领域都潜在地使用到了这个API，比如：</p>\n<ol>\n<li>游戏</li>\n<li>远程桌面应用</li>\n<li>实时文字聊天</li>\n<li>文件传输</li>\n<li>分散网络</li>\n</ol>\n<p><img src=\"/2024/02/21/WebRtc/RTCDataChannel.png\" alt=\"image\"></p>\n<h2 id=\"WebRtc连接过程\"><a href=\"#WebRtc连接过程\" class=\"headerlink\" title=\"WebRtc连接过程\"></a>WebRtc连接过程</h2><p>要想知道WebRtc的连接过程就需要先知道什么是NAT（Network Address Translation，网络地址转换）。</p>\n<h3 id=\"NAT（Network-Address-Translation，网络地址转换）\"><a href=\"#NAT（Network-Address-Translation，网络地址转换）\" class=\"headerlink\" title=\"NAT（Network Address Translation，网络地址转换）\"></a>NAT（Network Address Translation，网络地址转换）</h3><blockquote>\n<p>NAT是一种网络通信技术，用于将一个网络的 IP 地址（本地局域网）转换成另一个网络（公网）的 IP 地址。其主要目的是解决 IPv4 地址不足的问题。<br>NAT 技术通过在网络路由器或防火墙上实现地址转换功能，允许多个设备共享一个公共 IP 地址，从而减少了对公共 IP 地址的需求。同时也提高了网络的安全性，因为内部网络的 IP 地址对外部网络是不可见的，从而增加了网络的隐私性和安全性。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/NAT.png\" alt=\"image\"></p>\n<p>了解了什么是NAT，就知道如果两台设备需要通信，肯定是要能够找到各自对应的ip地址以及对应的端口号（WebRtc也不例外）。这就涉及到了NAT穿透的一些知识。</p>\n<p><strong>常见的网络拓扑图</strong><br><img src=\"/2024/02/21/WebRtc/network.png\" alt=\"image\"></p>\n<h3 id=\"STUN-协议\"><a href=\"#STUN-协议\" class=\"headerlink\" title=\"STUN 协议\"></a>STUN 协议</h3><blockquote>\n<p>STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，用于解决网络通信中的NAT穿越问题。<br>STUN服务器位于公网上，可以帮助客户端发现自己的公网IP地址。客户端通过向STUN服务器发送请求，服务器会返回客户端的公网IP地址和端口号。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/stun.png\" alt=\"image\"></p>\n<h3 id=\"TURN协议\"><a href=\"#TURN协议\" class=\"headerlink\" title=\"TURN协议\"></a>TURN协议</h3><blockquote>\n<p>如果STUN无法穿透NAT，可以考虑使用TURN（Traversal Using Relays around NAT）服务器。TURN服务器可以帮助在无法直接连接的情况下，通过中继服务器进行通信。TURN服务器会接收来自客户端的数据，然后转发给对方，从而实现间接通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/turn.png\" alt=\"image\"></p>\n<h3 id=\"NAT类型\"><a href=\"#NAT类型\" class=\"headerlink\" title=\"NAT类型\"></a>NAT类型</h3><h4 id=\"完全锥型NAT\"><a href=\"#完全锥型NAT\" class=\"headerlink\" title=\"完全锥型NAT\"></a>完全锥型NAT</h4><blockquote>\n<p>完全锥型 NAT 的特点: 一旦打洞成功，所有知道该洞的主机都可以 通过它与内网主机进行通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/Full%1DConeNAT.png\" alt=\"image\"></p>\n<p>当host主机通过NAT访问外网主机B时，就会在NAT 上打个洞。如果主机B将该洞的信息分享给主机A和C，那么知道这个洞 的主机A和C都可以通过该洞给内网的host主机发送信息。<br>这里所谓的“洞”就是在NAT上建立了一个内外网的映射 表。你可以将这个映射表简单地理解为一个4元组，包括内网IP、内网 端口、映射的外网IP以及映射的外网端口。</p>\n<h4 id=\"IP限制锥型NAT\"><a href=\"#IP限制锥型NAT\" class=\"headerlink\" title=\"IP限制锥型NAT\"></a>IP限制锥型NAT</h4><blockquote>\n<p>IP 限制锥型 NAT 的特点: 一旦打洞成功，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。 </p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/IPNat.png\" alt=\"image\"></p>\n<p>IP限制锥型NAT要比完全锥型NAT严格得多。IP限制锥型NAT的主 要特点:NAT打洞成功后，只有与之打洞成功的外网主机才能通过该洞 与内网主机通信，而其他外网主机即使知道洞口也不能与之通信。<br>host主机访问主机B时，在NAT上打了一个洞。此 时，只有主机B才能通过该洞向内网host主机发送信息，而其他外网主 机(如A与C)不能再像完全锥型NAT一样通过该洞与内网host主机通信 了。但需要注意的是，主机B上不同的端口(如p1、p2等)是可以向 host主机发送消息的。</p>\n<h4 id=\"端口限制NAT\"><a href=\"#端口限制NAT\" class=\"headerlink\" title=\"端口限制NAT\"></a>端口限制NAT</h4><blockquote>\n<p>端口限制锥型 NAT 的特点: 一旦打洞成功，除了像IP限制锥型 NAT 一样需要对IP地址进行检测外，还需要对端口进行检测 。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/portNat.png\" alt=\"image\"></p>\n<p>host主机访问主机B时在NAT上打了一个洞，此时外 网主机A和C是访问不了内网host主机的，这与IP限制锥型NAT是一样 的。此外，如果host主机访问的是主机B的p1端口，那么只有主机B的p1 端口发送的消息才能穿越NAT，而主机B的p2端口已无法再通过NAT 了。</p>\n<h4 id=\"对称型NAT\"><a href=\"#对称型NAT\" class=\"headerlink\" title=\"对称型NAT\"></a>对称型NAT</h4><blockquote>\n<p>对称型 NAT 的特点: 内网主机每次访问不同的IP或端口时，都会生成一个新洞，而不像前面3种NAT类型使用的是同一个洞。 </p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/SymmetricNat.png\" alt=\"image\"></p>\n<p>在对称型NAT中，host主机访问主机B时在NAT上打 了一个洞，此时只有主机B上相应端口发送的数据才能穿越该洞，这一 点与端口限制型NAT是一致的。它与端口限制型NAT最大的不同是当 host主机访问外网主机A时，它与主机A之间会新建一个洞，而不是复用 访问主机B时的洞。</p>\n<h4 id=\"打洞举例\"><a href=\"#打洞举例\" class=\"headerlink\" title=\"打洞举例\"></a>打洞举例</h4><p><strong>A B均为完全锥型NAT</strong><br><img src=\"/2024/02/21/WebRtc/A%26BFullNat.png\" alt=\"image\"></p>\n<ol>\n<li>A 向 server 发起与 B 的打洞请求，server 向 B 转发打洞请求，同时A向 PB1 直接发送探测包，那么 A 为 B 在 PA1 已经成功打洞，但是 A 的消息无法到达，因为 B 的 NAT 会将不明的地址(PA1) 丢弃/拒绝。</li>\n<li>B 收到从 server 转发过来的打洞请求后，向 PA1 直接发送探测包，这时 B 的 NAT 可以放行 PA1 的消息了，也就是 B 为 A 在 PB1 上完成了打洞。</li>\n<li>至此，A 和 B 消息能够互通，打洞成功</li>\n</ol>\n<p><strong>A为对称型 B为端口限制型</strong><br><img src=\"/2024/02/21/WebRtc/AS%26BPNat.png\" alt=\"image\"></p>\n<p>由于 B 收到 server 转发过来的打洞请求后，是向 PA1 发送探测包的，因为 B 只知道 PA1（PA1 是 A 与 server 连接是映射的端口号，server 也只知道 PA1)，但是 A 由于是对称型 NAT，所以会拒绝B往PA1发的消息，同时会从一个新端口 PA2 向 B 发包，但是 B 由于是端口限制型，只允许 PA1 端口的包通过，所以 B 会拒绝 PA2。</p>\n<p><strong>A为对称型 B为IP限制型</strong><br><img src=\"/2024/02/21/WebRtc/NAT%E7%A9%BF%E9%80%8F%E6%B5%81%E7%A8%8B%E4%B8%BE%E4%BE%8B.png\" alt=\"image\"></p>\n<h4 id=\"各NAT类型打洞可行性\"><a href=\"#各NAT类型打洞可行性\" class=\"headerlink\" title=\"各NAT类型打洞可行性\"></a>各NAT类型打洞可行性</h4><p><img src=\"/2024/02/21/WebRtc/NATOpen.png\" alt=\"image\"></p>\n<h3 id=\"ICE\"><a href=\"#ICE\" class=\"headerlink\" title=\"ICE\"></a>ICE</h3><blockquote>\n<p>ICE（Interactive Connectivity Establishment）候选项（ICE candidates）是一组网络地址（包括IP地址和端口号），用于建立对等连接（peer-to-peer connections）的过程中。ICE候选项由WebRTC框架自动收集和处理，用于解决网络中存在的NAT（Network Address Translation）和防火墙问题，以便在不同的网络环境中实现点对点通信。</p>\n</blockquote>\n<p><img src=\"/2024/02/21/WebRtc/ICE.png\" alt=\"image\"></p>\n<p>WebRtc将Candidate分为四种类型：host、srflx、prflx及 relay，且它们还有优先级次序，其中host优先级最高，relay优先级最低。比如WebRTC收集到了两个Candidate，一个是host类型，另一个是 srflx类型，那么WebRTC一定会先尝试与host类型的Candidate建立连 接，如果不成功，才会使用srflx类型的Candidate。 </p>\n<h4 id=\"ICE候选交换过程\"><a href=\"#ICE候选交换过程\" class=\"headerlink\" title=\"ICE候选交换过程\"></a>ICE候选交换过程</h4><p><img src=\"/2024/02/21/WebRtc/ICESend.png\" alt=\"image\"></p>\n<h3 id=\"信令交互过程（sdp-主要用来协商媒体格式）\"><a href=\"#信令交互过程（sdp-主要用来协商媒体格式）\" class=\"headerlink\" title=\"信令交互过程（sdp 主要用来协商媒体格式）\"></a>信令交互过程（sdp 主要用来协商媒体格式）</h3><p><img src=\"/2024/02/21/WebRtc/sdp.png\" alt=\"image\"></p>\n<h3 id=\"WebRtc连接核心过程\"><a href=\"#WebRtc连接核心过程\" class=\"headerlink\" title=\"WebRtc连接核心过程\"></a>WebRtc连接核心过程</h3><ol>\n<li>创建 p2p 通道端 A，添加本地视频流至通道，并且本地预览</li>\n<li>创建 p2p 通道端 B，添加本地视频流至通道，并且本地预览</li>\n<li>offer、answer 交换</li>\n<li>addIceCandidate 候选地址</li>\n<li>通道 A、B 连接建立成功，获取对端视频流，播放</li>\n</ol>\n"}],"PostAsset":[{"_id":"source/_posts/MVVM/c045b16c40f808e480f874a801a7680a.png","slug":"c045b16c40f808e480f874a801a7680a.png","post":"clsstdr9d000x1xopejjg837l","modified":0,"renderable":0},{"_id":"source/_posts/Vuex/ef5b88bd404de9f080415eceb994a780.png","slug":"ef5b88bd404de9f080415eceb994a780.png","post":"clsstdr9f00181xopfly9gs17","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125170026281.png","slug":"image-20220125170026281.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125171344267.png","slug":"image-20220125171344267.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125171812419.png","slug":"image-20220125171812419.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172427718.png","slug":"image-20220125172427718.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172507453.png","slug":"image-20220125172507453.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/css层叠上下文、层叠等级、层叠顺序以及z-index/image-20200805170444733.png","slug":"image-20200805170444733.png","post":"clsstdr9z001q1xopf4z25vr7","modified":0,"renderable":0},{"_id":"source/_posts/js类型检测总结/5e35a8e04062aeeb805a82c051a9560d.png","slug":"5e35a8e04062aeeb805a82c051a9560d.png","post":"clsstdraj00311xopfg739e8b","modified":0,"renderable":0},{"_id":"source/_posts/js闭包/a33c05334094f1ce80d00166ab7ed5aa.png","slug":"a33c05334094f1ce80d00166ab7ed5aa.png","post":"clsstdras003m1xop2p5vc7eu","modified":0,"renderable":0},{"_id":"source/_posts/浏览器渲染流程/5aa1c0da40be870480eef4f2f8b77931.png","slug":"5aa1c0da40be870480eef4f2f8b77931.png","post":"clsstdric006i1xop7tfo5umz","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/2428C12B709F42D38859BA4234F61E5D.png","slug":"2428C12B709F42D38859BA4234F61E5D.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125103700660.png","slug":"image-20220125103700660.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/git使用/d3c801894031d80480e26efe7008a949.png","slug":"d3c801894031d80480e26efe7008a949.png","post":"clsstdrad00261xop7thqfot6","modified":0,"renderable":0},{"_id":"source/_posts/redux/417252aa40fd5841805aee7017fc73cd.png","slug":"417252aa40fd5841805aee7017fc73cd.png","post":"clsstdrb000401xop885zdjyr","modified":0,"renderable":0},{"_id":"source/_posts/HTTP-Live-Streaming-HLS/4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png","slug":"4B0A0C9B610A4573BCA9DCD0DF2DFCB7.png","post":"clsstdr9a000n1xopauctdqdq","modified":0,"renderable":0},{"_id":"source/_posts/HTTP-Live-Streaming-HLS/WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png","slug":"WEBRESOURCE7db8da1ac6ab759c2364a5e7cacd4f68.png","post":"clsstdr9a000n1xopauctdqdq","modified":0,"renderable":0},{"_id":"source/_posts/css盒模型/0754b65440c0fe40808b6481d881c0d2.png","slug":"0754b65440c0fe40808b6481d881c0d2.png","post":"clsstdra6001x1xop7zdeccjn","modified":0,"renderable":0},{"_id":"source/_posts/css盒模型/7018d20d4024c8748094ee6c656cbc13.png","slug":"7018d20d4024c8748094ee6c656cbc13.png","post":"clsstdra6001x1xop7zdeccjn","modified":0,"renderable":0},{"_id":"source/_posts/js变量提升-预处理&&执行上下文/image-20200706120514737.png","slug":"image-20200706120514737.png","post":"clsstdraf002g1xopdw61geh2","modified":0,"renderable":0},{"_id":"source/_posts/js变量提升-预处理&&执行上下文/image-20200706121750467.png","slug":"image-20200706121750467.png","post":"clsstdraf002g1xopdw61geh2","modified":0,"renderable":0},{"_id":"source/_posts/js闭包/d2a9dab04077415480e81d7d8e8fd13e.png","slug":"d2a9dab04077415480e81d7d8e8fd13e.png","post":"clsstdras003m1xop2p5vc7eu","modified":0,"renderable":0},{"_id":"source/_posts/react/231d414640b509d980203a5ab45a3c4e.png","slug":"231d414640b509d980203a5ab45a3c4e.png","post":"clsstdrb100431xopciuk7jof","modified":0,"renderable":0},{"_id":"source/_posts/react/35cc29484072961d801e4de7f94c3b65.png","slug":"35cc29484072961d801e4de7f94c3b65.png","post":"clsstdrb100431xopciuk7jof","modified":0,"renderable":0},{"_id":"source/_posts/react/6873d82c40e03c3080a5f4098f6df602.png","slug":"6873d82c40e03c3080a5f4098f6df602.png","post":"clsstdrb100431xopciuk7jof","modified":0,"renderable":0},{"_id":"source/_posts/js的prototype总结/3ed52e91409ae13e805e9ea9c771c66c.png","slug":"3ed52e91409ae13e805e9ea9c771c66c.png","post":"clsstdrah002u1xop0e8rcouz","modified":0,"renderable":0},{"_id":"source/_posts/js的prototype总结/672e52454044214b80a9d2f140417535.png","slug":"672e52454044214b80a9d2f140417535.png","post":"clsstdrah002u1xop0e8rcouz","modified":0,"renderable":0},{"_id":"source/_posts/js的prototype总结/ad023c9f40a1e17f803967a5a402683e.png","slug":"ad023c9f40a1e17f803967a5a402683e.png","post":"clsstdrah002u1xop0e8rcouz","modified":0,"renderable":0},{"_id":"source/_posts/js的prototype总结/fb2ec26540658c9480e22f7217f7ff29.png","slug":"fb2ec26540658c9480e22f7217f7ff29.png","post":"clsstdrah002u1xop0e8rcouz","modified":0,"renderable":0},{"_id":"source/_posts/js的prototype总结/fc61390740d130488051d1089074ba12.png","slug":"fc61390740d130488051d1089074ba12.png","post":"clsstdrah002u1xop0e8rcouz","modified":0,"renderable":0},{"_id":"source/_posts/BFC/1362e17d4024bf32807439bb428f8806.png","slug":"1362e17d4024bf32807439bb428f8806.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/2e7435f6404a840180b90b5050465d7d.png","slug":"2e7435f6404a840180b90b5050465d7d.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/4e7ccdd640f9f1948001b77f22fff5bc.png","slug":"4e7ccdd640f9f1948001b77f22fff5bc.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/58fe0bc24074305e80124130cb611524.png","slug":"58fe0bc24074305e80124130cb611524.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/61f755c3404c04f880bf3759d96965db.png","slug":"61f755c3404c04f880bf3759d96965db.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/8fe9e38b40ca8d5c80e2e402f6b1d609.png","slug":"8fe9e38b40ca8d5c80e2e402f6b1d609.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/9f51d5ac40bdb5fa804d79aed400cab1.png","slug":"9f51d5ac40bdb5fa804d79aed400cab1.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/BFC/d1d0d0b84057b84c8064633356e7a56a.png","slug":"d1d0d0b84057b84c8064633356e7a56a.png","post":"clsstdr8m00031xopd6zh7qsx","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/504B85A8EA314E70BC3BB9C865A14FB4.png","slug":"504B85A8EA314E70BC3BB9C865A14FB4.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/5DDB5B88A2924C6A840C41533AE0920D.png","slug":"5DDB5B88A2924C6A840C41533AE0920D.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/8AC59C17C15A4885A126F0B3B824E20B.png","slug":"8AC59C17C15A4885A126F0B3B824E20B.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/9DED6512254D4CF0A117E6B1AE5EE402.png","slug":"9DED6512254D4CF0A117E6B1AE5EE402.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/B670A19A85B547999C298B6BA314E0F1.png","slug":"B670A19A85B547999C298B6BA314E0F1.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/CBED4F4AC4EC45B78044E27BA0CB6A8B.png","slug":"CBED4F4AC4EC45B78044E27BA0CB6A8B.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/I帧、P帧、B帧、GOP、IDR-和PTS-DTS之间的关系/D7B775D11EB743F094F9802ACDF78DBA.png","slug":"D7B775D11EB743F094F9802ACDF78DBA.png","post":"clsstdr96000h1xopfgpo11r7","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125110844187.png","slug":"image-20220125110844187.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125111712303.png","slug":"image-20220125111712303.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125111731747.png","slug":"image-20220125111731747.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125113409121.png","slug":"image-20220125113409121.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125113538013.png","slug":"image-20220125113538013.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125143155721.png","slug":"image-20220125143155721.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125162500220.png","slug":"image-20220125162500220.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125162859189.png","slug":"image-20220125162859189.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125163342091.png","slug":"image-20220125163342091.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164612639.png","slug":"image-20220125164612639.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164622944.png","slug":"image-20220125164622944.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125164803760.png","slug":"image-20220125164803760.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125165024993.png","slug":"image-20220125165024993.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125165043733.png","slug":"image-20220125165043733.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125170242142.png","slug":"image-20220125170242142.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172252449.png","slug":"image-20220125172252449.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/image-20220125172315264.png","slug":"image-20220125172315264.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc-Internals工具使用/截屏2022-01-25 上午10.49.46.png","slug":"截屏2022-01-25 上午10.49.46.png","post":"clsstdr9p001h1xop12gy1zqf","modified":0,"renderable":0},{"_id":"source/_posts/事件捕获和事件冒泡/b2a98b1d408c0923807704ad7ac95fde.png","slug":"b2a98b1d408c0923807704ad7ac95fde.png","post":"clsstdri5005n1xopegca7em8","modified":0,"renderable":0},{"_id":"source/_posts/常见的排序算法/9a8c68df405b4ae980c7a100d9395d26.png","slug":"9a8c68df405b4ae980c7a100d9395d26.png","post":"clsstdrid006o1xop3w5a9b9o","modified":0,"renderable":0},{"_id":"source/_posts/浏览器渲染流程/f339212b403299f1802345e04edc3c3e.png","slug":"f339212b403299f1802345e04edc3c3e.png","post":"clsstdric006i1xop7tfo5umz","modified":0,"renderable":0},{"_id":"source/_posts/二叉树/2153c29240544948808c3bd9081b6a74.png","slug":"2153c29240544948808c3bd9081b6a74.png","post":"clsstdri2005k1xop1t0sddoe","modified":0,"renderable":0},{"_id":"source/_posts/二叉树/31c90baf409ce7088051e95c118005e1.png","slug":"31c90baf409ce7088051e95c118005e1.png","post":"clsstdri2005k1xop1t0sddoe","modified":0,"renderable":0},{"_id":"source/_posts/二叉树/f2b1e4ea4075a3078066c8279e3b8028.png","slug":"f2b1e4ea4075a3078066c8279e3b8028.png","post":"clsstdri2005k1xop1t0sddoe","modified":0,"renderable":0},{"_id":"source/_posts/二叉树/f8f24bb14013ad4f806d1ec8bec299bd.jpg","slug":"f8f24bb14013ad4f806d1ec8bec299bd.jpg","post":"clsstdri2005k1xop1t0sddoe","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络/8b9c50964095160480f00995d28b8ac3.png","slug":"8b9c50964095160480f00995d28b8ac3.png","post":"clsstdrif006w1xop7lipa19u","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络/a5edd4d540ed8572803058f6a9f0c854.png","slug":"a5edd4d540ed8572803058f6a9f0c854.png","post":"clsstdrif006w1xop7lipa19u","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络/e0e0be624093114e805cd93918b993b9.png","slug":"e0e0be624093114e805cd93918b993b9.png","post":"clsstdrif006w1xop7lipa19u","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络/ffd0bea740c395d2807ae91fd1a27a4f.png","slug":"ffd0bea740c395d2807ae91fd1a27a4f.png","post":"clsstdrif006w1xop7lipa19u","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc/webrtcJiagou.png","slug":"webrtcJiagou.png","post":"clsvnp9mb0000jgopb2vz838l","modified":0,"renderable":0},{"_id":"source/_posts/WebRtc/mediaStream.png","slug":"mediaStream.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/RTCPeerConnection.png","slug":"RTCPeerConnection.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/RTCDataChannel.png","slug":"RTCDataChannel.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/network.png","slug":"network.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/NAT.png","slug":"NAT.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/NAT穿透流程举例.png","slug":"NAT穿透流程举例.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/stun.png","slug":"stun.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/turn.png","slug":"turn.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/ICE.png","slug":"ICE.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/Full\u001dConeNAT.png","slug":"Full\u001dConeNAT.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/IPNat.png","slug":"IPNat.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/portNat.png","slug":"portNat.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/SymmetricNat.png","slug":"SymmetricNat.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/A&BFullNat.png","slug":"A&BFullNat.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/AS&BPNat.png","slug":"AS&BPNat.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/NATOpen.png","slug":"NATOpen.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/sdp.png","slug":"sdp.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0},{"_id":"source/_posts/WebRtc/ICESend.png","slug":"ICESend.png","post":"clsvnp9mb0000jgopb2vz838l","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clsstdr8t00071xop9ou15p8y","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr95000e1xop8wxy5u9c"},{"post_id":"clsstdr8g00011xop9cdy97hu","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr96000i1xopgduefoqh"},{"post_id":"clsstdr8v00081xopf79aa958","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr97000l1xop8xckayt0"},{"post_id":"clsstdr92000c1xop83no97cs","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9b000o1xopcpv7gkok"},{"post_id":"clsstdr8m00031xopd6zh7qsx","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9c000s1xopc9wf1jca"},{"post_id":"clsstdr94000d1xop74wsdp2w","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9d000v1xop0jifeib7"},{"post_id":"clsstdr96000h1xopfgpo11r7","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9e000z1xopaj9be0xl"},{"post_id":"clsstdr8s00061xop9dgke1qb","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9f00131xop644d0xle"},{"post_id":"clsstdr9a000n1xopauctdqdq","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9f00161xopb4yj1yf4"},{"post_id":"clsstdr9c000u1xop1n7fdfal","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9g00191xopf9fcac1s"},{"post_id":"clsstdr97000k1xop1xmx4j0u","category_id":"clsstdr9b000q1xop6bh7buvq","_id":"clsstdr9g001c1xophxxvaaca"},{"post_id":"clsstdr9d000x1xopejjg837l","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9n001f1xopanvcfirm"},{"post_id":"clsstdr9e00121xop9ve8hy2n","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9r001i1xop2xdk8umz"},{"post_id":"clsstdr9b000r1xophyb9asql","category_id":"clsstdr9b000q1xop6bh7buvq","_id":"clsstdr9t001k1xop84qofrlh"},{"post_id":"clsstdr9f00151xop7v1qd5ej","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9x001o1xop6hma1pte"},{"post_id":"clsstdr9f00181xopfly9gs17","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdr9z001r1xop8m7g2dnk"},{"post_id":"clsstdr9g001b1xop09aacfko","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdra4001v1xop96dbc3ok"},{"post_id":"clsstdr9m001e1xopd5qfhqxx","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdra8001y1xop48he4fe9"},{"post_id":"clsstdr9p001h1xop12gy1zqf","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraa00221xopggsh7k28"},{"post_id":"clsstdr9s001j1xopgqi26ph3","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrad00241xopaak69kye"},{"post_id":"clsstdr9w001n1xop0uesdqmq","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrae00271xopc1s0afil"},{"post_id":"clsstdr9z001q1xopf4z25vr7","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrae002a1xopbdh9btfh"},{"post_id":"clsstdra3001u1xop7307c4i4","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraf002e1xop98u060b7"},{"post_id":"clsstdra6001x1xop7zdeccjn","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraf002h1xoph62qg5mo"},{"post_id":"clsstdraa00211xopar72c3gv","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrag002l1xopfe894cz6"},{"post_id":"clsstdrab00231xop69udhlbg","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrah002o1xop911se7sm"},{"post_id":"clsstdrae00291xop0y97f2ww","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrah002s1xop0vxi8fkg"},{"post_id":"clsstdraf002d1xophzlk7mot","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrai002v1xopemss4efv"},{"post_id":"clsstdraf002g1xopdw61geh2","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrai002y1xopfiur79ll"},{"post_id":"clsstdrad00261xop7thqfot6","category_id":"clsstdraf002c1xope5hf0m61","_id":"clsstdraj00321xopf8o683pv"},{"post_id":"clsstdrag002k1xopc0v3dca3","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraj00351xopgntdfi2k"},{"post_id":"clsstdrag002n1xopdbkc7uin","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdran00391xop06vn30uy"},{"post_id":"clsstdrah002r1xop178d4pnl","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdran003c1xopcayp9jfo"},{"post_id":"clsstdrah002u1xop0e8rcouz","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrap003g1xop93sq1s5w"},{"post_id":"clsstdrai002x1xop3l0vc15u","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrap003j1xopbpzta2n5"},{"post_id":"clsstdraj00311xopfg739e8b","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrau003n1xop9f8k81pb"},{"post_id":"clsstdraj00341xophazv48b2","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraw003q1xop8st9cp9h"},{"post_id":"clsstdrak00381xop0on4eahu","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdraz003u1xopan0s8rh7"},{"post_id":"clsstdran003b1xop896hdf8z","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb0003x1xopf1lna6je"},{"post_id":"clsstdrao003f1xop08t6drh6","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb100411xopejjpa1bo"},{"post_id":"clsstdrap003i1xopc278a7tu","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb500441xopgr2e2tfo"},{"post_id":"clsstdras003m1xop2p5vc7eu","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb600481xop2yt049fm"},{"post_id":"clsstdrau003p1xop1vh45469","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb7004b1xopdvbx65ht"},{"post_id":"clsstdrax003t1xoph6y72g2i","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb8004f1xop8ksv8m0x"},{"post_id":"clsstdrb0003w1xop9e400u15","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb9004i1xop035216i2"},{"post_id":"clsstdrb000401xop885zdjyr","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb9004l1xop5k07cft1"},{"post_id":"clsstdrb100431xopciuk7jof","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb9004n1xop8o7v8q0b"},{"post_id":"clsstdrb500471xop66wn4xz9","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrb9004p1xop8y7z9xbz"},{"post_id":"clsstdrb6004a1xopgkci6ali","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrba004s1xopdwl7dxmw"},{"post_id":"clsstdrb8004e1xop9czec9qt","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrba004u1xopbh5s5pvy"},{"post_id":"clsstdrb8004h1xopdb1j6cil","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrba004x1xop7heyc9ah"},{"post_id":"clsstdrh4005b1xop50k077lb","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdri1005i1xop14c63w4v"},{"post_id":"clsstdrhj005d1xopc7ej76yv","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdri3005l1xopd5m83l77"},{"post_id":"clsstdrhx005f1xophu36ebx7","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdri6005o1xop88k0fk48"},{"post_id":"clsstdri0005h1xopdaol47bk","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdri6005r1xopfbo0fren"},{"post_id":"clsstdri5005n1xopegca7em8","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdri8005x1xop1vc53yc6"},{"post_id":"clsstdri6005q1xop1gp98c4s","category_id":"clsstdraf002c1xope5hf0m61","_id":"clsstdri900601xop94w13g67"},{"post_id":"clsstdri7005t1xop1fi788c3","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdria00641xop2kc1dpxw"},{"post_id":"clsstdri2005k1xop1t0sddoe","category_id":"clsstdri6005p1xope5edeaqm","_id":"clsstdria00671xope7bia4ur"},{"post_id":"clsstdri8005w1xopdxje81jl","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrib006a1xop6zpt94hw"},{"post_id":"clsstdri8005z1xop4h2s34gb","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrib006d1xop3g369bxj"},{"post_id":"clsstdri900631xopcrtufom0","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdric006g1xop2o9kfhoq"},{"post_id":"clsstdria00661xop6tmldad1","category_id":"clsstdri6005p1xope5edeaqm","_id":"clsstdrid006j1xopeubt8qcl"},{"post_id":"clsstdrib00691xop6lh64dt8","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrid006l1xop8pf9gzi6"},{"post_id":"clsstdrib006c1xopaggqgkfa","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrie006p1xop1zn70arc"},{"post_id":"clsstdric006f1xopb3nmhqbg","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrie006s1xopf8t0cyfc"},{"post_id":"clsstdric006i1xop7tfo5umz","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrif006x1xop3gvu5n0x"},{"post_id":"clsstdrid006k1xop44t2290y","category_id":"clsstdr9b000q1xop6bh7buvq","_id":"clsstdrif00701xopfid570ck"},{"post_id":"clsstdrie006r1xop987vdfwm","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrig00741xopgys4giho"},{"post_id":"clsstdrif006z1xopfnin1bwz","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrig00781xop32rz6mvh"},{"post_id":"clsstdrid006o1xop3w5a9b9o","category_id":"clsstdrie006u1xopb8vv96ca","_id":"clsstdrih007a1xopbcj90rtd"},{"post_id":"clsstdrig00721xop36m21gg7","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsstdrih007c1xopag9z4lbz"},{"post_id":"clsstdrif006w1xop7lipa19u","category_id":"clsstdrig00731xop22eg6ze7","_id":"clsstdrih007e1xopahtwdihv"},{"post_id":"clsvnp9mb0000jgopb2vz838l","category_id":"clsstdr8q00041xop5xyn9fmk","_id":"clsvnp9mi0002jgopaytieusq"}],"PostTag":[{"post_id":"clsstdr8g00011xop9cdy97hu","tag_id":"clsstdr8r00051xop2e6l4ir1","_id":"clsstdr91000b1xopeuyph6zk"},{"post_id":"clsstdr8m00031xopd6zh7qsx","tag_id":"clsstdr8v000a1xopgrwd0u4d","_id":"clsstdr96000j1xopbox4b71r"},{"post_id":"clsstdr8s00061xop9dgke1qb","tag_id":"clsstdr8r00051xop2e6l4ir1","_id":"clsstdr9b000p1xop9any6vxh"},{"post_id":"clsstdr8t00071xop9ou15p8y","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdr9d000w1xop2m35310i"},{"post_id":"clsstdr9b000r1xophyb9asql","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdr9e00101xopfjnu3xq8"},{"post_id":"clsstdr8v00081xopf79aa958","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdr9f00141xopctnffves"},{"post_id":"clsstdr92000c1xop83no97cs","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdr9g001a1xope5mc930b"},{"post_id":"clsstdr94000d1xop74wsdp2w","tag_id":"clsstdr9f00171xop655lalnn","_id":"clsstdr9o001g1xop5jobga6f"},{"post_id":"clsstdr9p001h1xop12gy1zqf","tag_id":"clsstdr9i001d1xopgrfm89qm","_id":"clsstdr9w001m1xopcua98fj0"},{"post_id":"clsstdr96000h1xopfgpo11r7","tag_id":"clsstdr9i001d1xopgrfm89qm","_id":"clsstdr9z001p1xop83fef3lk"},{"post_id":"clsstdr9w001n1xop0uesdqmq","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdra2001t1xop2vz1c8bz"},{"post_id":"clsstdr97000k1xop1xmx4j0u","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdra6001w1xop65shcajs"},{"post_id":"clsstdr9a000n1xopauctdqdq","tag_id":"clsstdr9i001d1xopgrfm89qm","_id":"clsstdra900201xopekdp6h0g"},{"post_id":"clsstdr9c000u1xop1n7fdfal","tag_id":"clsstdra8001z1xop7kl928it","_id":"clsstdrae00281xop2ggecx68"},{"post_id":"clsstdr9d000x1xopejjg837l","tag_id":"clsstdrad00251xop5n0w9z0u","_id":"clsstdraf002f1xoph4hcezp5"},{"post_id":"clsstdrae00291xop0y97f2ww","tag_id":"clsstdr9f00171xop655lalnn","_id":"clsstdraf002i1xopf6wm3ojr"},{"post_id":"clsstdraf002d1xophzlk7mot","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrag002m1xope7j94mzf"},{"post_id":"clsstdr9e00121xop9ve8hy2n","tag_id":"clsstdrae002b1xopd6scdto4","_id":"clsstdrah002p1xop2m94h5m9"},{"post_id":"clsstdraf002g1xopdw61geh2","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrah002t1xopg1ra5q0f"},{"post_id":"clsstdrag002k1xopc0v3dca3","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrai002w1xop6u3peyey"},{"post_id":"clsstdr9f00151xop7v1qd5ej","tag_id":"clsstdrae002b1xopd6scdto4","_id":"clsstdrai00301xopcncpaq02"},{"post_id":"clsstdrag002n1xopdbkc7uin","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdraj00331xop07us0354"},{"post_id":"clsstdrah002r1xop178d4pnl","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrak00371xophuyka6fz"},{"post_id":"clsstdrah002u1xop0e8rcouz","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdran003a1xop1a2i3fd0"},{"post_id":"clsstdr9f00181xopfly9gs17","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrao003e1xophcnl7nii"},{"post_id":"clsstdrai002x1xop3l0vc15u","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrap003h1xopaovo62pf"},{"post_id":"clsstdraj00311xopfg739e8b","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdraq003l1xophu8hab9e"},{"post_id":"clsstdr9g001b1xop09aacfko","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrau003o1xophy2j7sdt"},{"post_id":"clsstdraj00341xophazv48b2","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdraw003r1xoph4tn03oz"},{"post_id":"clsstdr9m001e1xopd5qfhqxx","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdraz003v1xopcli2elyv"},{"post_id":"clsstdrao003f1xop08t6drh6","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrb0003y1xop8nakc8zw"},{"post_id":"clsstdr9s001j1xopgqi26ph3","tag_id":"clsstdran003d1xop6sif3mo9","_id":"clsstdrb100421xopel8s05l8"},{"post_id":"clsstdras003m1xop2p5vc7eu","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdrb500451xopgbxi2pqr"},{"post_id":"clsstdr9z001q1xopf4z25vr7","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrb600491xopb6934jqm"},{"post_id":"clsstdrau003p1xop1vh45469","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrb7004c1xopg73b7648"},{"post_id":"clsstdrax003t1xoph6y72g2i","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrb8004g1xop1jjz3e74"},{"post_id":"clsstdra3001u1xop7307c4i4","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrb9004j1xopb8jh07d7"},{"post_id":"clsstdrb0003w1xop9e400u15","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrb9004m1xopew417q26"},{"post_id":"clsstdra6001x1xop7zdeccjn","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrb9004o1xop84z64y0g"},{"post_id":"clsstdraa00211xopar72c3gv","tag_id":"clsstdrb500461xop0j389j0r","_id":"clsstdrb9004r1xop767w56mr"},{"post_id":"clsstdrb6004a1xopgkci6ali","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrba004t1xopcrfjhuau"},{"post_id":"clsstdrb8004e1xop9czec9qt","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrba004w1xop0g9kb4sc"},{"post_id":"clsstdrab00231xop69udhlbg","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrba004y1xop1yio0fz4"},{"post_id":"clsstdrb8004h1xopdb1j6cil","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrba00501xop8i5e8m46"},{"post_id":"clsstdrad00261xop7thqfot6","tag_id":"clsstdrb9004k1xopb9s638im","_id":"clsstdrba00511xop777k0lhk"},{"post_id":"clsstdrak00381xop0on4eahu","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrba00531xopfy4a3knx"},{"post_id":"clsstdran003b1xop896hdf8z","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrba00541xop48rg0pzr"},{"post_id":"clsstdrap003i1xopc278a7tu","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdrba00561xopaaonhkvm"},{"post_id":"clsstdrb000401xop885zdjyr","tag_id":"clsstdrba00521xop6z58g37c","_id":"clsstdrbb00571xop6rchf4ri"},{"post_id":"clsstdrb100431xopciuk7jof","tag_id":"clsstdrba00521xop6z58g37c","_id":"clsstdrbb00591xopedg635kg"},{"post_id":"clsstdrb500471xop66wn4xz9","tag_id":"clsstdrbb00581xopgdlcdtww","_id":"clsstdrbb005a1xop95e10jbe"},{"post_id":"clsstdrh4005b1xop50k077lb","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdrhw005e1xop7gpz91yx"},{"post_id":"clsstdrhj005d1xopc7ej76yv","tag_id":"clsstdrap003k1xop97w9564p","_id":"clsstdri0005g1xoph2lohye6"},{"post_id":"clsstdrhx005f1xophu36ebx7","tag_id":"clsstdrah002q1xop13cm2da0","_id":"clsstdri2005j1xop1uv4aym1"},{"post_id":"clsstdri5005n1xopegca7em8","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdri7005s1xop3rejagmx"},{"post_id":"clsstdri0005h1xopdaol47bk","tag_id":"clsstdri5005m1xop67o06c5a","_id":"clsstdri8005v1xopa02qgpju"},{"post_id":"clsstdri7005t1xop1fi788c3","tag_id":"clsstdr97000m1xopdlsud93o","_id":"clsstdri8005y1xop9i1j31vz"},{"post_id":"clsstdri8005w1xopdxje81jl","tag_id":"clsstdrb500461xop0j389j0r","_id":"clsstdri900621xopb0pt5hgg"},{"post_id":"clsstdri2005k1xop1t0sddoe","tag_id":"clsstdri7005u1xop62dbh6zm","_id":"clsstdria00651xop8ti7f6oi"},{"post_id":"clsstdri6005q1xop1gp98c4s","tag_id":"clsstdri900611xop0qfwerjp","_id":"clsstdrib006b1xop1vaw0t0a"},{"post_id":"clsstdri8005z1xop4h2s34gb","tag_id":"clsstdrib00681xopbmmua0bh","_id":"clsstdric006h1xopcqtshxd3"},{"post_id":"clsstdri900631xopcrtufom0","tag_id":"clsstdric006e1xopdvau9w9l","_id":"clsstdrid006n1xop6n287bn9"},{"post_id":"clsstdrid006k1xop44t2290y","tag_id":"clsstdran003d1xop6sif3mo9","_id":"clsstdrie006q1xop8yps3eoj"},{"post_id":"clsstdrid006o1xop3w5a9b9o","tag_id":"clsstdra8001z1xop7kl928it","_id":"clsstdrie006v1xopfktxhye0"},{"post_id":"clsstdria00661xop6tmldad1","tag_id":"clsstdrid006m1xop06f46b36","_id":"clsstdrif006y1xop4v5m6vqy"},{"post_id":"clsstdrib00691xop6lh64dt8","tag_id":"clsstdrie006t1xop53g1721u","_id":"clsstdrig00751xop7c5jbd2n"},{"post_id":"clsstdrig00721xop36m21gg7","tag_id":"clsstdrib00681xopbmmua0bh","_id":"clsstdrig00761xop7ziegavz"},{"post_id":"clsstdrib006c1xopaggqgkfa","tag_id":"clsstdrif00711xop0oha06y5","_id":"clsstdrih00791xop818v3ro4"},{"post_id":"clsstdric006f1xopb3nmhqbg","tag_id":"clsstdrif00711xop0oha06y5","_id":"clsstdrih007d1xop1ibwen1l"},{"post_id":"clsstdric006i1xop7tfo5umz","tag_id":"clsstdrif00711xop0oha06y5","_id":"clsstdrih007g1xophiaa628x"},{"post_id":"clsstdrie006r1xop987vdfwm","tag_id":"clsstdrie006t1xop53g1721u","_id":"clsstdrii007i1xop6j3m52g7"},{"post_id":"clsstdrif006w1xop7lipa19u","tag_id":"clsstdrii007h1xopfgw84d1u","_id":"clsstdrii007k1xop57sr6vwg"},{"post_id":"clsstdrif006z1xopfnin1bwz","tag_id":"clsstdrii007j1xop2qqj5o00","_id":"clsstdrii007l1xop56wm0r6u"},{"post_id":"clsvnp9mb0000jgopb2vz838l","tag_id":"clsstdr9i001d1xopgrfm89qm","_id":"clsvnp9mi0001jgop0suk9ghr"}],"Tag":[{"name":"模块开发规范","_id":"clsstdr8r00051xop2e6l4ir1"},{"name":"CSS布局和BFC","_id":"clsstdr8v000a1xopgrwd0u4d"},{"name":"js","_id":"clsstdr97000m1xopdlsud93o"},{"name":"HTML","_id":"clsstdr9f00171xop655lalnn"},{"name":"音视频","_id":"clsstdr9i001d1xopgrfm89qm"},{"name":"算法","_id":"clsstdra8001z1xop7kl928it"},{"name":"MVVM相关","_id":"clsstdrad00251xop5n0w9z0u"},{"name":"NodeJS","_id":"clsstdrae002b1xopd6scdto4"},{"name":"Vue","_id":"clsstdrah002q1xop13cm2da0"},{"name":"axios","_id":"clsstdran003d1xop6sif3mo9"},{"name":"css","_id":"clsstdrap003k1xop97w9564p"},{"name":"前端性能相关","_id":"clsstdrb500461xop0j389j0r"},{"name":"git","_id":"clsstdrb9004k1xopb9s638im"},{"name":"react","_id":"clsstdrba00521xop6z58g37c"},{"name":"vue","_id":"clsstdrbb00581xopgdlcdtww"},{"name":"webpack使用","_id":"clsstdri5005m1xop67o06c5a"},{"name":"树","_id":"clsstdri7005u1xop62dbh6zm"},{"name":"hexo","_id":"clsstdri900611xop0qfwerjp"},{"name":"规范","_id":"clsstdrib00681xopbmmua0bh"},{"name":"常见布局","_id":"clsstdric006e1xopdvau9w9l"},{"name":"数据结构","_id":"clsstdrid006m1xop06f46b36"},{"name":"设计模式","_id":"clsstdrie006t1xop53g1721u"},{"name":"浏览器","_id":"clsstdrif00711xop0oha06y5"},{"name":"计算机网络","_id":"clsstdrii007h1xopfgw84d1u"},{"name":"跨域","_id":"clsstdrii007j1xop2qqj5o00"}]}}